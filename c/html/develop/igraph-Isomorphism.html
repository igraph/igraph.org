---
layout: c-manual
title: igraph Reference Manual
mainheader: igraph Reference Manual
lead: For using the igraph C library
vmenu: true
doctype: html/
langversion: develop
---

{% raw %}
<div class="navigation-header mb-4" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-light" href="igraph-Motifs.html"><i class="fa fa-chevron-left"></i>
              Previous
            </a><a accesskey="h" class="btn btn-light" href="index.html"><i class="fa fa-home"></i>
              Home
            </a><a accesskey="n" class="btn btn-light" href="igraph-Coloring.html"><i class="fa fa-chevron-right"></i>
              Next
            </a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Isomorphism"></a>Chapter 21. Graph isomorphism</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#isomorphism-simple-interface">1. The simple interface</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#bliss-algorithm">2. The BLISS algorithm</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#vf2-algorithm">3. The VF2 algorithm</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#lad-algorithm">4. The LAD algorithm</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#functions-for-graphs-with-3-or-4-vertices">5. Functions for small graphs</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#isomorphism-utility-functions">6. Utility functions</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="isomorphism-simple-interface"></a>1. The simple interface</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic">1.1. <code class="function">igraph_isomorphic</code> —  Are two graphs isomorphic?</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_subisomorphic">1.2. <code class="function">igraph_subisomorphic</code> —  Decide subgraph isomorphism.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_count_automorphisms">1.3. <code class="function">igraph_count_automorphisms</code> —  Number of automorphisms of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_automorphism_group">1.4. <code class="function">igraph_automorphism_group</code> —  Automorphism group generators of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_canonical_permutation">1.5. <code class="function">igraph_canonical_permutation</code> —  Canonical permutation of a graph.</a></span></dt>
</dl></div>
<p>igraph provides four set of functions to deal with graph
isomorphism problems.</p>
<p>The <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.1. igraph_isomorphic — Are two graphs isomorphic?"><code class="function">igraph_isomorphic()</code></a> and <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic" title="1.2. igraph_subisomorphic — Decide subgraph isomorphism."><code class="function">igraph_subisomorphic()</code></a>
functions make up the first set (in addition with the <a class="link" href="igraph-Isomorphism.html#igraph_permute_vertices" title="6.2. igraph_permute_vertices — Permute the vertices."><code class="function">igraph_permute_vertices()</code></a> function). These functions choose the
algorithm which is best for the supplied input graph. (The choice is
not very sophisticated though, see their documentation for
details.)</p>
<p>The VF2 graph (and subgraph) isomorphism algorithm is implemented in
igraph, these functions are the second set. See <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2."><code class="function">igraph_isomorphic_vf2()</code></a> and <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a> for
starters.</p>
<p>Functions for the Bliss algorithm constitute the third set,
see <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.3. igraph_isomorphic_bliss — Graph isomorphism via Bliss."><code class="function">igraph_isomorphic_bliss()</code></a>.</p>
<p>Finally, the isomorphism classes of all directed graphs with three and
four vertices and all undirected graphs with 3-6 vertices are precomputed
and stored in igraph, so for these small graphs there is a separate fast
path in the code that does not use more complex, generic isomorphism
algorithms.</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic"></a>1.1. <code class="function">igraph_isomorphic</code> —  Are two graphs isomorphic?</h3></div></div></div>
<a class="indexterm" name="id-1.22.2.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_isomorphic(const igraph_t *graph1, const igraph_t *graph2,
                      igraph_bool_t *iso);
</pre></div>
<p>
</p>
<p>



In simple terms, two graphs are isomorphic if they become indistinguishable
from each other once their vertex labels are removed (rendering the vertices
within each graph indistiguishable). More precisely, two graphs are isomorphic
if there is a one-to-one mapping from the vertices of the first one
to the vertices of the second such that it transforms the edge set of the
first graph into the edge set of the second. This mapping is called
an <span class="emphasis"><em>isomorphism.</em></span>

</p>
<p>This function decides which graph isomorphism algorithm to be
used based on the input graphs. Right now it does the following:
</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>
If one graph is directed and the other undirected then an
   error is triggered.

</p></li>
<li class="listitem"><p>
If one of the graphs has multi-edges then both graphs are
   simplified and colorized using <a class="link" href="igraph-Isomorphism.html#igraph_simplify_and_colorize" title="6.3. igraph_simplify_and_colorize — Simplify the graph and compute self-loop and edge multiplicities."><code class="function">igraph_simplify_and_colorize()</code></a> and sent to VF2.

</p></li>
<li class="listitem"><p>
If the two graphs does not have the same number of vertices
   and edges it returns with <code class="constant">false</code>.

</p></li>
<li class="listitem"><p>
Otherwise, if the <a class="link" href="igraph-Isomorphism.html#igraph_isoclass" title="5.1. igraph_isoclass — Determine the isomorphism class of small graphs."><code class="function">igraph_isoclass()</code></a> function supports both
   graphs (which is true for directed graphs with 3 and 4 vertices, and
   undirected graphs with 3-6 vertices), an O(1) algorithm is used with
   precomputed data.

</p></li>
<li class="listitem"><p>
Otherwise Bliss is used, see <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.3. igraph_isomorphic_bliss — Graph isomorphism via Bliss."><code class="function">igraph_isomorphic_bliss()</code></a>.

</p></li>
</ol></div>
<p>

</p>
<p>Please call the VF2 and Bliss functions directly if you need
something more sophisticated, e.g. you need the isomorphic mapping.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a Boolean variable, will be set to <code class="constant">true</code>
       if the two graphs are isomorphic, and <code class="constant">false</code> otherwise.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isoclass" title="5.1. igraph_isoclass — Determine the isomorphism class of small graphs."><code class="function">igraph_isoclass()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_isoclass_subgraph" title="5.2. igraph_isoclass_subgraph — The isomorphism class of a subgraph of a graph."><code class="function">igraph_isoclass_subgraph()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isoclass_create" title="5.3. igraph_isoclass_create — Creates a graph from the given isomorphism class."><code class="function">igraph_isoclass_create()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subisomorphic"></a>1.2. <code class="function">igraph_subisomorphic</code> —  Decide subgraph isomorphism.</h3></div></div></div>
<a class="indexterm" name="id-1.22.2.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_subisomorphic(const igraph_t *graph1, const igraph_t *graph2,
                         igraph_bool_t *iso);
</pre></div>
<p>
</p>
<p>



Check whether <em class="parameter"><code>graph2</code></em> is isomorphic to a subgraph of <em class="parameter"><code>graph1</code></em>.
Currently this function just calls <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a>
for all graphs.

</p>
<p>
Currently this function does not support non-simple graphs.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
  undirected. This is supposed to be the bigger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
  directedness as <em class="parameter"><code>graph2</code></em>, or an error is triggered. This is
  supposed to be the smaller graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_count_automorphisms"></a>1.3. <code class="function">igraph_count_automorphisms</code> —  Number of automorphisms of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.22.2.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_count_automorphisms(
    const igraph_t *graph, const igraph_vector_int_t *colors,
    igraph_real_t *result
);
</pre></div>
<p>
</p>
<p>



This function computes the number of automorphisms of a graph. Since the
number of automorphisms may be very large, the result is returned as an
<code class="constant">igraph_real_t</code> instead of an integer. If the number of automorphisms
is larger than what can be represented in an <code class="constant">igraph_real_t</code> and you need
the exact number, use <a class="link" href="igraph-Isomorphism.html#igraph_count_automorphisms_bliss" title="2.4. igraph_count_automorphisms_bliss — Number of automorphisms using Bliss."><code class="function">igraph_count_automorphisms_bliss()</code></a>, which can
return the number as a string.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the graph. Supply a
  null pointer is the graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  Pointer to an <code class="constant">igraph_real_t</code>, the number of automorphisms
  will be returned here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code. <code class="constant">IGRAPH_EOVERFLOW</code> if the number of automorphisms is
  too large to be represented in an <code class="constant">igraph_real_t</code> .
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, in practice it is fast for many graphs.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_automorphism_group"></a>1.4. <code class="function">igraph_automorphism_group</code> —  Automorphism group generators of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.22.2.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_automorphism_group(
    const igraph_t *graph, const igraph_vector_int_t *colors,
    igraph_vector_int_list_t *generators
);
</pre></div>
<p>
</p>
<p>



This function computes the generators of the automorphism group of a graph.
The generator set may not be minimal and may depend on the specific parameters
of the algorithm under the hood. The generators are permutations represented
using zero-based indexing.

</p>
<p>
The current implementation uses BLISS behind the scenes and the result may
be dependent on the splitting heuristics. Use <a class="link" href="igraph-Isomorphism.html#igraph_automorphism_group_bliss" title="2.5. igraph_automorphism_group_bliss — Automorphism group generators using Bliss."><code class="function">igraph_automorphism_group_bliss()</code></a>
if you want to fine-tune the splitting heuristics.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the graph. Supply a
  null pointer is the graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>generators</code></em>:</span></p></td>
<td><p>
  Must be an initialized interger vector list.
  The generators of the automorphism group will be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, in practice it is fast for many graphs.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_canonical_permutation"></a>1.5. <code class="function">igraph_canonical_permutation</code> —  Canonical permutation of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.22.2.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_canonical_permutation(
    const igraph_t *graph, const igraph_vector_int_t *colors,
    igraph_vector_int_t *labeling
);
</pre></div>
<p>
</p>
<p>



This function computes the vertex permutation which transforms
the graph into a canonical form. Two graphs have the same canonical form if
and only if they are isomorphic. Use <a class="link" href="igraph-Basic.html#igraph_is_same_graph" title="6.6. igraph_is_same_graph — Are two graphs identical as labelled graphs?"><code class="function">igraph_is_same_graph()</code></a> to compare
two canonical forms.

</p>
<p>
The current implementation uses the BLISS isomorphism algorithms with
sensible defaults. Use <a class="link" href="igraph-Isomorphism.html#igraph_canonical_permutation_bliss" title="2.6. igraph_canonical_permutation_bliss — Canonical permutation using Bliss."><code class="function">igraph_canonical_permutation_bliss()</code></a> to fine-tune
the parameters.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the graph. Supply a
  null pointer is the graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>labeling</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result is stored here. The
   permutation takes vertex 0 to the first element of the vector,
   vertex 1 to the second, etc. The vector will be resized as
   needed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Basic.html#igraph_is_same_graph" title="6.6. igraph_is_same_graph — Are two graphs identical as labelled graphs?"><code class="function">igraph_is_same_graph()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, in practice it is fast for many graphs.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="bliss-algorithm"></a>2. The BLISS algorithm</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_bliss_sh_t">2.1. <code class="function">igraph_bliss_sh_t</code> —  Splitting heuristics for Bliss.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_bliss_info_t">2.2. <code class="function">igraph_bliss_info_t</code> —  Information about a Bliss run.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic_bliss">2.3. <code class="function">igraph_isomorphic_bliss</code> —  Graph isomorphism via Bliss.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_count_automorphisms_bliss">2.4. <code class="function">igraph_count_automorphisms_bliss</code> —  Number of automorphisms using Bliss.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_automorphism_group_bliss">2.5. <code class="function">igraph_automorphism_group_bliss</code> —  Automorphism group generators using Bliss.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_canonical_permutation_bliss">2.6. <code class="function">igraph_canonical_permutation_bliss</code> —  Canonical permutation using Bliss.</a></span></dt>
</dl></div>
<p>
Bliss is a successor of the famous NAUTY algorithm and
implementation. While using the same ideas in general, with better
heuristics and data structures Bliss outperforms NAUTY on most
graphs.
</p>
<p>
Bliss was developed and implemented by Tommi Junttila and Petteri Kaski at
Helsinki University of Technology, Finland. For more information,
see the Bliss homepage at <a class="ulink" href="https://users.aalto.fi/~tjunttil/bliss/" target="_top">https://users.aalto.fi/~tjunttil/bliss/</a> and the following
publication:
</p>
<p>
Tommi Junttila and Petteri Kaski: "Engineering an Efficient Canonical Labeling
Tool for Large and Sparse Graphs" In ALENEX 2007, pages 135–149, 2007
<a class="ulink" href="https://doi.org/10.1137/1.9781611972870.13" target="_top">https://doi.org/10.1137/1.9781611972870.13</a>
</p>
<p>
Tommi Junttila and Petteri Kaski: "Conflict Propagation and Component Recursion
for Canonical Labeling" in TAPAS 2011, pages 151–162, 2011.
<a class="ulink" href="https://doi.org/10.1007/978-3-642-19754-3_16" target="_top">https://doi.org/10.1007/978-3-642-19754-3_16</a>
</p>
<p>
Bliss works with both directed graphs and undirected graphs. It supports graphs with
self-loops, but not graphs with multi-edges.
</p>
<p>
Bliss version 0.75 is included in igraph.
</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bliss_sh_t"></a>2.1. <code class="function">igraph_bliss_sh_t</code> —  Splitting heuristics for Bliss.</h3></div></div></div>
<a class="indexterm" name="id-1.22.3.8.2"></a><p>
</p>
<pre class="programlisting">
typedef enum { IGRAPH_BLISS_F = 0, IGRAPH_BLISS_FL,
               IGRAPH_BLISS_FS, IGRAPH_BLISS_FM,
               IGRAPH_BLISS_FLM, IGRAPH_BLISS_FSM
             } igraph_bliss_sh_t;
</pre>
<p>
</p>
<p>


<code class="constant">IGRAPH_BLISS_FL</code> provides good performance for many graphs, and is a reasonable
default choice. <code class="constant">IGRAPH_BLISS_FSM</code> is recommended for graphs that have some
combinatorial structure, and is the default of the Bliss library's command
line tool.

</p>
<p><b>Values: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_F</code>:</span></p></td>
<td><p>
  First non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FL</code>:</span></p></td>
<td><p>
  First largest non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FS</code>:</span></p></td>
<td><p>
  First smallest non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FM</code>:</span></p></td>
<td><p>
  First maximally non-trivially connected
     non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FLM</code>:</span></p></td>
<td><p>
  Largest maximally non-trivially connected
     non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FSM</code>:</span></p></td>
<td><p>
  Smallest maximally non-trivially
     connected non-singleton cell.</p></td>
</tr>
</tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bliss_info_t"></a>2.2. <code class="function">igraph_bliss_info_t</code> —  Information about a Bliss run.</h3></div></div></div>
<a class="indexterm" name="id-1.22.3.9.2"></a><p>
</p>
<pre class="programlisting">
typedef struct igraph_bliss_info_t {
    unsigned long nof_nodes;
    unsigned long nof_leaf_nodes;
    unsigned long nof_bad_nodes;
    unsigned long nof_canupdates;
    unsigned long nof_generators;
    unsigned long max_level;
    char *group_size;
} igraph_bliss_info_t;
</pre>
<p>
</p>
<p>
</p>
<p>Some secondary information found by the Bliss algorithm is stored
here. It is useful if you wany to study the internal working of the
algorithm.

</p>
<p><b>Values: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">nof_nodes</code>:</span></p></td>
<td><p>
  The number of nodes in the search tree.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">nof_leaf_nodes</code>:</span></p></td>
<td><p>
  The number of leaf nodes in the search tree.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">nof_bad_nodes</code>:</span></p></td>
<td><p>
  Number of bad nodes.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">nof_canupdates</code>:</span></p></td>
<td><p>
  Number of canrep updates.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">nof_generators</code>:</span></p></td>
<td><p>
  Number of generators of the automorphism group.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">max_level</code>:</span></p></td>
<td><p>
  Maximum level.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">group_size</code>:</span></p></td>
<td><p>
  The size of the automorphism group of the graph,
   given as a string. It should be deallocated via
   <a class="link" href="igraph-Memory.html#igraph_free" title="2.4. igraph_free — Deallocates memory that was allocated by igraph functions."><code class="function">igraph_free()</code></a> if not needed any more.</p></td>
</tr>
</tbody>
</table></div>
<p>
See <a class="ulink" href="https://users.aalto.fi/~tjunttil/bliss/" target="_top">https://users.aalto.fi/~tjunttil/bliss/</a>
for details about the algorithm and these parameters.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic_bliss"></a>2.3. <code class="function">igraph_isomorphic_bliss</code> —  Graph isomorphism via Bliss.</h3></div></div></div>
<a class="indexterm" name="id-1.22.3.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_isomorphic_bliss(const igraph_t *graph1, const igraph_t *graph2,
                            const igraph_vector_int_t *colors1, const igraph_vector_int_t *colors2,
                            igraph_bool_t *iso, igraph_vector_int_t *map12,
                            igraph_vector_int_t *map21, igraph_bliss_sh_t sh,
                            igraph_bliss_info_t *info1, igraph_bliss_info_t *info2);
</pre></div>
<p>
</p>
<p>



This function uses the Bliss graph isomorphism algorithm, a
successor of the famous NAUTY algorithm and implementation. Bliss
is open source and licensed according to the GNU LGPL. See
<a class="ulink" href="https://users.aalto.fi/~tjunttil/bliss/" target="_top">https://users.aalto.fi/~tjunttil/bliss/</a> for
details. Currently the 0.75 version of Bliss is included in igraph.

</p>
<p>
Isomorphism testing is implemented by producing the canonical form
of both graphs using <a class="link" href="igraph-Isomorphism.html#igraph_canonical_permutation_bliss" title="2.6. igraph_canonical_permutation_bliss — Canonical permutation using Bliss."><code class="function">igraph_canonical_permutation_bliss()</code></a> and
comparing them.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors1</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the first graph. Supply a
  null pointer if your graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors2</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the second graph. Supply a
  null pointer if your graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  A vector or <code class="constant">NULL</code> pointer. If not <code class="constant">NULL</code> then an
  isomorphic mapping from <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph2</code></em> is stored here.
  If the input graphs are not isomorphic then this vector is
  cleared, i.e. it will have length zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  Similar to <em class="parameter"><code>map12</code></em>, but for the mapping from <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sh</code></em>:</span></p></td>
<td><p>
  Splitting heuristics to be used for the graphs. See
  <a class="link" href="igraph-Isomorphism.html#igraph_bliss_sh_t" title="2.1. igraph_bliss_sh_t — Splitting heuristics for Bliss."><code class="function">igraph_bliss_sh_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info1</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code>, information about the canonization of
   the first input graph is stored here. Note that if the two graphs
   have different number of vertices or edges, then this is only
   partially filled. The memory used by this structure should be
   released when no longer needed, see <a class="link" href="igraph-Isomorphism.html#igraph_bliss_info_t" title="2.2. igraph_bliss_info_t — Information about a Bliss run."><code class="function">igraph_bliss_info_t</code></a>
   for details.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info2</code></em>:</span></p></td>
<td><p>
  Same as <em class="parameter"><code>info1</code></em>, but for the second graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, but in practice it is quite fast.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_count_automorphisms_bliss"></a>2.4. <code class="function">igraph_count_automorphisms_bliss</code> —  Number of automorphisms using Bliss.</h3></div></div></div>
<a class="indexterm" name="id-1.22.3.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_count_automorphisms_bliss(
    const igraph_t *graph, const igraph_vector_int_t *colors,
    igraph_bliss_sh_t sh, igraph_bliss_info_t *info
);
</pre></div>
<p>
</p>
<p>



The number of automorphisms of a graph is computed using Bliss. The
result is returned as part of the <em class="parameter"><code>info</code></em> structure, in tag <code class="constant">group_size</code>. It is returned as a string, as it can be very high even
for relatively small graphs. See also <a class="link" href="igraph-Isomorphism.html#igraph_bliss_info_t" title="2.2. igraph_bliss_info_t — Information about a Bliss run."><code class="function">igraph_bliss_info_t</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the graph. Supply a
  null pointer is the graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sh</code></em>:</span></p></td>
<td><p>
  The splitting heuristics to be used in Bliss. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_sh_t" title="2.1. igraph_bliss_sh_t — Splitting heuristics for Bliss."><code class="function">igraph_bliss_sh_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info</code></em>:</span></p></td>
<td><p>
  The result is stored here, in particular in the <code class="constant">group_size</code> tag of <em class="parameter"><code>info</code></em>. The memory used by this structure must be
   released when no longer needed, see <a class="link" href="igraph-Isomorphism.html#igraph_bliss_info_t" title="2.2. igraph_bliss_info_t — Information about a Bliss run."><code class="function">igraph_bliss_info_t</code></a>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, in practice it is fast for many graphs.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_automorphism_group_bliss"></a>2.5. <code class="function">igraph_automorphism_group_bliss</code> —  Automorphism group generators using Bliss.</h3></div></div></div>
<a class="indexterm" name="id-1.22.3.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_automorphism_group_bliss(
    const igraph_t *graph, const igraph_vector_int_t *colors,
    igraph_vector_int_list_t *generators, igraph_bliss_sh_t sh,
    igraph_bliss_info_t *info
);
</pre></div>
<p>
</p>
<p>



The generators of the automorphism group of a graph are computed
using Bliss. The generator set may not be minimal and may depend on
the splitting heuristics. The generators are permutations represented
using zero-based indexing.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the graph. Supply a
  null pointer is the graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>generators</code></em>:</span></p></td>
<td><p>
  Must be an initialized interger vector list.
  The generators of the automorphism group will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sh</code></em>:</span></p></td>
<td><p>
  The splitting heuristics to be used in Bliss. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_sh_t" title="2.1. igraph_bliss_sh_t — Splitting heuristics for Bliss."><code class="function">igraph_bliss_sh_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code> then information on Bliss internals is
   stored here. The memory used by this structure must to be freed
   when no longer needed, see <a class="link" href="igraph-Isomorphism.html#igraph_bliss_info_t" title="2.2. igraph_bliss_info_t — Information about a Bliss run."><code class="function">igraph_bliss_info_t</code></a>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, in practice it is fast for many graphs.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_canonical_permutation_bliss"></a>2.6. <code class="function">igraph_canonical_permutation_bliss</code> —  Canonical permutation using Bliss.</h3></div></div></div>
<a class="indexterm" name="id-1.22.3.13.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_canonical_permutation_bliss(
    const igraph_t *graph, const igraph_vector_int_t *colors,
    igraph_vector_int_t *labeling, igraph_bliss_sh_t sh,
    igraph_bliss_info_t *info
);
</pre></div>
<p>
</p>
<p>



This function computes the vertex permutation which transforms
the graph into a canonical form, using the Bliss algorithm.
Two graphs have the same canonical form if and only if they
are isomorphic. Use <a class="link" href="igraph-Basic.html#igraph_is_same_graph" title="6.6. igraph_is_same_graph — Are two graphs identical as labelled graphs?"><code class="function">igraph_is_same_graph()</code></a> to compare
two canonical forms.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the graph. Supply a
  null pointer is the graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>labeling</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result is stored here. The
   permutation takes vertex 0 to the first element of the vector,
   vertex 1 to the second, etc. The vector will be resized as
   needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sh</code></em>:</span></p></td>
<td><p>
  The splitting heuristics to be used in Bliss. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_sh_t" title="2.1. igraph_bliss_sh_t — Splitting heuristics for Bliss."><code class="function">igraph_bliss_sh_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code> then information on Bliss internals is
   stored here. The memory used by this structure must to be freed
   when no longer needed, see <a class="link" href="igraph-Isomorphism.html#igraph_bliss_info_t" title="2.2. igraph_bliss_info_t — Information about a Bliss run."><code class="function">igraph_bliss_info_t</code></a>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Basic.html#igraph_is_same_graph" title="6.6. igraph_is_same_graph — Are two graphs identical as labelled graphs?"><code class="function">igraph_is_same_graph()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, in practice it is fast for many graphs.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="vf2-algorithm"></a>3. The VF2 algorithm</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic_vf2">3.1. <code class="function">igraph_isomorphic_vf2</code> —  Isomorphism via VF2.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2">3.2. <code class="function">igraph_count_isomorphisms_vf2</code> —  Number of isomorphisms via VF2.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2">3.3. <code class="function">igraph_get_isomorphisms_vf2</code> —  Collect all isomorphic mappings of two graphs.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2_callback">3.4. <code class="function">igraph_get_isomorphisms_vf2_callback</code> — The generic VF2 interface</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isohandler_t">3.5. <code class="function">igraph_isohandler_t</code> — Callback type, called when an isomorphism was found</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isocompat_t">3.6. <code class="function">igraph_isocompat_t</code> — Callback type, called to check whether two vertices or edges are compatible</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_subisomorphic_vf2">3.7. <code class="function">igraph_subisomorphic_vf2</code> — Decide subgraph isomorphism using VF2</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2">3.8. <code class="function">igraph_count_subisomorphisms_vf2</code> — Number of subgraph isomorphisms using VF2</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_get_subisomorphisms_vf2">3.9. <code class="function">igraph_get_subisomorphisms_vf2</code> —  Return all subgraph isomorphic mappings.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_get_subisomorphisms_vf2_callback">3.10. <code class="function">igraph_get_subisomorphisms_vf2_callback</code> —  Generic VF2 function for subgraph isomorphism problems.</a></span></dt>
</dl></div>
<p>
The VF2 algorithm can search for a subgraph in a larger graph, or check if two
graphs are isomorphic. See P. Foggia, C. Sansone, M. Vento, An Improved algorithm for
matching large graphs, Proc. of the 3rd IAPR-TC-15 International
Workshop on Graph-based Representations, Italy, 2001.
</p>
<p>
VF2 supports both vertex and edge-colored graphs, as well as custom vertex or edge
compatibility functions.
</p>
<p>
VF2 works with both directed and undirected graphs. Only simple graphs are supported.
Self-loops or multi-edges must not be present in the graphs. Currently, the VF2
functions do not check that the input graph is simple: it is the responsibility
of the user to pass in valid input.
</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic_vf2"></a>3.1. <code class="function">igraph_isomorphic_vf2</code> —  Isomorphism via VF2.</h3></div></div></div>
<a class="indexterm" name="id-1.22.4.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_isomorphic_vf2(const igraph_t *graph1, const igraph_t *graph2,
                          const igraph_vector_int_t *vertex_color1,
                          const igraph_vector_int_t *vertex_color2,
                          const igraph_vector_int_t *edge_color1,
                          const igraph_vector_int_t *edge_color2,
                          igraph_bool_t *iso, igraph_vector_int_t *map12,
                          igraph_vector_int_t *map21,
                          igraph_isocompat_t *node_compat_fn,
                          igraph_isocompat_t *edge_compat_fn,
                          void *arg);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function performs the VF2 algorithm via calling <a class="link" href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2_callback" title="3.4. igraph_get_isomorphisms_vf2_callback — The generic VF2 interface"><code class="function">igraph_get_isomorphisms_vf2_callback()</code></a>.

</p>
<p> Note that this function cannot be used for
deciding subgraph isomorphism, use <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a>
for that.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first graph, may be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second graph. It must have the same directedness
   as <em class="parameter"><code>graph1</code></em>, otherwise an error is reported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a Boolean constant, the result of the
   algorithm will be placed here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a NULL pointer. If not
   a NULL pointer then the mapping from <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph2</code></em> is
   stored here. If the graphs are not isomorphic then the vector is
   cleared (i.e. has zero elements).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a NULL pointer. If not
   a NULL pointer then the mapping from <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em> is
   stored here. If the graphs are not isomorphic then the vector is
   cleared (i.e. has zero elements).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em>
  and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2."><code class="function">igraph_count_isomorphisms_vf2()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2" title="3.3. igraph_get_isomorphisms_vf2 — Collect all isomorphic mappings of two graphs."><code class="function">igraph_get_isomorphisms_vf2()</code></a>,
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, what did you expect?

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.22.4.5.12.1"></a><p class="title"><b>Example 21.1.  File <code class="code">examples/simple/igraph_isomorphic_vf2.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_setup" title="4.1. igraph_setup — Initializes the igraph library.">igraph_setup</a></strong></span>();

    igraph_t ring1, ring2;
    igraph_vector_int_t color1, color2;
    igraph_vector_int_t perm;
    igraph_bool_t iso;
    igraph_int_t count;
    igraph_int_t i;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Seeds a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 12345);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="4.7. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;ring1, 100, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>1);
    <span class="strong"><strong>igraph_vector_int_init_range</strong></span>(&amp;perm, 0, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="5.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring1));
    <span class="strong"><strong>igraph_vector_int_shuffle</strong></span>(&amp;perm);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_permute_vertices" title="6.2. igraph_permute_vertices — Permute the vertices.">igraph_permute_vertices</a></strong></span>(&amp;ring1, &amp;ring2, &amp;perm);

    <span class="emphasis"><em>/* Everything has the same color */</em></span>
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color1, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="5.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring1));
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color2, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="5.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring2));
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2.">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, &amp;iso, 0, 0, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Single color failed.\n");
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="emphasis"><em>/* Two colors, just counting */</em></span>
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1); i += 2) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i] = 1;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color2); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i] = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(perm)[i]];
    }
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2.">igraph_count_isomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, &amp;count, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (count != 100) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with two colors failed, expected 100, got %" IGRAPH_PRId ".\n", count);
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="5.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="5.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring2);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color2);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;perm);

    <span class="emphasis"><em>/* Two colors, count subisomorphisms */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="4.7. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;ring1, 100, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>0);
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="4.7. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;ring2, 80, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>0);

    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color2, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="5.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring2));
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1); i += 2) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i]   = 0;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i + 1] = 1;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color2); i += 2) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i]   = 0;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i + 1] = 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2" title="3.8. igraph_count_subisomorphisms_vf2 — Number of subgraph isomorphisms using VF2">igraph_count_subisomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0,
                                     &amp;count, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (count != 21) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with two colors failed, expected 21, got %" IGRAPH_PRId ".\n", count);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color1);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color2);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="5.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="5.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring2);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_count_isomorphisms_vf2"></a>3.2. <code class="function">igraph_count_isomorphisms_vf2</code> —  Number of isomorphisms via VF2.</h3></div></div></div>
<a class="indexterm" name="id-1.22.4.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_count_isomorphisms_vf2(const igraph_t *graph1, const igraph_t *graph2,
                                  const igraph_vector_int_t *vertex_color1,
                                  const igraph_vector_int_t *vertex_color2,
                                  const igraph_vector_int_t *edge_color1,
                                  const igraph_vector_int_t *edge_color2,
                                  igraph_int_t *count,
                                  igraph_isocompat_t *node_compat_fn,
                                  igraph_isocompat_t *edge_compat_fn,
                                  void *arg);
</pre></div>
<p>
</p>
<p>



This function counts the number of isomorphic mappings between two
graphs. It uses the generic <a class="link" href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2_callback" title="3.4. igraph_get_isomorphisms_vf2_callback — The generic VF2 interface"><code class="function">igraph_get_isomorphisms_vf2_callback()</code></a>
function.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
  directedness as <em class="parameter"><code>graph1</code></em>, or an error will be reported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>count</code></em>:</span></p></td>
<td><p>
  Point to an integer, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em> and
  <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  igraph_count_automorphisms_bliss()
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_isomorphisms_vf2"></a>3.3. <code class="function">igraph_get_isomorphisms_vf2</code> —  Collect all isomorphic mappings of two graphs.</h3></div></div></div>
<a class="indexterm" name="id-1.22.4.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_isomorphisms_vf2(const igraph_t *graph1,
                                const igraph_t *graph2,
                                const igraph_vector_int_t *vertex_color1,
                                const igraph_vector_int_t *vertex_color2,
                                const igraph_vector_int_t *edge_color1,
                                const igraph_vector_int_t *edge_color2,
                                igraph_vector_int_list_t *maps,
                                igraph_isocompat_t *node_compat_fn,
                                igraph_isocompat_t *edge_compat_fn,
                                void *arg);
</pre></div>
<p>
</p>
<p>



This function finds all the isomorphic mappings between two simple
graphs. It uses the <a class="link" href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2_callback" title="3.4. igraph_get_isomorphisms_vf2_callback — The generic VF2 interface"><code class="function">igraph_get_isomorphisms_vf2_callback()</code></a>
function. Call the function with the same graph as <em class="parameter"><code>graph1</code></em> and <em class="parameter"><code>graph2</code></em> to get automorphisms.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
  directedness as <em class="parameter"><code>graph1</code></em>, or an error will be reported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maps</code></em>:</span></p></td>
<td><p>
  Pointer to a list of integer vectors. On return it is empty if
  the input graphs are not isomorphic. Otherwise it contains pointers to
  <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> objects, each vector is an
  isomorphic mapping of <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em>
  and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_isomorphisms_vf2_callback"></a>3.4. <code class="function">igraph_get_isomorphisms_vf2_callback</code> — The generic VF2 interface</h3></div></div></div>
<a class="indexterm" name="id-1.22.4.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_isomorphisms_vf2_callback(
    const igraph_t *graph1, const igraph_t *graph2,
    const igraph_vector_int_t *vertex_color1, const igraph_vector_int_t *vertex_color2,
    const igraph_vector_int_t *edge_color1, const igraph_vector_int_t *edge_color2,
    igraph_vector_int_t *map12, igraph_vector_int_t *map21,
    igraph_isohandler_t *isohandler_fn, igraph_isocompat_t *node_compat_fn,
    igraph_isocompat_t *edge_compat_fn, void *arg
);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function is an implementation of the VF2 isomorphism algorithm,
see P. Foggia, C. Sansone, M. Vento, An Improved algorithm for
matching large graphs, Proc. of the 3rd IAPR-TC-15 International
Workshop on Graph-based Representations, Italy, 2001.</p>
<p>For using it you need to define a callback function of type
<a class="link" href="igraph-Isomorphism.html#igraph_isohandler_t" title="3.5. igraph_isohandler_t — Callback type, called when an isomorphism was found"><code class="function">igraph_isohandler_t</code></a>. This function will be called whenever VF2
finds an isomorphism between the two graphs. The mapping between
the two graphs will be also provided to this function. If the
callback returns <code class="constant">IGRAPH_SUCCESS</code>, then the search is continued,
otherwise it stops. <code class="constant">IGRAPH_STOP</code> as a return value can be used to
indicate normal premature termination; any other return value will be
treated as an igraph error code, making the caller function return the
same error code as well. The callback function must not destroy the
mapping vectors that are passed to it.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or <code class="constant">NULL</code>. If not <code class="constant">NULL</code> and the supplied graphs are isomorphic then the permutation
  taking <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph</code></em> is stored here. If not <code class="constant">NULL</code> and the
  graphs are not isomorphic then a zero-length vector is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  This is the same as <em class="parameter"><code>map12</code></em>, but for the permutation
  taking <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>isohandler_fn</code></em>:</span></p></td>
<td><p>
  The callback function to be called if an
  isomorphism is found. See also <a class="link" href="igraph-Isomorphism.html#igraph_isohandler_t" title="3.5. igraph_isohandler_t — Callback type, called when an isomorphism was found"><code class="function">igraph_isohandler_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>isohandler_fn</code></em>, <em class="parameter"><code>node_compat_fn</code></em> and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isohandler_t"></a>3.5. <code class="function">igraph_isohandler_t</code> — Callback type, called when an isomorphism was found</h3></div></div></div>
<a class="indexterm" name="id-1.22.4.9.2"></a><pre class="programlisting">
typedef igraph_error_t igraph_isohandler_t(const igraph_vector_int_t *map12,
        const igraph_vector_int_t *map21, void *arg);
</pre>
<p>


See the details at the documentation of <a class="link" href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2_callback" title="3.4. igraph_get_isomorphisms_vf2_callback — The generic VF2 interface"><code class="function">igraph_get_isomorphisms_vf2_callback()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  The mapping from the first graph to the second.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  The mapping from the second graph to the first, the
  inverse of <em class="parameter"><code>map12</code></em> basically.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  This extra argument was passed to <a class="link" href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2_callback" title="3.4. igraph_get_isomorphisms_vf2_callback — The generic VF2 interface"><code class="function">igraph_get_isomorphisms_vf2_callback()</code></a> when it was called.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <code class="constant">IGRAPH_SUCCESS</code> to continue the search, <code class="constant">IGRAPH_STOP</code> to
  terminate the search. Any other return value is interpreted as an
  igraph error code, which will then abort the search and return the
  same error code from the caller function.
 
  </p></td>
</tr></tbody>
</table></div>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isocompat_t"></a>3.6. <code class="function">igraph_isocompat_t</code> — Callback type, called to check whether two vertices or edges are compatible</h3></div></div></div>
<a class="indexterm" name="id-1.22.4.10.2"></a><pre class="programlisting">
typedef igraph_bool_t igraph_isocompat_t(const igraph_t *graph1,
        const igraph_t *graph2,
        const igraph_int_t g1_num,
        const igraph_int_t g2_num,
        void *arg);
</pre>
<p>


VF2 (subgraph) isomorphism functions can be restricted by defining
relations on the vertices and/or edges of the graphs, and then checking
whether the vertices (edges) match according to these relations.

</p>
<p>This feature is implemented by two callbacks, one for
vertices, one for edges. Every time igraph tries to match a vertex (edge)
of the first (sub)graph to a vertex of the second graph, the vertex
(edge) compatibility callback is called. The callback returns a
logical value, giving whether the two vertices match.

</p>
<p>Both callback functions are of type <code class="constant">igraph_isocompat_t</code>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>g1_num</code></em>:</span></p></td>
<td><p>
  The id of a vertex or edge in the first graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>g2_num</code></em>:</span></p></td>
<td><p>
  The id of a vertex or edge in the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to pass to the callback functions.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Logical scalar, whether vertex (or edge) <em class="parameter"><code>g1_num</code></em> in <em class="parameter"><code>graph1</code></em>
   is compatible with vertex (or edge) <em class="parameter"><code>g2_num</code></em> in <em class="parameter"><code>graph2</code></em>.
 
  </p></td>
</tr></tbody>
</table></div>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subisomorphic_vf2"></a>3.7. <code class="function">igraph_subisomorphic_vf2</code> — Decide subgraph isomorphism using VF2</h3></div></div></div>
<a class="indexterm" name="id-1.22.4.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_subisomorphic_vf2(const igraph_t *graph1, const igraph_t *graph2,
                             const igraph_vector_int_t *vertex_color1,
                             const igraph_vector_int_t *vertex_color2,
                             const igraph_vector_int_t *edge_color1,
                             const igraph_vector_int_t *edge_color2,
                             igraph_bool_t *iso, igraph_vector_int_t *map12,
                             igraph_vector_int_t *map21,
                             igraph_isocompat_t *node_compat_fn,
                             igraph_isocompat_t *edge_compat_fn,
                             void *arg);
</pre></div>
<p>
</p>
<p>



Decides whether a subgraph of <em class="parameter"><code>graph1</code></em> is isomorphic to <em class="parameter"><code>graph2</code></em>. It uses <a class="link" href="igraph-Isomorphism.html#igraph_get_subisomorphisms_vf2_callback" title="3.10. igraph_get_subisomorphisms_vf2_callback — Generic VF2 function for subgraph isomorphism problems."><code class="function">igraph_get_subisomorphisms_vf2_callback()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
   undirected. This is supposed to be the larger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
   directedness as <em class="parameter"><code>graph1</code></em>. This is supposed to be the smaller
   graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the subgraph isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean. The result of the decision problem
   is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  Pointer to a vector or <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, then an
   isomorphic mapping from <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph2</code></em> is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  Pointer to a vector ot <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, then
   an isomorphic mapping from <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em> is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em>
  and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_count_subisomorphisms_vf2"></a>3.8. <code class="function">igraph_count_subisomorphisms_vf2</code> — Number of subgraph isomorphisms using VF2</h3></div></div></div>
<a class="indexterm" name="id-1.22.4.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_count_subisomorphisms_vf2(const igraph_t *graph1, const igraph_t *graph2,
                                     const igraph_vector_int_t *vertex_color1,
                                     const igraph_vector_int_t *vertex_color2,
                                     const igraph_vector_int_t *edge_color1,
                                     const igraph_vector_int_t *edge_color2,
                                     igraph_int_t *count,
                                     igraph_isocompat_t *node_compat_fn,
                                     igraph_isocompat_t *edge_compat_fn,
                                     void *arg);
</pre></div>
<p>
</p>
<p>



Count the number of isomorphisms between subgraphs of <em class="parameter"><code>graph1</code></em> and
<em class="parameter"><code>graph2</code></em>. This function uses <a class="link" href="igraph-Isomorphism.html#igraph_get_subisomorphisms_vf2_callback" title="3.10. igraph_get_subisomorphisms_vf2_callback — Generic VF2 function for subgraph isomorphism problems."><code class="function">igraph_get_subisomorphisms_vf2_callback()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
   undirected. This is supposed to be the larger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
   directedness as <em class="parameter"><code>graph1</code></em>. This is supposed to be the smaller
   graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the subgraph isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>count</code></em>:</span></p></td>
<td><p>
  Pointer to an integer. The number of subgraph
   isomorphisms is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em> and
  <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_subisomorphisms_vf2"></a>3.9. <code class="function">igraph_get_subisomorphisms_vf2</code> —  Return all subgraph isomorphic mappings.</h3></div></div></div>
<a class="indexterm" name="id-1.22.4.13.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_subisomorphisms_vf2(const igraph_t *graph1,
                                   const igraph_t *graph2,
                                   const igraph_vector_int_t *vertex_color1,
                                   const igraph_vector_int_t *vertex_color2,
                                   const igraph_vector_int_t *edge_color1,
                                   const igraph_vector_int_t *edge_color2,
                                   igraph_vector_int_list_t *maps,
                                   igraph_isocompat_t *node_compat_fn,
                                   igraph_isocompat_t *edge_compat_fn,
                                   void *arg);
</pre></div>
<p>
</p>
<p>



This function collects all isomorphic mappings of <em class="parameter"><code>graph2</code></em> to a
subgraph of <em class="parameter"><code>graph1</code></em>. It uses the <a class="link" href="igraph-Isomorphism.html#igraph_get_subisomorphisms_vf2_callback" title="3.10. igraph_get_subisomorphisms_vf2_callback — Generic VF2 function for subgraph isomorphism problems."><code class="function">igraph_get_subisomorphisms_vf2_callback()</code></a> function. The graphs should be simple.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
   undirected. This is supposed to be the larger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
   directedness as <em class="parameter"><code>graph1</code></em>. This is supposed to be the smaller
   graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the subgraph isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maps</code></em>:</span></p></td>
<td><p>
  Pointer to a list of integer vectors. On return it contains
  pointers to <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> objects, each vector is an isomorphic
  mapping of <em class="parameter"><code>graph2</code></em> to a subgraph of <em class="parameter"><code>graph1</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em>
  and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_subisomorphisms_vf2_callback"></a>3.10. <code class="function">igraph_get_subisomorphisms_vf2_callback</code> —  Generic VF2 function for subgraph isomorphism problems.</h3></div></div></div>
<a class="indexterm" name="id-1.22.4.14.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_subisomorphisms_vf2_callback(
    const igraph_t *graph1, const igraph_t *graph2,
    const igraph_vector_int_t *vertex_color1, const igraph_vector_int_t *vertex_color2,
    const igraph_vector_int_t *edge_color1, const igraph_vector_int_t *edge_color2,
    igraph_vector_int_t *map12, igraph_vector_int_t *map21,
    igraph_isohandler_t *isohandler_fn, igraph_isocompat_t *node_compat_fn,
    igraph_isocompat_t *edge_compat_fn, void *arg
);
</pre></div>
<p>
</p>
<p>



This function is the pair of <a class="link" href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2_callback" title="3.4. igraph_get_isomorphisms_vf2_callback — The generic VF2 interface"><code class="function">igraph_get_isomorphisms_vf2_callback()</code></a>,
for subgraph isomorphism problems. It searches for subgraphs of <em class="parameter"><code>graph1</code></em> which are isomorphic to <em class="parameter"><code>graph2</code></em>. When it founds an
isomorphic mapping it calls the supplied callback <em class="parameter"><code>isohandler_fn</code></em>.
The mapping (and its inverse) and the additional <em class="parameter"><code>arg</code></em> argument
are supplied to the callback.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
   undirected. This is supposed to be the larger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
   directedness as <em class="parameter"><code>graph1</code></em>. This is supposed to be the smaller
   graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the subgraph isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  Pointer to a vector or <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, then an
   isomorphic mapping from <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph2</code></em> is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  Pointer to a vector ot <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, then
   an isomorphic mapping from <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em> is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>isohandler_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isohandler_t" title="3.5. igraph_isohandler_t — Callback type, called when an isomorphism was found"><code class="function">igraph_isohandler_t</code></a>. This will be called whenever a subgraph
  isomorphism is found. If the function returns <code class="constant">IGRAPH_SUCCESS</code>,
  then the search is continued. If the function returns <code class="constant">IGRAPH_STOP</code>,
  the search is terminated normally. Any other value is treated as an
  igraph error code.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.6. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>isohandler_fn</code></em>, <em class="parameter"><code>node_compat_fn</code></em> and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="lad-algorithm"></a>4. The LAD algorithm</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Isomorphism.html#igraph_subisomorphic_lad">4.1. <code class="function">igraph_subisomorphic_lad</code> — Check subgraph isomorphism with the LAD algorithm</a></span></dt></dl></div>
<p>
The LAD algorithm can search for a subgraph in a larger graph, or check
if two graphs are isomorphic.
See Christine Solnon: AllDifferent-based Filtering for Subgraph
Isomorphism. Artificial Intelligence, 174(12-13):850-864, 2010.
<a class="ulink" href="https://doi.org/10.1016/j.artint.2010.05.002" target="_top">https://doi.org/10.1016/j.artint.2010.05.002</a>
as well as the homepage of the LAD library at <a class="ulink" href="http://liris.cnrs.fr/csolnon/LAD.html" target="_top">http://liris.cnrs.fr/csolnon/LAD.html</a>
The implementation in igraph is based on LADv1, but it is
modified to use igraph's own memory allocation and error handling.
</p>
<p>
LAD uses the concept of domains to indicate vertex compatibility when matching the
pattern graph. Domains can be used to implement matching of colored vertices.
</p>
<p>
LAD works with both directed and undirected graphs. Graphs with multi-edges are not supported.
</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subisomorphic_lad"></a>4.1. <code class="function">igraph_subisomorphic_lad</code> — Check subgraph isomorphism with the LAD algorithm</h3></div></div></div>
<a class="indexterm" name="id-1.22.5.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_subisomorphic_lad(const igraph_t *pattern, const igraph_t *target,
                             const igraph_vector_int_list_t *domains,
                             igraph_bool_t *iso, igraph_vector_int_t *map,
                             igraph_vector_int_list_t *maps,
                             igraph_bool_t induced);
</pre></div>
<p>
</p>
<p>



Check whether <em class="parameter"><code>pattern</code></em> is isomorphic to a subgraph os <em class="parameter"><code>target</code></em>.
The original LAD implementation by Christine Solnon was used as the
basis of this code.

</p>
<p>
See more about LAD at <a class="ulink" href="http://liris.cnrs.fr/csolnon/LAD.html" target="_top">http://liris.cnrs.fr/csolnon/LAD.html</a> and in
Christine Solnon: AllDifferent-based Filtering for Subgraph
Isomorphism. Artificial Intelligence, 174(12-13):850-864, 2010.
<a class="ulink" href="https://doi.org/10.1016/j.artint.2010.05.002" target="_top">https://doi.org/10.1016/j.artint.2010.05.002</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>pattern</code></em>:</span></p></td>
<td><p>
  The smaller graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  The bigger graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>domains</code></em>:</span></p></td>
<td><p>
  An integer vector list of <code class="constant">NULL</code>. The length of each
   vector must match the number of vertices in the <em class="parameter"><code>pattern</code></em> graph.
   For each vertex, the IDs of the compatible vertices in the target
   graph are listed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, or a null pointer. If not a null
   pointer, then the boolean is set to <code class="constant">true</code> if a subgraph
   isomorphism is found, and to <code class="constant">false</code> otherwise.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map</code></em>:</span></p></td>
<td><p>
  Pointer to a vector or a null pointer. If not a null
   pointer and a subgraph isomorphism is found, the matching
   vertices from the target graph are listed here, for each vertex
   (in vertex ID order) from the pattern graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maps</code></em>:</span></p></td>
<td><p>
  Pointer to a list of integer vectors or a null pointer. If not
   a null pointer, then all subgraph isomorphisms are stored in the
   vector list, in <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> objects.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>induced</code></em>:</span></p></td>
<td><p>
  Boolean, whether to search for induced matching
   subgraphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>time_limit</code></em>:</span></p></td>
<td><p>
  Processor time limit in seconds. Supply zero
   here for no limit. If the time limit is over, then the function
   signals an error.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a> for the VF2 algorithm.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.22.5.5.11.1"></a><p class="title"><b>Example 21.2.  File <code class="code">examples/simple/igraph_subisomorphic_lad.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_maps</strong></span>(igraph_vector_int_t *map, igraph_vector_int_list_t *maps) {
    igraph_int_t n, i;
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(map);
    n = <span class="strong"><strong>igraph_vector_int_list_size</strong></span>(maps);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        igraph_vector_int_t *v = <span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(maps, i);
        <span class="strong"><strong>igraph_vector_int_print</strong></span>(v);
    }
    <span class="strong"><strong>igraph_vector_int_list_clear</strong></span>(maps);
}

int <span class="strong"><strong>main</strong></span>(void) {
    igraph_t target, pattern;
    igraph_bool_t iso;
    igraph_vector_int_t map;
    igraph_vector_int_list_t maps;
    igraph_int_t i;
    int domainsvec[] = { 0, 2, 8, -1,
                         4, 5, 6, 7, -1,
                         1, 3, 5, 6, 7, 8, -1,
                         0, 2, 8, -1,
                         1, 3, 7, 8, -1, -2
                       };
    igraph_vector_int_list_t domains;
    igraph_vector_int_t v;

    <span class="emphasis"><em>/* Initialize the library. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_setup" title="4.1. igraph_setup — Initializes the igraph library.">igraph_setup</a></strong></span>();

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="2.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;target, 9, IGRAPH_UNDIRECTED,
                 0, 1, 0, 4, 0, 6,
                 1, 4, 1, 2,
                 2, 3,
                 3, 4, 3, 5, 3, 7, 3, 8,
                 4, 5, 4, 6,
                 5, 6, 5, 8,
                 7, 8,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="2.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;pattern, 5, IGRAPH_UNDIRECTED,
                 0, 1, 0, 4,
                 1, 4, 1, 2,
                 2, 3,
                 3, 4,
                 -1);

    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;map, 0);
    <span class="strong"><strong>igraph_vector_int_list_init</strong></span>(&amp;maps, 0);

    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;target, <span class="emphasis"><em>/*domains=*/</em></span> NULL, &amp;iso, &amp;map,
                             &amp;maps, <span class="emphasis"><em>/*induced=*/</em></span> false);

    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>print_maps</strong></span>(&amp;map, &amp;maps);

    <span class="strong"><strong>printf</strong></span>("---------\n");

    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;target, <span class="emphasis"><em>/*domains=*/</em></span> NULL, &amp;iso, &amp;map,
                             &amp;maps, <span class="emphasis"><em>/*induced=*/</em></span> true);

    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong>print_maps</strong></span>(&amp;map, &amp;maps);

    <span class="strong"><strong>printf</strong></span>("---------\n");

    <span class="strong"><strong>igraph_vector_int_list_init</strong></span>(&amp;domains, 0);
    i = 0;
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;v, 0);
    <span class="strong"><strong>while</strong></span> (1) {
        <span class="strong"><strong>if</strong></span> (domainsvec[i] == -2) {
            <span class="strong"><strong>break</strong></span>;
        } <span class="strong"><strong>else</strong></span> <span class="strong"><strong>if</strong></span> (domainsvec[i] == -1) {
            <span class="strong"><strong>igraph_vector_int_list_push_back_copy</strong></span>(&amp;domains, &amp;v);
            <span class="strong"><strong>igraph_vector_int_clear</strong></span>(&amp;v);
        } <span class="strong"><strong>else</strong></span> {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;v, domainsvec[i]);
        }
        i++;
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;v);

    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;target, &amp;domains, &amp;iso, &amp;map, &amp;maps,
                             <span class="emphasis"><em>/*induced=*/</em></span> false);

    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong>print_maps</strong></span>(&amp;map, &amp;maps);

    <span class="strong"><strong>igraph_vector_int_list_destroy</strong></span>(&amp;domains);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;map);
    <span class="strong"><strong>igraph_vector_int_list_destroy</strong></span>(&amp;maps);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="5.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;pattern);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="5.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;target);


    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="functions-for-graphs-with-3-or-4-vertices"></a>5. Functions for small graphs</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isoclass">5.1. <code class="function">igraph_isoclass</code> —  Determine the isomorphism class of small graphs.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isoclass_subgraph">5.2. <code class="function">igraph_isoclass_subgraph</code> —  The isomorphism class of a subgraph of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isoclass_create">5.3. <code class="function">igraph_isoclass_create</code> —  Creates a graph from the given isomorphism class.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_graph_count">5.4. <code class="function">igraph_graph_count</code> —  The number of unlabelled graphs on the given number of vertices.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isoclass"></a>5.1. <code class="function">igraph_isoclass</code> —  Determine the isomorphism class of small graphs.</h3></div></div></div>
<a class="indexterm" name="id-1.22.6.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_isoclass(const igraph_t *graph, igraph_int_t *isoclass);
</pre></div>
<p>
</p>
<p>



</p>
<p>
All graphs with a given number of vertices belong to a number of
isomorphism classes, with every graph in a given class being
isomorphic to each other.

</p>
<p>
This function gives the isomorphism class (a number) of a
graph. Two graphs have the same isomorphism class if and only if
they are isomorphic.

</p>
<p>
The first isomorphism class is numbered zero and it contains the edgeless
graph. The last isomorphism class contains the full graph. The number of
isomorphism classes for directed graphs with three vertices is 16
(between 0 and 15), for undirected graph it is only 4. For graphs
with four vertices it is 218 (directed) and 11 (undirected).
For 5 and 6 vertex undirected graphs, it is 34 and 156, respectively.
These values can also be retrieved using <a class="link" href="igraph-Isomorphism.html#igraph_graph_count" title="5.4. igraph_graph_count — The number of unlabelled graphs on the given number of vertices."><code class="function">igraph_graph_count()</code></a>.
For more information, see <a class="ulink" href="https://oeis.org/A000273" target="_top">https://oeis.org/A000273</a> and <a class="ulink" href="https://oeis.org/A000088" target="_top">https://oeis.org/A000088</a>.

</p>
<p>
At the moment, 3- and 4-vertex directed graphs and 3 to 6 vertex
undirected graphs are supported.

</p>
<p>
Multi-edges and self-loops are ignored by this function.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>isoclass</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, the isomorphism class will
       be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.1. igraph_isomorphic — Are two graphs isomorphic?"><code class="function">igraph_isomorphic()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_isoclass_subgraph" title="5.2. igraph_isoclass_subgraph — The isomorphism class of a subgraph of a graph."><code class="function">igraph_isoclass_subgraph()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isoclass_create" title="5.3. igraph_isoclass_create — Creates a graph from the given isomorphism class."><code class="function">igraph_isoclass_create()</code></a>, <a class="link" href="igraph-Motifs.html#igraph_motifs_randesu" title="4.1. igraph_motifs_randesu — Count the number of motifs in a graph."><code class="function">igraph_motifs_randesu()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Because of some limitations this function works only for graphs
with three of four vertices.

</p>
<p>
Time complexity: O(|E|), the number of edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isoclass_subgraph"></a>5.2. <code class="function">igraph_isoclass_subgraph</code> —  The isomorphism class of a subgraph of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.22.6.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_isoclass_subgraph(const igraph_t *graph, const igraph_vector_int_t *vids,
                             igraph_int_t *isoclass);
</pre></div>
<p>
</p>
<p>



This function identifies the isomorphism class of the subgraph
induced the vertices specified in <em class="parameter"><code>vids</code></em>.

</p>
<p>
At the moment, 3- and 4-vertex directed graphs and 3 to 6 vertex
undirected graphs are supported.

</p>
<p>
Multi-edges and self-loops are ignored by this function.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  A vector containing the vertex IDs to be considered as
       a subgraph. Each vertex ID should be included at most once.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>isoclass</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, this will be set to the
       isomorphism class.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isoclass" title="5.1. igraph_isoclass — Determine the isomorphism class of small graphs."><code class="function">igraph_isoclass()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.1. igraph_isomorphic — Are two graphs isomorphic?"><code class="function">igraph_isomorphic()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isoclass_create" title="5.3. igraph_isoclass_create — Creates a graph from the given isomorphism class."><code class="function">igraph_isoclass_create()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O((d+n)*n), d is the average degree in the network,
and n is the number of vertices in <code class="constant">vids</code>.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isoclass_create"></a>5.3. <code class="function">igraph_isoclass_create</code> —  Creates a graph from the given isomorphism class.</h3></div></div></div>
<a class="indexterm" name="id-1.22.6.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_isoclass_create(igraph_t *graph, igraph_int_t size,
                           igraph_int_t number, igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function creates the canonical representative graph of the
given isomorphism class.

</p>
<p>
The isomorphism class is an integer between 0 and the number of
unique unlabeled (i.e. non-isomorphic) graphs on the given number
of vertices and give directedness. See <a class="ulink" href="https://oeis.org/A000273" target="_top">https://oeis.org/A000273</a>
and <a class="ulink" href="https://oeis.org/A000088" target="_top">https://oeis.org/A000088</a> for the number of directed and
undirected graphs on <em class="parameter"><code>size</code></em> nodes.

</p>
<p>
At the moment, 3- and 4-vertex directed graphs and 3 to 6 vertex
undirected graphs are supported.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>size</code></em>:</span></p></td>
<td><p>
  The number of vertices to add to the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>number</code></em>:</span></p></td>
<td><p>
  The isomorphism class.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean constant, whether to create a directed
       graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isoclass" title="5.1. igraph_isoclass — Determine the isomorphism class of small graphs."><code class="function">igraph_isoclass()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isoclass_subgraph" title="5.2. igraph_isoclass_subgraph — The isomorphism class of a subgraph of a graph."><code class="function">igraph_isoclass_subgraph()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.1. igraph_isomorphic — Are two graphs isomorphic?"><code class="function">igraph_isomorphic()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges in the graph to create.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_graph_count"></a>5.4. <code class="function">igraph_graph_count</code> —  The number of unlabelled graphs on the given number of vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.22.6.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_graph_count(igraph_int_t n, igraph_bool_t directed, igraph_int_t *count);
</pre></div>
<p>
</p>
<p>



Gives the number of unlabelled <span class="emphasis"><em>simple</em></span> graphs on the specified number of vertices.
The "isoclass" of a graph of this size is at most one less than this value.

</p>
<p>
This function is meant to be used in conjunction with isoclass and motif finder
functions. It will only work for small <em class="parameter"><code>n</code></em> values for which the result is
represetable in an <span class="type">igraph_int_t</span>. For larger <em class="parameter"><code>n</code></em> values, an overflow
error is raised.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>count</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, the result will be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isoclass" title="5.1. igraph_isoclass — Determine the isomorphism class of small graphs."><code class="function">igraph_isoclass()</code></a>, <a class="link" href="igraph-Motifs.html#igraph_motifs_randesu_callback" title="4.4. igraph_motifs_randesu_callback — Finds motifs in a graph and calls a function for each of them."><code class="function">igraph_motifs_randesu_callback()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="isomorphism-utility-functions"></a>6. Utility functions</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_invert_permutation">6.1. <code class="function">igraph_invert_permutation</code> —  Inverts a permutation.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_permute_vertices">6.2. <code class="function">igraph_permute_vertices</code> —  Permute the vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_simplify_and_colorize">6.3. <code class="function">igraph_simplify_and_colorize</code> —  Simplify the graph and compute self-loop and edge multiplicities.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_invert_permutation"></a>6.1. <code class="function">igraph_invert_permutation</code> —  Inverts a permutation.</h3></div></div></div>
<a class="indexterm" name="id-1.22.7.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_invert_permutation(const igraph_vector_int_t *permutation, igraph_vector_int_t *inverse);
</pre></div>
<p>
</p>
<p>



Produces the inverse of <em class="parameter"><code>permutation</code></em> into <em class="parameter"><code>inverse</code></em> and at the same time it checks
that the permutation vector is valid, i.e. all indices are within range and there are
no duplicate entries.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>permutation</code></em>:</span></p></td>
<td><p>
  A permutation vector containing 0-based integer indices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>inverse</code></em>:</span></p></td>
<td><p>
  An initialized vector. The inverse of <em class="parameter"><code>permutation</code></em> will be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_permute_vertices"></a>6.2. <code class="function">igraph_permute_vertices</code> —  Permute the vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.22.7.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_permute_vertices(const igraph_t *graph, igraph_t *res,
                                       const igraph_vector_int_t *permutation);
</pre></div>
<p>
</p>
<p>



This function creates a new graph from the input graph by permuting
its vertices according to the specified mapping. Call this function
with the output of <a class="link" href="igraph-Isomorphism.html#igraph_canonical_permutation" title="1.5. igraph_canonical_permutation — Canonical permutation of a graph."><code class="function">igraph_canonical_permutation()</code></a> to create
the canonical form of a graph.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object. The new graph
   is created here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>permutation</code></em>:</span></p></td>
<td><p>
  The permutation to apply. The i-th element of the
   vector specifies the index of the vertex in the original graph that
   will become vertex i in the new graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in terms of the number of
vertices and edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_simplify_and_colorize"></a>6.3. <code class="function">igraph_simplify_and_colorize</code> —  Simplify the graph and compute self-loop and edge multiplicities.</h3></div></div></div>
<a class="indexterm" name="id-1.22.7.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_simplify_and_colorize(
    const igraph_t *graph, igraph_t *res,
    igraph_vector_int_t *vertex_color, igraph_vector_int_t *edge_color);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function creates a vertex and edge colored simple graph from the input
graph. The vertex colors are computed as the number of incident self-loops
to each vertex in the input graph. The edge colors are computed as the number of
parallel edges in the input graph that were merged to create each edge
in the simple graph.

</p>
<p>
The resulting colored simple graph is suitable for use by isomorphism checking
algorithms such as VF2, which only support simple graphs, but can consider
vertex and edge colors.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object, typically having self-loops or multi-edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An uninitialized graph object. The result will be stored here
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color</code></em>:</span></p></td>
<td><p>
  Computed vertex colors corresponding to self-loop multiplicities.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color</code></em>:</span></p></td>
<td><p>
  Computed edge colors corresponding to edge multiplicities
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.11. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2."><code class="function">igraph_isomorphic_vf2()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
</div>
</div>
<table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Motifs.html"><b>← Chapter 20. Graph motifs, dyad census and triad census</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Coloring.html"><b>Chapter 22. Graph coloring →</b></a></td>
</tr></table>
{% endraw %}
