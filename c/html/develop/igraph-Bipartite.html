---
layout: c-manual
title: igraph Reference Manual
mainheader: igraph Reference Manual
lead: For using the igraph C library
vmenu: true
doctype: html/
langversion: develop
---

{% raw %}
<div class="navigation-header mb-4" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-light" href="igraph-Games.html"><i class="fa fa-chevron-left"></i>
              Previous
            </a><a accesskey="h" class="btn btn-light" href="index.html"><i class="fa fa-home"></i>
              Home
            </a><a accesskey="n" class="btn btn-light" href="igraph-Spatial.html"><i class="fa fa-chevron-right"></i>
              Next
            </a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Bipartite"></a>Chapter 13. Bipartite, i.e. two-mode graphs</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Bipartite.html#about-bipartite">1.  Bipartite networks in igraph</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#create-two-mode-networks">2. Create two-mode networks</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#bipartite-adjacency-matrices">3. Bipartite adjacency matrices</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#project-two-mode-graphs">4. Project two-mode graphs</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#other-operations-on-bipartite-graphs">5. Other operations on bipartite graphs</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="about-bipartite"></a>1.  Bipartite networks in igraph</h2></div></div></div>
<p>
A bipartite network contains two kinds of vertices and connections
are only possible between two vertices of different kinds. There are
many natural examples, e.g. movies and actors as vertices and a
movie is connected to all participating actors, etc.

</p>
<p>
igraph does not have direct support for bipartite networks, at
least not at the C language level. In other words the igraph_t
structure does not contain information about the vertex types.
The C functions for bipartite networks usually have an additional
input argument to graph, called <code class="constant">types</code>, a boolean vector giving
the vertex types.

</p>
<p>
Most functions creating bipartite networks are able to create this
extra vector, you just need to supply an initialized boolean vector
to them.</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="create-two-mode-networks"></a>2. Create two-mode networks</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_create_bipartite">2.1. <code class="function">igraph_create_bipartite</code> —  Create a bipartite graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_full_bipartite">2.2. <code class="function">igraph_full_bipartite</code> —  Creates a complete bipartite graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_bipartite_game_gnm">2.3. <code class="function">igraph_bipartite_game_gnm</code> —  Generate a random bipartite graph with a fixed number of edges.</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_bipartite_game_gnp">2.4. <code class="function">igraph_bipartite_game_gnp</code> —  Generates a random bipartite graph with a fixed connection probability.</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_bipartite_iea_game">2.5. <code class="function">igraph_bipartite_iea_game</code> —  Generates a random bipartite multigraph through independent edge assignment.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_create_bipartite"></a>2.1. <code class="function">igraph_create_bipartite</code> —  Create a bipartite graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.3.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_create_bipartite(igraph_t *graph, const igraph_vector_bool_t *types,
                            const igraph_vector_int_t *edges,
                            igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



This is a simple wrapper function to create a bipartite graph. It
does a little more than <a class="link" href="igraph-Generators.html#igraph_create" title="2.1. igraph_create — Creates a graph with the specified edges."><code class="function">igraph_create()</code></a>, e.g. it checks that
the graph is indeed bipartite with respect to the given <em class="parameter"><code>types</code></em>
vector. If there is an edge connecting two vertices of the same
kind, then an error is reported.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the result is
  created here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Boolean vector giving the vertex types. The length of
  the vector defines the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  Vector giving the edges of the graph. The highest
  vertex ID in this vector must be smaller than the length of the
  <em class="parameter"><code>types</code></em> vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to create a directed graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.3.2.8.1"></a><p class="title"><b>Example 13.1.  File <code class="code">examples/simple/igraph_bipartite_create.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {
    igraph_int_t edges2[] = {0, 1, 1, 2, 3, 4, 5, 6, 6, 5, 1, 4, 1, 6, 0, 3 };
    igraph_t g;
    igraph_vector_bool_t types;
    igraph_vector_int_t edges;
    igraph_int_t i;

    <span class="emphasis"><em>/* Initialize the library. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_setup" title="4.1. igraph_setup — Initializes the igraph library.">igraph_setup</a></strong></span>();

    <span class="strong"><strong>igraph_vector_int_view</strong></span>(&amp;edges, edges2, <span class="strong"><strong>sizeof</strong></span>(edges2) / <span class="strong"><strong>sizeof</strong></span>(edges2[0]));
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, <span class="strong"><strong>igraph_vector_int_max</strong></span>(&amp;edges) + 1);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_bool_size</strong></span>(&amp;types); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = i % 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_create_bipartite" title="2.1. igraph_create_bipartite — Create a bipartite graph.">igraph_create_bipartite</a></strong></span>(&amp;g, &amp;types, &amp;edges, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;g, stdout);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="5.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);


    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_full_bipartite"></a>2.2. <code class="function">igraph_full_bipartite</code> —  Creates a complete bipartite graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.3.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_full_bipartite(igraph_t *graph,
                          igraph_vector_bool_t *types,
                          igraph_int_t n1, igraph_int_t n2,
                          igraph_bool_t directed,
                          igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



A bipartite network contains two kinds of vertices and connections
are only possible between two vertices of different kind. There are
many natural examples, e.g. movies and actors as vertices and a
movie is connected to all participating actors, etc.

</p>
<p>
igraph does not have direct support for bipartite networks, at
least not at the C language level. In other words the <span class="type">igraph_t</span>
structure does not contain information about the vertex types.
The C functions for bipartite networks usually have an additional
input argument to graph, called <em class="parameter"><code>types</code></em>, a boolean vector giving
the vertex types.

</p>
<p>
Most functions creating bipartite networks are able to create this
extra vector, you just need to supply an initialized boolean vector
to them.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the graph will be
  created here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean vector. If not a null pointer,
  then the vertex types will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n1</code></em>:</span></p></td>
<td><p>
  Integer, the number of vertices of the first kind.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n2</code></em>:</span></p></td>
<td><p>
  Integer, the number of vertices of the second kind.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to create a directed graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  A constant that gives the type of connections for
  directed graphs. If <code class="constant">IGRAPH_OUT</code>, then edges point from vertices
  of the first kind to vertices of the second kind; if <code class="constant">IGRAPH_IN</code>, then the opposite direction is realized; if <code class="constant">IGRAPH_ALL</code>, then mutual edges will be created.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_full" title="7.1. igraph_full — Creates a full graph (complete graph)."><code class="function">igraph_full()</code></a> for non-bipartite complete graphs,
<a class="link" href="igraph-Generators.html#igraph_full_multipartite" title="7.3. igraph_full_multipartite — Creates a full multipartite graph."><code class="function">igraph_full_multipartite()</code></a> for complete multipartite graphs.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bipartite_game_gnm"></a>2.3. <code class="function">igraph_bipartite_game_gnm</code> —  Generate a random bipartite graph with a fixed number of edges.</h3></div></div></div>
<a class="indexterm" name="id-1.14.3.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_bipartite_game_gnm(igraph_t *graph, igraph_vector_bool_t *types,
                              igraph_int_t n1, igraph_int_t n2,
                              igraph_int_t m, igraph_bool_t directed,
                              igraph_neimode_t mode, igraph_bool_t multiple);
</pre></div>
<p>
</p>
<p>



The <code class="literal">G(n1, n2, m)</code> model uniformly samples bipartite graphs with
<em class="parameter"><code>n1</code></em> bottom vertices and <em class="parameter"><code>n2</code></em> top vertices, and precisely <em class="parameter"><code>m</code></em> edges.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized igraph graph, the result
   is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized boolean vector, or a null
   pointer. If not a null pointer, then the vertex types are stored
   here. Bottom vertices come first, <em class="parameter"><code>n1</code></em> of them, then <em class="parameter"><code>n2</code></em> top
   vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n1</code></em>:</span></p></td>
<td><p>
  The number of bottom vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n2</code></em>:</span></p></td>
<td><p>
  The number of top vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The number of edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to generate a directed graph. See
    also the <em class="parameter"><code>mode</code></em> argument.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies how to direct the edges in directed
    graphs. If it is <code class="constant">IGRAPH_OUT</code>, then directed edges point from
    bottom vertices to top vertices. If it is <code class="constant">IGRAPH_IN</code>, edges
    point from top vertices to bottom vertices. <code class="constant">IGRAPH_OUT</code> and
    <code class="constant">IGRAPH_IN</code> do not generate mutual edges. If this argument is
    <code class="constant">IGRAPH_ALL</code>, then each edge direction is considered
    independently and mutual edges might be generated. This
    argument is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiple</code></em>:</span></p></td>
<td><p>
  Boolean, whether it is allowed to generate more
    than one edge between the same pair of vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Games.html#igraph_erdos_renyi_game_gnm" title="1.1. igraph_erdos_renyi_game_gnm — Generates a random (Erdős-Rényi) graph with a fixed number of edges."><code class="function">igraph_erdos_renyi_game_gnm()</code></a> for the unipartite version,
<a class="link" href="igraph-Bipartite.html#igraph_bipartite_game_gnp" title="2.4. igraph_bipartite_game_gnp — Generates a random bipartite graph with a fixed connection probability."><code class="function">igraph_bipartite_game_gnp()</code></a> for the <code class="literal">G(n1, n2, p)</code>
model.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bipartite_game_gnp"></a>2.4. <code class="function">igraph_bipartite_game_gnp</code> —  Generates a random bipartite graph with a fixed connection probability.</h3></div></div></div>
<a class="indexterm" name="id-1.14.3.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_bipartite_game_gnp(igraph_t *graph, igraph_vector_bool_t *types,
                                         igraph_int_t n1, igraph_int_t n2,
                                         igraph_real_t p, igraph_bool_t directed,
                                         igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



In the <code class="literal">G(n1, n2, p)</code> model, every possible edge between the <em class="parameter"><code>n1</code></em>
bottom vertices and <em class="parameter"><code>n2</code></em> top vertices is realized independently with
probability <em class="parameter"><code>p</code></em>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized igraph graph, the result
   is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized boolean vector, or a null
   pointer. If not <code class="constant">NULL</code>, then the vertex types are stored
   here. Bottom vertices come first, <em class="parameter"><code>n1</code></em> of them, then <em class="parameter"><code>n2</code></em> top
   vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n1</code></em>:</span></p></td>
<td><p>
  The number of bottom vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n2</code></em>:</span></p></td>
<td><p>
  The number of top vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  The connection probability.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to generate a directed graph. See
    also the <em class="parameter"><code>mode</code></em> argument.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies how to direct the edges in directed
    graphs. If it is <code class="constant">IGRAPH_OUT</code>, then directed edges point from
    bottom vertices to top vertices. If it is <code class="constant">IGRAPH_IN</code>, edges
    point from top vertices to bottom vertices. <code class="constant">IGRAPH_OUT</code> and
    <code class="constant">IGRAPH_IN</code> do not generate mutual edges. If this argument is
    <code class="constant">IGRAPH_ALL</code>, then each edge direction is considered
    independently and mutual edges might be generated. This
    argument is ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Games.html#igraph_erdos_renyi_game_gnp" title="1.2. igraph_erdos_renyi_game_gnp — Generates a random (Erdős-Rényi) graph with fixed edge probabilities."><code class="function">igraph_erdos_renyi_game_gnp()</code></a> for the unipartite version,
<a class="link" href="igraph-Bipartite.html#igraph_bipartite_game_gnm" title="2.3. igraph_bipartite_game_gnm — Generate a random bipartite graph with a fixed number of edges."><code class="function">igraph_bipartite_game_gnm()</code></a> for the <code class="literal">G(n1, n2, m)</code> model.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bipartite_iea_game"></a>2.5. <code class="function">igraph_bipartite_iea_game</code> —  Generates a random bipartite multigraph through independent edge assignment.</h3></div></div></div>
<a class="indexterm" name="id-1.14.3.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_bipartite_iea_game(
        igraph_t *graph, igraph_vector_bool_t *types,
        igraph_int_t n1, igraph_int_t n2, igraph_int_t m,
        igraph_bool_t directed, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>This function is experimental and its signature is not considered final yet.
We reserve the right to change the function signature without changing the
major version of igraph. Use it at your own risk.</p>
</div>
<p>This model generates random multigraphs with <em class="parameter"><code>n1</code></em> bottom vertices,
<em class="parameter"><code>n2</code></em> top vertices and <em class="parameter"><code>m</code></em> edges through independent edge assignment (IEA).
Each of the <em class="parameter"><code>m</code></em> edges is assigned uniformly at random to a vertex pair,
independently of each other.

</p>
<p>
This model does not sample multigraphs uniformly. Undirected graphs are
generated with probability proportional to

</p>
<p>
<code class="literal">(prod_(i&lt;j) A_ij !)^(-1)</code>,

</p>
<p>
where <code class="constant">A</code> denotes the adjacency matrix. The corresponding  expression for
directed graphs is

</p>
<p>
<code class="literal">(prod_(i,j) A_ij !)^(-1)</code>.

</p>
<p>
Thus the probability of all simple graphs (which only have 0s and 1s in the
adjacency matrix) is the same, while that of non-simple ones depends on
their edge and self-loop multiplicities.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized igraph graph, the result
   is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized boolean vector, or a <code class="constant">NULL</code>
   pointer. If not <code class="constant">NULL</code>, then the vertex types are stored
   here. Bottom vertices come first, <em class="parameter"><code>n1</code></em> of them, then <em class="parameter"><code>n2</code></em> top
   vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n1</code></em>:</span></p></td>
<td><p>
  The number of bottom vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n2</code></em>:</span></p></td>
<td><p>
  The number of top vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The number of edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Whether to generate a directed graph. See
    also the <em class="parameter"><code>mode</code></em> argument.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies how to direct the edges in directed
    graphs. If it is <code class="constant">IGRAPH_OUT</code>, then directed edges point from
    bottom vertices to top vertices. If it is <code class="constant">IGRAPH_IN</code>, edges
    point from top vertices to bottom vertices. <code class="constant">IGRAPH_OUT</code> and
    <code class="constant">IGRAPH_IN</code> do not generate mutual edges. If this argument is
    <code class="constant">IGRAPH_ALL</code>, then each edge direction is considered
    independently and mutual edges might be generated. This
    argument is ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Games.html#igraph_iea_game" title="1.3. igraph_iea_game — Generates a random multigraph through independent edge assignment."><code class="function">igraph_iea_game()</code></a> for the unipartite version;
<a class="link" href="igraph-Bipartite.html#igraph_bipartite_game_gnm" title="2.3. igraph_bipartite_game_gnm — Generate a random bipartite graph with a fixed number of edges."><code class="function">igraph_bipartite_game_gnm()</code></a> to uniformly sample bipartite graphs
with a given number of vertices and edges.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="bipartite-adjacency-matrices"></a>3. Bipartite adjacency matrices</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_biadjacency">3.1. <code class="function">igraph_biadjacency</code> —  Creates a bipartite graph from a bipartite adjacency matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_weighted_biadjacency">3.2. <code class="function">igraph_weighted_biadjacency</code> —  Creates a bipartite graph from a weighted bipartite adjacency matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_get_biadjacency">3.3. <code class="function">igraph_get_biadjacency</code> —  Converts a bipartite graph into a bipartite adjacency matrix.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_biadjacency"></a>3.1. <code class="function">igraph_biadjacency</code> —  Creates a bipartite graph from a bipartite adjacency matrix.</h3></div></div></div>
<a class="indexterm" name="id-1.14.4.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_biadjacency(
        igraph_t *graph,
        igraph_vector_bool_t *types,
        const igraph_matrix_t *biadjmatrix,
        igraph_bool_t directed,
        igraph_neimode_t mode,
        igraph_bool_t multiple);
</pre></div>
<p>
</p>
<p>



A bipartite (or two-mode) graph contains two types of vertices and
edges always connect vertices of different types. A bipartite adjacency
matrix is an <span class="emphasis"><em>n</em></span> x <span class="emphasis"><em>m</em></span> matrix, <span class="emphasis"><em>n</em></span> and <span class="emphasis"><em>m</em></span> are the number of vertices
of the two types, respectively. Nonzero elements in the matrix denote
edges between the two corresponding vertices.

</p>
<p>
This function can operate in two modes, depending on the
<em class="parameter"><code>multiple</code></em> argument. If it is <code class="constant">false</code>, then a single edge is
created for every non-zero element in the bipartite adjacency matrix. If
<em class="parameter"><code>multiple</code></em> is <code class="constant">true</code>, then as many edges are created between two
vertices as the corresponding matrix element. When <em class="parameter"><code>multiple</code></em>
is set to <code class="constant">true</code>, matrix elements should be whole numbers.
Otherwise their fractional part will be discarded.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized boolean vector, or a null
  pointer. If not a null pointer, then the vertex types are stored
  here. It is resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>biadjmatrix</code></em>:</span></p></td>
<td><p>
  The bipartite adjacency matrix that serves as an input
  to this function.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Specifies whether to create an undirected or a directed
  graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies the direction of the edges in a directed
  graph. If <code class="constant">IGRAPH_OUT</code>, then edges point from vertices
  of the first kind (corresponding to rows) to vertices of the
  second kind (corresponding to columns); if <code class="constant">IGRAPH_IN</code>,
  then the opposite direction is realized; if <code class="constant">IGRAPH_ALL</code>,
  then mutual edges will be created.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiple</code></em>:</span></p></td>
<td><p>
  Whether to interpret matrix entries as edge multiplicities,
  see details above.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*m), the size of the bipartite adjacency matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_weighted_biadjacency"></a>3.2. <code class="function">igraph_weighted_biadjacency</code> —  Creates a bipartite graph from a weighted bipartite adjacency matrix.</h3></div></div></div>
<a class="indexterm" name="id-1.14.4.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_weighted_biadjacency(
        igraph_t *graph,
        igraph_vector_bool_t *types,
        igraph_vector_t *weights,
        const igraph_matrix_t *biadjmatrix,
        igraph_bool_t directed,
        igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



A bipartite (or two-mode) graph contains two types of vertices and
edges always connect vertices of different types. A bipartite adjacency
matrix is an <span class="emphasis"><em>n</em></span> x <span class="emphasis"><em>m</em></span> matrix, <span class="emphasis"><em>n</em></span> and <span class="emphasis"><em>m</em></span> are the number of vertices
of the two types, respectively. Nonzero elements in the matrix denote
edges between the two corresponding vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized boolean vector, or a null
  pointer. If not a null pointer, then the vertex types are stored
  here. It is resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the weights will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>biadjmatrix</code></em>:</span></p></td>
<td><p>
  The bipartite adjacency matrix that serves as an input
  to this function.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Specifies whether to create an undirected or a directed
  graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies the direction of the edges in a directed
  graph. If <code class="constant">IGRAPH_OUT</code>, then edges point from vertices
  of the first kind (corresponding to rows) to vertices of the
  second kind (corresponding to columns); if <code class="constant">IGRAPH_IN</code>,
  then the opposite direction is realized; if <code class="constant">IGRAPH_ALL</code>,
  then mutual edges will be created.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*m), the size of the bipartite adjacency matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_biadjacency"></a>3.3. <code class="function">igraph_get_biadjacency</code> —  Converts a bipartite graph into a bipartite adjacency matrix.</h3></div></div></div>
<a class="indexterm" name="id-1.14.4.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_biadjacency(
    const igraph_t *graph, const igraph_vector_bool_t *types,
    const igraph_vector_t *weights,
    igraph_matrix_t *res, igraph_vector_int_t *row_ids,
    igraph_vector_int_t *col_ids
);
</pre></div>
<p>
</p>
<p>



In a bipartite adjacency matrix <code class="constant">A</code>, element <code class="literal">A_ij</code>
gives the number of edges between the <code class="literal">i</code>th vertex of the
first partition and the <code class="literal">j</code>th vertex of the second partition.

</p>
<p>
If the graph contains edges within the same partition, this function
issues a warning.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, edge directions are ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Boolean vector containing the vertex types. Vertices belonging
  to the first partition have type <code class="constant">false</code>, the one in the second
  partition type <code class="constant">true</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A vector specifying a weight for each edge or <code class="constant">NULL</code>.
  If <code class="constant">NULL</code>, all edges are assumed to have weight 1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix, the result is stored
  here. An element of the matrix gives the number of edges
  (irrespectively of their direction), or sum of edge weights,
  between the two corresponding vertices. The rows will correspond
  to vertices with type <code class="constant">false</code>, the columns correspond to vertices
  with type <code class="constant">true</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>row_ids</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or <code class="constant">NULL</code>.
  If not a null pointer, then the IDs of vertices with type <code class="constant">false</code>
  are stored here, with the same ordering as the rows of the
  biadjacency matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>col_ids</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or <code class="constant">NULL</code>.
  If not a null pointer, then the IDs of vertices with type <code class="constant">true</code>
  are stored here, with the same ordering as the columns of the
  biadjacency matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|) where |E| is the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Bipartite.html#igraph_biadjacency" title="3.1. igraph_biadjacency — Creates a bipartite graph from a bipartite adjacency matrix."><code class="function">igraph_biadjacency()</code></a> for the opposite operation.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="project-two-mode-graphs"></a>4. Project two-mode graphs</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_bipartite_projection_size">4.1. <code class="function">igraph_bipartite_projection_size</code> —  Calculate the number of vertices and edges in the bipartite projections.</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_bipartite_projection">4.2. <code class="function">igraph_bipartite_projection</code> —  Create one or both projections of a bipartite (two-mode) network.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bipartite_projection_size"></a>4.1. <code class="function">igraph_bipartite_projection_size</code> —  Calculate the number of vertices and edges in the bipartite projections.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_bipartite_projection_size(const igraph_t *graph,
                                     const igraph_vector_bool_t *types,
                                     igraph_int_t *vcount1,
                                     igraph_int_t *ecount1,
                                     igraph_int_t *vcount2,
                                     igraph_int_t *ecount2);
</pre></div>
<p>
</p>
<p>



This function calculates the number of vertices and edges in the
two projections of a bipartite network. This is useful if you have
a big bipartite network and you want to estimate the amount of
memory you would need to calculate the projections themselves.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Boolean vector giving the vertex types of the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vcount1</code></em>:</span></p></td>
<td><p>
  Pointer to an <code class="constant">igraph_int_t</code>, the number of
    vertices in the first projection is stored here. May be <code class="constant">NULL</code>
    if not needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ecount1</code></em>:</span></p></td>
<td><p>
  Pointer to an <code class="constant">igraph_int_t</code>, the number of
    edges in the first projection is stored here. May be <code class="constant">NULL</code>
    if not needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vcount2</code></em>:</span></p></td>
<td><p>
  Pointer to an <code class="constant">igraph_int_t</code>, the number of
    vertices in the second projection is stored here. May be <code class="constant">NULL</code>
    if not needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ecount2</code></em>:</span></p></td>
<td><p>
  Pointer to an <code class="constant">igraph_int_t</code>, the number of
    edges in the second projection is stored here. May be <code class="constant">NULL</code>
    if not needed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Bipartite.html#igraph_bipartite_projection" title="4.2. igraph_bipartite_projection — Create one or both projections of a bipartite (two-mode) network."><code class="function">igraph_bipartite_projection()</code></a> to calculate the actual
projection.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*d^2+|E|), |V| is the number of vertices, |E|
is the number of edges, d is the average (total) degree of the
graphs.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bipartite_projection"></a>4.2. <code class="function">igraph_bipartite_projection</code> —  Create one or both projections of a bipartite (two-mode) network.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_bipartite_projection(const igraph_t *graph,
                                const igraph_vector_bool_t *types,
                                igraph_t *proj1,
                                igraph_t *proj2,
                                igraph_vector_int_t *multiplicity1,
                                igraph_vector_int_t *multiplicity2,
                                igraph_int_t probe1);
</pre></div>
<p>
</p>
<p>



Creates one or both projections of a bipartite graph.

</p>
<p>
A graph is called bipartite if its vertices can be partitioned into
two sets, V1 and V2, so that connections only run between V1 and V2,
but not within V1 or within V2. The <em class="parameter"><code>types</code></em> parameter specifies
which vertex should be considered a member of one or the other
partition. The projection to V1 has vertex set V1, and two vertices
are connected if they have at least one common neighbour in V2.
The number of common neighbours is returned in <em class="parameter"><code>multiplicity1</code></em>,
if requested.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The bipartite input graph. Directedness of the edges
  is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Boolean vector giving the vertex types of the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>proj1</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the first
  projection will be created here. It a null pointer, then it is
  ignored, see also the <em class="parameter"><code>probe1</code></em> argument.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>proj2</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the second
  projection is created here, if it is not a null pointer. See also
  the <em class="parameter"><code>probe1</code></em> argument.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiplicity1</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, or a null pointer. If not
  the latter, then the multiplicity of the edges is stored
  here. E.g. if there is an A-C-B and also an A-D-B triple in the
  bipartite graph (but no more X, such that A-X-B is also in the
  graph), then the multiplicity of the A-B edge in the projection
  will be 2.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiplicity2</code></em>:</span></p></td>
<td><p>
  The same as <code class="constant">multiplicity1</code>, but for the
  other projection.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>probe1</code></em>:</span></p></td>
<td><p>
  This argument can be used to specify the order of the
  projections in the resulting list. When it is non-negative, then
  it is considered as a vertex ID and the projection containing
  this vertex will be the first one in the result. Setting this
  argument to a non-negative value implies that <code class="constant">proj1</code> must be
  a non-null pointer. If you don't care about the ordering of the
  projections, pass -1 here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Bipartite.html#igraph_bipartite_projection_size" title="4.1. igraph_bipartite_projection_size — Calculate the number of vertices and edges in the bipartite projections."><code class="function">igraph_bipartite_projection_size()</code></a> to calculate the number
of vertices and edges in the projections, without creating the
projection graphs themselves.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*d^2+|E|), |V| is the number of vertices, |E|
is the number of edges, d is the average (total) degree of the
graphs.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="other-operations-on-bipartite-graphs"></a>5. Other operations on bipartite graphs</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Bipartite.html#igraph_is_bipartite">5.1. <code class="function">igraph_is_bipartite</code> —  Check whether a graph is bipartite.</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_bipartite"></a>5.1. <code class="function">igraph_is_bipartite</code> —  Check whether a graph is bipartite.</h3></div></div></div>
<a class="indexterm" name="id-1.14.6.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_bipartite(const igraph_t *graph,
                        igraph_bool_t *res,
                        igraph_vector_bool_t *types);
</pre></div>
<p>
</p>
<p>



This function checks whether a graph is bipartite. It tries
to find a mapping that gives a possible division of the vertices into two
classes, such that no two vertices of the same class are connected by an
edge.

</p>
<p>
The existence of such a mapping is equivalent of having no circuits of
odd length in the graph. A graph with loop edges cannot be bipartite.

</p>
<p>
Note that the mapping is not necessarily unique, e.g. if the graph has
at least two components, then the vertices in the separate components
can be mapped independently.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized boolean vector, or a null
  pointer. If not a null pointer and a mapping was found, then it
  is stored here. If not a null pointer, but no mapping was found,
  the contents of this vector is invalid.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  igraph_is_bipartite_coloring() to determine if all edges connect
vertices of different types, given a specific type vector.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
</div>
<table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Games.html"><b>← Chapter 12. Stochastic graph generators ("games")</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Spatial.html"><b>Chapter 14. Spatial graphs →</b></a></td>
</tr></table>
{% endraw %}
