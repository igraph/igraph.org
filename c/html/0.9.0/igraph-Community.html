---
layout: c-manual
title: igraph Reference Manual
mainheader: igraph Reference Manual
lead: For using the igraph C library
vmenu: true
doctype: html/
langversion: 0.9.0
---

{% raw %}
<div class="navigation-header mb-4" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-light" href="igraph-Separators.html"><i class="fa fa-chevron-left"></i>
              Previous
            </a><a accesskey="h" class="btn btn-light" href="index.html"><i class="fa fa-home"></i>
              Home
            </a><a accesskey="n" class="btn btn-light" href="igraph-Graphlets.html"><i class="fa fa-chevron-right"></i>
              Next
            </a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Community"></a>Chapter 24. Detecting Community Structure</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Community.html#common-functions-related-to-community-detection">1. Common functions related to community structure</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#community-detection-based-on-statistical-mechanics">2. Community structure based on statistical mechanics</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#community-structure-based-on-eigenvectors-of-matrices">3. Community structure based on eigenvectors of matrices</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#walktrap-community-structure-based-on-random-walks">4. Walktrap: community structure based on random walks</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#edge-betweenness-based-community-detection">5. Edge betweenness based community detection</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#community-structure-based-on-the-optimization-of-modularity">6. Community structure based on the optimization of modularity</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#fluid-communities">7. Fluid Communities</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#label-propagation">8. Label propagation</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#infomap-algorithm">9. The InfoMAP algorithm</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="common-functions-related-to-community-detection"></a>1. Common functions related to community structure</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Community.html#igraph_modularity">1.1. <code class="function">igraph_modularity</code> —  Calculate the modularity of a graph with respect to some clusters or vertex types.</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#igraph_modularity_matrix">1.2. <code class="function">igraph_modularity_matrix</code> —  Calculate the modularity matrix</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#igraph_community_optimal_modularity">1.3. <code class="function">igraph_community_optimal_modularity</code> — Calculate the community structure with the highest modularity value</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#igraph_community_to_membership">1.4. <code class="function">igraph_community_to_membership</code> —  Create membership vector from community structure dendrogram</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#igraph_reindex_membership">1.5. <code class="function">igraph_reindex_membership</code> —  Makes the IDs in a membership vector continuous</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#igraph_compare_communities">1.6. <code class="function">igraph_compare_communities</code> —  Compares community structures using various metrics</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#igraph_split_join_distance">1.7. <code class="function">igraph_split_join_distance</code> —  Calculates the split-join distance of two community structures</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_modularity"></a>1.1. <code class="function">igraph_modularity</code> —  Calculate the modularity of a graph with respect to some clusters or vertex types.</h3></div></div></div>
<a class="indexterm" name="idp105545339920968"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_modularity(const igraph_t *graph,
                      const igraph_vector_t *membership,
                      const igraph_vector_t *weights,
                      const igraph_real_t resolution,
                      const igraph_bool_t directed,
                      igraph_real_t *modularity);
</pre></div>
<p>
</p>
<p>



The modularity of a graph with respect to some clustering of the vertices
(or assignment of vertex types)
measures how strongly separated the different clusters are from each
other compared to a random null model. It is defined as

</p>
<p>
<code class="literal"> Q = 1/(2m) sum_ij (A_ij - gamma * k_i * k_j / (2m)) * d(c_i,c_j)</code> ,

</p>
<p>
where <code class="constant">m</code> is the number of edges, <code class="literal"> A_ij</code>  is the adjacency matrix,
<code class="constant">k_i</code> is the degree of vertex <code class="constant">i</code>, <code class="constant">c_i</code> is the cluster that vertex <code class="constant">i</code> belongs to
(or its vertex type), <code class="literal"> d(i,j)=1</code>  if <code class="literal"> i=j</code>  and 0 otherwise,
and the sum goes over all <code class="literal"> i, j</code>  pairs of vertices.

</p>
<p>
The resolution parameter <code class="constant">gamma</code> allows weighting the random null model, which
might be useful when finding partitions with a high modularity. Maximizing modularity
with higher values of the resolution parameter typically results in more, smaller clusters
when finding partitions with a high modularity. Lower values typically results in
fewer, larger clusters. The original definition of modularity is retrieved
when setting <code class="literal"> gamma=1</code> .

</p>
<p>
Modularity can also be calculated on directed graphs. This only requires a relatively
modest change

</p>
<p>
<code class="literal"> Q = 1/(m) sum_ij (A_ij - gamma * k^out_i * k^in_j / m) * d(c_i,c_j)</code> ,

</p>
<p>
where <code class="constant">k^out_i</code> is the out-degree of node <code class="constant">i</code> and <code class="constant">k^in_j</code> is the in-degree of node <code class="constant">j</code>.

</p>
<p>
Modularity on weighted graphs is also meaningful. When taking
edge weights into account, <code class="constant">A_ij</code> equals the weight of the corresponding edge
(or 0 if there is no edge), <code class="constant">k_i</code> is the strength (i.e. the weighted degree) of
vertex <code class="constant">i</code>, with similar counterparts for a directed graph, and <code class="constant">m</code> is the total
weight of all edges.

</p>
<p>
Note that the modularity is not well-defined for graphs with no edges.
igraph returns <code class="constant">NaN</code> for graphs with no edges; see
<a class="ulink" href="https://github.com/igraph/igraph/issues/1539" target="_top">https://github.com/igraph/igraph/issues/1539</a> for
a detailed discussion.

</p>
<p>
For the original definition of modularity, see Newman, M. E. J., and Girvan, M.
(2004). Finding and evaluating community structure in networks.
Physical Review E 69, 026113. <a class="ulink" href="https://doi.org/10.1103/PhysRevE.69.026113" target="_top">https://doi.org/10.1103/PhysRevE.69.026113</a>

</p>
<p>
For the directed definition of modularity, see Leicht, E. A., and Newman, M. E.
J. (2008). Community Structure in Directed Networks. Physical Review Letters 100,
118703. <a class="ulink" href="https://doi.org/10.1103/PhysRevLett.100.118703" target="_top">https://doi.org/10.1103/PhysRevLett.100.118703</a>

</p>
<p>
For the introduction of the resolution parameter, see Reichardt, J., and
Bornholdt, S. (2006). Statistical mechanics of community detection. Physical
Review E 74, 016110. <a class="ulink" href="https://doi.org/10.1103/PhysRevE.74.016110" target="_top">https://doi.org/10.1103/PhysRevE.74.016110</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  Numeric vector of integer values which gives the type of each
                  vertex, i.e. the cluster to which it belongs.
                  It does not have to be consecutive, i.e. empty communities
                  are allowed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Weight vector or <code class="constant">NULL</code> if no weights are specified.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>resolution</code></em>:</span></p></td>
<td><p>
  Resolution parameter. Must be greater than or equal to 0.
                  Set it to 1 to use the classical definition of modularity.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Whether to use the directed or undirected version of modularity.
                  Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>modularity</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the result will be
                  stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Community.html#igraph_modularity_matrix" title="1.2. igraph_modularity_matrix — Calculate the modularity matrix"><code class="function">igraph_modularity_matrix()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_modularity_matrix"></a>1.2. <code class="function">igraph_modularity_matrix</code> —  Calculate the modularity matrix</h3></div></div></div>
<a class="indexterm" name="idp105545339934792"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_modularity_matrix(const igraph_t *graph,
                             const igraph_vector_t *weights,
                             const igraph_real_t resolution,
                             igraph_matrix_t *modmat,
                             igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



This function returns the modularity matrix defined as

</p>
<p>
<code class="literal"> B_ij = A_ij - gamma * k_i * k_j / (2m)</code> 

</p>
<p>
for undirected graphs, where <code class="constant">A_ij</code> is the adjacency matrix, <code class="constant">gamma</code> is the
resolution parameter, <code class="constant">k_i</code> is the degree of vertex <code class="constant">i</code>, and <code class="constant">m</code> is the
number of edges in the graph. When there are no edges, or the weights add up
to zero, the result is undefined.

</p>
<p>
For directed graphs the modularity matrix is changed to

</p>
<p>
<code class="literal"> B_ij = A_ij - gamma * k^out_i * k^in_j / m</code> 
where <code class="literal"> k^out_i</code>  is the out-degree of node <code class="constant">i</code> and <code class="literal"> k^in_j</code>  is the
in-degree of node <code class="constant">j</code>.

</p>
<p>
Note that self-loops in undirected graphs are multiplied by 2 in this
implementation. If weights are specified, the weighted counterparts are used.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Edge weights, pointer to a vector. If this is a null pointer
                  then every edge is assumed to have a weight of 1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>resolution</code></em>:</span></p></td>
<td><p>
  Resolution parameter. Must be greater than or equal to 0.
                  Default is 1. Lower values favor fewer, larger communities;
                  higher values favor more, smaller communities.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>modmat</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix in which the modularity
                  matrix is stored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  For directed graphs: if the edges should be treated as
                  undirected.
                  For undirected graphs this is ignored.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Community.html#igraph_modularity" title="1.1. igraph_modularity — Calculate the modularity of a graph with respect to some clusters or vertex types."><code class="function">igraph_modularity()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_optimal_modularity"></a>1.3. <code class="function">igraph_community_optimal_modularity</code> — Calculate the community structure with the highest modularity value</h3></div></div></div>
<a class="indexterm" name="idp105545339824584"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_optimal_modularity(const igraph_t *graph,
                                        igraph_real_t *modularity,
                                        igraph_vector_t *membership,
                                        const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>



This function calculates the optimal community structure for a
graph, in terms of maximal modularity score.

</p>
<p>
The calculation is done by transforming the modularity maximization
into an integer programming problem, and then calling the GLPK
library to solve that. Please see Ulrik Brandes et al.: On
Modularity Clustering, IEEE Transactions on Knowledge and Data
Engineering 20(2):172-188, 2008.

</p>
<p>
Note that modularity optimization is an NP-complete problem, and
all known algorithms for it have exponential time complexity. This
means that you probably don't want to run this function on larger
graphs. Graphs with up to fifty vertices should be fine, graphs
with a couple of hundred vertices might be possible.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It is always treated as undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>modularity</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, or a null pointer.
       If it is not a null pointer, then a optimal modularity value
       is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, or a null pointer. If not a
       null pointer, then the membership vector of the optimal
       community structure is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Vector giving the weights of the edges. If it is
       <code class="constant">NULL</code> then each edge is supposed to have the same weight.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Community.html#igraph_modularity" title="1.1. igraph_modularity — Calculate the modularity of a graph with respect to some clusters or vertex types."><code class="function">igraph_modularity()</code></a>, <a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity."><code class="function">igraph_community_fastgreedy()</code></a>
for an algorithm that finds a local optimum in a greedy way.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential in the number of vertices.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545339840456"></a><p class="title"><b>Example 24.1.  File <code class="code">examples/simple/igraph_community_optimal_modularity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2010-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>prepare_weights_vector</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>* weights, <span class="strong"><strong>const</strong></span> igraph_t* graph) {
    int i, n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_resize" title="2.13.3. igraph_vector_resize — Resize the vector.">igraph_vector_resize</a></strong></span>(weights, n);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*weights)[i] = i % 5;
    }
}

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;

    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> v;
    igraph_real_t edges[] = { 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8,
                              0, 10, 0, 11, 0, 12, 0, 13, 0, 17, 0, 19, 0, 21, 0, 31,
                              1, 2, 1, 3, 1, 7, 1, 13, 1, 17, 1, 19, 1, 21, 1, 30,
                              2, 3, 2, 7, 2, 27, 2, 28, 2, 32, 2, 9, 2, 8, 2, 13,
                              3, 7, 3, 12, 3, 13, 4, 6, 4, 10, 5, 6, 5, 10, 5, 16,
                              6, 16, 8, 30, 8, 32, 8, 33, 9, 33, 13, 33, 14, 32, 14, 33,
                              15, 32, 15, 33, 18, 32, 18, 33, 19, 33, 20, 32, 20, 33,
                              22, 32, 22, 33, 23, 25, 23, 27, 23, 32, 23, 33, 23, 29,
                              24, 25, 24, 27, 24, 31, 25, 31, 26, 29, 26, 33, 27, 33,
                              28, 31, 28, 33, 29, 32, 29, 33, 30, 32, 30, 33, 31, 32, 31, 33,
                              32, 33
                            };

    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> membership;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_real_t modularity;
    igraph_bool_t simple;
    int retval;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;v, edges, <span class="strong"><strong>sizeof</strong></span>(edges) / <span class="strong"><strong>sizeof</strong></span>(double));
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_create" title="1.1. igraph_create — Creates a graph with the specified edges.">igraph_create</a></strong></span>(&amp;graph, &amp;v, 0, IGRAPH_UNDIRECTED);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_simple" title="16.1. igraph_is_simple — Decides whether the input graph is a simple graph.">igraph_is_simple</a></strong></span>(&amp;graph, &amp;simple);
    <span class="strong"><strong>if</strong></span> (!simple) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;membership, 0);

    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(&amp;<a class="link" href="igraph-Error.html#igraph_error_handler_printignore" title="2.4. igraph_error_handler_printignore — Print and ignore errors.">igraph_error_handler_printignore</a>);

    <span class="emphasis"><em>/* Zachary karate club, unweighted */</em></span>
    retval = <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_optimal_modularity" title="1.3. igraph_community_optimal_modularity — Calculate the community structure with the highest modularity value">igraph_community_optimal_modularity</a></strong></span>(&amp;graph, &amp;modularity,
             &amp;membership, 0);
    <span class="strong"><strong>if</strong></span> (retval == IGRAPH_UNIMPLEMENTED) {
        <span class="strong"><strong>return</strong></span> 77;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(modularity - 0.4197896) &gt; 0.0000001) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="emphasis"><em>/* Zachary karate club, weighted */</em></span>
    <span class="strong"><strong>prepare_weights_vector</strong></span>(&amp;weights, &amp;graph);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_optimal_modularity" title="1.3. igraph_community_optimal_modularity — Calculate the community structure with the highest modularity value">igraph_community_optimal_modularity</a></strong></span>(&amp;graph, &amp;modularity,
                                        &amp;membership, &amp;weights);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(modularity - 0.5115767) &gt; 0.0000001) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="emphasis"><em>/* simple graph with loop edges, unweighted */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 6, IGRAPH_UNDIRECTED,
                 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 0, 0, 0, 2, 2, -1);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_optimal_modularity" title="1.3. igraph_community_optimal_modularity — Calculate the community structure with the highest modularity value">igraph_community_optimal_modularity</a></strong></span>(&amp;graph, &amp;modularity,
                                        &amp;membership, 0);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(modularity - 0.28125) &gt; 0.00001) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="emphasis"><em>/* simple graph with loop edges, weighted */</em></span>
    <span class="strong"><strong>prepare_weights_vector</strong></span>(&amp;weights, &amp;graph);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_optimal_modularity" title="1.3. igraph_community_optimal_modularity — Calculate the community structure with the highest modularity value">igraph_community_optimal_modularity</a></strong></span>(&amp;graph, &amp;modularity,
                                        &amp;membership, &amp;weights);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(modularity - 0.36686) &gt; 0.00001) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;membership);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);

    <span class="strong"><strong>return</strong></span> 0;
}

</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_to_membership"></a>1.4. <code class="function">igraph_community_to_membership</code> —  Create membership vector from community structure dendrogram</h3></div></div></div>
<a class="indexterm" name="idp105545340013256"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_to_membership(const igraph_matrix_t *merges,
                                   igraph_integer_t nodes,
                                   igraph_integer_t steps,
                                   igraph_vector_t *membership,
                                   igraph_vector_t *csize);
</pre></div>
<p>
</p>
<p>



This function creates a membership vector from a community
structure dendrogram. A membership vector contains for each vertex
the id of its graph component, the graph components are numbered
from zero, see the same argument of <a class="link" href="igraph-Structural.html#igraph_clusters" title="6.2. igraph_clusters — Calculates the (weakly or strongly) connected components in a graph."><code class="function">igraph_clusters()</code></a> for an
example of a membership vector.

</p>
<p>
Many community detection algorithms return with a <span class="emphasis"><em>merges</em></span>
matrix, <a class="link" href="igraph-Community.html#igraph_community_walktrap" title="4.1. igraph_community_walktrap — This function is the implementation of the Walktrap community"><code class="function">igraph_community_walktrap()</code></a> and <a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness."><code class="function">igraph_community_edge_betweenness()</code></a> are two examples. The matrix
contains the merge operations performed while mapping the
hierarchical structure of a network. If the matrix has <code class="constant">n-1</code> rows,
where <code class="constant">n</code> is the number of vertices in the graph, then it contains
the hierarchical structure of the whole network and it is called a
dendrogram.

</p>
<p>
This function performs <em class="parameter"><code>steps</code></em> merge operations as prescribed by
the <em class="parameter"><code>merges</code></em> matrix and returns the current state of the network.

</p>
<p>
If <em class="parameter"><code>merges</code></em> is not a complete dendrogram, it is possible to
take <em class="parameter"><code>steps</code></em> steps if <em class="parameter"><code>steps</code></em> is not bigger than the number
lines in <em class="parameter"><code>merges</code></em>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>merges</code></em>:</span></p></td>
<td><p>
  The two-column matrix containing the merge
   operations. See <a class="link" href="igraph-Community.html#igraph_community_walktrap" title="4.1. igraph_community_walktrap — This function is the implementation of the Walktrap community"><code class="function">igraph_community_walktrap()</code></a> for the
   detailed syntax.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of leaf nodes in the dendrogram.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>steps</code></em>:</span></p></td>
<td><p>
  Integer constant, the number of steps to take.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the membership
   results will be stored here, if not NULL. The vector will be
   resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>csize</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, or NULL. If not NULL
   then the sizes of the components will be stored here, the vector
   will be resized as needed.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Community.html#igraph_community_walktrap" title="4.1. igraph_community_walktrap — This function is the implementation of the Walktrap community"><code class="function">igraph_community_walktrap()</code></a>, <a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness."><code class="function">igraph_community_edge_betweenness()</code></a>, <a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity."><code class="function">igraph_community_fastgreedy()</code></a> for community structure detection
algorithms.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|), the number of vertices in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_reindex_membership"></a>1.5. <code class="function">igraph_reindex_membership</code> —  Makes the IDs in a membership vector continuous</h3></div></div></div>
<a class="indexterm" name="idp105545340037576"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_reindex_membership(igraph_vector_t *membership,
                              igraph_vector_t *new_to_old,
                              igraph_integer_t *nb_clusters);
</pre></div>
<p>
</p>
<p>



This function reindexes component IDs in a membership vector
in a way that the new IDs start from zero and go up to C-1,
where C is the number of unique component IDs in the original
vector. The supplied membership is expected to fall in the
range 0, ..., n - 1.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  Numeric vector which gives the type of each
                    vertex, i.e. the component to which it belongs.
                    The vector will be altered in-place.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>new_to_old</code></em>:</span></p></td>
<td><p>
  Pointer to a vector which will contain the
                    old component ID for each new one, or NULL,
                    in which case it is not returned. The vector
                    will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nb_clusters</code></em>:</span></p></td>
<td><p>
  Pointer to an integer for the number of
                    distinct clusters. If not NULL, this will be
                    updated to reflect the number of distinct
                    clusters found in membership.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: should be O(n) for n elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_compare_communities"></a>1.6. <code class="function">igraph_compare_communities</code> —  Compares community structures using various metrics</h3></div></div></div>
<a class="indexterm" name="idp105545340046536"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_compare_communities(const igraph_vector_t *comm1,
                               const igraph_vector_t *comm2, igraph_real_t* result,
                               igraph_community_comparison_t method);
</pre></div>
<p>
</p>
<p>




This function assesses the distance between two community structures
using the variation of information (VI) metric of Meila (2003), the
normalized mutual information (NMI) of Danon et al (2005), the
split-join distance of van Dongen (2000), the Rand index of Rand (1971)
or the adjusted Rand index of Hubert and Arabie (1985).

</p>
<p>
References:

</p>
<p>
Meila M: Comparing clusterings by the variation of information.
In: Schölkopf B, Warmuth MK (eds.). Learning Theory and Kernel Machines:
16th Annual Conference on Computational Learning Theory and 7th Kernel
Workshop, COLT/Kernel 2003, Washington, DC, USA. Lecture Notes in Computer
Science, vol. 2777, Springer, 2003. ISBN: 978-3-540-40720-1.

</p>
<p>
Danon L, Diaz-Guilera A, Duch J, Arenas A: Comparing community structure
identification. J Stat Mech P09008, 2005.

</p>
<p>
van Dongen S: Performance criteria for graph clustering and Markov cluster
experiments. Technical Report INS-R0012, National Research Institute for
Mathematics and Computer Science in the Netherlands, Amsterdam, May 2000.

</p>
<p>
Rand WM: Objective criteria for the evaluation of clustering methods.
J Am Stat Assoc 66(336):846-850, 1971.

</p>
<p>
Hubert L and Arabie P: Comparing partitions. Journal of Classification
2:193-218, 1985.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>comm1</code></em>:</span></p></td>
<td><p>
  the membership vector of the first community structure
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>comm2</code></em>:</span></p></td>
<td><p>
  the membership vector of the second community structure
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>method</code></em>:</span></p></td>
<td><p>
  the comparison method to use. <code class="constant">IGRAPH_COMMCMP_VI</code>
                selects the variation of information (VI) metric of
                Meila (2003), <code class="constant">IGRAPH_COMMCMP_NMI</code> selects the
                normalized mutual information measure proposed by
                Danon et al (2005), <code class="constant">IGRAPH_COMMCMP_SPLIT_JOIN</code>
                selects the split-join distance of van Dongen (2000),
                <code class="constant">IGRAPH_COMMCMP_RAND</code> selects the unadjusted Rand
                index (1971) and <code class="constant">IGRAPH_COMMCMP_ADJUSTED_RAND</code>
                selects the adjusted Rand index.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n log(n)).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_split_join_distance"></a>1.7. <code class="function">igraph_split_join_distance</code> —  Calculates the split-join distance of two community structures</h3></div></div></div>
<a class="indexterm" name="idp105545340062792"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_split_join_distance(const igraph_vector_t *comm1,
                               const igraph_vector_t *comm2, igraph_integer_t *distance12,
                               igraph_integer_t *distance21);
</pre></div>
<p>
</p>
<p>




The split-join distance between partitions A and B is the sum of the
projection distance of A from B and the projection distance of B from
A. The projection distance is an asymmetric measure and it is defined
as follows:

</p>
<p>
First, each set in partition A is evaluated against all sets in partition
B. For each set in partition A, the best matching set in partition B is
found and the overlap size is calculated. (Matching is quantified by the
size of the overlap between the two sets). Then, the maximal overlap sizes
for each set in A are summed together and subtracted from the number of
elements in A.

</p>
<p>
The split-join distance will be returned in two arguments, <code class="constant">distance12</code>
will contain the projection distance of the first partition from the
second, while <code class="constant">distance21</code> will be the projection distance of the second
partition from the first. This makes it easier to detect whether a
partition is a subpartition of the other, since in this case, the
corresponding distance will be zero.

</p>
<p>
Reference:

</p>
<p>
van Dongen S: Performance criteria for graph clustering and Markov cluster
experiments. Technical Report INS-R0012, National Research Institute for
Mathematics and Computer Science in the Netherlands, Amsterdam, May 2000.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>comm1</code></em>:</span></p></td>
<td><p>
  the membership vector of the first community structure
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>comm2</code></em>:</span></p></td>
<td><p>
  the membership vector of the second community structure
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>distance12</code></em>:</span></p></td>
<td><p>
  pointer to an <code class="constant">igraph_integer_t</code>, the projection distance
                    of the first community structure from the second one will be
                    returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>distance21</code></em>:</span></p></td>
<td><p>
  pointer to an <code class="constant">igraph_integer_t</code>, the projection distance
                    of the second community structure from the first one will be
                    returned here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

\see <a class="link" href="igraph-Community.html#igraph_compare_communities" title="1.6. igraph_compare_communities — Compares community structures using various metrics"><code class="function">igraph_compare_communities()</code></a> with the <code class="constant">IGRAPH_COMMCMP_SPLIT_JOIN</code>
method if you are not interested in the individual distances but only the sum
of them.

Time complexity: O(n log(n)).
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="community-detection-based-on-statistical-mechanics"></a>2. Community structure based on statistical mechanics</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Community.html#igraph_community_spinglass">2.1. <code class="function">igraph_community_spinglass</code> —  Community detection based on statistical mechanics</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#igraph_community_spinglass_single">2.2. <code class="function">igraph_community_spinglass_single</code> —  Community of a single node based on statistical mechanics</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_spinglass"></a>2.1. <code class="function">igraph_community_spinglass</code> —  Community detection based on statistical mechanics</h3></div></div></div>
<a class="indexterm" name="idp105545339948872"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_spinglass(const igraph_t *graph,
                               const igraph_vector_t *weights,
                               igraph_real_t *modularity,
                               igraph_real_t *temperature,
                               igraph_vector_t *membership,
                               igraph_vector_t *csize,
                               igraph_integer_t spins,
                               igraph_bool_t parupdate,
                               igraph_real_t starttemp,
                               igraph_real_t stoptemp,
                               igraph_real_t coolfact,
                               igraph_spincomm_update_t update_rule,
                               igraph_real_t gamma,
                               /* the rest is for the NegSpin implementation */
                               igraph_spinglass_implementation_t implementation,
                               /*                 igraph_matrix_t *adhesion, */
                               /*                 igraph_matrix_t *normalised_adhesion, */
                               /*                 igraph_real_t *polarization, */
                               igraph_real_t gamma_minus);
</pre></div>
<p>
</p>
<p>



This function implements the community structure detection
algorithm proposed by Joerg Reichardt and Stefan Bornholdt.
The algorithm is described in their paper: Statistical Mechanics of
Community Detection, <a class="ulink" href="http://arxiv.org/abs/cond-mat/0603718" target="_top">http://arxiv.org/abs/cond-mat/0603718</a> .

</p>
<p>
From version 0.6, igraph also supports an extension to
the algorithm that allows negative edge weights. This is described
in  V. A. Traag and Jeroen Bruggeman: Community detection in networks
with positive and negative links, <a class="ulink" href="http://arxiv.org/abs/0811.2329" target="_top">http://arxiv.org/abs/0811.2329</a> .

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it may be directed but the direction
    of the edges is not used in the algorithm.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The vector giving the edge weights, it may be <code class="constant">NULL</code>,
    in which case all edges are weighted equally. The edge weights
    must be positive unless using the <code class="constant">IGRAPH_SPINCOMM_IMP_NEG</code>
    implementation. This condition is not verified by the function.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>modularity</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, if not <code class="constant">NULL</code> then the
    modularity score of the solution will be stored here. This is the
    gereralized modularity that simplifies to the one defined in
    M. E. J. Newman and M. Girvan, Phys. Rev. E 69, 026113 (2004),
    if the gamma parameter is one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>temperature</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, if not <code class="constant">NULL</code> then
    the temperature at the end of the algorithm will be stored
    here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or <code class="constant">NULL</code>. If
    not <code class="constant">NULL</code> then the result of the clustering will be stored
    here. For each vertex, the number of its cluster is given, with the
    first cluster numbered zero. The vector will be resized as
    needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>csize</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or <code class="constant">NULL</code>. If not <code class="constant">NULL</code> then the sizes of the clusters will stored here in cluster
    number order. The vector will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>spins</code></em>:</span></p></td>
<td><p>
  Integer giving the number of spins, i.e. the maximum
    number of clusters. Usually it is not a program to give a high
    number here, the default was 25 in the original code. Even if
    the number of spins is high the number of clusters in the
    result might be small.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>parupdate</code></em>:</span></p></td>
<td><p>
  A logical constant, whether to update all spins in
    parallel. The default for this argument was <code class="constant">FALSE</code> (i.e. 0) in
    the original code. It is not implemented in the <code class="constant">IGRAPH_SPINCOMM_INP_NEG</code> implementation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>starttemp</code></em>:</span></p></td>
<td><p>
  Real number, the temperature at the start. The
    value of this argument was 1.0 in the original code.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>stoptemp</code></em>:</span></p></td>
<td><p>
  Real number, the algorithm stops at this
    temperature. The default was 0.01 in the original code.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>coolfact</code></em>:</span></p></td>
<td><p>
  Real number, the cooling factor for the simulated
    annealing. The default was 0.99 in the original code.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>update_rule</code></em>:</span></p></td>
<td><p>
  The type of the update rule. Possible values: <code class="constant">IGRAPH_SPINCOMM_UPDATE_SIMPLE</code> and <code class="constant">IGRAPH_SPINCOMM_UPDATE_CONFIG</code>. Basically this parameter defines
    the null model based on which the actual clustering is done. If
    this is <code class="constant">IGRAPH_SPINCOMM_UPDATE_SIMPLE</code> then the random graph
    (i.e. G(n,p)), if it is <code class="constant">IGRAPH_SPINCOMM_UPDATE</code> then the
    configuration model is used. The configuration means that the
    baseline for the clustering is a random graph with the same
    degree distribution as the input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>gamma</code></em>:</span></p></td>
<td><p>
  Real number. The gamma parameter of the
    algorithm. This defines the weight of the missing and existing
    links in the quality function for the clustering. The default
    value in the original code was 1.0, which is equal weight to
    missing and existing edges. Smaller values make the existing
    links contibute more to the energy function which is minimized
    in the algorithm. Bigger values make the missing links more
    important. (If my understanding is correct.)
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>implementation</code></em>:</span></p></td>
<td><p>
  Constant, chooses between the two
    implementations of the spin-glass algorithm that are included
    in igraph. <code class="constant">IGRAPH_SPINCOMM_IMP_ORIG</code> selects the original
    implementation, this is faster, <code class="constant">IGRAPH_SPINCOMM_INP_NEG</code> selects
    a new implementation by Vincent Traag that allows negative edge
    weights.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>gamma_minus</code></em>:</span></p></td>
<td><p>
  Real number. Parameter for the <code class="constant">IGRAPH_SPINCOMM_IMP_NEG</code> implementation. This
    specifies the balance between the importance of present and
    non-present negative weighted edges in a community. Smaller values of
    <em class="parameter"><code>gamma_minus</code></em> lead to communities with lesser
    negative intra-connectivity.
    If this argument is set to zero, the algorithm reduces to a graph
    coloring algorithm, using the number of spins as the number of
    colors.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  igraph_community_spinglass_single() for calculating the community
of a single vertex.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_spinglass_single"></a>2.2. <code class="function">igraph_community_spinglass_single</code> —  Community of a single node based on statistical mechanics</h3></div></div></div>
<a class="indexterm" name="idp105545339987784"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_spinglass_single(const igraph_t *graph,
                                      const igraph_vector_t *weights,
                                      igraph_integer_t vertex,
                                      igraph_vector_t *community,
                                      igraph_real_t *cohesion,
                                      igraph_real_t *adhesion,
                                      igraph_integer_t *inner_links,
                                      igraph_integer_t *outer_links,
                                      igraph_integer_t spins,
                                      igraph_spincomm_update_t update_rule,
                                      igraph_real_t gamma);
</pre></div>
<p>
</p>
<p>



This function implements the community structure detection
algorithm proposed by Joerg Reichardt and Stefan Bornholdt. It is
described in their paper: Statistical Mechanics of
Community Detection, <a class="ulink" href="http://arxiv.org/abs/cond-mat/0603718" target="_top">http://arxiv.org/abs/cond-mat/0603718</a> .

</p>
<p>
This function calculates the community of a single vertex without
calculating all the communities in the graph.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it may be directed but the direction
   of the edges is not used in the algorithm.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Pointer to a vector with the weights of the edges.
   Alternatively <code class="constant">NULL</code> can be supplied to have the same weight
   for every edge.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex</code></em>:</span></p></td>
<td><p>
  The vertex id of the vertex of which ths community is
   calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>community</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result, the
   ids of the vertices in the community of the input vertex will be
   stored here. The vector will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cohesion</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, if not <code class="constant">NULL</code> the
    cohesion index of the community will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>adhesion</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, if not <code class="constant">NULL</code> the
    adhesion index of the community will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>inner_links</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> the
    number of edges within the community is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>outer_links</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> the
    number of edges between the community and the rest of the graph
    will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>spins</code></em>:</span></p></td>
<td><p>
  The number of spins to use, this can be higher than
   the actual number of clusters in the network, in which case some
   clusters will contain zero vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>update_rule</code></em>:</span></p></td>
<td><p>
  The type of the update rule. Possible values: <code class="constant">IGRAPH_SPINCOMM_UPDATE_SIMPLE</code> and <code class="constant">IGRAPH_SPINCOMM_UPDATE_CONFIG</code>. Basically this parameter defined
    the null model based on which the actual clustering is done. If
    this is <code class="constant">IGRAPH_SPINCOMM_UPDATE_SIMPLE</code> then the random graph
    (ie. G(n,p)), if it is <code class="constant">IGRAPH_SPINCOMM_UPDATE</code> then the
    configuration model is used. The configuration means that the
    baseline for the clustering is a random graph with the same
    degree distribution as the input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>gamma</code></em>:</span></p></td>
<td><p>
  Real number. The gamma parameter of the
    algorithm. This defined the weight of the missing and existing
    links in the quality function for the clustering. The default
    value in the original code was 1.0, which is equal weight to
    missing and existing edges. Smaller values make the existing
    links contibute more to the energy function which is minimized
    in the algorithm. Bigger values make the missing links more
    important. (If my understanding is correct.)
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  igraph_community_spinglass() for the traditional version of the
algorithm.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="community-structure-based-on-eigenvectors-of-matrices"></a>3. Community structure based on eigenvectors of matrices</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Community.html#igraph_community_leading_eigenvector">3.1. <code class="function">igraph_community_leading_eigenvector</code> —  Leading eigenvector community finding (proper version).</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#igraph_community_leading_eigenvector_callback_t">3.2. <code class="function">igraph_community_leading_eigenvector_callback_t</code> — Callback for the leading eigenvector community finding method.</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#igraph_le_community_to_membership">3.3. <code class="function">igraph_le_community_to_membership</code> — Vertex membership from the leading eigenvector community structure</a></span></dt>
</dl></div>
<p>
The function documented in these section implements the
<span class="quote">“<span class="quote">leading eigenvector</span>”</span> method developed by Mark Newman and
published in MEJ Newman: Finding community structure using the
eigenvectors of matrices, Phys Rev E 74:036104 (2006).</p>
<p>
The heart of the method is the definition of the modularity matrix,
B, which is B=A-P, A being the adjacency matrix of the (undirected)
network, and P contains the probability that certain edges are
present according to the <span class="quote">“<span class="quote">configuration model</span>”</span> In
other words, a Pij element of P is the probability that there is an
edge between vertices i and j in a random network in which the
degrees of all vertices are the same as in the input graph.</p>
<p>
The leading eigenvector method works by calculating the eigenvector
of the modularity matrix for the largest positive eigenvalue and
then separating vertices into two community based on the sign of
the corresponding element in the eigenvector. If all elements in
the eigenvector are of the same sign that means that the network
has no underlying community structure.
Check Newman's paper to understand why this is a good method for
detecting community structure. </p>
<p>
The leading eigenvector community structure detection method is
implemented in <a class="link" href="igraph-Community.html#igraph_community_leading_eigenvector" title="3.1. igraph_community_leading_eigenvector — Leading eigenvector community finding (proper version)."><code class="function">igraph_community_leading_eigenvector()</code></a>. After
the initial split, the following splits are done in a way to
optimize modularity regarding to the original network. Note that
any further refinement, for example using Kernighan-Lin, as
proposed in Section V.A of Newman (2006), is not implemented here.
</p>
<p>
</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545339626568"></a><p class="title"><b>Example 24.2.  File <code class="code">examples/simple/igraph_community_leading_eigenvector.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2007-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>print_vector</strong></span>(<span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v) {
    long int i, n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(v);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>printf</strong></span>("%.2g", (double)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i]);
        <span class="strong"><strong>if</strong></span> (i != n - 1) {
            <span class="strong"><strong>printf</strong></span>(" ");
        }
    }
    <span class="strong"><strong>printf</strong></span>("\n");
    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>print_matrix</strong></span>(<span class="strong"><strong>const</strong></span> igraph_matrix_t *m) {
    long int i, j, nrow = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(m), ncol = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(m);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; nrow; i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; ncol; j++) {
            <span class="strong"><strong>printf</strong></span>("%.2g", (double)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>if</strong></span> (j != ncol - 1) {
                <span class="strong"><strong>printf</strong></span>(" ");
            }
        }
        <span class="strong"><strong>printf</strong></span>("\n");
    }
    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t merges;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> membership;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> x;
    <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK">igraph_arpack_options_t</a> options;

    <span class="emphasis"><em>/* Zachary Karate club */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED,
                 0,  1,  0,  2,  0,  3,  0,  4,  0,  5,
                 0,  6,  0,  7,  0,  8,  0, 10,  0, 11,
                 0, 12,  0, 13,  0, 17,  0, 19,  0, 21,
                 0, 31,  1,  2,  1,  3,  1,  7,  1, 13,
                 1, 17,  1, 19,  1, 21,  1, 30,  2,  3,
                 2,  7,  2,  8,  2,  9,  2, 13,  2, 27,
                 2, 28,  2, 32,  3,  7,  3, 12,  3, 13,
                 4,  6,  4, 10,  5,  6,  5, 10,  5, 16,
                 6, 16,  8, 30,  8, 32,  8, 33,  9, 33,
                 13, 33, 14, 32, 14, 33, 15, 32, 15, 33,
                 18, 32, 18, 33, 19, 33, 20, 32, 20, 33,
                 22, 32, 22, 33, 23, 25, 23, 27, 23, 29,
                 23, 32, 23, 33, 24, 25, 24, 27, 24, 31,
                 25, 31, 26, 29, 26, 33, 27, 33, 28, 31,
                 28, 33, 29, 32, 29, 33, 30, 32, 30, 33,
                 31, 32, 31, 33, 32, 33,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;merges, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;membership, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;x, 0);
    <span class="strong"><strong><a class="link" href="igraph-Arpack.html#igraph_arpack_options_init" title="3.1.4. igraph_arpack_options_init — Initialize ARPACK options">igraph_arpack_options_init</a></strong></span>(&amp;options);

    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_leading_eigenvector" title="3.1. igraph_community_leading_eigenvector — Leading eigenvector community finding (proper version).">igraph_community_leading_eigenvector</a></strong></span>(&amp;g, <span class="emphasis"><em>/*weights=*/</em></span> 0, &amp;merges,
                                         &amp;membership, 1,
                                         &amp;options, <span class="emphasis"><em>/*modularity=*/</em></span> 0,
                                         <span class="emphasis"><em>/*start=*/</em></span> 0, <span class="emphasis"><em>/*eigenvalues=*/</em></span> 0,
                                         <span class="emphasis"><em>/*eigenvectors=*/</em></span> 0, <span class="emphasis"><em>/*history=*/</em></span> 0,
                                         <span class="emphasis"><em>/*callback=*/</em></span> 0,
                                         <span class="emphasis"><em>/*callback_extra=*/</em></span> 0);

    <span class="strong"><strong>print_matrix</strong></span>(&amp;merges);
    <span class="strong"><strong>print_vector</strong></span>(&amp;membership);

    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="emphasis"><em>/* Make all the steps */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_leading_eigenvector" title="3.1. igraph_community_leading_eigenvector — Leading eigenvector community finding (proper version).">igraph_community_leading_eigenvector</a></strong></span>(&amp;g, <span class="emphasis"><em>/*weights=*/</em></span> 0, &amp;merges,
                                         &amp;membership, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g),
                                         &amp;options, <span class="emphasis"><em>/*modularity=*/</em></span> 0,
                                         <span class="emphasis"><em>/*start=*/</em></span> 0, <span class="emphasis"><em>/*eigenvalues=*/</em></span> 0,
                                         <span class="emphasis"><em>/*eigenvectors=*/</em></span> 0, <span class="emphasis"><em>/*history=*/</em></span> 0,
                                         <span class="emphasis"><em>/*callback=*/</em></span> 0,
                                         <span class="emphasis"><em>/*callback_extra=*/</em></span> 0);

    <span class="strong"><strong>print_matrix</strong></span>(&amp;merges);
    <span class="strong"><strong>print_vector</strong></span>(&amp;membership);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;x);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;membership);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;merges);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_leading_eigenvector"></a>3.1. <code class="function">igraph_community_leading_eigenvector</code> —  Leading eigenvector community finding (proper version).</h3></div></div></div>
<a class="indexterm" name="idp105545339671752"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_leading_eigenvector(const igraph_t *graph,
        const igraph_vector_t *weights,
        igraph_matrix_t *merges,
        igraph_vector_t *membership,
        igraph_integer_t steps,
        igraph_arpack_options_t *options,
        igraph_real_t *modularity,
        igraph_bool_t start,
        igraph_vector_t *eigenvalues,
        igraph_vector_ptr_t *eigenvectors,
        igraph_vector_t *history,
        igraph_community_leading_eigenvector_callback_t *callback,
        void *callback_extra);
</pre></div>
<p>
</p>
<p>




Newman's leading eigenvector method for detecting community
structure. This is the proper implementation of the recursive,
divisive algorithm: each split is done by maximizing the modularity
regarding the original network, see MEJ Newman: Finding community
structure in networks using the eigenvectors of matrices,
Phys Rev E 74:036104 (2006).

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The undirected input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The weights of the edges, or a null pointer for
   unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>merges</code></em>:</span></p></td>
<td><p>
  The result of the algorithm, a matrix containing the
   information about the splits performed. The matrix is built in
   the opposite way however, it is like the result of an
   agglomerative algorithm. If at the end of the algorithm (after
   <em class="parameter"><code>steps</code></em> steps was done) there are <span class="quote">“<span class="quote">p</span>”</span> communities,
   then these are numbered from zero to <span class="quote">“<span class="quote">p-1</span>”</span>. The
   first line of the matrix contains the first <span class="quote">“<span class="quote">merge</span>”</span>
   (which is in reality the last split) of two communities into
   community <span class="quote">“<span class="quote">p</span>”</span>, the merge in the second line forms
   community <span class="quote">“<span class="quote">p+1</span>”</span>, etc. The matrix should be
   initialized before calling and will be resized as needed.
   This argument is ignored of it is <code class="constant">NULL</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  The membership of the vertices after all the
   splits were performed will be stored here. The vector must be
   initialized  before calling and will be resized as needed.
   This argument is ignored if it is <code class="constant">NULL</code>. This argument can
   also be used to supply a starting configuration for the community
   finding, in the format of a membership vector. In this case the
   <em class="parameter"><code>start</code></em> argument must be set to 1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>steps</code></em>:</span></p></td>
<td><p>
  The maximum number of steps to perform. It might
   happen that some component (or the whole network) has no
   underlying community structure and no further steps can be
   done. If you want as many steps as possible then supply the
   number of vertices in the network here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  The options for ARPACK. <code class="constant">n</code> is always
   overwritten. <code class="constant">ncv</code> is set to at least 4.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>modularity</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then it must be a pointer
   to a real number and the modularity score of the final division
   is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>start</code></em>:</span></p></td>
<td><p>
  Boolean, whether to use the community structure given
   in the <em class="parameter"><code>membership</code></em> argument as a starting point.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>eigenvalues</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
   pointer. If not a null pointer, then the eigenvalues calculated
   along the community structure detection are stored here. The
   non-positive eigenvalues, that do not result a split, are stored
   as well.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>eigenvectors</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then the eigenvectors
   that are calculated in each step of the algorithm, are stored here,
   in a pointer vector. Each eigenvector is stored in an
   <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_t</code></a> object. The user is responsible of
   deallocating the memory that belongs to the individual vectors,
   by calling first <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a>, and then
   <a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions"><code class="function">igraph_free()</code></a> on them.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>history</code></em>:</span></p></td>
<td>
<p>
  Pointer to an initialized vector or a null pointer.
   If not a null pointer, then a trace of the algorithm is stored
   here, encoded numerically. The various operations:
   </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LEVC_HIST_START_FULL</code></span></p></td>
<td><p>

     Start the algorithm from an initial state where each connected
     component is a separate community.
   
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LEVC_HIST_START_GIVEN</code></span></p></td>
<td><p>

     Start the algorithm from a given community structure. The next
     value in the vector contains the initial number of
     communities.
   
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LEVC_HIST_SPLIT</code></span></p></td>
<td><p>

     Split a community into two communities. The id of the splitted
     community is given in the next element of the history vector.
     The id of the first new community is the same as the id of the
     splitted community. The id of the second community equals to
     the number of communities before the split.
   
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LEVC_HIST_FAILED</code></span></p></td>
<td><p>

     Tried to split a community, but it was not worth it, as it
     does not result in a bigger modularity value. The id of the
     community is given in the next element of the vector.
   
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>callback</code></em>:</span></p></td>
<td><p>
  A null pointer or a function of type <a class="link" href="igraph-Community.html#igraph_community_leading_eigenvector_callback_t" title="3.2. igraph_community_leading_eigenvector_callback_t — Callback for the leading eigenvector community finding method."><code class="function">igraph_community_leading_eigenvector_callback_t</code></a>. If given, this
   callback function is called after each eigenvector/eigenvalue
   calculation. If the callback returns a non-zero value, then the
   community finding algorithm stops. See the arguments passed to
   the callback at the documentation of <a class="link" href="igraph-Community.html#igraph_community_leading_eigenvector_callback_t" title="3.2. igraph_community_leading_eigenvector_callback_t — Callback for the leading eigenvector community finding method."><code class="function">igraph_community_leading_eigenvector_callback_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>callback_extra</code></em>:</span></p></td>
<td><p>
  Extra argument to pass to the callback
   function.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Community.html#igraph_community_walktrap" title="4.1. igraph_community_walktrap — This function is the implementation of the Walktrap community"><code class="function">igraph_community_walktrap()</code></a> and <a class="link" href="igraph-Community.html#igraph_community_spinglass" title="2.1. igraph_community_spinglass — Community detection based on statistical mechanics"><code class="function">igraph_community_spinglass()</code></a> for other community structure
detection methods.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|+|V|^2*steps), |V| is the number of vertices,
|E| the number of edges, <span class="quote">“<span class="quote">steps</span>”</span> the number of splits
performed.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_leading_eigenvector_callback_t"></a>3.2. <code class="function">igraph_community_leading_eigenvector_callback_t</code> — Callback for the leading eigenvector community finding method.</h3></div></div></div>
<a class="indexterm" name="idp105545339583560"></a><pre class="programlisting">
typedef int igraph_community_leading_eigenvector_callback_t(
    const igraph_vector_t *membership,
    long int comm,
    igraph_real_t eigenvalue,
    const igraph_vector_t *eigenvector,
    igraph_arpack_function_t *arpack_multiplier,
    void *arpack_extra,
    void *extra);
</pre>
<p>


The leading eigenvector community finding implementation in igraph
is able to call a callback function, after each eigenvalue
calculation. This callback function must be of <code class="constant">igraph_community_leading_eigenvector_callback_t</code> type.
The following arguments are passed to the callback:
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  The actual membership vector, before recording
   the potential change implied by the newly found eigenvalue.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>comm</code></em>:</span></p></td>
<td><p>
  The id of the community that the algorithm tried to
   split in the last iteration. The community ids are indexed from
   zero here!
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>eigenvalue</code></em>:</span></p></td>
<td><p>
  The eigenvalue the algorithm has just found.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>eigenvector</code></em>:</span></p></td>
<td><p>
  The eigenvector corresponding to the eigenvalue
   the algorithm just found.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arpack_multiplier</code></em>:</span></p></td>
<td><p>
  A function that was passed to <a class="link" href="igraph-Arpack.html#igraph_arpack_rssolve" title="3.2.1. igraph_arpack_rssolve — ARPACK solver for symmetric matrices"><code class="function">igraph_arpack_rssolve()</code></a> to solve the last eigenproblem.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arpack_extra</code></em>:</span></p></td>
<td><p>
  The extra argument that was passed to the
   ARPACK solver.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>extra</code></em>:</span></p></td>
<td><p>
  Extra argument that as passed to <a class="link" href="igraph-Community.html#igraph_community_leading_eigenvector" title="3.1. igraph_community_leading_eigenvector — Leading eigenvector community finding (proper version)."><code class="function">igraph_community_leading_eigenvector()</code></a>.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Community.html#igraph_community_leading_eigenvector" title="3.1. igraph_community_leading_eigenvector — Leading eigenvector community finding (proper version)."><code class="function">igraph_community_leading_eigenvector()</code></a>, <a class="link" href="igraph-Arpack.html#igraph_arpack_function_t" title="3.1.3. igraph_arpack_function_t — Type of the ARPACK callback function"><code class="function">igraph_arpack_function_t</code></a>, <a class="link" href="igraph-Arpack.html#igraph_arpack_rssolve" title="3.2.1. igraph_arpack_rssolve — ARPACK solver for symmetric matrices"><code class="function">igraph_arpack_rssolve()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_le_community_to_membership"></a>3.3. <code class="function">igraph_le_community_to_membership</code> — Vertex membership from the leading eigenvector community structure</h3></div></div></div>
<a class="indexterm" name="idp105545339604296"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_le_community_to_membership(const igraph_matrix_t *merges,
                                      igraph_integer_t steps,
                                      igraph_vector_t *membership,
                                      igraph_vector_t *csize);
</pre></div>
<p>
</p>
<p>



This function creates a membership vector from the
result of <a class="link" href="igraph-Community.html#igraph_community_leading_eigenvector" title="3.1. igraph_community_leading_eigenvector — Leading eigenvector community finding (proper version)."><code class="function">igraph_community_leading_eigenvector()</code></a>,
It takes <code class="constant">membership</code>
and performs <code class="constant">steps</code> merges, according to the supplied
<code class="constant">merges</code> matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>merges</code></em>:</span></p></td>
<td><p>
  The two-column matrix containing the merge
   operations. See <a class="link" href="igraph-Community.html#igraph_community_walktrap" title="4.1. igraph_community_walktrap — This function is the implementation of the Walktrap community"><code class="function">igraph_community_walktrap()</code></a> for the
   detailed syntax. This is usually from the output of the
   leading eigenvector community structure detection routines.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>steps</code></em>:</span></p></td>
<td><p>
  The number of steps to make according to <code class="constant">merges</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  Initially the starting membership vector,
    on output the resulting membership vector, after performing <code class="constant">steps</code> merges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>csize</code></em>:</span></p></td>
<td><p>
  Optionally the sizes of the communities is stored here,
    if this is not a null pointer, but an initialized vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|), the number of vertices.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="walktrap-community-structure-based-on-random-walks"></a>4. Walktrap: community structure based on random walks</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Community.html#igraph_community_walktrap">4.1. <code class="function">igraph_community_walktrap</code> — This function is the implementation of the Walktrap community</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_walktrap"></a>4.1. <code class="function">igraph_community_walktrap</code> — This function is the implementation of the Walktrap community</h3></div></div></div>
<a class="indexterm" name="idp105545339752264"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_walktrap(const igraph_t *graph,
                              const igraph_vector_t *weights,
                              int steps,
                              igraph_matrix_t *merges,
                              igraph_vector_t *modularity,
                              igraph_vector_t *membership);
</pre></div>
<p>
</p>
<p>


finding algorithm, see Pascal Pons, Matthieu Latapy: Computing
communities in large networks using random walks,
<a class="ulink" href="https://arxiv.org/abs/physics/0512106" target="_top">https://arxiv.org/abs/physics/0512106</a>

</p>
<p>
Currently the original C++ implementation is used in igraph,
see <a class="ulink" href="https://www-complexnetworks.lip6.fr/~latapy/PP/walktrap.html" target="_top">https://www-complexnetworks.lip6.fr/~latapy/PP/walktrap.html</a>
We are grateful to Matthieu Latapy and Pascal Pons for providing this
source code.

</p>
<p>
In contrast to the original implementation, isolated vertices are allowed
in the graph and they are assumed to have a single incident loop edge with
weight 1.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, edge directions are ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Numeric vector giving the weights of the edges.
    If it is a NULL pointer then all edges will have equal
    weights. The weights are expected to be positive.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>steps</code></em>:</span></p></td>
<td><p>
  Integer constant, the length of the random walks.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>merges</code></em>:</span></p></td>
<td><p>
  Pointer to a matrix, the merges performed by the
    algorithm will be stored here (if not NULL). Each merge is a
    row in a two-column matrix and contains the ids of the merged
    clusters. Clusters are numbered from zero and cluster numbers
    smaller than the number of nodes in the network belong to the
    individual vertices as singleton clusters. In each step a new
    cluster is created from two other clusters and its id will be
    one larger than the largest cluster id so far. This means that
    before the first merge we have <code class="constant">n</code> clusters (the number of
    vertices in the graph) numbered from zero to <code class="constant">n-1</code>. The first
    merge creates cluster <code class="constant">n</code>, the second cluster <code class="constant">n</code>+1, etc.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>modularity</code></em>:</span></p></td>
<td><p>
  Pointer to a vector. If not NULL then the
    modularity score of the current clustering is stored here after
    each merge operation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  Pointer to a vector. If not a NULL pointer, then
    the membership vector corresponding to the maximal modularity
    score is stored here. If it is not a NULL pointer, then neither
    <em class="parameter"><code>modularity</code></em> nor <em class="parameter"><code>merges</code></em> may be NULL.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Community.html#igraph_community_spinglass" title="2.1. igraph_community_spinglass — Community detection based on statistical mechanics"><code class="function">igraph_community_spinglass()</code></a>, <a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness."><code class="function">igraph_community_edge_betweenness()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E||V|^2) in the worst case, O(|V|^2 log|V|) typically,
|V| is the number of vertices, |E| is the number of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545339774152"></a><p class="title"><b>Example 24.3.  File <code class="code">examples/simple/walktrap.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2007-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    igraph_matrix_t merges;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> modularity;
    long int no_of_nodes;
    long int i;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 5, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 0, 3, 0, 4, 1, 2, 1, 3, 1, 4, 2, 3, 2, 4, 3, 4,
                 5, 6, 5, 7, 5, 8, 5, 9, 6, 7, 6, 8, 6, 9, 7, 8, 7, 9, 8, 9, 0, 5, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;modularity, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;merges, 0, 0);

    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_walktrap" title="4.1. igraph_community_walktrap — This function is the implementation of the Walktrap community">igraph_community_walktrap</a></strong></span>(&amp;g, 0 <span class="emphasis"><em>/* no weights */</em></span>,
                              4 <span class="emphasis"><em>/* steps */</em></span>,
                              &amp;merges, &amp;modularity,
                              <span class="emphasis"><em>/* membership=*/</em></span> 0);

    no_of_nodes = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g);
    <span class="strong"><strong>printf</strong></span>("Merges:\n");
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(&amp;merges); i++) {
        <span class="strong"><strong>printf</strong></span>("%2.1li + %2.li -&gt; %2.li (modularity %4.2f)\n",
               (long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(merges, i, 0),
               (long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(merges, i, 1),
               no_of_nodes + i,
               <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(modularity)[i]);
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* isolated vertices */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 5, IGRAPH_UNDIRECTED, -1);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_walktrap" title="4.1. igraph_community_walktrap — This function is the implementation of the Walktrap community">igraph_community_walktrap</a></strong></span>(&amp;g, 0 <span class="emphasis"><em>/* no weights */</em></span>, 4 <span class="emphasis"><em>/* steps */</em></span>, &amp;merges,
                                  &amp;modularity, <span class="emphasis"><em>/* membership = */</em></span> 0)) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_min" title="2.10.1. igraph_vector_min — Smallest element of a vector.">igraph_vector_min</a></strong></span>(&amp;modularity) != 0 || <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_max" title="2.10.2. igraph_vector_max — Largest element of a vector.">igraph_vector_max</a></strong></span>(&amp;modularity) != 0) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;merges);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;modularity);
    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="edge-betweenness-based-community-detection"></a>5. Edge betweenness based community detection</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Community.html#igraph_community_edge_betweenness">5.1. <code class="function">igraph_community_edge_betweenness</code> —  Community finding based on edge betweenness.</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#igraph_community_eb_get_merges">5.2. <code class="function">igraph_community_eb_get_merges</code> —  Calculating the merges, i.e. the dendrogram for an edge betweenness community structure.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_edge_betweenness"></a>5.1. <code class="function">igraph_community_edge_betweenness</code> —  Community finding based on edge betweenness.</h3></div></div></div>
<a class="indexterm" name="idp105545339677256"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_edge_betweenness(const igraph_t *graph,
                                      igraph_vector_t *result,
                                      igraph_vector_t *edge_betweenness,
                                      igraph_matrix_t *merges,
                                      igraph_vector_t *bridges,
                                      igraph_vector_t *modularity,
                                      igraph_vector_t *membership,
                                      igraph_bool_t directed,
                                      const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>



Community structure detection based on the betweenness of the edges
in the network. The algorithm was invented by M. Girvan and
M. Newman, see: M. Girvan and M. E. J. Newman: Community structure in
social and biological networks, Proc. Nat. Acad. Sci. USA 99, 7821-7826
(2002).

</p>
<p>
The idea is that the betweenness of the edges connecting two
communities is typically high, as many of the shortest paths
between nodes in separate communities go through them. So we
gradually remove the edge with highest betweenness from the
network, and recalculate edge betweenness after every removal.
This way sooner or later the network falls off to two components,
then after a while one of these components falls off to two smaller
components, etc. until all edges are removed. This is a divisive
hierarchical approach, the result is a dendrogram.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result will be
    stored here, the ids of the removed edges in the order of their
    removal. It will be resized as needed. It may be <code class="constant">NULL</code> if
    the edge IDs are not needed by the caller.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_betweenness</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or
    <code class="constant">NULL</code>. In the former case the edge betweenness of the removed
    edge is stored here. The vector will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>merges</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix or <code class="constant">NULL</code>. If not <code class="constant">NULL</code>
    then merges performed by the algorithm are stored here. Even if
    this is a divisive algorithm, we can replay it backwards and
    note which two clusters were merged. Clusters are numbered from
    zero, see the <em class="parameter"><code>merges</code></em> argument of <a class="link" href="igraph-Community.html#igraph_community_walktrap" title="4.1. igraph_community_walktrap — This function is the implementation of the Walktrap community"><code class="function">igraph_community_walktrap()</code></a> for details. The matrix will be
    resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>bridges</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector of <code class="constant">NULL</code>. If not
    NULL then all edge removals which separated the network into
    more components are marked here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>modularity</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then the modularity values
    of the different divisions are stored here, in the order
    corresponding to the merge matrix. The modularity values will
    take weights into account if <em class="parameter"><code>weights</code></em> is not null.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then the membership vector,
    corresponding to the highest modularity value, is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical constant, whether to calculate directed
   betweenness (i.e. directed paths) for directed graphs. It is
   ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights. If null,
    the unweighted edge betweenness scores will be calculated and
    used. If not null, the weighted edge betweenness scores will be
    calculated and used.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Community.html#igraph_community_eb_get_merges" title="5.2. igraph_community_eb_get_merges — Calculating the merges, i.e. the dendrogram for an edge betweenness community structure."><code class="function">igraph_community_eb_get_merges()</code></a>, <a class="link" href="igraph-Community.html#igraph_community_spinglass" title="2.1. igraph_community_spinglass — Community detection based on statistical mechanics"><code class="function">igraph_community_spinglass()</code></a>, <a class="link" href="igraph-Community.html#igraph_community_walktrap" title="4.1. igraph_community_walktrap — This function is the implementation of the Walktrap community"><code class="function">igraph_community_walktrap()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|^2), as the betweenness calculation requires
O(|V||E|) and we do it |E|-1 times.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545339704136"></a><p class="title"><b>Example 24.4.  File <code class="code">examples/simple/igraph_community_edge_betweenness.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2007-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>igraph_vector_between</strong></span>(<span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>* v, <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>* lo,
                          <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>* hi) {
    <span class="strong"><strong>return</strong></span> <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_all_le" title="2.9.4. igraph_vector_all_le — Are all elements less or equal?">igraph_vector_all_le</a></strong></span>(lo, v) &amp;&amp; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_all_ge" title="2.9.5. igraph_vector_all_ge — Are all elements greater or equal?">igraph_vector_all_ge</a></strong></span>(hi, v);
}

void <span class="strong"><strong>test_unweighted</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> edges, eb;
    long int i;
    long int no_of_edges;

    <span class="emphasis"><em>/* Zachary Karate club */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED,
                 0,  1,  0,  2,  0,  3,  0,  4,  0,  5,
                 0,  6,  0,  7,  0,  8,  0, 10,  0, 11,
                 0, 12,  0, 13,  0, 17,  0, 19,  0, 21,
                 0, 31,  1,  2,  1,  3,  1,  7,  1, 13,
                 1, 17,  1, 19,  1, 21,  1, 30,  2,  3,
                 2,  7,  2,  8,  2,  9,  2, 13,  2, 27,
                 2, 28,  2, 32,  3,  7,  3, 12,  3, 13,
                 4,  6,  4, 10,  5,  6,  5, 10,  5, 16,
                 6, 16,  8, 30,  8, 32,  8, 33,  9, 33,
                 13, 33, 14, 32, 14, 33, 15, 32, 15, 33,
                 18, 32, 18, 33, 19, 33, 20, 32, 20, 33,
                 22, 32, 22, 33, 23, 25, 23, 27, 23, 29,
                 23, 32, 23, 33, 24, 25, 24, 27, 24, 31,
                 25, 31, 26, 29, 26, 33, 27, 33, 28, 31,
                 28, 33, 29, 32, 29, 33, 30, 32, 30, 33,
                 31, 32, 31, 33, 32, 33,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;edges, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;eb, 0);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness.">igraph_community_edge_betweenness</a></strong></span>(&amp;g, &amp;edges, &amp;eb, 0 <span class="emphasis"><em>/*merges */</em></span>,
                                      0 <span class="emphasis"><em>/*bridges */</em></span>, <span class="emphasis"><em>/*modularity=*/</em></span> 0,
                                      <span class="emphasis"><em>/*membership=*/</em></span> 0,
                                      IGRAPH_UNDIRECTED,
                                      <span class="emphasis"><em>/*weights=*/</em></span> 0);

    no_of_edges = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; no_of_edges; i++) {
        <span class="strong"><strong>printf</strong></span>("%li ", (long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(edges)[i]);
    }
    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; no_of_edges; i++) {
        <span class="strong"><strong>printf</strong></span>("%.2f ", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(eb)[i]);
    }
    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="emphasis"><em>/* Try it once again without storage space for edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness.">igraph_community_edge_betweenness</a></strong></span>(&amp;g, 0, &amp;eb, 0 <span class="emphasis"><em>/*merges */</em></span>,
                                      0 <span class="emphasis"><em>/*bridges */</em></span>, <span class="emphasis"><em>/*modularity=*/</em></span> 0,
                                      <span class="emphasis"><em>/*membership=*/</em></span> 0,
                                      IGRAPH_UNDIRECTED,
                                      <span class="emphasis"><em>/*weights=*/</em></span> 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; no_of_edges; i++) {
        <span class="strong"><strong>printf</strong></span>("%.2f ", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(eb)[i]);
    }
    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;eb);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;edges);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
}

<span class="strong"><strong>#define</strong></span> EPS 1e-4

void <span class="strong"><strong>test_weighted</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> edges, eb, weights;
    igraph_real_t weights_array[] = { 4, 1, 3, 2, 5, 8, 6, 7 };

    igraph_real_t edges_array1[] = { 2, 3, 0, 1, 4, 7, 5, 6 };
    igraph_real_t edges_array2[] = { 2, 3, 6, 5, 0, 1, 4, 7 };
    igraph_real_t eb_array1_lo[] = { 4, 5, 3 + 1 / 3.0 - EPS, 4, 2.5, 4, 1, 1 };
    igraph_real_t eb_array1_hi[] = { 4, 5, 3 + 1 / 3.0 + EPS, 4, 2.5, 4, 1, 1 };
    igraph_real_t eb_array2_lo[] = { 4, 5, 3 + 1 / 3.0 - EPS, 6, 1.5, 2, 1, 1 };
    igraph_real_t eb_array2_hi[] = { 4, 5, 3 + 1 / 3.0 + EPS, 6, 1.5, 2, 1, 1 };

    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> edges_sol1, edges_sol2, eb_sol1_lo, eb_sol1_hi, eb_sol2_lo, eb_sol2_hi;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;edges_sol1, edges_array1,
                       <span class="strong"><strong>sizeof</strong></span>(edges_array1) / <span class="strong"><strong>sizeof</strong></span>(double));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;edges_sol2, edges_array2,
                       <span class="strong"><strong>sizeof</strong></span>(edges_array2) / <span class="strong"><strong>sizeof</strong></span>(double));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;eb_sol1_lo, eb_array1_lo, <span class="strong"><strong>sizeof</strong></span>(eb_array1_lo) / <span class="strong"><strong>sizeof</strong></span>(double));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;eb_sol2_lo, eb_array2_lo, <span class="strong"><strong>sizeof</strong></span>(eb_array2_lo) / <span class="strong"><strong>sizeof</strong></span>(double));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;eb_sol1_hi, eb_array1_hi, <span class="strong"><strong>sizeof</strong></span>(eb_array1_hi) / <span class="strong"><strong>sizeof</strong></span>(double));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;eb_sol2_hi, eb_array2_hi, <span class="strong"><strong>sizeof</strong></span>(eb_array2_hi) / <span class="strong"><strong>sizeof</strong></span>(double));

    <span class="emphasis"><em>/* Small graph as follows: A--B--C--A, A--D--E--A, B--D, C--E */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 0, 3, 0, 4, 1, 2, 1, 3, 2, 4, 3, 4, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights, weights_array, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g));

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;edges, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;eb, 0);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness.">igraph_community_edge_betweenness</a></strong></span>(&amp;g, &amp;edges, &amp;eb, 0 <span class="emphasis"><em>/*merges */</em></span>,
                                      0 <span class="emphasis"><em>/*bridges */</em></span>, <span class="emphasis"><em>/*modularity=*/</em></span> 0,
                                      <span class="emphasis"><em>/*membership=*/</em></span> 0,
                                      IGRAPH_UNDIRECTED,
                                      &amp;weights);

    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_all_e" title="2.9.1. igraph_vector_all_e — Are all elements equal?">igraph_vector_all_e</a></strong></span>(&amp;edges_sol1, &amp;edges) &amp;&amp;
        !<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_all_e" title="2.9.1. igraph_vector_all_e — Are all elements equal?">igraph_vector_all_e</a></strong></span>(&amp;edges_sol2, &amp;edges)) {
        <span class="strong"><strong>printf</strong></span>("Error, edges vector was: \n");
        <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;edges);
        <span class="strong"><strong>exit</strong></span>(2);
    }
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>igraph_vector_between</strong></span>(&amp;eb, &amp;eb_sol1_lo, &amp;eb_sol1_hi) &amp;&amp;
        !<span class="strong"><strong>igraph_vector_between</strong></span>(&amp;eb, &amp;eb_sol2_lo, &amp;eb_sol2_hi)) {
        <span class="strong"><strong>printf</strong></span>("Error, eb vector was: \n");
        <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;eb);
        <span class="strong"><strong>exit</strong></span>(2);
    }

    <span class="emphasis"><em>/* Try it once again without storage space for edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness.">igraph_community_edge_betweenness</a></strong></span>(&amp;g, 0, &amp;eb, 0 <span class="emphasis"><em>/*merges */</em></span>,
                                      0 <span class="emphasis"><em>/*bridges */</em></span>, <span class="emphasis"><em>/*modularity=*/</em></span> 0,
                                      <span class="emphasis"><em>/*membership=*/</em></span> 0,
                                      IGRAPH_UNDIRECTED,
                                      &amp;weights);

    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>igraph_vector_between</strong></span>(&amp;eb, &amp;eb_sol1_lo, &amp;eb_sol1_hi) &amp;&amp;
        !<span class="strong"><strong>igraph_vector_between</strong></span>(&amp;eb, &amp;eb_sol2_lo, &amp;eb_sol2_hi)) {
        <span class="strong"><strong>printf</strong></span>("Error, eb vector was: \n");
        <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;eb);
        <span class="strong"><strong>exit</strong></span>(2);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;eb);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;edges);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
}

void <span class="strong"><strong>test_zero_edge_graph</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> eb;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.10. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;g, 1, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;eb, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g));

    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness.">igraph_community_edge_betweenness</a></strong></span>(&amp;g, 
        &amp;res, <span class="emphasis"><em>// result</em></span>
        &amp;eb, <span class="emphasis"><em>// edge_betweenness result</em></span>
        NULL, <span class="emphasis"><em>// merges result</em></span>
        NULL, <span class="emphasis"><em>// bridges</em></span>
        NULL, <span class="emphasis"><em>// modularity</em></span>
        NULL, <span class="emphasis"><em>// membership</em></span>
        IGRAPH_UNDIRECTED, <span class="emphasis"><em>// directed</em></span>
        NULL <span class="emphasis"><em>// weights</em></span>
        );    

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;eb);
    <span class="strong"><strong>printf</strong></span>("No crash\n");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
}

int <span class="strong"><strong>main</strong></span>() {
    <span class="strong"><strong>test_unweighted</strong></span>();
    <span class="strong"><strong>test_weighted</strong></span>();
    <span class="strong"><strong>test_zero_edge_graph</strong></span>();
    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_eb_get_merges"></a>5.2. <code class="function">igraph_community_eb_get_merges</code> —  Calculating the merges, i.e. the dendrogram for an edge betweenness community structure.</h3></div></div></div>
<a class="indexterm" name="idp105545339395912"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_eb_get_merges(const igraph_t *graph,
                                   const igraph_bool_t directed,
                                   const igraph_vector_t *edges,
                                   const igraph_vector_t *weights,
                                   igraph_matrix_t *res,
                                   igraph_vector_t *bridges,
                                   igraph_vector_t *modularity,
                                   igraph_vector_t *membership);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function is handy if you have a sequence of edges which are
gradually removed from the network and you would like to know how
the network falls apart into separate components. The edge sequence
may come from the <a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness."><code class="function">igraph_community_edge_betweenness()</code></a>
function, but this is not necessary. Note that <a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness."><code class="function">igraph_community_edge_betweenness()</code></a> can also calculate the
dendrogram, via its <em class="parameter"><code>merges</code></em> argument.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  Vector containing the edges to be removed from the
   network, all edges are expected to appear exactly once in the
   vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Whether to use the directed or undirected version
   of modularity. Will be ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights. If null,
    the unweighted modularity scores will be calculated. If not null,
    the weighted modularity scores will be calculated. Ignored if both
    <em class="parameter"><code>modularity</code></em> and <em class="parameter"><code>membership</code></em> are <code class="constant">NULL</code> pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix, if not <code class="constant">NULL</code> then the
   dendrogram will be stored here, in the same form as for the <a class="link" href="igraph-Community.html#igraph_community_walktrap" title="4.1. igraph_community_walktrap — This function is the implementation of the Walktrap community"><code class="function">igraph_community_walktrap()</code></a> function: the matrix has two columns
   and each line is a merge given by the ids of the merged
   components. The component ids are numbered from zero and
   component ids smaller than the number of vertices in the graph
   belong to individual vertices. The non-trivial components
   containing at least two vertices are numbered from <code class="constant">n</code>, where <code class="constant">n</code> is
   the number of vertices in the graph. So if the first line
   contains <code class="constant">a</code> and <code class="constant">b</code> that means that components <code class="constant">a</code> and <code class="constant">b</code>
   are merged into component <code class="constant">n</code>, the second line creates
   component <code class="constant">n</code>+1, etc. The matrix will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>bridges</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or <code class="constant">NULL</code>. If not
   null then the index of the edge removals which split the network
   will be stored here. The vector will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>modularity</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then the modularity values
   for the different divisions, corresponding to the merges matrix,
   will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then the membership vector
   for the best division (in terms of modularity) will be stored
   here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness."><code class="function">igraph_community_edge_betweenness()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|+|V|log|V|), |V| is the number of vertices,
|E| is the number of edges.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="community-structure-based-on-the-optimization-of-modularity"></a>6. Community structure based on the optimization of modularity</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Community.html#igraph_community_fastgreedy">6.1. <code class="function">igraph_community_fastgreedy</code> —  Finding community structure by greedy optimization of modularity.</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#igraph_community_multilevel">6.2. <code class="function">igraph_community_multilevel</code> —  Finding community structure by multi-level optimization of modularity</a></span></dt>
<dt><span class="section"><a href="igraph-Community.html#igraph_community_leiden">6.3. <code class="function">igraph_community_leiden</code> —  Finding community structure using the Leiden algorithm.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_fastgreedy"></a>6.1. <code class="function">igraph_community_fastgreedy</code> —  Finding community structure by greedy optimization of modularity.</h3></div></div></div>
<a class="indexterm" name="idp105545339295176"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_fastgreedy(const igraph_t *graph,
                                const igraph_vector_t *weights,
                                igraph_matrix_t *merges,
                                igraph_vector_t *modularity,
                                igraph_vector_t *membership);
</pre></div>
<p>
</p>
<p>



This function implements the fast greedy modularity optimization
algorithm for finding community structure, see
A Clauset, MEJ Newman, C Moore: Finding community structure in very
large networks, <a class="ulink" href="http://www.arxiv.org/abs/cond-mat/0408187" target="_top">http://www.arxiv.org/abs/cond-mat/0408187</a> for the
details.

</p>
<p>
Some improvements proposed in K Wakita, T Tsurumi: Finding community
structure in mega-scale social networks,
<a class="ulink" href="http://www.arxiv.org/abs/cs.CY/0702048v1" target="_top">http://www.arxiv.org/abs/cs.CY/0702048v1</a> have also been implemented.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It must be a graph without multiple edges.
   This is checked and an error message is given for graphs with multiple
   edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Potentially a numeric vector containing edge
   weights. Supply a null pointer here for unweighted graphs. The
   weights are expected to be non-negative.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>merges</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix or <code class="constant">NULL</code>, the result of the
   computation is stored here. The matrix has two columns and each
   merge corresponds to one merge, the ids of the two merged
   components are stored. The component ids are numbered from zero and
   the first <code class="constant">n</code> components are the individual vertices, <code class="constant">n</code> is
   the number of vertices in the graph. Component <code class="constant">n</code> is created
   in the first merge, component <code class="literal"> n+1</code>  in the second merge, etc.
   The matrix will be resized as needed. If this argument is <code class="constant">NULL</code>
   then it is ignored completely.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>modularity</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or <code class="constant">NULL</code> pointer,
   in the former case the modularity scores along the stages of the
   computation are recorded here. The vector will be resized as
   needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  Pointer to a vector. If not a null pointer, then
   the membership vector corresponding to the best split (in terms
   of modularity) is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Community.html#igraph_community_walktrap" title="4.1. igraph_community_walktrap — This function is the implementation of the Walktrap community"><code class="function">igraph_community_walktrap()</code></a>, <a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness."><code class="function">igraph_community_edge_betweenness()</code></a> for other community detection
algorithms, <a class="link" href="igraph-Community.html#igraph_community_to_membership" title="1.4. igraph_community_to_membership — Create membership vector from community structure dendrogram"><code class="function">igraph_community_to_membership()</code></a> to convert the
dendrogram to a membership vector.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E||V|log|V|) in the worst case,
O(|E|+|V|log^2|V|) typically, |V| is the number of vertices, |E| is
the number of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545339316296"></a><p class="title"><b>Example 24.5.  File <code class="code">examples/simple/igraph_community_fastgreedy.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>show_results</strong></span>(igraph_t *g, <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *mod, igraph_matrix_t *merges,
                  <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *membership, FILE* f) {
    long int i = 0;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> our_membership;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;our_membership, 0);

    <span class="strong"><strong>if</strong></span> (mod != 0) {
        i = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_which_max" title="2.10.4. igraph_vector_which_max — Gives the index of the maximum element of the vector.">igraph_vector_which_max</a></strong></span>(mod);
        <span class="strong"><strong>fprintf</strong></span>(f, "Modularity:  %f\n", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*mod)[i]);
    } <span class="strong"><strong>else</strong></span> {
        <span class="strong"><strong>fprintf</strong></span>(f, "Modularity:  ---\n");
    }

    <span class="strong"><strong>if</strong></span> (membership != 0) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_update" title="2.6.2. igraph_vector_update — Update a vector from another one.">igraph_vector_update</a></strong></span>(&amp;our_membership, membership);
    } <span class="strong"><strong>else</strong></span> <span class="strong"><strong>if</strong></span> (merges != 0) {
        <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_to_membership" title="1.4. igraph_community_to_membership — Create membership vector from community structure dendrogram">igraph_community_to_membership</a></strong></span>(merges, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g), i, &amp;our_membership, 0);
    }

    <span class="strong"><strong>printf</strong></span>("Membership: ");
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;our_membership); i++) {
        <span class="strong"><strong>printf</strong></span>("%li ", (long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(our_membership)[i]);
    }
    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;our_membership);
}

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> modularity, weights, membership;
    igraph_matrix_t merges;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;modularity, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;merges, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;membership, 0);

    <span class="emphasis"><em>/* Simple unweighted graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 0, 3, 0, 4, 1, 2, 1, 3, 1, 4, 2, 3, 2, 4, 3, 4,
                 5, 6, 5, 7, 5, 8, 5, 9, 6, 7, 6, 8, 6, 9, 7, 8, 7, 9, 8, 9,
                 0, 5, -1);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, 0, &amp;merges, &amp;modularity, <span class="emphasis"><em>/*membership=*/</em></span> 0);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;modularity, &amp;merges, 0, stdout);

    <span class="emphasis"><em>/* Same simple graph, with uniform edge weights */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_resize" title="2.13.3. igraph_vector_resize — Resize the vector.">igraph_vector_resize</a></strong></span>(&amp;weights, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_fill" title="2.3.2. igraph_vector_fill — Fill a vector with a constant element">igraph_vector_fill</a></strong></span>(&amp;weights, 2);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, &amp;weights, &amp;merges, &amp;modularity,
                                <span class="emphasis"><em>/*membership=*/</em></span> 0);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;modularity, &amp;merges, 0, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Simple nonuniform weighted graph, with and without weights */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 6, IGRAPH_UNDIRECTED,
                 0, 1, 1, 2, 2, 3, 2, 4, 2, 5, 3, 4, 3, 5, 4, 5, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_resize" title="2.13.3. igraph_vector_resize — Resize the vector.">igraph_vector_resize</a></strong></span>(&amp;weights, 8);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_fill" title="2.3.2. igraph_vector_fill — Fill a vector with a constant element">igraph_vector_fill</a></strong></span>(&amp;weights, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(weights)[0] = 10;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(weights)[1] = 10;
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, 0, &amp;merges, &amp;modularity, <span class="emphasis"><em>/*membership=*/</em></span> 0);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;modularity, &amp;merges, 0, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, &amp;weights, &amp;merges, &amp;modularity,
                                <span class="emphasis"><em>/*membership=*/</em></span> 0);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;modularity, &amp;merges, 0, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Zachary Karate club */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED,
                 0,  1,  0,  2,  0,  3,  0,  4,  0,  5,
                 0,  6,  0,  7,  0,  8,  0, 10,  0, 11,
                 0, 12,  0, 13,  0, 17,  0, 19,  0, 21,
                 0, 31,  1,  2,  1,  3,  1,  7,  1, 13,
                 1, 17,  1, 19,  1, 21,  1, 30,  2,  3,
                 2,  7,  2,  8,  2,  9,  2, 13,  2, 27,
                 2, 28,  2, 32,  3,  7,  3, 12,  3, 13,
                 4,  6,  4, 10,  5,  6,  5, 10,  5, 16,
                 6, 16,  8, 30,  8, 32,  8, 33,  9, 33,
                 13, 33, 14, 32, 14, 33, 15, 32, 15, 33,
                 18, 32, 18, 33, 19, 33, 20, 32, 20, 33,
                 22, 32, 22, 33, 23, 25, 23, 27, 23, 29,
                 23, 32, 23, 33, 24, 25, 24, 27, 24, 31,
                 25, 31, 26, 29, 26, 33, 27, 33, 28, 31,
                 28, 33, 29, 32, 29, 33, 30, 32, 30, 33,
                 31, 32, 31, 33, 32, 33,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, 0, &amp;merges, &amp;modularity,
                                <span class="emphasis"><em>/*membership=*/</em></span> 0);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;modularity, &amp;merges, 0, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Simple disconnected graph with isolates */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 9, IGRAPH_UNDIRECTED,
                 0,  1,  0,  2,  0,  3,  1,  2,  1,  3,  2,  3,
                 4,  5,  4,  6,  4,  7,  5,  6,  5,  7,  6,  7,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, 0, &amp;merges, &amp;modularity, <span class="emphasis"><em>/*membership=*/</em></span> 0);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;modularity, &amp;merges, 0, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Disjoint union of two rings */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 20, IGRAPH_UNDIRECTED,
                 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 0, 9,
                 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 10, 19, -1);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, 0, &amp;merges, &amp;modularity, <span class="emphasis"><em>/*membership=*/</em></span> 0);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;modularity, &amp;merges, 0, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Completely empty graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_UNDIRECTED, -1);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, 0, &amp;merges, &amp;modularity, <span class="emphasis"><em>/*membership=*/</em></span> 0);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;modularity, &amp;merges, 0, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Ring graph with loop edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 6, IGRAPH_UNDIRECTED,
                 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 0, 0, 0, 2, 2, -1);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, 0, &amp;merges, &amp;modularity, <span class="emphasis"><em>/*membership=*/</em></span> 0);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;modularity, &amp;merges, 0, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Regression test -- graph with two vertices and two edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 2, IGRAPH_UNDIRECTED, 0, 0, 1, 1, -1);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, 0, &amp;merges, &amp;modularity, <span class="emphasis"><em>/*membership=*/</em></span> 0);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;modularity, &amp;merges, 0, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Regression test -- asking for optimal membership vector but not</em></span>
<span class="emphasis"><em>     * providing a modularity vector */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 0, 3, 0, 4, 1, 2, 1, 3, 1, 4, 2, 3, 2, 4, 3, 4,
                 5, 6, 5, 7, 5, 8, 5, 9, 6, 7, 6, 8, 6, 9, 7, 8, 7, 9, 8, 9,
                 0, 5, -1);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, 0, &amp;merges, 0, &amp;membership);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, 0, &amp;merges, &amp;membership, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Regression test -- asking for optimal membership vector but not</em></span>
<span class="emphasis"><em>     * providing a merge matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 0, 3, 0, 4, 1, 2, 1, 3, 1, 4, 2, 3, 2, 4, 3, 4,
                 5, 6, 5, 7, 5, 8, 5, 9, 6, 7, 6, 8, 6, 9, 7, 8, 7, 9, 8, 9,
                 0, 5, -1);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, 0, 0, &amp;modularity, &amp;membership);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;modularity, 0, &amp;membership, stdout);

    <span class="emphasis"><em>/* Regression test -- asking for optimal membership vector but not</em></span>
<span class="emphasis"><em>     * providing a merge matrix or a modularity vector */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fastgreedy" title="6.1. igraph_community_fastgreedy — Finding community structure by greedy optimization of modularity.">igraph_community_fastgreedy</a></strong></span>(&amp;g, 0, 0, 0, &amp;membership);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, 0, 0, &amp;membership, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;membership);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;modularity);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;merges);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_multilevel"></a>6.2. <code class="function">igraph_community_multilevel</code> —  Finding community structure by multi-level optimization of modularity</h3></div></div></div>
<a class="indexterm" name="idp105545339527624"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_multilevel(const igraph_t *graph,
                                const igraph_vector_t *weights,
                                const igraph_real_t resolution,
                                igraph_vector_t *membership,
                                igraph_matrix_t *memberships, igraph_vector_t *modularity);
</pre></div>
<p>
</p>
<p>




This function implements the multi-level modularity optimization
algorithm for finding community structure, see
Blondel, V. D., Guillaume, J.-L., Lambiotte, R., &amp; Lefebvre, E. (2008). Fast
unfolding of communities in large networks. Journal of Statistical Mechanics:
Theory and Experiment, 10008(10), 6.
<a class="ulink" href="https://doi.org/10.1088/1742-5468/2008/10/P10008" target="_top">https://doi.org/10.1088/1742-5468/2008/10/P10008</a> for the details (preprint:
<a class="ulink" href="http://arxiv.org/abs/0803.0476" target="_top">http://arxiv.org/abs/0803.0476</a>). The algorithm is sometimes known as the
"Louvain" algorithm.

</p>
<p>
The algorithm is based on the modularity measure and a hierarchical approach.
Initially, each vertex is assigned to a community on its own. In every step,
vertices are re-assigned to communities in a local, greedy way: each vertex
is moved to the community with which it achieves the highest contribution to
modularity. When no vertices can be reassigned, each community is considered
a vertex on its own, and the process starts again with the merged communities.
The process stops when there is only a single vertex left or when the modularity
cannot be increased any more in a step.

</p>
<p>
The resolution parameter <code class="constant">gamma</code> allows finding communities at different
resolutions. Higher values of the resolution parameter typically result in
more, smaller communities. Lower values typically result in fewer, larger
communities. The original definition of modularity is retrieved when setting
<code class="literal"> gamma=1</code> . Note that the returned modularity value is calculated using
the indicated resolution parameter. See <a class="link" href="igraph-Community.html#igraph_modularity" title="1.1. igraph_modularity — Calculate the modularity of a graph with respect to some clusters or vertex types."><code class="function">igraph_modularity()</code></a> for more details.

This function was contributed by Tom Gregorovic.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It must be an undirected graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Numeric vector containing edge weights. If <code class="constant">NULL</code>, every edge
                   has equal weight. The weights are expected to be non-negative.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>resolution</code></em>:</span></p></td>
<td><p>
  Resolution parameter. Must be greater than or equal to 0.
                   Lower values favor fewer, larger communities;
                   higher values favor more, smaller communities.
                   Set it to 1 to use the classical definition of modularity.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  The membership vector, the result is returned here.
                   For each vertex it gives the ID of its community. The vector
                   must be initialized and it will be resized accordingly.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>memberships</code></em>:</span></p></td>
<td><p>
  Numeric matrix that will contain the membership vector after
                   each level, if not <code class="constant">NULL</code>. It must be initialized and
                   it will be resized accordingly.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>modularity</code></em>:</span></p></td>
<td><p>
  Numeric vector that will contain the modularity score
                   after each level, if not <code class="constant">NULL</code>. It must be initialized
                   and it will be resized accordingly.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: in average near linear on sparse graphs.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545339414856"></a><p class="title"><b>Example 24.6.  File <code class="code">examples/simple/igraph_community_multilevel.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sts=4 sw=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>show_results</strong></span>(igraph_t *g, <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *membership, igraph_matrix_t *memberships, <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *modularity, FILE* f) {
    long int i, j, no_of_nodes = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);

    j = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_which_max" title="2.10.4. igraph_vector_which_max — Gives the index of the maximum element of the vector.">igraph_vector_which_max</a></strong></span>(modularity);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(membership); i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*membership)[i] != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*memberships, j, i)) {
            <span class="strong"><strong>fprintf</strong></span>(f, "WARNING: best membership vector element %li does not match the best one in the membership matrix\n", i);
        }
    }

    <span class="strong"><strong>fprintf</strong></span>(f, "Modularities:\n");
    <span class="strong"><strong>igraph_vector_print</strong></span>(modularity);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(memberships); i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; no_of_nodes; j++) {
            <span class="strong"><strong>fprintf</strong></span>(f, "%ld ", (long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*memberships, i, j));
        }
        <span class="strong"><strong>fprintf</strong></span>(f, "\n");
    }

    <span class="strong"><strong>fprintf</strong></span>(f, "\n");
}

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> modularity, membership, edges;
    igraph_matrix_t memberships;
    int i, j, k;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;modularity, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;membership, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;memberships, 0, 0);

    <span class="emphasis"><em>/* Unweighted test graph from the paper of Blondel et al */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 16, IGRAPH_UNDIRECTED,
                 0, 2, 0, 3, 0, 4, 0, 5,
                 1, 2, 1, 4, 1, 7,
                 2, 4, 2, 5, 2, 6,
                 3, 7,
                 4, 10,
                 5, 7, 5, 11,
                 6, 7, 6, 11,
                 8, 9, 8, 10, 8, 11, 8, 14, 8, 15,
                 9, 12, 9, 14,
                 10, 11, 10, 12, 10, 13, 10, 14,
                 11, 13,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_multilevel" title="6.2. igraph_community_multilevel — Finding community structure by multi-level optimization of modularity">igraph_community_multilevel</a></strong></span>(&amp;g, 0, 1, &amp;membership, &amp;memberships, &amp;modularity);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;membership, &amp;memberships, &amp;modularity, stdout);

    <span class="emphasis"><em>/* Higher resolution */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_multilevel" title="6.2. igraph_community_multilevel — Finding community structure by multi-level optimization of modularity">igraph_community_multilevel</a></strong></span>(&amp;g, 0, 1.5, &amp;membership, &amp;memberships, &amp;modularity);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;membership, &amp;memberships, &amp;modularity, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Ring of 30 cliques */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;edges, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 30; i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; 5; j++) {
            <span class="strong"><strong>for</strong></span> (k = j + 1; k &lt; 5; k++) {
                <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;edges, i * 5 + j);
                <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;edges, i * 5 + k);
            }
        }
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 30; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;edges, i * 5 % 150);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;edges, (i * 5 + 6) % 150);
    }
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_create" title="1.1. igraph_create — Creates a graph with the specified edges.">igraph_create</a></strong></span>(&amp;g, &amp;edges, 150, 0);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_multilevel" title="6.2. igraph_community_multilevel — Finding community structure by multi-level optimization of modularity">igraph_community_multilevel</a></strong></span>(&amp;g, 0, 1, &amp;membership, &amp;memberships, &amp;modularity);
    <span class="strong"><strong>show_results</strong></span>(&amp;g, &amp;membership, &amp;memberships, &amp;modularity, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;modularity);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;membership);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;edges);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;memberships);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_leiden"></a>6.3. <code class="function">igraph_community_leiden</code> —  Finding community structure using the Leiden algorithm.</h3></div></div></div>
<a class="indexterm" name="idp105545339459144"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_leiden(const igraph_t *graph,
                            const igraph_vector_t *edge_weights, const igraph_vector_t *node_weights,
                            const igraph_real_t resolution_parameter, const igraph_real_t beta, const igraph_bool_t start,
                            igraph_vector_t *membership, igraph_integer_t *nb_clusters, igraph_real_t *quality);
</pre></div>
<p>
</p>
<p>




This function implements the Leiden algorithm for finding community
structure, see Traag, V. A., Waltman, L., &amp; van Eck, N. J. (2019). From
Louvain to Leiden: guaranteeing well-connected communities. Scientific
reports, 9(1), 5233. <a class="ulink" href="http://dx.doi.org/10.1038/s41598-019-41695-z" target="_top">http://dx.doi.org/10.1038/s41598-019-41695-z</a>

</p>
<p>
It is similar to the multilevel algorithm, often called the Louvain
algorithm, but it is faster and yields higher quality solutions. It can
optimize both modularity and the Constant Potts Model, which does not suffer
from the resolution-limit (see preprint <a class="ulink" href="http://arxiv.org/abs/1104.3083" target="_top">http://arxiv.org/abs/1104.3083</a>).

</p>
<p>
The Leiden algorithm consists of three phases: (1) local moving of nodes,
(2) refinement of the partition and (3) aggregation of the network based on
the refined partition, using the non-refined partition to create an initial
partition for the aggregate network. In the local move procedure in the
Leiden algorithm, only nodes whose neighborhood has changed are visited. The
refinement is done by restarting from a singleton partition within each
cluster and gradually merging the subclusters. When aggregating, a single
cluster may then be represented by several nodes (which are the subclusters
identified in the refinement).

</p>
<p>
The Leiden algorithm provides several guarantees. The Leiden algorithm is
typically iterated: the output of one iteration is used as the input for the
next iteration. At each iteration all clusters are guaranteed to be
connected and well-separated. After an iteration in which nothing has
changed, all nodes and some parts are guaranteed to be locally optimally
assigned. Finally, asymptotically, all subsets of all clusters are
guaranteed to be locally optimally assigned. For more details, please see
Traag, Waltman &amp; van Eck (2019).

</p>
<p>
The objective function being optimized is

</p>
<p>
1 / 2m sum_ij (A_ij - gamma n_i n_j)d(s_i, s_j)

</p>
<p>
where m is the total edge weight, A_ij is the weight of edge (i, j), gamma is
the so-called resolution parameter, n_i is the node weight of node i, s_i is
the cluster of node i and d(x, y) = 1 if and only if x = y and 0 otherwise.
By setting n_i = k_i, the degree of node i, and dividing gamma by 2m, you
effectively obtain an expression for modularity. Hence, the standard
modularity will be optimized when you supply the degrees as <code class="constant">node_weights</code>
and by supplying as a resolution parameter 1.0/(2*m), with m the number of
edges.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It must be an undirected graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_weights</code></em>:</span></p></td>
<td><p>
  Numeric vector containing edge weights. If <code class="constant">NULL</code>, every edge
   has equal weight of 1. The weights need not be non-negative.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_weights</code></em>:</span></p></td>
<td><p>
  Numeric vector containing node weights.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>resolution_parameter</code></em>:</span></p></td>
<td><p>
  The resolution parameter used, which is
   represented by gamma in the objective function mentioned in the
   documentation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>beta</code></em>:</span></p></td>
<td><p>
  The randomness used in the refinement step when merging. A small
   amount of randomness (<code class="constant">beta</code> = 0.01) typically works well.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>start</code></em>:</span></p></td>
<td><p>
  Start from membership vector. If this is true, the optimization
   will start from the provided membership vector. If this is false, the
   optimization will start from a singleton partition.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  The membership vector. This is both used as the initial
   membership from which optimisation starts and is updated in place. It
   must hence be properly initialized. When finding clusters from scratch it
   is typically started using a singleton clustering. This can be achieved
   using <code class="constant">igraph_vector_init_seq</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nb_clusters</code></em>:</span></p></td>
<td><p>
  The number of clusters contained in <code class="constant">membership</code>. Must
   not be a <code class="constant">NULL</code> pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>quality</code></em>:</span></p></td>
<td><p>
  The quality of the partition, in terms of the objective
   function as included in the documentation. If <code class="constant">NULL</code> the quality will
   not be calculated.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: near linear on sparse graphs.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545339089352"></a><p class="title"><b>Example 24.7.  File <code class="code">examples/simple/igraph_community_leiden.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> membership, degree;
    igraph_integer_t nb_clusters;
    igraph_real_t quality;

    <span class="emphasis"><em>/* Set default seed to get reproducible results */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 0);

    <span class="emphasis"><em>/* Simple unweighted graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 10, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 0, 3, 0, 4, 1, 2, 1, 3, 1, 4, 2, 3, 2, 4, 3, 4,
                 5, 6, 5, 7, 5, 8, 5, 9, 6, 7, 6, 8, 6, 9, 7, 8, 7, 9, 8, 9,
                 0, 5, -1);

    <span class="emphasis"><em>/* Perform Leiden algorithm using CPM */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;membership, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;graph));
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_leiden" title="6.3. igraph_community_leiden — Finding community structure using the Leiden algorithm.">igraph_community_leiden</a></strong></span>(&amp;graph, NULL, NULL, 0.05, 0.01, 0, &amp;membership, &amp;nb_clusters, &amp;quality);

    <span class="strong"><strong>printf</strong></span>("Leiden found %i clusters using CPM (resolution parameter 0.05), quality is %.4f.\n", nb_clusters, quality);
    <span class="strong"><strong>printf</strong></span>("Membership: ");
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;membership);
    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="emphasis"><em>/* Start from existing membership to improve it further */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_leiden" title="6.3. igraph_community_leiden — Finding community structure using the Leiden algorithm.">igraph_community_leiden</a></strong></span>(&amp;graph, NULL, NULL, 0.05, 0.01, 1, &amp;membership, &amp;nb_clusters, &amp;quality);

    <span class="strong"><strong>printf</strong></span>("Iterated Leiden, using CPM (resolution parameter 0.05), quality is %.4f.\n", quality);
    <span class="strong"><strong>printf</strong></span>("Membership: ");
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;membership);
    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="emphasis"><em>/* Initialize degree vector to use for optimizing modularity */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;degree, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;graph));
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;graph, &amp;degree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, 1);

    <span class="emphasis"><em>/* Perform Leiden algorithm using modularity */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_leiden" title="6.3. igraph_community_leiden — Finding community structure using the Leiden algorithm.">igraph_community_leiden</a></strong></span>(&amp;graph, NULL, &amp;degree, 1.0 / (2 * <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;graph)), 0.01, 0, &amp;membership, &amp;nb_clusters, &amp;quality);

    <span class="strong"><strong>printf</strong></span>("Leiden found %i clusters using modularity, quality is %.4f.\n", nb_clusters, quality);
    <span class="strong"><strong>printf</strong></span>("Membership: ");
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;membership);
    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;degree);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;membership);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="fluid-communities"></a>7. Fluid Communities</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Community.html#igraph_community_fluid_communities">7.1. <code class="function">igraph_community_fluid_communities</code> —  Community detection based on fluids interacting on the graph.</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_fluid_communities"></a>7.1. <code class="function">igraph_community_fluid_communities</code> —  Community detection based on fluids interacting on the graph.</h3></div></div></div>
<a class="indexterm" name="idp105545339123528"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_fluid_communities(const igraph_t *graph,
                                       igraph_integer_t no_of_communities,
                                       igraph_vector_t *membership,
                                       igraph_real_t *modularity);
</pre></div>
<p>
</p>
<p>




The algorithm is based on the simple idea of
several fluids interacting in a non-homogeneous environment
(the graph topology), expanding and contracting based on their
interaction and density.

This function implements the community detection method described in:
Parés F, Gasulla DG, et. al. (2018) Fluid Communities: A Competitive,
Scalable and Diverse Community Detection Algorithm. In: Complex Networks
&amp; Their Applications VI: Proceedings of Complex Networks 2017 (The Sixth
International Conference on Complex Networks and Their Applications),
Springer, vol 689, p 229.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. The graph must be simple and connected.
  Empty graphs are not supported as well as single vertex graphs.
  Edge directions are ignored. Weights are not considered.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no_of_communities</code></em>:</span></p></td>
<td><p>
  The number of communities to be found. Must be
  greater than 0 and fewer than number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  The result vector mapping vertices to the communities
they are assigned to.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>modularity</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then it must be a pointer
  to a real number. The modularity score of the detected community
  structure is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|)

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545339134792"></a><p class="title"><b>Example 24.8.  File <code class="code">examples/simple/igraph_community_fluid_communities.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2007-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

<span class="strong"><strong>#include</strong></span> "../../tests/unit/test_utilities.inc"

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    igraph_integer_t k;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> membership;
    igraph_real_t modularity;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 247);

    <span class="emphasis"><em>/* Empty graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;membership, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;membership, 1);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fluid_communities" title="7.1. igraph_community_fluid_communities — Community detection based on fluids interacting on the graph.">igraph_community_fluid_communities</a></strong></span>(&amp;g, 2, &amp;membership, &amp;modularity);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>igraph_is_nan</strong></span>(modularity) || <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;membership) != 0) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;membership);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Graph with one vertex only */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 1, IGRAPH_UNDIRECTED, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;membership, 0);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fluid_communities" title="7.1. igraph_community_fluid_communities — Community detection based on fluids interacting on the graph.">igraph_community_fluid_communities</a></strong></span>(&amp;g, 2, &amp;membership, &amp;modularity);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>igraph_is_nan</strong></span>(modularity) || <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;membership) != 1 || <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(membership)[0] != 0) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;membership);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Zachary Karate club -- this is just a quick smoke test */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED,
                 0,  1,  0,  2,  0,  3,  0,  4,  0,  5,
                 0,  6,  0,  7,  0,  8,  0, 10,  0, 11,
                 0, 12,  0, 13,  0, 17,  0, 19,  0, 21,
                 0, 31,  1,  2,  1,  3,  1,  7,  1, 13,
                 1, 17,  1, 19,  1, 21,  1, 30,  2,  3,
                 2,  7,  2,  8,  2,  9,  2, 13,  2, 27,
                 2, 28,  2, 32,  3,  7,  3, 12,  3, 13,
                 4,  6,  4, 10,  5,  6,  5, 10,  5, 16,
                 6, 16,  8, 30,  8, 32,  8, 33,  9, 33,
                 13, 33, 14, 32, 14, 33, 15, 32, 15, 33,
                 18, 32, 18, 33, 19, 33, 20, 32, 20, 33,
                 22, 32, 22, 33, 23, 25, 23, 27, 23, 29,
                 23, 32, 23, 33, 24, 25, 24, 27, 24, 31,
                 25, 31, 26, 29, 26, 33, 27, 33, 28, 31,
                 28, 33, 29, 32, 29, 33, 30, 32, 30, 33,
                 31, 32, 31, 33, 32, 33,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;membership, 0);
    k = 2;
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_fluid_communities" title="7.1. igraph_community_fluid_communities — Community detection based on fluids interacting on the graph.">igraph_community_fluid_communities</a></strong></span>(&amp;g, k, &amp;membership,
                                       <span class="emphasis"><em>/*modularity=*/</em></span> 0);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_contains" title="2.12.1. igraph_vector_contains — Linear search in a vector.">igraph_vector_contains</a></strong></span>(&amp;membership, 0) || !<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_contains" title="2.12.1. igraph_vector_contains — Linear search in a vector.">igraph_vector_contains</a></strong></span>(&amp;membership, 1)) {
        <span class="strong"><strong>printf</strong></span>("Resulting graph does not have exactly 2 communities as expected.\n");
        <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;membership);
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;membership);

    <span class="strong"><strong>VERIFY_FINALLY_STACK</strong></span>();

    <span class="strong"><strong>return</strong></span> 0;
}

</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="label-propagation"></a>8. Label propagation</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Community.html#igraph_community_label_propagation">8.1. <code class="function">igraph_community_label_propagation</code> —  Community detection based on label propagation.</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_label_propagation"></a>8.1. <code class="function">igraph_community_label_propagation</code> —  Community detection based on label propagation.</h3></div></div></div>
<a class="indexterm" name="idp105545339042760"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_label_propagation(const igraph_t *graph,
                                       igraph_vector_t *membership,
                                       const igraph_vector_t *weights,
                                       const igraph_vector_t *initial,
                                       igraph_vector_bool_t *fixed,
                                       igraph_real_t *modularity);
</pre></div>
<p>
</p>
<p>




This function implements the community detection method described in:
Raghavan, U.N. and Albert, R. and Kumara, S.: Near linear time algorithm
to detect community structures in large-scale networks. Phys Rev E
76, 036106. (2007). This version extends the original method by
the ability to take edge weights into consideration and also
by allowing some labels to be fixed.

</p>
<p>
Weights are taken into account as follows: when the new label of node
<code class="constant">i</code> is determined, the algorithm iterates over all edges incident on
node <code class="constant">i</code> and calculate the total weight of edges leading to other
nodes with label 0, 1, 2, ..., <code class="constant">k</code> - 1 (where <code class="constant">k</code> is the number of possible
labels). The new label of node <code class="constant">i</code> will then be the label whose edges
(among the ones incident on node <code class="constant">i</code>) have the highest total weight.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, should be undirected to make sense.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  The membership vector, the result is returned here.
   For each vertex it gives the ID of its community (label).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The weight vector, it should contain a positive
   weight for all the edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>initial</code></em>:</span></p></td>
<td><p>
  The initial state. If NULL, every vertex will have
  a different label at the beginning. Otherwise it must be a vector
  with an entry for each vertex. Non-negative values denote different
  labels, negative entries denote vertices without labels.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>fixed</code></em>:</span></p></td>
<td><p>
  Boolean vector denoting which labels are fixed. Of course
  this makes sense only if you provided an initial state, otherwise
  this element will be ignored. Also note that vertices without labels
  cannot be fixed. If they are, this vector will be modified to
  make it consistent with <em class="parameter"><code>initial</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>modularity</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then it must be a pointer
  to a real number. The modularity score of the detected community
  structure is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(m+n)

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545339059912"></a><p class="title"><b>Example 24.9.  File <code class="code">examples/simple/igraph_community_label_propagation.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2007-2020  The igraph development team </em></span>&lt;igraph@igraph.org&gt;

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program.  If not, see </em></span>&lt;https://www.gnu.org/licenses/&gt;<span class="emphasis"><em>.</em></span>
<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> membership;
    igraph_real_t modularity;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_famous" title="1.13. igraph_famous — Create a famous graph by simply providing its name">igraph_famous</a></strong></span>(&amp;graph, "Zachary"); <span class="emphasis"><em>/* We use Zachary's karate club network. */</em></span>

    <span class="emphasis"><em>/* Label propagation is a stochastic method; the result will depend on the random seed. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 123);

    <span class="emphasis"><em>/* All igraph functions that returns their result in an igraph_vector_t must be given</em></span>
<span class="emphasis"><em>       an already initialized vector. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;membership, 0);
    <span class="strong"><strong><a class="link" href="igraph-Community.html#igraph_community_label_propagation" title="8.1. igraph_community_label_propagation — Community detection based on label propagation.">igraph_community_label_propagation</a></strong></span>(
                &amp;graph, &amp;membership,
                <span class="emphasis"><em>/* weights= */</em></span> NULL, <span class="emphasis"><em>/* initial= */</em></span> NULL, <span class="emphasis"><em>/* fixed= */</em></span> NULL,
                &amp;modularity);

    <span class="strong"><strong>printf</strong></span>("%ld communities found; modularity score is %g.\n",
           (long int) (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_max" title="2.10.2. igraph_vector_max — Largest element of a vector.">igraph_vector_max</a></strong></span>(&amp;membership) + 1),
           modularity);

    <span class="emphasis"><em>/* Destroy data structures at the end. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;membership);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="infomap-algorithm"></a>9. The InfoMAP algorithm</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Community.html#igraph_community_infomap">9.1. <code class="function">igraph_community_infomap</code> —  Find community structure that minimizes the expected</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_community_infomap"></a>9.1. <code class="function">igraph_community_infomap</code> —  Find community structure that minimizes the expected</h3></div></div></div>
<a class="indexterm" name="idp105545339083080"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_community_infomap(const igraph_t * graph,
                             const igraph_vector_t *e_weights,
                             const igraph_vector_t *v_weights,
                             int nb_trials,
                             igraph_vector_t *membership,
                             igraph_real_t *codelength);
</pre></div>
<p>
</p>
<p>


description length of a random walker trajectory.

Implementation of the InfoMap community detection algorithm.of
Martin Rosvall and Carl T. Bergstrom.

See :
Visualization of the math and the map generator: www.mapequation.org
[2] The original paper: M. Rosvall and C. T. Bergstrom, Maps of
information flow reveal community structure in complex networks, PNAS
105, 1118 (2008) [<a class="ulink" href="http://dx.doi.org/10.1073/pnas.0706851105" target="_top">http://dx.doi.org/10.1073/pnas.0706851105</a> ,
<a class="ulink" href="http://arxiv.org/abs/0707.0609" target="_top">http://arxiv.org/abs/0707.0609</a> ]
[3] A more detailed paper: M. Rosvall, D. Axelsson, and C. T. Bergstrom,
The map equation, Eur. Phys. J. Special Topics 178, 13 (2009).
[<a class="ulink" href="http://dx.doi.org/10.1140/epjst/e2010-01179-1" target="_top">http://dx.doi.org/10.1140/epjst/e2010-01179-1</a> ,
<a class="ulink" href="http://arxiv.org/abs/0906.1405" target="_top">http://arxiv.org/abs/0906.1405</a> ]

</p>
<p>
The original C++ implementation of Martin Rosvall is used,
see <a class="ulink" href="http://www.tp.umu.se/~rosvall/downloads/infomap_undir.tgz" target="_top">http://www.tp.umu.se/~rosvall/downloads/infomap_undir.tgz</a> .
Intergation in igraph has be done by Emmanuel Navarro (who is grateful to
  * Martin Rosvall and Carl T. Bergstrom for providing this source code.)

</p>
<p>
Note that the graph must not contain isolated vertices.

</p>
<p>
If you want to specify a random seed (as in original
implementation) you can use <a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator"><code class="function">igraph_rng_seed()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>e_weights</code></em>:</span></p></td>
<td><p>
  Numeric vector giving the weights of the edges.
    If it is a NULL pointer then all edges will have equal
    weights. The weights are expected to be positive.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v_weights</code></em>:</span></p></td>
<td><p>
  Numeric vector giving the weights of the vertices.
    If it is a NULL pointer then all vertices will have equal
    weights. The weights are expected to be positive.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nb_trials</code></em>:</span></p></td>
<td><p>
  The number of attempts to partition the network
    (can be any integer value equal or larger than 1).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  Pointer to a vector. The membership vector is
   stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>codelength</code></em>:</span></p></td>
<td><p>
  Pointer to a real. If not NULL the code length of the
    partition is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Community.html#igraph_community_spinglass" title="2.1. igraph_community_spinglass — Community detection based on statistical mechanics"><code class="function">igraph_community_spinglass()</code></a>, <a class="link" href="igraph-Community.html#igraph_community_edge_betweenness" title="5.1. igraph_community_edge_betweenness — Community finding based on edge betweenness."><code class="function">igraph_community_edge_betweenness()</code></a>, <a class="link" href="igraph-Community.html#igraph_community_walktrap" title="4.1. igraph_community_walktrap — This function is the implementation of the Walktrap community"><code class="function">igraph_community_walktrap()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
</div>
</div>
<table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Separators.html"><b>← Chapter 23. Vertex separators</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Graphlets.html"><b>Chapter 25. Graphlets →</b></a></td>
</tr></table>
{% endraw %}
