









<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/favicon.ico" type="image/png" />

    <title>igraph Reference Manual</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-1392972-5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-1392972-5');
    </script>

    <link href="/css/manual.css" rel="stylesheet">
  </head>

  <body class="cc">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        <li class="nav-item"><a class="nav-link" href="/c">igraph library</a></li>
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="/r">igraph R package</a>
              <a class="dropdown-item" href="/python">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class-"nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">igraph Reference Manual</h1>
        <p class="lead">For using the igraph C library</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="bs-docs-section">
        
<div class="navigation-header mb-4" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-light" href="igraph-Arpack.html"><i class="fa fa-chevron-left"></i>
              Previous
            </a><a accesskey="h" class="btn btn-light" href="index.html"><i class="fa fa-home"></i>
              Home
            </a><a accesskey="n" class="btn btn-light" href="igraph-Advanced.html"><i class="fa fa-chevron-right"></i>
              Next
            </a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Bipartite"></a>Chapter 30. Bipartite, i.e. two-mode graphs</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Bipartite.html#idm537721443088">1.  Bipartite networks in igraph</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#idm537717215184">2. Create two-mode networks</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#idm537722124688">3. Incidence matrices</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#idm537722790864">4. Project a two-mode graphs</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#idm537721271520">5. Other operations on bipartite graphs</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idm537721443088"></a>1.  Bipartite networks in igraph</h2></div></div></div>
<p>
A bipartite network contains two kinds of vertices and connections
are only possible between two vertices of different kind. There are
many natural examples, e.g. movies and actors as vertices and a
movie is connected to all participating actors, etc.

</p>
<p>
igraph does not have direct support for bipartite networks, at
least not at the C language level. In other words the igraph_t
structure does not contain information about the vertex types.
The C functions for bipartite networks usually have an additional
input argument to graph, called <code class="constant">types</code>, a boolean vector giving
the vertex types.

</p>
<p>
Most functions creating bipartite networks are able to create this
extra vector, you just need to supply an initialized boolean vector
to them.</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idm537717215184"></a>2. Create two-mode networks</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_create_bipartite">2.1. <code class="function">igraph_create_bipartite</code> — Create a bipartite graph</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_full_bipartite">2.2. <code class="function">igraph_full_bipartite</code> — Create a full bipartite network</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_bipartite_game">2.3. <code class="function">igraph_bipartite_game</code> — Generate a bipartite random graph (similar to Erdos-Renyi)</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_create_bipartite"></a>2.1. <code class="function">igraph_create_bipartite</code> — Create a bipartite graph</h3></div></div></div>
<a class="indexterm" name="idm537721991376"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_create_bipartite(igraph_t *graph, const igraph_vector_bool_t *types,
                            const igraph_vector_t *edges,
                            igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



This is a simple wrapper function to create a bipartite graph. It
does a little more than <a class="link" href="igraph-Generators.html#igraph_create" title="1.1. igraph_create — Creates a graph with the specified edges."><code class="function">igraph_create()</code></a>, e.g. it checks that
the graph is indeed bipartite with respect to the given <em class="parameter"><code>types</code></em>
vector. If there is an edge connecting two vertices of the same
kind, then an error is reported.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the result is
  created here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Boolean vector giving the vertex types. The length of
  the vector defines the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  Vector giving the edges of the graph. The highest
  vertex id in this vector must be smaller than the length of the
  <em class="parameter"><code>types</code></em> vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean scalar, whether to create a directed
  graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.

</p>
<div class="hideshow" onClick="toggle(this)">
<div class="example">
<a name="idm537722310272"></a><p class="title"><b>Example 30.1.  File <code class="code">examples/simple/igraph_bipartite_create.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2008-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_real_t edges2[] = {0, 1, 1, 2, 3, 4, 5, 6, 6, 5, 1, 4, 1, 6, 0, 3 };
    igraph_real_t edges3[] = {0, 1, 1, 2, 3, 4, 5, 6, 6, 5, 2, 4, 1, 6, 0, 3 };
    igraph_t g;
    igraph_vector_bool_t types;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> edges;
    long int i;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;edges, edges2, <span class="strong"><strong>sizeof</strong></span>(edges2) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_max" title="2.10.2. igraph_vector_max — Gives the maximum element of the vector.">igraph_vector_max</a></strong></span>(&amp;edges) + 1);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_bool_size</strong></span>(&amp;types); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = i % 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_create_bipartite" title="2.1. igraph_create_bipartite — Create a bipartite graph">igraph_create_bipartite</a></strong></span>(&amp;g, &amp;types, &amp;edges, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;g, stdout);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Error handling */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Set a new error handler.">igraph_set_error_handler</a></strong></span>(<a class="link" href="igraph-Error.html#igraph_error_handler_ignore" title="2.3. igraph_error_handler_ignore — Ignore errors.">igraph_error_handler_ignore</a>);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;edges, edges3, <span class="strong"><strong>sizeof</strong></span>(edges3) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_max" title="2.10.2. igraph_vector_max — Gives the maximum element of the vector.">igraph_vector_max</a></strong></span>(&amp;edges) + 1);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_bool_size</strong></span>(&amp;types); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = i % 2;
    }
    ret = <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_create_bipartite" title="2.1. igraph_create_bipartite — Create a bipartite graph">igraph_create_bipartite</a></strong></span>(&amp;g, &amp;types, &amp;edges, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>if</strong></span> (ret != IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}




</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_full_bipartite"></a>2.2. <code class="function">igraph_full_bipartite</code> — Create a full bipartite network</h3></div></div></div>
<a class="indexterm" name="idm537722102544"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_full_bipartite(igraph_t *graph,
                          igraph_vector_bool_t *types,
                          igraph_integer_t n1, igraph_integer_t n2,
                          igraph_bool_t directed,
                          igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



A bipartite network contains two kinds of vertices and connections
are only possible between two vertices of different kind. There are
many natural examples, e.g. movies and actors as vertices and a
movie is connected to all participating actors, etc.

</p>
<p>
igraph does not have direct support for bipartite networks, at
least not at the C language level. In other words the igraph_t
structure does not contain information about the vertex types.
The C functions for bipartite networks usually have an additional
input argument to graph, called <code class="constant">types</code>, a boolean vector giving
the vertex types.

</p>
<p>
Most functions creating bipartite networks are able to create this
extra vector, you just need to supply an initialized boolean vector
to them.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an igraph_t object, the graph will be
  created here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean vector. If not a null pointer,
  then the vertex types will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n1</code></em>:</span></p></td>
<td><p>
  Integer, the number of vertices of the first kind.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n2</code></em>:</span></p></td>
<td><p>
  Integer, the number of vertices of the second kind.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to create a directed graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  A constant that gives the type of connections for
  directed graphs. If <code class="constant">IGRAPH_OUT</code>, then edges point from vertices
  of the first kind to vertices of the second kind; if <code class="constant">IGRAPH_IN</code>, then the opposite direction is realized; if <code class="constant">IGRAPH_ALL</code>, then mutual edges will be created.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_full" title="1.10. igraph_full — Creates a full graph (directed or undirected, with or without loops)."><code class="function">igraph_full()</code></a> for non-bipartite full graphs.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bipartite_game"></a>2.3. <code class="function">igraph_bipartite_game</code> — Generate a bipartite random graph (similar to Erdos-Renyi)</h3></div></div></div>
<a class="indexterm" name="idm537722572736"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_bipartite_game(igraph_t *graph, igraph_vector_bool_t *types,
                          igraph_erdos_renyi_t type,
                          igraph_integer_t n1, igraph_integer_t n2,
                          igraph_real_t p, igraph_integer_t m,
                          igraph_bool_t directed, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Similarly to unipartite (one-mode) networks, we can define the
G(n,p), and G(n,m) graph classes for bipartite graphs, via their
generating process. In G(n,p) every possible edge between top and
bottom vertices is realized with probablity p, independently of the
rest of the edges. In G(n,m), we uniformly choose m edges to
realize.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized igraph graph, the result
   is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized boolean vector, or a null
   pointer. If not a null pointer, then the vertex types are stored
   here. Bottom vertices come first, n1 of them, then n2 top
   vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type</code></em>:</span></p></td>
<td>
<p>
  The type of the random graph, possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ERDOS_RENYI_GNM</code></span></p></td>
<td><p>

         G(n,m) graph,
         m edges are
         selected uniformly randomly in a graph with
         n vertices.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ERDOS_RENYI_GNP</code></span></p></td>
<td><p>

         G(n,p) graph,
         every possible edge is included in the graph with
         probability p.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n1</code></em>:</span></p></td>
<td><p>
  The number of bottom vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n2</code></em>:</span></p></td>
<td><p>
  The number of top verices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  The connection probability for G(n,p) graphs. It is
    ignored for G(n,m) graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The number of edges for G(n,m) graphs. It is ignored for
    G(n,p) graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to generate a directed graph. See
    also the <em class="parameter"><code>mode</code></em> argument.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies how to direct the edges in directed
    graphs. If it is <code class="constant">IGRAPH_OUT</code>, then directed edges point from
    bottom vertices to top vertices. If it is <code class="constant">IGRAPH_IN</code>, edges
    point from top vertices to bottom vertices. <code class="constant">IGRAPH_OUT</code> and
    <code class="constant">IGRAPH_IN</code> do not generate mutual edges. If this argument is
    <code class="constant">IGRAPH_ALL</code>, then each edge direction is considered
    independently and mutual edges might be generated. This
    argument is ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game" title="2.3. igraph_erdos_renyi_game — Generates a random (Erdos-Renyi) graph."><code class="function">igraph_erdos_renyi_game</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idm537722124688"></a>3. Incidence matrices</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_incidence">3.1. <code class="function">igraph_incidence</code> — Create a bipartite graph from an incidence matrix</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_get_incidence">3.2. <code class="function">igraph_get_incidence</code> — Convert a bipartite graph into an incidence matrix</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_incidence"></a>3.1. <code class="function">igraph_incidence</code> — Create a bipartite graph from an incidence matrix</h3></div></div></div>
<a class="indexterm" name="idm537722122768"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_incidence(igraph_t *graph, igraph_vector_bool_t *types,
                     const igraph_matrix_t *incidence,
                     igraph_bool_t directed,
                     igraph_neimode_t mode, igraph_bool_t multiple);
</pre></div>
<p>
</p>
<p>



A bipartite (or two-mode) graph contains two types of vertices and
edges always connect vertices of different types. An incidence
matrix is an nxm matrix, n and m are the number of vertices of the
two types, respectively. Nonzero elements in the matrix denote
edges between the two corresponding vertices.

</p>
<p>
Note that this function can operate in two modes, depending on the
<em class="parameter"><code>multiple</code></em> argument. If it is FALSE (i.e. 0), then a single edge is
created for every non-zero element in the incidence matrix. If <em class="parameter"><code>multiple</code></em> is TRUE (i.e. 1), then the matrix elements are rounded up
to the closest non-negative integer to get the number of edges to
create between a pair of vertices.

</p>
<p>
This function does not create multiple edges if <em class="parameter"><code>multiple</code></em> is
FALSE, but might create some if it is TRUE.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized boolean vector, or a null
  pointer. If not a null pointer, then the vertex types are stored
  here. It is resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>incidence</code></em>:</span></p></td>
<td><p>
  The incidence matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Gives whether to create an undirected or a directed
  graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies the direction of the edges in a directed
  graph. If <code class="constant">IGRAPH_OUT</code>, then edges point from vertices
  of the first kind (corresponding to rows) to vertices of the
  second kind (corresponding to columns); if <code class="constant">IGRAPH_IN</code>, then the opposite direction is realized; if <code class="constant">IGRAPH_ALL</code>, then mutual edges will be created.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiple</code></em>:</span></p></td>
<td><p>
  How to interpret the incidence matrix elements. See
  details below.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*m), the size of the incidence matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_incidence"></a>3.2. <code class="function">igraph_get_incidence</code> — Convert a bipartite graph into an incidence matrix</h3></div></div></div>
<a class="indexterm" name="idm537722294848"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_incidence(const igraph_t *graph,
                         const igraph_vector_bool_t *types,
                         igraph_matrix_t *res,
                         igraph_vector_t *row_ids,
                         igraph_vector_t *col_ids);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, edge directions are ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Boolean vector containing the vertex types.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix, the result is stored
  here. An element of the matrix gives the number of edges
  (irrespectively of their direction) between the two corresponding
  vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>row_ids</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
  pointer. If not a null pointer, then the vertex ids (in the
  graph) corresponding to the rows of the result matrix are stored
  here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>col_ids</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
  pointer. If not a null pointer, then the vertex ids corresponding
  to the columns of the result matrix are stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*m), n and m are number of vertices of the two
different kind.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Bipartite.html#igraph_incidence" title="3.1. igraph_incidence — Create a bipartite graph from an incidence matrix"><code class="function">igraph_incidence()</code></a> for the opposite operation.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idm537722790864"></a>4. Project a two-mode graphs</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_bipartite_projection_size">4.1. <code class="function">igraph_bipartite_projection_size</code> — Calculate the number of vertices and edges in the bipartite projections</a></span></dt>
<dt><span class="section"><a href="igraph-Bipartite.html#igraph_bipartite_projection">4.2. <code class="function">igraph_bipartite_projection</code> — Create one or both projections of a bipartite (two-mode) network</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bipartite_projection_size"></a>4.1. <code class="function">igraph_bipartite_projection_size</code> — Calculate the number of vertices and edges in the bipartite projections</h3></div></div></div>
<a class="indexterm" name="idm537722615104"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_bipartite_projection_size(const igraph_t *graph,
                                     const igraph_vector_bool_t *types,
                                     igraph_integer_t *vcount1,
                                     igraph_integer_t *ecount1,
                                     igraph_integer_t *vcount2,
                                     igraph_integer_t *ecount2);
</pre></div>
<p>
</p>
<p>



This function calculates the number of vertices and edges in the
two projections of a bipartite network. This is useful if you have
a big bipartite network and you want to estimate the amount of
memory you would need to calculate the projections themselves.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Boolean vector giving the vertex types of the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vcount1</code></em>:</span></p></td>
<td><p>
  Pointer to an <code class="constant">igraph_integer_t</code>, the number of
    vertices in the first projection is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ecount1</code></em>:</span></p></td>
<td><p>
  Pointer to an <code class="constant">igraph_integer_t</code>, the number of
    edges in the first projection is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vcount2</code></em>:</span></p></td>
<td><p>
  Pointer to an <code class="constant">igraph_integer_t</code>, the number of
    vertices in the second projection is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ecount2</code></em>:</span></p></td>
<td><p>
  Pointer to an <code class="constant">igraph_integer_t</code>, the number of
    edges in the second projection is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Bipartite.html#igraph_bipartite_projection" title="4.2. igraph_bipartite_projection — Create one or both projections of a bipartite (two-mode) network"><code class="function">igraph_bipartite_projection()</code></a> to calculate the actual
projection.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*d^2+|E|), |V| is the number of vertices, |E|
is the number of edges, d is the average (total) degree of the
graphs.

</p>
<div class="hideshow" onClick="toggle(this)">
<div class="example">
<a name="idm537722071520"></a><p class="title"><b>Example 30.2.  File <code class="code">examples/simple/igraph_bipartite_projection.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2008-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

int <span class="strong"><strong>check_projection</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t *graph,
                     <span class="strong"><strong>const</strong></span> igraph_vector_bool_t *types,
                     <span class="strong"><strong>const</strong></span> igraph_t *proj1,
                     <span class="strong"><strong>const</strong></span> igraph_t *proj2) {
    igraph_integer_t vcount1, ecount1, vcount2, ecount2;
    <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_bipartite_projection_size" title="4.1. igraph_bipartite_projection_size — Calculate the number of vertices and edges in the bipartite projections">igraph_bipartite_projection_size</a></strong></span>(graph, types, &amp;vcount1, &amp;ecount1,
                                     &amp;vcount2, &amp;ecount2);
    <span class="strong"><strong>if</strong></span> (proj1 &amp;&amp; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(proj1) != vcount1) {
        <span class="strong"><strong>exit</strong></span>(10);
    }
    <span class="strong"><strong>if</strong></span> (proj1 &amp;&amp; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(proj1) != ecount1) {
        <span class="strong"><strong>exit</strong></span>(11);
    }
    <span class="strong"><strong>if</strong></span> (proj2 &amp;&amp; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(proj2) != vcount2) {
        <span class="strong"><strong>exit</strong></span>(12);
    }
    <span class="strong"><strong>if</strong></span> (proj2 &amp;&amp; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(proj2) != ecount2) {
        <span class="strong"><strong>exit</strong></span>(13);
    }
    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g, p1, p2, full, ring;
    igraph_vector_bool_t types;
    igraph_bool_t iso;
    long int i, m2 = 0, w, f, t;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> mult1, mult2;

    <span class="emphasis"><em>/*******************************************************/</em></span>
    <span class="emphasis"><em>/* Full bipartite graph -&gt; full graphs                 */</em></span>
    <span class="emphasis"><em>/*******************************************************/</em></span>

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 0);
    <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_full_bipartite" title="2.2. igraph_full_bipartite — Create a full bipartite network">igraph_full_bipartite</a></strong></span>(&amp;g, &amp;types, 5, 3, <span class="emphasis"><em>/*directed=*/</em></span> 0,
                          <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_ALL);

    <span class="emphasis"><em>/* Get both projections */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_bipartite_projection" title="4.2. igraph_bipartite_projection — Create one or both projections of a bipartite (two-mode) network">igraph_bipartite_projection</a></strong></span>(&amp;g, &amp;types, &amp;p1, &amp;p2, 0, 0, <span class="emphasis"><em>/*probe1=*/</em></span> -1);
    <span class="strong"><strong>check_projection</strong></span>(&amp;g, &amp;types, &amp;p1, &amp;p2);

    <span class="emphasis"><em>/* Check first projection */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.10. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;full, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;p1), <span class="emphasis"><em>/*directed=*/</em></span>0, <span class="emphasis"><em>/*loops=*/</em></span>0);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.4. igraph_isomorphic_bliss — Graph isomorphism via BLISS">igraph_isomorphic_bliss</a></strong></span>(&amp;p1, &amp;full, 0, 0, &amp;iso, 0, 0,
                            IGRAPH_BLISS_FM, 0, 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;full);

    <span class="emphasis"><em>/* Check second projection */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.10. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;full, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;p2), <span class="emphasis"><em>/*directed=*/</em></span>0, <span class="emphasis"><em>/*loops=*/</em></span>0);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.4. igraph_isomorphic_bliss — Graph isomorphism via BLISS">igraph_isomorphic_bliss</a></strong></span>(&amp;p2, &amp;full, 0, 0, &amp;iso, 0, 0,
                            IGRAPH_BLISS_FM, 0, 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;full);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;p1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;p2);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);

    <span class="emphasis"><em>/*******************************************************/</em></span>
    <span class="emphasis"><em>/* More sophisticated test                             */</em></span>
    <span class="emphasis"><em>/*******************************************************/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 100, <span class="emphasis"><em>/*directed=*/</em></span> 1, <span class="emphasis"><em>/*mutual=*/</em></span> 1,
                <span class="emphasis"><em>/*circular=*/</em></span> 1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g));
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_bool_size</strong></span>(&amp;types); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = i % 2 ? 0 : 1;
    }

    <span class="emphasis"><em>/* Get both projections */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_bipartite_projection" title="4.2. igraph_bipartite_projection — Create one or both projections of a bipartite (two-mode) network">igraph_bipartite_projection</a></strong></span>(&amp;g, &amp;types, &amp;p1, &amp;p2, 0, 0, <span class="emphasis"><em>/*probe1=*/</em></span> -1);
    <span class="strong"><strong>check_projection</strong></span>(&amp;g, &amp;types, &amp;p1, &amp;p2);

    <span class="emphasis"><em>/* Check first projection */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) / 2, <span class="emphasis"><em>/*directed=*/</em></span> 0,
                <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.4. igraph_isomorphic_bliss — Graph isomorphism via BLISS">igraph_isomorphic_bliss</a></strong></span>(&amp;p1, &amp;ring, 0, 0, &amp;iso, 0, 0,
                            IGRAPH_BLISS_FM, 0, 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="emphasis"><em>/* Check second projection */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.4. igraph_isomorphic_bliss — Graph isomorphism via BLISS">igraph_isomorphic_bliss</a></strong></span>(&amp;p2, &amp;ring, 0, 0, &amp;iso, 0, 0,
                            IGRAPH_BLISS_FM, 0, 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;p1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;p2);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);

    <span class="emphasis"><em>/*******************************************************/</em></span>
    <span class="emphasis"><em>/* Multiplicity test                                   */</em></span>
    <span class="emphasis"><em>/*******************************************************/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a short graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_UNDIRECTED,
                 0, 8, 1, 8, 2, 8, 3, 8, 4, 8, 4, 9, 5, 9, 6, 9, 7, 9, 0, 9,
                 -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g));
    <span class="strong"><strong>igraph_vector_bool_fill</strong></span>(&amp;types, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[8] = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[9] = 0;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;mult1, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;mult2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_bipartite_projection" title="4.2. igraph_bipartite_projection — Create one or both projections of a bipartite (two-mode) network">igraph_bipartite_projection</a></strong></span>(&amp;g, &amp;types, &amp;p1, &amp;p2, &amp;mult1, &amp;mult2,
                                <span class="emphasis"><em>/*probe=*/</em></span> -1);
    <span class="strong"><strong>check_projection</strong></span>(&amp;g, &amp;types, &amp;p1, &amp;p2);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;mult1) != <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;p1)) {
        <span class="strong"><strong>return</strong></span> 21;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;mult2) != <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;p2)) {
        <span class="strong"><strong>return</strong></span> 22;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(mult1)[0] != 2) {
        <span class="strong"><strong>return</strong></span> 23;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;mult2); i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(mult2)[i] != 1 &amp;&amp; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(mult2)[i] != 2) {
            <span class="strong"><strong>return</strong></span> 24;
        }
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(mult2)[i] == 2) {
            m2++;
            w = i;
        }
    }
    <span class="strong"><strong>if</strong></span> (m2 != 1) {
        <span class="strong"><strong>return</strong></span> 25;
    }
    f = <span class="strong"><strong>IGRAPH_FROM</strong></span>(&amp;p2, w);
    t = <span class="strong"><strong>IGRAPH_TO</strong></span>(&amp;p2, w);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fmin</strong></span>(f, t) != 0 || <span class="strong"><strong>fmax</strong></span>(f, t) != 4) {
        <span class="strong"><strong>return</strong></span> 26;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;mult1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;mult2);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;p1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;p2);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bipartite_projection"></a>4.2. <code class="function">igraph_bipartite_projection</code> — Create one or both projections of a bipartite (two-mode) network</h3></div></div></div>
<a class="indexterm" name="idm537721102752"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_bipartite_projection(const igraph_t *graph,
                                const igraph_vector_bool_t *types,
                                igraph_t *proj1,
                                igraph_t *proj2,
                                igraph_vector_t *multiplicity1,
                                igraph_vector_t *multiplicity2,
                                igraph_integer_t probe1);
</pre></div>
<p>
</p>
<p>



Creates one or both projections of a bipartite graph.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The bipartite input graph. Directedness of the edges
  is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Boolean vector giving the vertex types of the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>proj1</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the first
  projection will be created here. It a null pointer, then it is
  ignored, see also the <em class="parameter"><code>probe1</code></em> argument.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>proj2</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the second
  projection is created here, if it is not a null pointer. See also
  the <em class="parameter"><code>probe1</code></em> argument.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiplicity1</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, or a null pointer. If not
  the latter, then the multiplicity of the edges is stored
  here. E.g. if there is an A-C-B and also an A-D-B triple in the
  bipartite graph (but no more X, such that A-X-B is also in the
  graph), then the multiplicity of the A-B edge in the projection
  will be 2.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiplicity2</code></em>:</span></p></td>
<td><p>
  The same as <code class="constant">multiplicity1</code>, but for the
  other projection.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>probe1</code></em>:</span></p></td>
<td><p>
  This argument can be used to specify the order of the
  projections in the resulting list. When it is non-negative, then
  it is considered as a vertex ID and the projection containing
  this vertex will be the first one in the result. Setting this
  argument to a non-negative value implies that <code class="constant">proj1</code> must be
  a non-null pointer. If you don't care about the ordering of the
  projections, pass -1 here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Bipartite.html#igraph_bipartite_projection_size" title="4.1. igraph_bipartite_projection_size — Calculate the number of vertices and edges in the bipartite projections"><code class="function">igraph_bipartite_projection_size()</code></a> to calculate the number
of vertices and edges in the projections, without creating the
projection graphs themselves.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*d^2+|E|), |V| is the number of vertices, |E|
is the number of edges, d is the average (total) degree of the
graphs.

</p>
<div class="hideshow" onClick="toggle(this)">
<div class="example">
<a name="idm537721235936"></a><p class="title"><b>Example 30.3.  File <code class="code">examples/simple/igraph_bipartite_projection.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2008-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

int <span class="strong"><strong>check_projection</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t *graph,
                     <span class="strong"><strong>const</strong></span> igraph_vector_bool_t *types,
                     <span class="strong"><strong>const</strong></span> igraph_t *proj1,
                     <span class="strong"><strong>const</strong></span> igraph_t *proj2) {
    igraph_integer_t vcount1, ecount1, vcount2, ecount2;
    <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_bipartite_projection_size" title="4.1. igraph_bipartite_projection_size — Calculate the number of vertices and edges in the bipartite projections">igraph_bipartite_projection_size</a></strong></span>(graph, types, &amp;vcount1, &amp;ecount1,
                                     &amp;vcount2, &amp;ecount2);
    <span class="strong"><strong>if</strong></span> (proj1 &amp;&amp; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(proj1) != vcount1) {
        <span class="strong"><strong>exit</strong></span>(10);
    }
    <span class="strong"><strong>if</strong></span> (proj1 &amp;&amp; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(proj1) != ecount1) {
        <span class="strong"><strong>exit</strong></span>(11);
    }
    <span class="strong"><strong>if</strong></span> (proj2 &amp;&amp; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(proj2) != vcount2) {
        <span class="strong"><strong>exit</strong></span>(12);
    }
    <span class="strong"><strong>if</strong></span> (proj2 &amp;&amp; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(proj2) != ecount2) {
        <span class="strong"><strong>exit</strong></span>(13);
    }
    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g, p1, p2, full, ring;
    igraph_vector_bool_t types;
    igraph_bool_t iso;
    long int i, m2 = 0, w, f, t;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> mult1, mult2;

    <span class="emphasis"><em>/*******************************************************/</em></span>
    <span class="emphasis"><em>/* Full bipartite graph -&gt; full graphs                 */</em></span>
    <span class="emphasis"><em>/*******************************************************/</em></span>

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 0);
    <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_full_bipartite" title="2.2. igraph_full_bipartite — Create a full bipartite network">igraph_full_bipartite</a></strong></span>(&amp;g, &amp;types, 5, 3, <span class="emphasis"><em>/*directed=*/</em></span> 0,
                          <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_ALL);

    <span class="emphasis"><em>/* Get both projections */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_bipartite_projection" title="4.2. igraph_bipartite_projection — Create one or both projections of a bipartite (two-mode) network">igraph_bipartite_projection</a></strong></span>(&amp;g, &amp;types, &amp;p1, &amp;p2, 0, 0, <span class="emphasis"><em>/*probe1=*/</em></span> -1);
    <span class="strong"><strong>check_projection</strong></span>(&amp;g, &amp;types, &amp;p1, &amp;p2);

    <span class="emphasis"><em>/* Check first projection */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.10. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;full, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;p1), <span class="emphasis"><em>/*directed=*/</em></span>0, <span class="emphasis"><em>/*loops=*/</em></span>0);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.4. igraph_isomorphic_bliss — Graph isomorphism via BLISS">igraph_isomorphic_bliss</a></strong></span>(&amp;p1, &amp;full, 0, 0, &amp;iso, 0, 0,
                            IGRAPH_BLISS_FM, 0, 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;full);

    <span class="emphasis"><em>/* Check second projection */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.10. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;full, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;p2), <span class="emphasis"><em>/*directed=*/</em></span>0, <span class="emphasis"><em>/*loops=*/</em></span>0);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.4. igraph_isomorphic_bliss — Graph isomorphism via BLISS">igraph_isomorphic_bliss</a></strong></span>(&amp;p2, &amp;full, 0, 0, &amp;iso, 0, 0,
                            IGRAPH_BLISS_FM, 0, 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;full);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;p1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;p2);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);

    <span class="emphasis"><em>/*******************************************************/</em></span>
    <span class="emphasis"><em>/* More sophisticated test                             */</em></span>
    <span class="emphasis"><em>/*******************************************************/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 100, <span class="emphasis"><em>/*directed=*/</em></span> 1, <span class="emphasis"><em>/*mutual=*/</em></span> 1,
                <span class="emphasis"><em>/*circular=*/</em></span> 1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g));
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_bool_size</strong></span>(&amp;types); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = i % 2 ? 0 : 1;
    }

    <span class="emphasis"><em>/* Get both projections */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_bipartite_projection" title="4.2. igraph_bipartite_projection — Create one or both projections of a bipartite (two-mode) network">igraph_bipartite_projection</a></strong></span>(&amp;g, &amp;types, &amp;p1, &amp;p2, 0, 0, <span class="emphasis"><em>/*probe1=*/</em></span> -1);
    <span class="strong"><strong>check_projection</strong></span>(&amp;g, &amp;types, &amp;p1, &amp;p2);

    <span class="emphasis"><em>/* Check first projection */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) / 2, <span class="emphasis"><em>/*directed=*/</em></span> 0,
                <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.4. igraph_isomorphic_bliss — Graph isomorphism via BLISS">igraph_isomorphic_bliss</a></strong></span>(&amp;p1, &amp;ring, 0, 0, &amp;iso, 0, 0,
                            IGRAPH_BLISS_FM, 0, 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="emphasis"><em>/* Check second projection */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.4. igraph_isomorphic_bliss — Graph isomorphism via BLISS">igraph_isomorphic_bliss</a></strong></span>(&amp;p2, &amp;ring, 0, 0, &amp;iso, 0, 0,
                            IGRAPH_BLISS_FM, 0, 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;p1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;p2);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);

    <span class="emphasis"><em>/*******************************************************/</em></span>
    <span class="emphasis"><em>/* Multiplicity test                                   */</em></span>
    <span class="emphasis"><em>/*******************************************************/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a short graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_UNDIRECTED,
                 0, 8, 1, 8, 2, 8, 3, 8, 4, 8, 4, 9, 5, 9, 6, 9, 7, 9, 0, 9,
                 -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g));
    <span class="strong"><strong>igraph_vector_bool_fill</strong></span>(&amp;types, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[8] = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[9] = 0;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;mult1, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;mult2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Bipartite.html#igraph_bipartite_projection" title="4.2. igraph_bipartite_projection — Create one or both projections of a bipartite (two-mode) network">igraph_bipartite_projection</a></strong></span>(&amp;g, &amp;types, &amp;p1, &amp;p2, &amp;mult1, &amp;mult2,
                                <span class="emphasis"><em>/*probe=*/</em></span> -1);
    <span class="strong"><strong>check_projection</strong></span>(&amp;g, &amp;types, &amp;p1, &amp;p2);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;mult1) != <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;p1)) {
        <span class="strong"><strong>return</strong></span> 21;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;mult2) != <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;p2)) {
        <span class="strong"><strong>return</strong></span> 22;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(mult1)[0] != 2) {
        <span class="strong"><strong>return</strong></span> 23;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Gives the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;mult2); i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(mult2)[i] != 1 &amp;&amp; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(mult2)[i] != 2) {
            <span class="strong"><strong>return</strong></span> 24;
        }
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(mult2)[i] == 2) {
            m2++;
            w = i;
        }
    }
    <span class="strong"><strong>if</strong></span> (m2 != 1) {
        <span class="strong"><strong>return</strong></span> 25;
    }
    f = <span class="strong"><strong>IGRAPH_FROM</strong></span>(&amp;p2, w);
    t = <span class="strong"><strong>IGRAPH_TO</strong></span>(&amp;p2, w);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fmin</strong></span>(f, t) != 0 || <span class="strong"><strong>fmax</strong></span>(f, t) != 4) {
        <span class="strong"><strong>return</strong></span> 26;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;mult1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;mult2);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;p1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;p2);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="idm537721271520"></a>5. Other operations on bipartite graphs</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Bipartite.html#igraph_is_bipartite">5.1. <code class="function">igraph_is_bipartite</code> — Check whether a graph is bipartite</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_bipartite"></a>5.1. <code class="function">igraph_is_bipartite</code> — Check whether a graph is bipartite</h3></div></div></div>
<a class="indexterm" name="idm537721864512"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_bipartite(const igraph_t *graph,
                        igraph_bool_t *res,
                        igraph_vector_bool_t *type);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function simply checks whether a graph \emph{could} be
bipartite. It tries to find a mapping that gives a possible division
of the vertices into two classes, such that no two vertices of the
same class are connected by an edge.

</p>
<p>
The existence of such a mapping is equivalent of having no circuits of
odd length in the graph. A graph with loop edges cannot bipartite.

</p>
<p>
Note that the mapping is not necessarily unique, e.g. if the graph has
at least two components, then the vertices in the separate components
can be mapped independently.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized boolean vector, or a null
  pointer. If not a null pointer and a mapping was found, then it
  is stored here. If not a null pointer, but no mapping was found,
  the contents of this vector is invalid.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.
 
</p>
</div>
</div>
</div>
<table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Arpack.html"><b>← Chapter 29. Using BLAS, LAPACK and ARPACK for igraph matrices and graphs</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Advanced.html"><b>Chapter 31. Advanced igraph programming →</b></a></td>
</tr></table>


      </div>
    </div>
  </div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
      &copy; 2003 &ndash; 2020 The igraph core team.
            &bull; Code licensed under 
            <a href="http://www.gnu.org/licenses/gpl-2.0.html">
            GNU GPL 2</a> or later, documentation under 
            <a href="http://www.gnu.org/copyleft/fdl.html">
              GNU FDL.</a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>

    
  </body>
</html>
