




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>igraph Reference Manual</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/fontawesome.min.css" integrity="sha384-QYIZto+st3yW+o8+5OHfT6S482Zsvz2WfOzpFSXMF9zqeLcFV0/wlZpMtyFcZALm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/solid.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/brands.min.css">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DY4MJME11Z"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-DY4MJME11Z');
	</script>

    <link href="/css/manual.css" rel="stylesheet">
<script async src="https://cse.google.com/cse.js?cx=003494361702844740117:dlnifinshhm"></script>

  </head>

  <body class="cc">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/c">igraph library</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            0.9.7
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="https://r.igraph.org">igraph R package</a>
              <a class="dropdown-item" href="https://python.igraph.org">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa-brands fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa-solid fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa-solid fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa-solid fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa-brands fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">igraph Reference Manual</h1>
        <p class="lead">For using the igraph C library</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container search-box-container">
  <div class="row">
    <div class="col-md-12 d-flex flex-row align-items-middle">
      <div class="search-label">Search the manual:</div>
	  <div style="flex: 1; margin: -1em 0 -1em 0"><div class="gcse-search" data-personalizedAds="false"></div></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="bs-docs-section">
        
<div class="navigation-header mb-4" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-light" href="igraph-Generators.html"><i class="fa fa-chevron-left"></i>
              Previous
            </a><a accesskey="h" class="btn btn-light" href="index.html"><i class="fa fa-home"></i>
              Home
            </a><a accesskey="n" class="btn btn-light" href="igraph-Iterators.html"><i class="fa fa-chevron-right"></i>
              Next
            </a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Spatial-Games"></a>Chapter 10. Games on graphs</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Spatial-Games.html#microscopic-update-rules">1. Microscopic update rules</a></span></dt>
<dt><span class="section"><a href="igraph-Spatial-Games.html#epidemic-models">2. Epidemic models</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="microscopic-update-rules"></a>1. Microscopic update rules</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Spatial-Games.html#igraph_deterministic_optimal_imitation">1.1. <code class="function">igraph_deterministic_optimal_imitation</code> —  Adopt a strategy via deterministic optimal imitation.</a></span></dt>
<dt><span class="section"><a href="igraph-Spatial-Games.html#igraph_moran_process">1.2. <code class="function">igraph_moran_process</code> —  The Moran process in a network setting.</a></span></dt>
<dt><span class="section"><a href="igraph-Spatial-Games.html#igraph_roulette_wheel_imitation">1.3. <code class="function">igraph_roulette_wheel_imitation</code> —  Adopt a strategy via roulette wheel selection.</a></span></dt>
<dt><span class="section"><a href="igraph-Spatial-Games.html#igraph_stochastic_imitation">1.4. <code class="function">igraph_stochastic_imitation</code> —  Adopt a strategy via stochastic imitation with uniform selection.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_deterministic_optimal_imitation"></a>1.1. <code class="function">igraph_deterministic_optimal_imitation</code> —  Adopt a strategy via deterministic optimal imitation.</h3></div></div></div>
<a class="indexterm" name="id-1.11.2.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_deterministic_optimal_imitation(const igraph_t *graph,
        igraph_integer_t vid,
        igraph_optimal_t optimality,
        const igraph_vector_t *quantities,
        igraph_vector_t *strategies,
        igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




A simple deterministic imitation strategy where a vertex revises its
strategy to that which yields a local optimal. Here "local" is with
respect to the immediate neighbours of the vertex. The vertex retains its
current strategy where this strategy yields a locally optimal quantity.
The quantity in this case could be a measure such as fitness.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object representing the game network. This cannot
       be the empty or trivial graph, but must have at least two vertices
       and one edge. If <em class="parameter"><code>graph</code></em> has one vertex, then no strategy update
       would take place. Furthermore, if <em class="parameter"><code>graph</code></em> has at least two vertices
       but zero edges, then strategy update would also not take place.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vid</code></em>:</span></p></td>
<td><p>
  The vertex whose strategy is to be updated. It is assumed that
       <em class="parameter"><code>vid</code></em> represents a vertex in <em class="parameter"><code>graph</code></em>. No checking is performed and
       it is your responsibility to ensure that <em class="parameter"><code>vid</code></em> is indeed a vertex
       of <em class="parameter"><code>graph</code></em>. If an isolated vertex is provided, i.e. the input
       vertex has degree 0, then no strategy update would take place and
       <em class="parameter"><code>vid</code></em> would retain its current strategy. Strategy update would also
       not take place if the local neighbourhood of <em class="parameter"><code>vid</code></em> are its
       in-neighbours (respectively out-neighbours), but <em class="parameter"><code>vid</code></em> has zero
       in-neighbours (respectively out-neighbours). Loops are ignored in
       computing the degree (in, out, all) of <em class="parameter"><code>vid</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>optimality</code></em>:</span></p></td>
<td>
<p>
  Logical; controls the type of optimality to be used.
       Supported values are:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_MAXIMUM</code></span></p></td>
<td><p>

         Use maximum deterministic imitation, where the strategy of the
         vertex with maximum quantity (e.g. fitness) would be adopted. We
         update the strategy of <em class="parameter"><code>vid</code></em> to that which yields a local
         maximum.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_MINIMUM</code></span></p></td>
<td><p>

         Use minimum deterministic imitation. That is, the strategy of the
         vertex with minimum quantity would be imitated. In other words,
         update to the strategy that yields a local minimum.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>quantities</code></em>:</span></p></td>
<td><p>
  A vector of quantities providing the quantity of each
       vertex in <em class="parameter"><code>graph</code></em>. Think of each entry of the vector as being
       generated by a function such as the fitness function for the game.
       So if the vector represents fitness quantities, then each vector
       entry is the fitness of some vertex. The length of this vector must
       be the same as the number of vertices in the vertex set of <em class="parameter"><code>graph</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>strategies</code></em>:</span></p></td>
<td><p>
  A vector of the current strategies for the vertex
       population. The updated strategy for <em class="parameter"><code>vid</code></em> would be stored here.
       Each strategy is identified with a nonnegative integer, whose
       interpretation depends on the payoff matrix of the game. Generally
       we use the strategy ID as a row or column index of the payoff
       matrix. The length of this vector must be the same as the number of
       vertices in the vertex set of <em class="parameter"><code>graph</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  Defines the sort of neighbourhood to consider for <em class="parameter"><code>vid</code></em>. If
       <em class="parameter"><code>graph</code></em> is undirected, then we use all the immediate neighbours of
       <em class="parameter"><code>vid</code></em>. Thus if you know that <em class="parameter"><code>graph</code></em> is undirected, then it is safe
       to pass the value <em class="parameter"><code>IGRAPH_ALL</code></em> here. Supported values are:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         Use the out-neighbours of <em class="parameter"><code>vid</code></em>. This option is only relevant
         when <em class="parameter"><code>graph</code></em> is a directed graph.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         Use the in-neighbours of <em class="parameter"><code>vid</code></em>. Again this option is only relevant
         when <em class="parameter"><code>graph</code></em> is a directed graph.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         Use both the in- and out-neighbours of <em class="parameter"><code>vid</code></em>. This option is only
         relevant if <em class="parameter"><code>graph</code></em> is a digraph. Also use this value if
         <em class="parameter"><code>graph</code></em> is undirected.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The error code <em class="parameter"><code>IGRAPH_EINVAL</code></em> is returned in each of the
        following cases: (1) Any of the parameters <em class="parameter"><code>graph</code></em>, <em class="parameter"><code>quantities</code></em>,
        or <em class="parameter"><code>strategies</code></em> is a null pointer. (2) The vector <em class="parameter"><code>quantities</code></em>
        or <em class="parameter"><code>strategies</code></em> has a length different from the number of vertices
        in <em class="parameter"><code>graph</code></em>. (3) The parameter <em class="parameter"><code>graph</code></em> is the empty or null graph,
        i.e. the graph with zero vertices and edges.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(2d), where d is the degree of the vertex <em class="parameter"><code>vid</code></em>.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.11.2.2.8.2"></a><p class="title"><b>Example 10.1.  File <code class="code">examples/simple/igraph_deterministic_optimal_imitation.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>  Test suite for deterministic optimal imitation.</em></span>
<span class="emphasis"><em>  Copyright (C) 2011 Minh Van Nguyen </em></span>&lt;nguyenminh2@gmail.com&gt;

<span class="emphasis"><em>  This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>  it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>  the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>  (at your option) any later version.</em></span>

<span class="emphasis"><em>  This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>  but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>  GNU General Public License for more details.</em></span>

<span class="emphasis"><em>  You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>  along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>  Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>  02110-1301 USA</em></span>
<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

<span class="emphasis"><em>/* test parameters structure */</em></span>
<span class="strong"><strong>typedef</strong></span> <span class="strong"><strong>struct</strong></span> {
    igraph_t *graph;
    igraph_integer_t vertex;
    igraph_optimal_t optimality;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *quantities;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *strategies;
    igraph_neimode_t mode;
    int retval;
} strategy_test_t;

<span class="emphasis"><em>/* Error tests. That is, we expect error codes to be returned from such tests.</em></span>
<span class="emphasis"><em> */</em></span>
int <span class="strong"><strong>error_tests</strong></span>() {
    igraph_t g, h;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> quant, strat;
    int i, n, ret;
    strategy_test_t *test;

    <span class="emphasis"><em>/* nonempty graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED, 0, 1, 1, 2, 2, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_empty" title="3.1.1. igraph_empty — Creates an empty graph with some vertices and no edges.">igraph_empty</a></strong></span>(&amp;h, 0, 0);         <span class="emphasis"><em>/* empty graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;quant, 1);  <span class="emphasis"><em>/* quantities vector */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;strat, 2);  <span class="emphasis"><em>/* strategies vector */</em></span>

    {
        <span class="emphasis"><em>/* test parameters */</em></span>
        <span class="emphasis"><em>/*--graph--vertex--optimality--quantities--strategies--mode--retval--*/</em></span>
        <span class="emphasis"><em>/* null pointer for graph */</em></span>
        strategy_test_t null_graph = { NULL, 0, 0, NULL, NULL, IGRAPH_ALL,
                                       IGRAPH_EINVAL
                                     };
        <span class="emphasis"><em>/* null pointer for quantities vector */</em></span>
        strategy_test_t null_quant = { &amp;g, 0, 0, NULL, NULL, IGRAPH_ALL,
                                       IGRAPH_EINVAL
                                     };
        <span class="emphasis"><em>/* null pointer for strategies vector */</em></span>
        strategy_test_t null_strat = { &amp;g, 0, 0, &amp;quant, NULL, IGRAPH_ALL,
                                       IGRAPH_EINVAL
                                     };
        <span class="emphasis"><em>/* empty graph */</em></span>
        strategy_test_t empty_graph = {&amp;h, 0, 0, &amp;quant, &amp;strat, IGRAPH_ALL,
                                       IGRAPH_EINVAL
                                      };
        <span class="emphasis"><em>/* length of quantities vector different from number of vertices */</em></span>
        strategy_test_t qdiff_length = {&amp;g, 0, 0, &amp;quant, &amp;strat, IGRAPH_ALL,
                                        IGRAPH_EINVAL
                                       };
        <span class="emphasis"><em>/* length of strategies vector different from number of vertices */</em></span>
        strategy_test_t sdiff_length = {&amp;g, 0, 0, &amp;quant, &amp;strat, IGRAPH_ALL,
                                        IGRAPH_EINVAL
                                       };
        strategy_test_t *all_checks[] = {<span class="emphasis"><em>/* 1 */</em></span> &amp;null_graph,
                                                 <span class="emphasis"><em>/* 2 */</em></span> &amp;null_quant,
                                                 <span class="emphasis"><em>/* 3 */</em></span> &amp;null_strat,
                                                 <span class="emphasis"><em>/* 4 */</em></span> &amp;empty_graph,
                                                 <span class="emphasis"><em>/* 5 */</em></span> &amp;qdiff_length,
                                                 <span class="emphasis"><em>/* 6 */</em></span> &amp;sdiff_length
                                        };
        n = 6;
        <span class="emphasis"><em>/* Run the error tests. We expect an error to be raised for each test. */</em></span>
        <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(<a class="link" href="igraph-Error.html#igraph_error_handler_ignore" title="2.3. igraph_error_handler_ignore — Ignore errors.">igraph_error_handler_ignore</a>);
        i = 0;
        <span class="strong"><strong>while</strong></span> (i &lt; n) {
            test = all_checks[i];
            ret = <span class="strong"><strong><a class="link" href="igraph-Spatial-Games.html#igraph_deterministic_optimal_imitation" title="1.1. igraph_deterministic_optimal_imitation — Adopt a strategy via deterministic optimal imitation.">igraph_deterministic_optimal_imitation</a></strong></span>(test-&gt;graph,
                    test-&gt;vertex,
                    test-&gt;optimality,
                    test-&gt;quantities,
                    test-&gt;strategies,
                    test-&gt;mode);
            <span class="strong"><strong>if</strong></span> (ret != test-&gt;retval) {
                <span class="strong"><strong>printf</strong></span>("Error test no. %d failed.\n", (int)(i + 1));
                <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
            }
            i++;
        }
    }
    <span class="emphasis"><em>/* clean up */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;h);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;quant);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;strat);

    <span class="strong"><strong>return</strong></span> IGRAPH_SUCCESS;
}

<span class="emphasis"><em>/* Updating the strategy of an isolated vertex. In this case, the strategies</em></span>
<span class="emphasis"><em> * vector should not change at all.</em></span>
<span class="emphasis"><em> */</em></span>
int <span class="strong"><strong>isolated_vertex_test</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> quant, strat, v;
    int i, ret;

    <span class="emphasis"><em>/* graph with one isolated vertex */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED, 0, 1, 1, 2, 2, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_add_vertices" title="3.3.3. igraph_add_vertices — Adds vertices to a graph.">igraph_add_vertices</a></strong></span>(&amp;g, 1, 0);  <span class="emphasis"><em>/* new vertex 3 is isolated */</em></span>
    <span class="emphasis"><em>/* quantities vector: all vertices have the same fitness */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;quant, 4, 0.25, 0.25, 0.25, 0.25);
    <span class="emphasis"><em>/* strategies vector: 0 means aggressive strategy; 1 means passive */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;strat, 4, 1., 0., 1., 0.);
    <span class="emphasis"><em>/* make a copy of the original strategies vector for comparison later on */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_copy" title="2.2.4. igraph_vector_copy — Initializes a vector from another vector object (constructor).">igraph_vector_copy</a></strong></span>(&amp;v, &amp;strat);
    <span class="emphasis"><em>/* Now update strategy of vertex 3. Since this vertex is isolated, no */</em></span>
    <span class="emphasis"><em>/* strategy update would take place. The resulting strategies vector */</em></span>
    <span class="emphasis"><em>/* would be the same as it was originally. */</em></span>
    ret = <span class="strong"><strong><a class="link" href="igraph-Spatial-Games.html#igraph_deterministic_optimal_imitation" title="1.1. igraph_deterministic_optimal_imitation — Adopt a strategy via deterministic optimal imitation.">igraph_deterministic_optimal_imitation</a></strong></span>(<span class="emphasis"><em>/*graph*/</em></span> &amp;g,
            <span class="emphasis"><em>/*vertex*/</em></span> 3,
            <span class="emphasis"><em>/*optimality*/</em></span> IGRAPH_MAXIMUM,
            <span class="emphasis"><em>/*quantities*/</em></span> &amp;quant,
            <span class="emphasis"><em>/*strategies*/</em></span> &amp;strat,
            <span class="emphasis"><em>/*mode*/</em></span> IGRAPH_ALL);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>printf</strong></span>("Isolated vertex test failed.\n");
        <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;strat); i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(strat)[i] != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[i]) {
            <span class="strong"><strong>printf</strong></span>("Isolated vertex test failed.\n");
            <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
        }
    }
    <span class="emphasis"><em>/* clean up */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;quant);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;strat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v);

    <span class="strong"><strong>return</strong></span> IGRAPH_SUCCESS;
}

<span class="emphasis"><em>/* A game on the Petersen graph. This graph has 10 vertices and 15 edges.</em></span>
<span class="emphasis"><em> * The Petersen graph is initialized with a default quantities vector and a</em></span>
<span class="emphasis"><em> * default strategies vector. For each vertex v in the graph, we update the</em></span>
<span class="emphasis"><em> * strategy of v via deterministic optimal imitation. The resulting updated</em></span>
<span class="emphasis"><em> * strategies vector is compared with the known result vector. A mismatch would</em></span>
<span class="emphasis"><em> * raise an error code. If the updated strategies vector matches the known</em></span>
<span class="emphasis"><em> * result vector, we reset the strategies vector to its default state and</em></span>
<span class="emphasis"><em> * repeat the game with another vertex.</em></span>
<span class="emphasis"><em> */</em></span>
int <span class="strong"><strong>petersen_game_test</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> known_max_v, known_min_v, quant, strat, stratcopy;
    int i, nvert;

    <span class="emphasis"><em>/* the Petersen graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, <span class="emphasis"><em>/*n=*/</em></span> 0, IGRAPH_UNDIRECTED,
                 0, 1, 0, 4, 0, 5, 1, 2, 1, 6, 2, 3, 2, 7, 3, 4, 3, 8, 4, 9,
                 5, 7, 5, 8, 6, 8, 6, 9, 7, 9, -1);
    nvert = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="3.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g);
    <span class="emphasis"><em>/* Strategies vector, one strategy for each vertex. Thus vec[i] is the */</em></span>
    <span class="emphasis"><em>/* strategy of vertex i. The strategy space is: {0, 1, 2, 3}. */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;strat, nvert,
                            1., 1., 2., 2., 0.,
                            0., 0., 1., 2., 3.);
    <span class="emphasis"><em>/* Quantities vector, one quantity per vertex. Thus vec[i] is the */</em></span>
    <span class="emphasis"><em>/* quantity for vertex i. */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;quant, nvert,
                            0.3, 1.1, 0.5, 1.0, 0.9,
                            0.8, 0.4, 0.1, 0.7, 0.7);
    <span class="emphasis"><em>/* Known strategies that would be adopted. Thus vec[i] means that in */</em></span>
    <span class="emphasis"><em>/* game i where we revise the strategy of vertex i, the strategy */</em></span>
    <span class="emphasis"><em>/* vec[i] would be adopted by i. */</em></span>
    <span class="emphasis"><em>/*maximum deterministic imitation*/</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;known_max_v, nvert,
                            1., 1., 1., 2., 2.,
                            0., 1., 0., 2., 0.);
    <span class="emphasis"><em>/*minimum deterministic imitation*/</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;known_min_v, nvert,
                            1., 1., 1., 2., 1.,
                            1., 0., 1., 0., 1.);
    <span class="emphasis"><em>/* play game and compare resulting updated strategies */</em></span>
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; nvert; i++) {
        <span class="emphasis"><em>/* maximum deterministic imitation */</em></span>
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_copy" title="2.2.4. igraph_vector_copy — Initializes a vector from another vector object (constructor).">igraph_vector_copy</a></strong></span>(&amp;stratcopy, &amp;strat);
        <span class="strong"><strong><a class="link" href="igraph-Spatial-Games.html#igraph_deterministic_optimal_imitation" title="1.1. igraph_deterministic_optimal_imitation — Adopt a strategy via deterministic optimal imitation.">igraph_deterministic_optimal_imitation</a></strong></span>(<span class="emphasis"><em>/*graph*/</em></span> &amp;g,
                <span class="emphasis"><em>/*vertex*/</em></span> (igraph_integer_t)i,
                <span class="emphasis"><em>/*optimality*/</em></span> IGRAPH_MAXIMUM,
                <span class="emphasis"><em>/*quantities*/</em></span> &amp;quant,
                <span class="emphasis"><em>/*strategies*/</em></span> &amp;stratcopy,
                <span class="emphasis"><em>/*neighbours*/</em></span> IGRAPH_ALL);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(stratcopy)[i] != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(known_max_v)[i]) {
            <span class="strong"><strong>printf</strong></span>("Maximum deterministic imitation failed for vertex %d.\n", i);
            <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
        }
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;stratcopy);
        <span class="emphasis"><em>/* minimum deterministic imitation */</em></span>
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_copy" title="2.2.4. igraph_vector_copy — Initializes a vector from another vector object (constructor).">igraph_vector_copy</a></strong></span>(&amp;stratcopy, &amp;strat);
        <span class="strong"><strong><a class="link" href="igraph-Spatial-Games.html#igraph_deterministic_optimal_imitation" title="1.1. igraph_deterministic_optimal_imitation — Adopt a strategy via deterministic optimal imitation.">igraph_deterministic_optimal_imitation</a></strong></span>(<span class="emphasis"><em>/*graph*/</em></span> &amp;g,
                <span class="emphasis"><em>/*vertex*/</em></span> (igraph_integer_t)i,
                <span class="emphasis"><em>/*optimality*/</em></span> IGRAPH_MINIMUM,
                <span class="emphasis"><em>/*quantities*/</em></span> &amp;quant,
                <span class="emphasis"><em>/*strategies*/</em></span> &amp;stratcopy,
                <span class="emphasis"><em>/*neighbours*/</em></span> IGRAPH_ALL);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(stratcopy)[i] != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(known_min_v)[i]) {
            <span class="strong"><strong>printf</strong></span>("Minimum deterministic imitation failed for vertex %d.\n", i);
            <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
        }
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;stratcopy);
    }
    <span class="emphasis"><em>/* clean up */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;known_max_v);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;known_min_v);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;quant);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;strat);

    <span class="strong"><strong>return</strong></span> IGRAPH_SUCCESS;
}

int <span class="strong"><strong>main</strong></span>() {
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 648);

    ret = <span class="strong"><strong>error_tests</strong></span>();
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> ret;
    }
    ret = <span class="strong"><strong>isolated_vertex_test</strong></span>();
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> ret;
    }
    ret = <span class="strong"><strong>petersen_game_test</strong></span>();
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> ret;
    }

    <span class="strong"><strong>return</strong></span> IGRAPH_SUCCESS;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_moran_process"></a>1.2. <code class="function">igraph_moran_process</code> —  The Moran process in a network setting.</h3></div></div></div>
<a class="indexterm" name="id-1.11.2.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_moran_process(const igraph_t *graph,
                         const igraph_vector_t *weights,
                         igraph_vector_t *quantities,
                         igraph_vector_t *strategies,
                         igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




This is an extension of the classic Moran process to a network setting.
The Moran process is a model of haploid (asexual) reproduction within a
population having a fixed size. In the network setting, the Moran process
operates on a weighted graph. At each time step a vertex a is chosen for
reproduction and another vertex b is chosen for death. Vertex a gives birth
to an identical clone c, which replaces b. Vertex c is a clone of a in that
c inherits both the current quantity (e.g. fitness) and current strategy
of a.

</p>
<p>
The graph G representing the game network is assumed to be simple,
i.e. free of loops and without multiple edges. If, on the other hand, G has
a loop incident on some vertex v, then it is possible that when v is chosen
for reproduction it would forgo this opportunity. In particular, when v is
chosen for reproduction and v is also chosen for death, the clone of v
would be v itself with its current vertex ID. In effect v forgoes its
chance for reproduction.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object representing the game network. This cannot
       be the empty or trivial graph, but must have at least two vertices
       and one edge. The Moran process will not take place in each of the
       following cases: (1) If <em class="parameter"><code>graph</code></em> has one vertex. (2) If <em class="parameter"><code>graph</code></em> has
       at least two vertices but zero edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A vector of all edge weights for <em class="parameter"><code>graph</code></em>. Thus weights[i]
       means the weight of the edge with edge ID i. For the purpose of the
       Moran process, each weight is assumed to be positive; it is your
       responsibility to ensure this condition holds. The length of this
       vector must be the same as the number of edges in <em class="parameter"><code>graph</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>quantities</code></em>:</span></p></td>
<td><p>
  A vector of quantities providing the quantity of each
       vertex in <em class="parameter"><code>graph</code></em>. The quantity of the new clone will be stored
       here. Think of each entry of the vector as being generated by a
       function such as the fitness function for the game. So if the vector
       represents fitness quantities, then each vector entry is the fitness
       of some vertex. The length of this vector must be the same as the
       number of vertices in the vertex set of <em class="parameter"><code>graph</code></em>. For the purpose of
       the Moran process, each vector entry is assumed to be nonnegative;
       no checks will be performed for this. It is your responsibility to
       ensure that at least one entry is positive. Furthermore, this vector
       cannot be a vector of zeros; this condition will be checked.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>strategies</code></em>:</span></p></td>
<td><p>
  A vector of the current strategies for the vertex
       population. The strategy of the new clone will be stored here. Each
       strategy is identified with a nonnegative integer, whose
       interpretation depends on the payoff matrix of the game. Generally
       we use the strategy ID as a row or column index of the payoff
       matrix. The length of this vector must be the same as the number of
       vertices in the vertex set of <em class="parameter"><code>graph</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  Defines the sort of neighbourhood to consider for the vertex a
       chosen for reproduction. This is only relevant if <em class="parameter"><code>graph</code></em> is
       directed. If <em class="parameter"><code>graph</code></em> is undirected, then it is safe to pass the
       value <em class="parameter"><code>IGRAPH_ALL</code></em> here. Supported values are:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         Use the out-neighbours of a. This option is only relevant when
         <em class="parameter"><code>graph</code></em> is directed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         Use the in-neighbours of a. Again this option is only relevant
         when <em class="parameter"><code>graph</code></em> is directed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         Use both the in- and out-neighbours of a. This option is only
         relevant if <em class="parameter"><code>graph</code></em> is directed. Also use this value if
         <em class="parameter"><code>graph</code></em> is undirected.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The error code <em class="parameter"><code>IGRAPH_EINVAL</code></em> is returned in each of the following
        cases: (1) Any of the parameters <em class="parameter"><code>graph</code></em>, <em class="parameter"><code>weights</code></em>,
        <em class="parameter"><code>quantities</code></em> or <em class="parameter"><code>strategies</code></em> is a null pointer. (2) The vector
        <em class="parameter"><code>quantities</code></em> or <em class="parameter"><code>strategies</code></em> has a length different from the
        number of vertices in <em class="parameter"><code>graph</code></em>. (3) The vector <em class="parameter"><code>weights</code></em> has a
        length different from the number of edges in <em class="parameter"><code>graph</code></em>. (4) The
        parameter <em class="parameter"><code>graph</code></em> is the empty or null graph, i.e. the graph with
        zero vertices and edges. (5) The vector <em class="parameter"><code>weights</code></em>, or the
        combination of interest, sums to zero. (6) The vector <em class="parameter"><code>quantities</code></em>,
        or the combination of interest, sums to zero.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the random number generator, but is usually
O(n) where n is the number of vertices in <em class="parameter"><code>graph</code></em>.

</p>
<p>
References:
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">(Lieberman et al. 2005)</code></span></p></td>
<td><p>

  E. Lieberman, C. Hauert, and M. A. Nowak. Evolutionary dynamics on
  graphs. <span class="emphasis"><em> Nature, </em></span> 433(7023):312--316, 2005.

</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">(Moran 1958)</code></span></p></td>
<td><p>

  P. A. P. Moran. Random processes in genetics. <span class="emphasis"><em> Mathematical
  Proceedings of the Cambridge Philosophical Society, </em></span> 54(1):60--71,
  1958.

</p></td>
</tr>
</tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_roulette_wheel_imitation"></a>1.3. <code class="function">igraph_roulette_wheel_imitation</code> —  Adopt a strategy via roulette wheel selection.</h3></div></div></div>
<a class="indexterm" name="id-1.11.2.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_roulette_wheel_imitation(const igraph_t *graph,
                                    igraph_integer_t vid,
                                    igraph_bool_t islocal,
                                    const igraph_vector_t *quantities,
                                    igraph_vector_t *strategies,
                                    igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




A simple stochastic imitation strategy where a vertex revises its
strategy to that of a vertex u chosen proportionate to u's quantity
(e.g. fitness). This is a special case of stochastic imitation, where a
candidate is not chosen uniformly at random but proportionate to its
quantity.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object representing the game network. This cannot
       be the empty or trivial graph, but must have at least two vertices
       and one edge. If <em class="parameter"><code>graph</code></em> has one vertex, then no strategy update
       would take place. Furthermore, if <em class="parameter"><code>graph</code></em> has at least two vertices
       but zero edges, then strategy update would also not take place.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vid</code></em>:</span></p></td>
<td><p>
  The vertex whose strategy is to be updated. It is assumed that
       <em class="parameter"><code>vid</code></em> represents a vertex in <em class="parameter"><code>graph</code></em>. No checking is performed and
       it is your responsibility to ensure that <em class="parameter"><code>vid</code></em> is indeed a vertex
       of <em class="parameter"><code>graph</code></em>. If an isolated vertex is provided, i.e. the input
       vertex has degree 0, then no strategy update would take place and
       <em class="parameter"><code>vid</code></em> would retain its current strategy. Strategy update would also
       not take place if the local neighbourhood of <em class="parameter"><code>vid</code></em> are its
       in-neighbours (respectively out-neighbours), but <em class="parameter"><code>vid</code></em> has zero
       in-neighbours (respectively out-neighbours). Loops are ignored in
       computing the degree (in, out, all) of <em class="parameter"><code>vid</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>islocal</code></em>:</span></p></td>
<td><p>
  Boolean; this flag controls which perspective to use in
       computing the relative quantity. If true then we use the local
       perspective; otherwise we use the global perspective. The local
       perspective for <em class="parameter"><code>vid</code></em> is the set of all immediate neighbours of
       <em class="parameter"><code>vid</code></em>. In contrast, the global perspective for <em class="parameter"><code>vid</code></em> is the
       vertex set of <em class="parameter"><code>graph</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>quantities</code></em>:</span></p></td>
<td><p>
  A vector of quantities providing the quantity of each
       vertex in <em class="parameter"><code>graph</code></em>. Think of each entry of the vector as being
       generated by a function such as the fitness function for the game.
       So if the vector represents fitness quantities, then each vector
       entry is the fitness of some vertex. The length of this vector must
       be the same as the number of vertices in the vertex set of <em class="parameter"><code>graph</code></em>.
       For the purpose of roulette wheel selection, each vector entry is
       assumed to be nonnegative; no checks will be performed for this. It
       is your responsibility to ensure that at least one entry is nonzero.
       Furthermore, this vector cannot be a vector of zeros; this condition
       will be checked.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>strategies</code></em>:</span></p></td>
<td><p>
  A vector of the current strategies for the vertex
       population. The updated strategy for <em class="parameter"><code>vid</code></em> would be stored here.
       Each strategy is identified with a nonnegative integer, whose
       interpretation depends on the payoff matrix of the game. Generally
       we use the strategy ID as a row or column index of the payoff
       matrix. The length of this vector must be the same as the number of
       vertices in the vertex set of <em class="parameter"><code>graph</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  Defines the sort of neighbourhood to consider for <em class="parameter"><code>vid</code></em>. This
       is only relevant if we are considering the local perspective, i.e. if
       <em class="parameter"><code>islocal</code></em> is true. If we are considering the global perspective,
       then it is safe to pass the value <em class="parameter"><code>IGRAPH_ALL</code></em> here. If <em class="parameter"><code>graph</code></em> is
       undirected, then we use all the immediate neighbours of <em class="parameter"><code>vid</code></em>. Thus
       if you know that <em class="parameter"><code>graph</code></em> is undirected, then it is safe to pass the
       value <em class="parameter"><code>IGRAPH_ALL</code></em> here. Supported values are:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         Use the out-neighbours of <em class="parameter"><code>vid</code></em>. This option is only relevant
         when <em class="parameter"><code>graph</code></em> is a digraph and we are considering the local
         perspective.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         Use the in-neighbours of <em class="parameter"><code>vid</code></em>. Again this option is only relevant
         when <em class="parameter"><code>graph</code></em> is a directed graph and we are considering the local
         perspective.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         Use both the in- and out-neighbours of <em class="parameter"><code>vid</code></em>. This option is only
         relevant if <em class="parameter"><code>graph</code></em> is a digraph. Also use this value if
         <em class="parameter"><code>graph</code></em> is undirected or we are considering the global
         perspective.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The error code <em class="parameter"><code>IGRAPH_EINVAL</code></em> is returned in each of the following
        cases: (1) Any of the parameters <em class="parameter"><code>graph</code></em>, <em class="parameter"><code>quantities</code></em>, or
        <em class="parameter"><code>strategies</code></em> is a null pointer. (2) The vector <em class="parameter"><code>quantities</code></em> or
        <em class="parameter"><code>strategies</code></em> has a length different from the number of vertices
        in <em class="parameter"><code>graph</code></em>. (3) The parameter <em class="parameter"><code>graph</code></em> is the empty or null graph,
        i.e. the graph with zero vertices and edges. (4) The vector
        <em class="parameter"><code>quantities</code></em> sums to zero.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n) where n is the number of vertices in the perspective
to consider. If we consider the global perspective, then n is the number
of vertices in the vertex set of <em class="parameter"><code>graph</code></em>. On the other hand, for the local
perspective n is the degree of <em class="parameter"><code>vid</code></em>, excluding loops.

</p>
<p>
Reference:
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><code class="constant">(Yu &amp; Gen 2010)</code></span></p></td>
<td><p>

  X. Yu and M. Gen. <span class="emphasis"><em> Introduction to Evolutionary Algorithms. </em></span>
  Springer, 2010, pages 18--20.

</p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.11.2.4.9.2"></a><p class="title"><b>Example 10.2.  File <code class="code">examples/simple/igraph_roulette_wheel_imitation.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>  Test suite for stochastic imitation via roulette wheel selection.</em></span>
<span class="emphasis"><em>  Copyright (C) 2011 Minh Van Nguyen </em></span>&lt;nguyenminh2@gmail.com&gt;

<span class="emphasis"><em>  This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>  it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>  the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>  (at your option) any later version.</em></span>

<span class="emphasis"><em>  This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>  but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>  GNU General Public License for more details.</em></span>

<span class="emphasis"><em>  You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>  along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>  Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>  02110-1301 USA</em></span>
<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>R_INTEGER</strong></span>(a,b) (<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_get_integer" title="4.1. igraph_rng_get_integer — Generate an integer random number from an interval.">igraph_rng_get_integer</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), (a), (b)))

<span class="emphasis"><em>/* test parameters structure */</em></span>
<span class="strong"><strong>typedef</strong></span> <span class="strong"><strong>struct</strong></span> {
    igraph_t *graph;
    igraph_integer_t vertex;
    igraph_bool_t islocal;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *quantities;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *strategies;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *known_strats;
    igraph_neimode_t mode;
    int retval;
} strategy_test_t;

<span class="emphasis"><em>/* Error tests. That is, we expect error codes to be returned from such tests.</em></span>
<span class="emphasis"><em> */</em></span>
int <span class="strong"><strong>error_tests</strong></span>() {
    igraph_t g, gzero, h;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> quant, quantzero, strat, stratzero;
    int i, n, nvert, ret;
    strategy_test_t *test;

    <span class="emphasis"><em>/* nonempty graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, <span class="emphasis"><em>/*nvert=*/</em></span> 0, IGRAPH_UNDIRECTED, 0, 1, 1, 2, 2, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_empty" title="3.1.1. igraph_empty — Creates an empty graph with some vertices and no edges.">igraph_empty</a></strong></span>(&amp;h, 0, 0);         <span class="emphasis"><em>/* empty graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;quant, 1);  <span class="emphasis"><em>/* quantities vector */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;strat, 2);  <span class="emphasis"><em>/* strategies vector */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;gzero, <span class="emphasis"><em>/*nvert=*/</em></span> 0, IGRAPH_UNDIRECTED,
                 0, 3, 0, 4, 1, 2, 1, 4, 1, 5, 2, 3, 2, 4, 3, 4, -1);
    nvert = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="3.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;gzero);
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;stratzero, nvert, 1.0, 0.0, 1.0, 2.0, 0.0, 3.0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;quantzero, nvert);  <span class="emphasis"><em>/* vector of zeros */</em></span>

    <span class="emphasis"><em>/* test parameters */</em></span>
    <span class="emphasis"><em>/*graph--vert--islocal--quantities--strategies--known_strats--mode--retval*/</em></span>
    <span class="emphasis"><em>/* null pointer for graph */</em></span>
    strategy_test_t null_graph = {NULL, 0, 1, NULL, NULL, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    <span class="emphasis"><em>/* null pointer for quantities vector */</em></span>
    strategy_test_t null_quant = {&amp;g, 0, 1, NULL, NULL, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    <span class="emphasis"><em>/* null pointer for strategies vector */</em></span>
    strategy_test_t null_strat = {&amp;g, 0, 1, &amp;quant, NULL, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    <span class="emphasis"><em>/* empty graph */</em></span>
    strategy_test_t empty_graph = {&amp;h, 0, 1, &amp;quant, &amp;strat, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    <span class="emphasis"><em>/* length of quantities vector different from number of vertices */</em></span>
    strategy_test_t qdiff_length = {&amp;g, 0, 1, &amp;quant, &amp;strat, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    <span class="emphasis"><em>/* length of strategies vector different from number of vertices */</em></span>
    strategy_test_t sdiff_length = {&amp;g, 0, 1, &amp;quant, &amp;strat, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    <span class="emphasis"><em>/* quantities vector contains all zeros */</em></span>
    strategy_test_t zero_quant = {&amp;gzero, 4, 1, &amp;quantzero, &amp;stratzero, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    strategy_test_t *all_checks[] = {<span class="emphasis"><em>/* 1 */</em></span> &amp;null_graph,
                                             <span class="emphasis"><em>/* 2 */</em></span> &amp;null_quant,
                                             <span class="emphasis"><em>/* 3 */</em></span> &amp;null_strat,
                                             <span class="emphasis"><em>/* 4 */</em></span> &amp;empty_graph,
                                             <span class="emphasis"><em>/* 5 */</em></span> &amp;qdiff_length,
                                             <span class="emphasis"><em>/* 6 */</em></span> &amp;sdiff_length,
                                             <span class="emphasis"><em>/* 7 */</em></span> &amp;zero_quant
                                    };

    <span class="emphasis"><em>/* Run the error tests. We expect error to be raised for each test. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(<a class="link" href="igraph-Error.html#igraph_error_handler_ignore" title="2.3. igraph_error_handler_ignore — Ignore errors.">igraph_error_handler_ignore</a>);
    n = 7;
    i = 0;
    <span class="strong"><strong>while</strong></span> (i &lt; n) {
        test = all_checks[i];
        ret = <span class="strong"><strong><a class="link" href="igraph-Spatial-Games.html#igraph_roulette_wheel_imitation" title="1.3. igraph_roulette_wheel_imitation — Adopt a strategy via roulette wheel selection.">igraph_roulette_wheel_imitation</a></strong></span>(test-&gt;graph, test-&gt;vertex,
                                              test-&gt;islocal, test-&gt;quantities,
                                              test-&gt;strategies, test-&gt;mode);
        <span class="strong"><strong>if</strong></span> (ret != test-&gt;retval) {
            <span class="strong"><strong>printf</strong></span>("Error test no. %d failed.\n", (int)(i + 1));
            <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
        }
        i++;
    }
    <span class="emphasis"><em>/* clean up */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;gzero);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;h);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;quant);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;quantzero);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;strat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;stratzero);

    <span class="strong"><strong>return</strong></span> IGRAPH_SUCCESS;
}

<span class="emphasis"><em>/* A game on a graph with 5 vertices and 7 edges. Use roulette wheel selection</em></span>
<span class="emphasis"><em> * to update strategies. This example also illustrates how a choice of</em></span>
<span class="emphasis"><em> * perspective (whether local or global) could affect the range of</em></span>
<span class="emphasis"><em> * possible strategies a vertex could adopt.</em></span>
<span class="emphasis"><em> */</em></span>
int <span class="strong"><strong>roulette_test</strong></span>() {
    igraph_t g;
    igraph_bool_t success;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *known, quant, strat, stratcopy;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> known0, known1, known2, known3, known4, known5;
    int i, k, n, nvert, ret;;
    strategy_test_t *test;

    <span class="emphasis"><em>/* the game network */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, <span class="emphasis"><em>/*nvert=*/</em></span> 0, IGRAPH_UNDIRECTED,
                 0, 3, 0, 4, 1, 2, 1, 4, 1, 5, 2, 3, 2, 4, 3, 4, -1);
    nvert = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="3.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g);
    <span class="emphasis"><em>/* strategies vector; the strategy space is {0, 1, 2, 3} */</em></span>
    <span class="emphasis"><em>/* V[i] is strategy of vertex i */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;strat, nvert, 1.0, 0.0, 1.0, 2.0, 0.0, 3.0);
    <span class="emphasis"><em>/* quantities vector; V[i] is quantity of vertex i */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;quant, nvert, 0.56, 0.13, 0.26, 0.73, 0.67, 0.82);
    <span class="emphasis"><em>/* possible strategies each vertex can adopt */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;known0, <span class="emphasis"><em>/*n=*/</em></span> 3, 0.0, 1.0, 2.0);       <span class="emphasis"><em>/* local */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;known1, <span class="emphasis"><em>/*n=*/</em></span> 3, 0.0, 1.0, 3.0);       <span class="emphasis"><em>/* local */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;known2, <span class="emphasis"><em>/*n=*/</em></span> 3, 0.0, 1.0, 2.0);       <span class="emphasis"><em>/* local */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;known3, <span class="emphasis"><em>/*n=*/</em></span> 3, 0.0, 1.0, 2.0);       <span class="emphasis"><em>/* local */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;known4, <span class="emphasis"><em>/*n=*/</em></span> 3, 0.0, 1.0, 2.0);       <span class="emphasis"><em>/* local */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;known5, <span class="emphasis"><em>/*n=*/</em></span> 4, 0.0, 1.0, 2.0, 3.0);  <span class="emphasis"><em>/* global */</em></span>

    <span class="emphasis"><em>/* test parameters */</em></span>
    <span class="emphasis"><em>/*graph--vert--islocal--quantities--strategies--known_strats--mode-retval*/</em></span>
    strategy_test_t game0 = {&amp;g, 0, 1, &amp;quant, NULL, &amp;known0, IGRAPH_ALL, IGRAPH_SUCCESS};
    strategy_test_t game1 = {&amp;g, 1, 1, &amp;quant, NULL, &amp;known1, IGRAPH_ALL, IGRAPH_SUCCESS};
    strategy_test_t game2 = {&amp;g, 2, 1, &amp;quant, NULL, &amp;known2, IGRAPH_ALL, IGRAPH_SUCCESS};
    strategy_test_t game3 = {&amp;g, 3, 1, &amp;quant, NULL, &amp;known3, IGRAPH_ALL, IGRAPH_SUCCESS};
    strategy_test_t game4 = {&amp;g, 4, 1, &amp;quant, NULL, &amp;known4, IGRAPH_ALL, IGRAPH_SUCCESS};
    strategy_test_t game5 = {&amp;g, 5, 0, &amp;quant, NULL, &amp;known5, IGRAPH_ALL, IGRAPH_SUCCESS};
    strategy_test_t *all_checks[] = {<span class="emphasis"><em>/* 1 */</em></span> &amp;game0,
                                             <span class="emphasis"><em>/* 2 */</em></span> &amp;game1,
                                             <span class="emphasis"><em>/* 3 */</em></span> &amp;game2,
                                             <span class="emphasis"><em>/* 4 */</em></span> &amp;game3,
                                             <span class="emphasis"><em>/* 5 */</em></span> &amp;game4,
                                             <span class="emphasis"><em>/* 6 */</em></span> &amp;game5
                                    };

    <span class="emphasis"><em>/* play game */</em></span>
    n = 6;
    i = 0;
    <span class="strong"><strong>while</strong></span> (i &lt; n) {
        test = all_checks[i];
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_copy" title="2.2.4. igraph_vector_copy — Initializes a vector from another vector object (constructor).">igraph_vector_copy</a></strong></span>(&amp;stratcopy, &amp;strat);
        ret = <span class="strong"><strong><a class="link" href="igraph-Spatial-Games.html#igraph_roulette_wheel_imitation" title="1.3. igraph_roulette_wheel_imitation — Adopt a strategy via roulette wheel selection.">igraph_roulette_wheel_imitation</a></strong></span>(test-&gt;graph, test-&gt;vertex,
                                              test-&gt;islocal, test-&gt;quantities,
                                              &amp;stratcopy, test-&gt;mode);
        <span class="strong"><strong>if</strong></span> (ret != test-&gt;retval) {
            <span class="strong"><strong>printf</strong></span>("Test no. %d failed.\n", i + 1);
            <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
        }
        <span class="emphasis"><em>/* If the revised strategy s matches one of the candidate strategies, */</em></span>
        <span class="emphasis"><em>/* then success. If s doesn't match any of the possible strategies, then */</em></span>
        <span class="emphasis"><em>/* failure. Default to failure. */</em></span>
        success = 0;
        known = test-&gt;known_strats;
        <span class="strong"><strong>for</strong></span> (k = 0; k &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(known); k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*known)[k] == <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(stratcopy)[test-&gt;vertex]) {
                success = 1;
                <span class="strong"><strong>break</strong></span>;
            }
        }
        <span class="strong"><strong>if</strong></span> (!success) {
            <span class="strong"><strong>printf</strong></span>("Roulette wheel imitation failed for vertex %d.\n",
                   (int)test-&gt;vertex);
            <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
        }
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;stratcopy);
        i++;
    }
    <span class="emphasis"><em>/* game finished; pack up */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;known0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;known1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;known2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;known3);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;known4);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;known5);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;quant);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;strat);

    <span class="strong"><strong>return</strong></span> IGRAPH_SUCCESS;
}

<span class="emphasis"><em>/* It is possible for a vertex to retain its current strategy. This can</em></span>
<span class="emphasis"><em> * happen both in the local and global perspectives.</em></span>
<span class="emphasis"><em> */</em></span>
int <span class="strong"><strong>retain_strategy_test</strong></span>() {
    igraph_t g;
    igraph_integer_t max, min, v;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> quant, strat, stratcp;
    int i, ntry, nvert;

    <span class="emphasis"><em>/* the game network */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, <span class="emphasis"><em>/*nvert=*/</em></span> 0, IGRAPH_UNDIRECTED,
                 0, 3, 0, 4, 1, 2, 1, 4, 1, 5, 2, 3, 2, 4, 3, 4, -1);
    nvert = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="3.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g);
    <span class="emphasis"><em>/* strategies vector; the strategy space is {0, 1, 2, 3} */</em></span>
    <span class="emphasis"><em>/* V[i] is strategy of vertex i */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;strat, nvert, 1.0, 0.0, 1.0, 2.0, 0.0, 3.0);
    <span class="emphasis"><em>/* quantities vector; V[i] is quantity of vertex i */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;quant, nvert, 0.56, 0.13, 0.26, 0.73, 0.67, 0.82);

    <span class="emphasis"><em>/* random vertex */</em></span>
    min = 0;
    max = 5;
    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42); <span class="emphasis"><em>/* make tests deterministic */</em></span>
    v = <span class="strong"><strong>R_INTEGER</strong></span>(min, max);  <span class="emphasis"><em>/* min &lt;= v &lt;= max */</em></span>
    <span class="emphasis"><em>/* Ensure that it is possible for v to retain its current strategy. We */</em></span>
    <span class="emphasis"><em>/* will try to do this at most ntry times. As there are at most 6 vertices */</em></span>
    <span class="emphasis"><em>/* to choose from, it shouldn't take long before we encounter a strategy */</em></span>
    <span class="emphasis"><em>/* revision round where v retains its current strategy. */</em></span>
    <span class="emphasis"><em>/* With local perspective. */</em></span>
    i = 0;
    ntry = 100;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;stratcp, 0);
    <span class="strong"><strong>do</strong></span> {
        i++;
        <span class="strong"><strong>if</strong></span> (i &gt; ntry) {
            <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;    <span class="emphasis"><em>/* ideally this should never happen */</em></span>
        }
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;stratcp);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_copy" title="2.2.4. igraph_vector_copy — Initializes a vector from another vector object (constructor).">igraph_vector_copy</a></strong></span>(&amp;stratcp, &amp;strat);
        <span class="strong"><strong><a class="link" href="igraph-Spatial-Games.html#igraph_roulette_wheel_imitation" title="1.3. igraph_roulette_wheel_imitation — Adopt a strategy via roulette wheel selection.">igraph_roulette_wheel_imitation</a></strong></span>(&amp;g, v, <span class="emphasis"><em>/*is local?*/</em></span> 1, &amp;quant, &amp;stratcp,
                                        IGRAPH_ALL);
    } <span class="strong"><strong>while</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(stratcp)[v] != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(strat)[v]);
    <span class="emphasis"><em>/* If we get to this point, we know that there was an update round */</em></span>
    <span class="emphasis"><em>/* i &lt;= ntry as a result of which v retains its current strategy. */</em></span>
    <span class="emphasis"><em>/* Now try again, but this time with the global perspective. */</em></span>
    i = 0;
    <span class="strong"><strong>do</strong></span> {
        i++;
        <span class="strong"><strong>if</strong></span> (i &gt; ntry) {
            <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;    <span class="emphasis"><em>/* ideally this should never happen */</em></span>
        }
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;stratcp);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_copy" title="2.2.4. igraph_vector_copy — Initializes a vector from another vector object (constructor).">igraph_vector_copy</a></strong></span>(&amp;stratcp, &amp;strat);
        <span class="strong"><strong><a class="link" href="igraph-Spatial-Games.html#igraph_roulette_wheel_imitation" title="1.3. igraph_roulette_wheel_imitation — Adopt a strategy via roulette wheel selection.">igraph_roulette_wheel_imitation</a></strong></span>(&amp;g, v, <span class="emphasis"><em>/*is local?*/</em></span> 0, &amp;quant, &amp;stratcp,
                                        IGRAPH_ALL);
    } <span class="strong"><strong>while</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(stratcp)[v] != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(strat)[v]);
    <span class="emphasis"><em>/* nothing further to do, but housekeeping */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;quant);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;strat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;stratcp);

    <span class="strong"><strong>return</strong></span> IGRAPH_SUCCESS;
}

int <span class="strong"><strong>main</strong></span>() {
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 3241);

    ret = <span class="strong"><strong>error_tests</strong></span>();
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
    }
    ret = <span class="strong"><strong>roulette_test</strong></span>();
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
    }
    ret = <span class="strong"><strong>retain_strategy_test</strong></span>();
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
    }

    <span class="strong"><strong>return</strong></span> IGRAPH_SUCCESS;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_stochastic_imitation"></a>1.4. <code class="function">igraph_stochastic_imitation</code> —  Adopt a strategy via stochastic imitation with uniform selection.</h3></div></div></div>
<a class="indexterm" name="id-1.11.2.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_stochastic_imitation(const igraph_t *graph,
                                igraph_integer_t vid,
                                igraph_imitate_algorithm_t algo,
                                const igraph_vector_t *quantities,
                                igraph_vector_t *strategies,
                                igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




A simple stochastic imitation strategy where a vertex revises its
strategy to that of a vertex chosen uniformly at random from its local
neighbourhood. This is called stochastic imitation via uniform selection,
where the strategy to imitate is chosen via some random process. For the
purposes of this function, we use uniform selection from a pool of
candidates.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object representing the game network. This cannot
       be the empty or trivial graph, but must have at least two vertices
       and one edge. If <em class="parameter"><code>graph</code></em> has one vertex, then no strategy update
       would take place. Furthermore, if <em class="parameter"><code>graph</code></em> has at least two vertices
       but zero edges, then strategy update would also not take place.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vid</code></em>:</span></p></td>
<td><p>
  The vertex whose strategy is to be updated. It is assumed that
       <em class="parameter"><code>vid</code></em> represents a vertex in <em class="parameter"><code>graph</code></em>. No checking is performed and
       it is your responsibility to ensure that <em class="parameter"><code>vid</code></em> is indeed a vertex
       of <em class="parameter"><code>graph</code></em>. If an isolated vertex is provided, i.e. the input
       vertex has degree 0, then no strategy update would take place and
       <em class="parameter"><code>vid</code></em> would retain its current strategy. Strategy update would also
       not take place if the local neighbourhood of <em class="parameter"><code>vid</code></em> are its
       in-neighbours (respectively out-neighbours), but <em class="parameter"><code>vid</code></em> has zero
       in-neighbours (respectively out-neighbours). Loops are ignored in
       computing the degree (in, out, all) of <em class="parameter"><code>vid</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td>
<p>
  This flag controls which algorithm to use in stochastic
       imitation. Supported values are:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IMITATE_AUGMENTED</code></span></p></td>
<td><p>

         Augmented imitation. Vertex <em class="parameter"><code>vid</code></em> imitates the strategy of the
         chosen vertex u provided that doing so would increase the
         quantity (e.g. fitness) of <em class="parameter"><code>vid</code></em>. Augmented imitation can be
         thought of as "imitate if better".
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IMITATE_BLIND</code></span></p></td>
<td><p>

         Blind imitation. Vertex <em class="parameter"><code>vid</code></em> blindly imitates the strategy of
         the chosen vertex u, regardless of whether doing so would
         increase or decrease the quantity of <em class="parameter"><code>vid</code></em>.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IMITATE_CONTRACTED</code></span></p></td>
<td><p>

         Contracted imitation. Here vertex <em class="parameter"><code>vid</code></em> imitates the strategy of
         the chosen vertex u if doing so would decrease the quantity of
         <em class="parameter"><code>vid</code></em>. Think of contracted imitation as "imitate if worse".
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>quantities</code></em>:</span></p></td>
<td><p>
  A vector of quantities providing the quantity of each
       vertex in <em class="parameter"><code>graph</code></em>. Think of each entry of the vector as being
       generated by a function such as the fitness function for the game.
       So if the vector represents fitness quantities, then each vector
       entry is the fitness of some vertex. The length of this vector must
       be the same as the number of vertices in the vertex set of <em class="parameter"><code>graph</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>strategies</code></em>:</span></p></td>
<td><p>
  A vector of the current strategies for the vertex
       population. The updated strategy for <em class="parameter"><code>vid</code></em> would be stored here.
       Each strategy is identified with a nonnegative integer, whose
       interpretation depends on the payoff matrix of the game. Generally
       we use the strategy ID as a row or column index of the payoff
       matrix. The length of this vector must be the same as the number of
       vertices in the vertex set of <em class="parameter"><code>graph</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  Defines the sort of neighbourhood to consider for <em class="parameter"><code>vid</code></em>. If
       <em class="parameter"><code>graph</code></em> is undirected, then we use all the immediate neighbours of
       <em class="parameter"><code>vid</code></em>. Thus if you know that <em class="parameter"><code>graph</code></em> is undirected, then it is safe
       to pass the value <em class="parameter"><code>IGRAPH_ALL</code></em> here. Supported values are:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         Use the out-neighbours of <em class="parameter"><code>vid</code></em>. This option is only relevant
         when <em class="parameter"><code>graph</code></em> is a directed graph.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         Use the in-neighbours of <em class="parameter"><code>vid</code></em>. Again this option is only relevant
         when <em class="parameter"><code>graph</code></em> is a directed graph.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         Use both the in- and out-neighbours of <em class="parameter"><code>vid</code></em>. This option is only
         relevant if <em class="parameter"><code>graph</code></em> is a digraph. Also use this value if
         <em class="parameter"><code>graph</code></em> is undirected.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The error code <em class="parameter"><code>IGRAPH_EINVAL</code></em> is returned in each of the following
        cases: (1) Any of the parameters <em class="parameter"><code>graph</code></em>, <em class="parameter"><code>quantities</code></em>, or
        <em class="parameter"><code>strategies</code></em> is a null pointer. (2) The vector <em class="parameter"><code>quantities</code></em> or
        <em class="parameter"><code>strategies</code></em> has a length different from the number of vertices
        in <em class="parameter"><code>graph</code></em>. (3) The parameter <em class="parameter"><code>graph</code></em> is the empty or null graph,
        i.e. the graph with zero vertices and edges. (4) The parameter
        <em class="parameter"><code>algo</code></em> refers to an unsupported stochastic imitation algorithm.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the uniform random number generator, but should
usually be O(1).

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.11.2.5.8.1"></a><p class="title"><b>Example 10.3.  File <code class="code">examples/simple/igraph_stochastic_imitation.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>  Test suite for stochastic imitation via uniform selection.</em></span>
<span class="emphasis"><em>  Copyright (C) 2011 Minh Van Nguyen </em></span>&lt;nguyenminh2@gmail.com&gt;

<span class="emphasis"><em>  This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>  it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>  the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>  (at your option) any later version.</em></span>

<span class="emphasis"><em>  This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>  but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>  GNU General Public License for more details.</em></span>

<span class="emphasis"><em>  You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>  along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>  Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>  02110-1301 USA</em></span>
<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

<span class="emphasis"><em>/* test parameters structure */</em></span>
<span class="strong"><strong>typedef</strong></span> <span class="strong"><strong>struct</strong></span> {
    igraph_t *graph;
    igraph_integer_t vertex;
    igraph_imitate_algorithm_t algo;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *quantities;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *strategies;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *known_strats;
    igraph_neimode_t mode;
    int retval;
} strategy_test_t;

<span class="emphasis"><em>/* Error tests. That is, we expect error codes to be returned from such tests.</em></span>
<span class="emphasis"><em> */</em></span>
int <span class="strong"><strong>error_tests</strong></span>() {
    igraph_t g, h;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> quant, strat;
    int i, n, ret;
    strategy_test_t *test;

    <span class="emphasis"><em>/* nonempty graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, <span class="emphasis"><em>/*n vertices*/</em></span> 0, IGRAPH_UNDIRECTED, 0, 1, 1, 2, 2, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_empty" title="3.1.1. igraph_empty — Creates an empty graph with some vertices and no edges.">igraph_empty</a></strong></span>(&amp;h, 0, 0);         <span class="emphasis"><em>/* empty graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;quant, 1);  <span class="emphasis"><em>/* quantities vector */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;strat, 2);  <span class="emphasis"><em>/* strategies vector */</em></span>

    <span class="emphasis"><em>/* test parameters */</em></span>
    <span class="emphasis"><em>/*graph--vertex--algo--quantities--strategies--known_strats--mode--retval*/</em></span>
    <span class="emphasis"><em>/* null pointer for graph */</em></span>
    strategy_test_t null_graph = {NULL, 0, IGRAPH_IMITATE_BLIND, NULL, NULL, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    <span class="emphasis"><em>/* null pointer for quantities vector */</em></span>
    strategy_test_t null_quant = {&amp;g, 0, IGRAPH_IMITATE_BLIND, NULL, NULL, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    <span class="emphasis"><em>/* null pointer for strategies vector */</em></span>
    strategy_test_t null_strat = {&amp;g, 0, IGRAPH_IMITATE_BLIND, &amp;quant, NULL, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    <span class="emphasis"><em>/* empty graph */</em></span>
    strategy_test_t empty_graph = {&amp;h, 0, IGRAPH_IMITATE_BLIND, &amp;quant, &amp;strat, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    <span class="emphasis"><em>/* length of quantities vector different from number of vertices */</em></span>
    strategy_test_t qdiff_length = {&amp;g, 0, IGRAPH_IMITATE_BLIND, &amp;quant, &amp;strat, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    <span class="emphasis"><em>/* length of strategies vector different from number of vertices */</em></span>
    strategy_test_t sdiff_length = {&amp;g, 0, IGRAPH_IMITATE_BLIND, &amp;quant, &amp;strat, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    strategy_test_t unknown_algo = {&amp;g, 0, -1, &amp;quant, &amp;strat, NULL, IGRAPH_ALL, IGRAPH_EINVAL};
    strategy_test_t *all_checks[] = {<span class="emphasis"><em>/* 1 */</em></span> &amp;null_graph,
                                             <span class="emphasis"><em>/* 2 */</em></span> &amp;null_quant,
                                             <span class="emphasis"><em>/* 3 */</em></span> &amp;null_strat,
                                             <span class="emphasis"><em>/* 4 */</em></span> &amp;empty_graph,
                                             <span class="emphasis"><em>/* 5 */</em></span> &amp;qdiff_length,
                                             <span class="emphasis"><em>/* 6 */</em></span> &amp;sdiff_length,
                                             <span class="emphasis"><em>/* 7 */</em></span> &amp;unknown_algo
                                    };
    <span class="emphasis"><em>/* Run the error tests. We expect error to be raised for each test. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(<a class="link" href="igraph-Error.html#igraph_error_handler_ignore" title="2.3. igraph_error_handler_ignore — Ignore errors.">igraph_error_handler_ignore</a>);
    n = 7;
    i = 0;
    <span class="strong"><strong>while</strong></span> (i &lt; n) {
        test = all_checks[i];
        ret = <span class="strong"><strong><a class="link" href="igraph-Spatial-Games.html#igraph_stochastic_imitation" title="1.4. igraph_stochastic_imitation — Adopt a strategy via stochastic imitation with uniform selection.">igraph_stochastic_imitation</a></strong></span>(test-&gt;graph, test-&gt;vertex, test-&gt;algo,
                                          test-&gt;quantities, test-&gt;strategies,
                                          test-&gt;mode);
        <span class="strong"><strong>if</strong></span> (ret != test-&gt;retval) {
            <span class="strong"><strong>printf</strong></span>("Error test no. %d failed.\n", (int)(i + 1));
            <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
        }
        i++;
    }
    <span class="emphasis"><em>/* clean up */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;h);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;quant);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;strat);

    <span class="strong"><strong>return</strong></span> IGRAPH_SUCCESS;
}

<span class="emphasis"><em>/* Updating the strategy of an isolated vertex. In this case, the strategies</em></span>
<span class="emphasis"><em> * vector should not change at all.</em></span>
<span class="emphasis"><em> */</em></span>
int <span class="strong"><strong>isolated_vertex_test</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> quant, strat, v;
    int i, ret;

    <span class="emphasis"><em>/* graph with one isolated vertex */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, <span class="emphasis"><em>/*n vertices*/</em></span> 0, IGRAPH_UNDIRECTED, 0, 1, 1, 2, 2, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_add_vertices" title="3.3.3. igraph_add_vertices — Adds vertices to a graph.">igraph_add_vertices</a></strong></span>(&amp;g, 1, 0);  <span class="emphasis"><em>/* new vertex 3 is isolated */</em></span>
    <span class="emphasis"><em>/* quantities vector: all vertices have the same fitness */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;quant, 4, 0.25, 0.25, 0.25, 0.25);
    <span class="emphasis"><em>/* strategies vector: 0 means aggressive strategy; 1 means passive */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;strat, 4, 1.0, 0.0, 1.0, 0.0);
    <span class="emphasis"><em>/* make a copy of the original strategies vector for comparison later on */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_copy" title="2.2.4. igraph_vector_copy — Initializes a vector from another vector object (constructor).">igraph_vector_copy</a></strong></span>(&amp;v, &amp;strat);
    <span class="emphasis"><em>/* Now update strategy of vertex 3. Since this vertex is isolated, no */</em></span>
    <span class="emphasis"><em>/* strategy update would take place. The resulting strategies vector */</em></span>
    <span class="emphasis"><em>/* would be the same as it was originally. */</em></span>
    ret = <span class="strong"><strong><a class="link" href="igraph-Spatial-Games.html#igraph_stochastic_imitation" title="1.4. igraph_stochastic_imitation — Adopt a strategy via stochastic imitation with uniform selection.">igraph_stochastic_imitation</a></strong></span>(<span class="emphasis"><em>/*graph*/</em></span> &amp;g,
            <span class="emphasis"><em>/*vertex*/</em></span> 3,
            <span class="emphasis"><em>/*algorithm*/</em></span> IGRAPH_IMITATE_BLIND,
            <span class="emphasis"><em>/*quantities*/</em></span> &amp;quant,
            <span class="emphasis"><em>/*strategies*/</em></span> &amp;strat,
            <span class="emphasis"><em>/*mode*/</em></span> IGRAPH_ALL);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>printf</strong></span>("Isolated vertex test failed.\n");
        <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;strat); i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(strat)[i] != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[i]) {
            <span class="strong"><strong>printf</strong></span>("Isolated vertex test failed.\n");
            <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
        }
    }
    <span class="emphasis"><em>/* clean up */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;quant);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;strat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v);

    <span class="strong"><strong>return</strong></span> IGRAPH_SUCCESS;
}

<span class="emphasis"><em>/* A game on the Petersen graph. This graph has 10 vertices and 15 edges. The</em></span>
<span class="emphasis"><em> * Petersen graph is initialized with a default quantities vector and a</em></span>
<span class="emphasis"><em> * default strategies vector. Some vertices are chosen for strategy revision,</em></span>
<span class="emphasis"><em> * each one via a different stochastic imitation rule.</em></span>
<span class="emphasis"><em> */</em></span>
int <span class="strong"><strong>petersen_game_test</strong></span>() {
    igraph_t g;
    igraph_bool_t success;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> quant, strat, stratcopy, *knownstrats;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> known0, known2, known4;
    int i, k, n, nvert, ret;
    strategy_test_t *test;

    <span class="emphasis"><em>/* the Petersen graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, <span class="emphasis"><em>/*n vertices*/</em></span> 0, IGRAPH_UNDIRECTED,
                 0, 1, 0, 4, 0, 5, 1, 2, 1, 6, 2, 3, 2, 7, 3, 4, 3, 8, 4, 9,
                 5, 7, 5, 8, 6, 8, 6, 9, 7, 9, -1);
    nvert = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="3.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g);
    <span class="emphasis"><em>/* Strategies vector, one strategy for each vertex. Thus vec[i] is the */</em></span>
    <span class="emphasis"><em>/* strategy of vertex i. The strategy space is: {0, 1, 2, 3}. */</em></span>
    <span class="emphasis"><em>/* Each strategy should be an integer. */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;strat, nvert,
                            1.0, 1.0, 2.0, 2.0, 0.0,
                            0.0, 0.0, 1.0, 2.0, 3.0);
    <span class="emphasis"><em>/* Quantities vector, one quantity per vertex. Thus vec[i] is the */</em></span>
    <span class="emphasis"><em>/* quantity for vertex i. */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;quant, nvert,
                            0.3, 1.1, 0.5, 1.0, 0.9,
                            0.8, 0.4, 0.1, 0.7, 0.7);
    <span class="emphasis"><em>/* parameter settings and known results */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;known0, 2, 0.0, 1.0);
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;known2, 2, 1.0, 2.0);
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;known4, 2, 0.0, 2.0);
    <span class="emphasis"><em>/*graph--vertex--algo--quantities--strategies--known_strats--mode--retval*/</em></span>
    strategy_test_t blind0 = {&amp;g, 0, IGRAPH_IMITATE_BLIND, &amp;quant, NULL, &amp;known0, IGRAPH_ALL, IGRAPH_SUCCESS};
    strategy_test_t augmented4 = {&amp;g, 4, IGRAPH_IMITATE_AUGMENTED, &amp;quant, NULL, &amp;known4, IGRAPH_ALL, IGRAPH_SUCCESS};
    strategy_test_t contracted2 = {&amp;g, 2, IGRAPH_IMITATE_CONTRACTED, &amp;quant, NULL, &amp;known2, IGRAPH_ALL, IGRAPH_SUCCESS};
    strategy_test_t *all_checks[] = {<span class="emphasis"><em>/* 1 */</em></span> &amp;blind0,
                                             <span class="emphasis"><em>/* 2 */</em></span> &amp;augmented4,
                                             <span class="emphasis"><em>/* 3 */</em></span> &amp;contracted2
                                    };
    <span class="emphasis"><em>/* run the tests */</em></span>
    n = 3;
    i = 0;
    <span class="strong"><strong>while</strong></span> (i &lt; n) {
        test = all_checks[i];
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_copy" title="2.2.4. igraph_vector_copy — Initializes a vector from another vector object (constructor).">igraph_vector_copy</a></strong></span>(&amp;stratcopy, &amp;strat);
        ret = <span class="strong"><strong><a class="link" href="igraph-Spatial-Games.html#igraph_stochastic_imitation" title="1.4. igraph_stochastic_imitation — Adopt a strategy via stochastic imitation with uniform selection.">igraph_stochastic_imitation</a></strong></span>(test-&gt;graph, test-&gt;vertex, test-&gt;algo,
                                          test-&gt;quantities, &amp;stratcopy,
                                          test-&gt;mode);
        <span class="strong"><strong>if</strong></span> (ret) {
            <span class="strong"><strong>printf</strong></span>("Stochastic imitation failed for vertex %d.\n",
                   (int)test-&gt;vertex);
            <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
        }
        <span class="emphasis"><em>/* If the updated strategy for the vertex matches one of the known */</em></span>
        <span class="emphasis"><em>/* strategies, then success. Default to failure. */</em></span>
        success = 0;
        knownstrats = test-&gt;known_strats;
        <span class="strong"><strong>for</strong></span> (k = 0; k &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(knownstrats); k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*knownstrats)[k] == <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(stratcopy)[test-&gt;vertex]) {
                success = 1;
                <span class="strong"><strong>break</strong></span>;
            }
        }
        <span class="strong"><strong>if</strong></span> (!success) {
            <span class="strong"><strong>printf</strong></span>("Stochastic imitation failed for vertex %d.\n",
                   (int)test-&gt;vertex);
            <span class="strong"><strong>return</strong></span> IGRAPH_FAILURE;
        }
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;stratcopy);
        i++;
    }
    <span class="emphasis"><em>/* clean up */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;known0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;known2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;known4);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;quant);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;strat);

    <span class="strong"><strong>return</strong></span> IGRAPH_SUCCESS;
}

int <span class="strong"><strong>main</strong></span>() {
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 547612);

    ret = <span class="strong"><strong>error_tests</strong></span>();
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> ret;
    }
    ret = <span class="strong"><strong>isolated_vertex_test</strong></span>();
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> ret;
    }
    ret = <span class="strong"><strong>petersen_game_test</strong></span>();
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> ret;
    }

    <span class="strong"><strong>return</strong></span> IGRAPH_SUCCESS;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="epidemic-models"></a>2. Epidemic models</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Spatial-Games.html#igraph_sir">2.1. <code class="function">igraph_sir</code> —  Performs a number of SIR epidemics model runs on a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Spatial-Games.html#igraph_sir_t">2.2. <code class="function">igraph_sir_t</code> —  The result of one SIR model simulation.</a></span></dt>
<dt><span class="section"><a href="igraph-Spatial-Games.html#igraph_sir_destroy">2.3. <code class="function">igraph_sir_destroy</code> —  Deallocates memory associated with a SIR simulation run.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_sir"></a>2.1. <code class="function">igraph_sir</code> —  Performs a number of SIR epidemics model runs on a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.11.3.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sir(const igraph_t *graph, igraph_real_t beta,
               igraph_real_t gamma, igraph_integer_t no_sim,
               igraph_vector_ptr_t *result);
</pre></div>
<p>
</p>
<p>



The SIR model is a simple model from epidemiology. The individuals
of the population might be in three states: susceptible, infected
and recovered. Recovered people are assumed to be immune to the
disease. Susceptibles become infected with a rate that depends on
their number of infected neigbors. Infected people become recovered
with a constant rate. See these parameters below.

</p>
<p>
This function runs multiple simulations, all starting with a
single uniformly randomly chosen infected individual. A simulation
is stopped when no infected individuals are left.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph to perform the model on. For directed graphs
       edge directions are ignored and a warning is given.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>beta</code></em>:</span></p></td>
<td><p>
  The rate of infection of an individual that is
       susceptible and has a single infected neighbor.
       The infection rate of a susceptible individual with n
       infected neighbors is n times beta. Formally
       this is the rate parameter of an exponential distribution.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>gamma</code></em>:</span></p></td>
<td><p>
  The rate of recovery of an infected individual.
       Formally, this is the rate parameter of an exponential
       distribution.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no_sim</code></em>:</span></p></td>
<td><p>
  The number of simulation runs to perform.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  The result of the simulation is stored here,
       in a list of <a class="link" href="igraph-Spatial-Games.html#igraph_sir_t" title="2.2. igraph_sir_t — The result of one SIR model simulation."><code class="function">igraph_sir_t</code></a> objects. To deallocate
       memory, the user needs to call <a class="link" href="igraph-Spatial-Games.html#igraph_sir_destroy" title="2.3. igraph_sir_destroy — Deallocates memory associated with a SIR simulation run."><code class="function">igraph_sir_destroy</code></a> on
       each element, before destroying the pointer vector itself
       using <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy_all" title="2.16.5. igraph_vector_ptr_destroy_all — Frees all the elements and destroys the pointer vector."><code class="function">igraph_vector_ptr_destroy_all()</code></a>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(no_sim * (|V| + |E| log(|V|))).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_sir_t"></a>2.2. <code class="function">igraph_sir_t</code> —  The result of one SIR model simulation.</h3></div></div></div>
<a class="indexterm" name="id-1.11.3.3.2"></a><p>
</p>
<pre class="programlisting">
typedef struct igraph_sir_t {
    igraph_vector_t times;
    igraph_vector_int_t no_s, no_i, no_r;
} igraph_sir_t;
</pre>
<p>
</p>
<p>
</p>
<p>Data structure to store the results of one simulation
of the SIR (susceptible-infected-recovered) model on a graph.

It has the following members. They are all (real or integer)
vectors, and they are of the same length.

</p>
<p><b>Values: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">times</code>:</span></p></td>
<td><p>
  A vector, the times of the events are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">no_s</code>:</span></p></td>
<td><p>
  An integer vector, the number of susceptibles in
             each time step is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">no_i</code>:</span></p></td>
<td><p>
  An integer vector, the number of infected individuals
             at each time step, is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">no_r</code>:</span></p></td>
<td><p>
  An integer vector, the number of recovered individuals
             is stored here at each time step.</p></td>
</tr>
</tbody>
</table></div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_sir_destroy"></a>2.3. <code class="function">igraph_sir_destroy</code> —  Deallocates memory associated with a SIR simulation run.</h3></div></div></div>
<a class="indexterm" name="id-1.11.3.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_sir_destroy(igraph_sir_t *sir);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>sir</code></em>:</span></p></td>
<td><p>
  The <a class="link" href="igraph-Spatial-Games.html#igraph_sir_t" title="2.2. igraph_sir_t — The result of one SIR model simulation."><code class="function">igraph_sir_t</code></a> object storing the simulation.</p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
</div>
</div>
<table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Generators.html"><b>← Chapter 9. Graph generators</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Iterators.html"><b>Chapter 11. Vertex and edge selectors and sequences, iterators →</b></a></td>
</tr></table>


      </div>
    </div>
  </div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	      &copy; 2003 &ndash; 2025 The igraph core team.
        &bull; Code licensed under <a href="http://www.gnu.org/licenses/gpl-2.0.html"> GNU GPL 2</a> or later,
        documentation under <a href="http://www.gnu.org/copyleft/fdl.html">GNU FDL</a>.
      </p>
      <p class="social">
        <a href="https://twitter.com/igraph2"><i class="fa-brands fa-twitter"></i></a>
        <a rel="me" href="https://fosstodon.org/@igraph"><i class="fa-brands fa-mastodon"></i></a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'c', 'html/');
    </script>





    
  </body>
</html>
