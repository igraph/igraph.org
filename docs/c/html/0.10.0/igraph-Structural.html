




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>igraph Reference Manual</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-1392972-5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-1392972-5');
    </script>

    <link href="/css/manual.css" rel="stylesheet">
<script async src="https://cse.google.com/cse.js?cx=003494361702844740117:dlnifinshhm"></script>

  </head>

  <body class="cc">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/c">igraph library</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            0.10.0
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="/r">igraph R package</a>
              <a class="dropdown-item" href="/python">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">igraph Reference Manual</h1>
        <p class="lead">For using the igraph C library</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container search-box-container">
  <div class="row">
    <div class="col-md-12 d-flex flex-row align-items-middle">
      <div class="search-label">Search the manual:</div>
	  <div style="flex: 1; margin: -1em 0 -1em 0"><div class="gcse-search" data-personalizedAds="false"></div></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="bs-docs-section">
        
<div class="navigation-header mb-4" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-light" href="igraph-Attributes.html"><i class="fa fa-chevron-left"></i>
              Previous
            </a><a accesskey="h" class="btn btn-light" href="index.html"><i class="fa fa-home"></i>
              Home
            </a><a accesskey="n" class="btn btn-light" href="igraph-Cycles.html"><i class="fa fa-chevron-right"></i>
              Next
            </a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Structural"></a>Chapter 13. Structural properties of graphs</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#basic-properties">1. Basic properties</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#Sparsifiers">2. Sparsifiers</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#shortest-path-related-functions">3. (Shortest)-path related functions</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#widest-path-related-functions">4. Widest-path related functions</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#efficiency-measures">5. Efficiency measures</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#neighborhood-of-a-vertex">6. Neighborhood of a vertex</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#local-scan-statistics">7. Local scan statistics</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#graph-components">8. Graph components</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#degree-sequences">9. Degree sequences</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#centrality-measures">10. Centrality measures</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#range-limited-centrality-measures">11. Range-limited centrality measures</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#subset-limited-centrality-measures">12. Subset-limited Centrality Measures</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#centralization">13. Centralization</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#similarity-measures">14. Similarity measures</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#trees">15. Trees and forests</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#transitivity-or-clustering-coefficient">16. Transitivity or clustering coefficient</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#directedness-conversion">17. Directedness conversion</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#spectral-properties">18. Spectral properties</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#non-simple-graphs-multiple-and-loop-edges">19. Non-simple graphs: Multiple and loop edges</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#mixing-patterns">20. Mixing patterns</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#k-cores">21. K-Cores and K-Trusses</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#topological-sorting-directed-acyclic-graphs">22. Topological sorting, directed acyclic graphs</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#maximum-cardinality-search-chordal-graphs">23. Maximum cardinality search and chordal graphs</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#matchings">24. Matchings</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#unfolding-a-graph-into-a-tree">25. Unfolding a graph into a tree</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#other-operations">26. Other operations</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#structural-properties-deprecated">27. Deprecated functions</a></span></dt>
</dl></div>
<p>These functions usually calculate some structural property
of a graph, like its diameter, the degree of the nodes, etc.</p>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="basic-properties"></a>1. Basic properties</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Structural.html#igraph_are_connected">1.1. <code class="function">igraph_are_connected</code> —  Decides whether two vertices are connected.</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_are_connected"></a>1.1. <code class="function">igraph_are_connected</code> —  Decides whether two vertices are connected.</h3></div></div></div>
<a class="indexterm" name="id-1.14.3.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_are_connected(const igraph_t *graph,
                         igraph_integer_t v1, igraph_integer_t v2,
                         igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v1</code></em>:</span></p></td>
<td><p>
  The first vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v2</code></em>:</span></p></td>
<td><p>
  The second vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Boolean, <code class="constant">true</code> if there is an edge from
        <em class="parameter"><code>v1</code></em> to <em class="parameter"><code>v2</code></em>, <code class="constant">false</code> otherwise.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The error code <code class="constant">IGRAPH_EINVVID</code> is returned if an invalid
        vertex ID is given.
  </p></td>
</tr></tbody>
</table></div>
<p>

The function is of course symmetric for undirected graphs.

</p>
<p>
Time complexity: O( min(log(d1), log(d2)) ),
d1 is the (out-)degree of <em class="parameter"><code>v1</code></em> and d2 is the (in-)degree of <em class="parameter"><code>v2</code></em>.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="Sparsifiers"></a>2. Sparsifiers</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Structural.html#igraph_spanner">2.1. <code class="function">igraph_spanner</code> —  Calculates a spanner of a graph with a given stretch factor.</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_spanner"></a>2.1. <code class="function">igraph_spanner</code> —  Calculates a spanner of a graph with a given stretch factor.</h3></div></div></div>
<a class="indexterm" name="id-1.14.4.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_spanner(const igraph_t *graph, igraph_vector_int_t *spanner,
        igraph_real_t stretch, const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>




A spanner of a graph G = (V,E) with a stretch t is a subgraph
H = (V,Es) such that Es is a subset of E and the distance
between any pair of nodes in H is at most t times the distance
in G. The returned graph is always a spanner of the
given graph with the specified stretch. For weighted graphs the
number of edges in the spanner is O(k * n^(1 + 1 / k)), where k is
k = (stretch + 1) / 2,  m is the number of edges and n is the number
of nodes in G. For unweighted graphs the number of edges is
O(n^(1 + 1 / k) + kn).

</p>
<p>
This function is based on the algorithm of Baswana and Sen: "A Simple and
Linear Time Randomized Algorithm for Computing Sparse Spanners in
Weighted Graphs"

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  An undirected connected graph object. If the graph
       is directed, the directions of the edges will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>spanenr</code></em>:</span></p></td>
<td><p>
  An initialized vector, the IDs of the edges that constitute
       the calculated spanner will be returned here. Use
       <a class="link" href="igraph-Operators.html#igraph_subgraph_edges" title="3.6. igraph_subgraph_edges — Creates a subgraph with the specified edges and their endpoints."><code class="function">igraph_subgraph_edges()</code></a> to extract the spanner as a separate
       graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>stretch</code></em>:</span></p></td>
<td><p>
  The stretch factor of the spanner.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights or NULL.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr></tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: The algorithm is a randomized Las Vegas algorithm. The expected
                 running time is O(km) where k is the value mentioned above.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="shortest-path-related-functions"></a>3. (Shortest)-path related functions</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_distances">3.1. <code class="function">igraph_distances</code> —  Length of the shortest paths between vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_distances_dijkstra">3.2. <code class="function">igraph_distances_dijkstra</code> —  Weighted shortest path lengths between vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_distances_bellman_ford">3.3. <code class="function">igraph_distances_bellman_ford</code> —  Weighted shortest path lengths between vertices, allowing negative weights.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_distances_johnson">3.4. <code class="function">igraph_distances_johnson</code> —  Weighted shortest path lengths between vertices, using Johnson's algorithm.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_shortest_paths">3.5. <code class="function">igraph_get_shortest_paths</code> —  Shortest paths from a vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_shortest_path">3.6. <code class="function">igraph_get_shortest_path</code> —  Shortest path from one vertex to another one.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra">3.7. <code class="function">igraph_get_shortest_paths_dijkstra</code> —  Weighted shortest paths from a vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_shortest_path_dijkstra">3.8. <code class="function">igraph_get_shortest_path_dijkstra</code> —  Weighted shortest path from one vertex to another one.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_shortest_paths_bellman_ford">3.9. <code class="function">igraph_get_shortest_paths_bellman_ford</code> —  Weighted shortest paths from a vertex, allowing negative weights.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_shortest_path_bellman_ford">3.10. <code class="function">igraph_get_shortest_path_bellman_ford</code> —  Weighted shortest path from one vertex to another one.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_all_shortest_paths">3.11. <code class="function">igraph_get_all_shortest_paths</code> —  All shortest paths (geodesics) from a vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_all_shortest_paths_dijkstra">3.12. <code class="function">igraph_get_all_shortest_paths_dijkstra</code> —  All weighted shortest paths (geodesics) from a vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_k_shortest_paths">3.13. <code class="function">igraph_get_k_shortest_paths</code> —  k shortest paths between two vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_all_simple_paths">3.14. <code class="function">igraph_get_all_simple_paths</code> —  List all simple paths from one source.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_average_path_length">3.15. <code class="function">igraph_average_path_length</code> —  Calculates the average unweighted shortest path length between all vertex pairs.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_average_path_length_dijkstra">3.16. <code class="function">igraph_average_path_length_dijkstra</code> —  Calculates the average weighted shortest path length between all vertex pairs.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_path_length_hist">3.17. <code class="function">igraph_path_length_hist</code> — Create a histogram of all shortest path lengths.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_diameter">3.18. <code class="function">igraph_diameter</code> —  Calculates the diameter of a graph (longest geodesic).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_diameter_dijkstra">3.19. <code class="function">igraph_diameter_dijkstra</code> —  Calculates the weighted diameter of a graph using Dijkstra's algorithm.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_girth">3.20. <code class="function">igraph_girth</code> —  The girth of a graph is the length of the shortest cycle in it.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_eccentricity">3.21. <code class="function">igraph_eccentricity</code> —  Eccentricity of some vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_eccentricity_dijkstra">3.22. <code class="function">igraph_eccentricity_dijkstra</code> —  Eccentricity of some vertices, using weighted edges.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_graph_center">3.23. <code class="function">igraph_graph_center</code> —  Central vertices of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_radius">3.24. <code class="function">igraph_radius</code> —  Radius of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_pseudo_diameter">3.25. <code class="function">igraph_pseudo_diameter</code> —  Approximation and lower bound of diameter.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_vertex_path_from_edge_path">3.26. <code class="function">igraph_vertex_path_from_edge_path</code> —  Converts a path of edge IDs to the traversed vertex IDs.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_distances"></a>3.1. <code class="function">igraph_distances</code> —  Length of the shortest paths between vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_distances(const igraph_t *graph, igraph_matrix_t *res,
                          const igraph_vs_t from, const igraph_vs_t to,
                          igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the calculation, a matrix. A pointer to an
       initialized matrix, to be more precise. The matrix will be
       resized if needed. It will have the same
       number of rows as the length of the <code class="constant">from</code>
       argument, and its number of columns is the number of
       vertices in the <code class="constant">to</code> argument. One row of the matrix shows the
       distances from/to a given vertex to the ones in <code class="constant">to</code>.
       For the unreachable vertices IGRAPH_INFINITY is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The source vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The target vertices. It is not allowed to include a
   vertex twice or more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the lengths of the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the lengths of the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for
         the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary
          data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex ID passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n(|V|+|E|)),
n is the
number of vertices to calculate, |V| and
|E| are the number of vertices and
edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="3.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a> to get the paths themselves,
<a class="link" href="igraph-Structural.html#igraph_distances_dijkstra" title="3.2. igraph_distances_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_distances_dijkstra()</code></a> for the weighted version with non-negative
weights, <a class="link" href="igraph-Structural.html#igraph_distances_bellman_ford" title="3.3. igraph_distances_bellman_ford — Weighted shortest path lengths between vertices, allowing negative weights."><code class="function">igraph_distances_bellman_ford()</code></a> if you also have negative
weights.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_distances_dijkstra"></a>3.2. <code class="function">igraph_distances_dijkstra</code> —  Weighted shortest path lengths between vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_distances_dijkstra(const igraph_t *graph,
                                   igraph_matrix_t *res,
                                   const igraph_vs_t from,
                                   const igraph_vs_t to,
                                   const igraph_vector_t *weights,
                                   igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



This function implements Dijkstra's algorithm, which can find
the weighted shortest path lengths from a source vertex to all
other vertices. This function allows specifying a set of source
and target vertices. The algorithm is run independently for each
source and the results are retained only for the specified targets.
This implementation uses a binary heap for efficiency.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, can be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result, a matrix. A pointer to an initialized matrix
   should be passed here. The matrix will be resized as needed.
   Each row contains the distances from a single source, to the
   vertices given in the <code class="constant">to</code> argument.
   Unreachable vertices has distance
   <code class="constant">IGRAPH_INFINITY</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The source vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The target vertices. It is not allowed to include a
   vertex twice or more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
   non-negative for Dijkstra's algorithm to work. Additionally, no
   edge weight may be NaN. If either case does not hold, an error
   is returned. If this is a null pointer, then the unweighted
   version, <a class="link" href="igraph-Structural.html#igraph_distances" title="3.1. igraph_distances — Length of the shortest paths between vertices."><code class="function">igraph_distances()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graphs; whether to follow paths along edge
   directions (<code class="constant">IGRAPH_OUT</code>), or the opposite (<code class="constant">IGRAPH_IN</code>), or
   ignore edge directions completely (<code class="constant">IGRAPH_ALL</code>). It is ignored
   for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(s*|E|log|E|+|V|), where |V| is the number of
vertices, |E| the number of edges and s the number of sources.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_distances" title="3.1. igraph_distances — Length of the shortest paths between vertices."><code class="function">igraph_distances()</code></a> for a (slightly) faster unweighted
version or <a class="link" href="igraph-Structural.html#igraph_distances_bellman_ford" title="3.3. igraph_distances_bellman_ford — Weighted shortest path lengths between vertices, allowing negative weights."><code class="function">igraph_distances_bellman_ford()</code></a> for a weighted
variant that works in the presence of negative edge weights (but no
negative loops)
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.5.3.10.1"></a><p class="title"><b>Example 13.1.  File <code class="code">examples/simple/dijkstra.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_real_t weights_data[] = { 0, 2, 1, 0, 5, 2, 1, 1, 0, 2, 2, 8, 1, 1, 3, 1, 1, 4, 2, 1 };
    igraph_matrix_t res;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED,
                 0, 1, 0, 2, 0, 3,    1, 2, 1, 4, 1, 5,
                 2, 3, 2, 6,         3, 2, 3, 6,
                 4, 5, 4, 7,         5, 6, 5, 8, 5, 9,
                 7, 5, 7, 8,         8, 9,
                 5, 2,
                 2, 1,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights, weights_data,
                       <span class="strong"><strong>sizeof</strong></span>(weights_data) / <span class="strong"><strong>sizeof</strong></span>(weights_data[0]));

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;res, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_distances_dijkstra" title="3.2. igraph_distances_dijkstra — Weighted shortest path lengths between vertices.">igraph_distances_dijkstra</a></strong></span>(&amp;g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                              &amp;weights, IGRAPH_OUT);
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;res);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;res);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_distances_bellman_ford"></a>3.3. <code class="function">igraph_distances_bellman_ford</code> —  Weighted shortest path lengths between vertices, allowing negative weights.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_distances_bellman_ford(const igraph_t *graph,
                                       igraph_matrix_t *res,
                                       const igraph_vs_t from,
                                       const igraph_vs_t to,
                                       const igraph_vector_t *weights,
                                       igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



This function implements the Bellman-Ford algorithm to find the weighted
shortest paths to all vertices from a single source, allowing negative weights.
It is run independently for the given sources. If there are no negative
weights, you are better off with <a class="link" href="igraph-Structural.html#igraph_distances_dijkstra" title="3.2. igraph_distances_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_distances_dijkstra()</code></a> .

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, can be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result, a matrix. A pointer to an initialized matrix
   should be passed here, the matrix will be resized if needed.
   Each row contains the distances from a single source, to all
   vertices in the graph, in the order of vertex IDs. For unreachable
   vertices the matrix contains <code class="constant">IGRAPH_INFINITY</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The source vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The target vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. There must not be any closed loop in
   the graph that has a negative total weight (since this would allow
   us to decrease the weight of any path containing at least a single
   vertex of this loop infinitely). Additionally, no edge weight may
   be NaN. If either case does not hold, an error is returned. If this
   is a null pointer, then the unweighted version,
   <a class="link" href="igraph-Structural.html#igraph_distances" title="3.1. igraph_distances — Length of the shortest paths between vertices."><code class="function">igraph_distances()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graphs; whether to follow paths along edge
   directions (<code class="constant">IGRAPH_OUT</code>), or the opposite (<code class="constant">IGRAPH_IN</code>), or
   ignore edge directions completely (<code class="constant">IGRAPH_ALL</code>). It is ignored
   for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(s*|E|*|V|), where |V| is the number of
vertices, |E| the number of edges and s the number of sources.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_distances" title="3.1. igraph_distances — Length of the shortest paths between vertices."><code class="function">igraph_distances()</code></a> for a faster unweighted version
or <a class="link" href="igraph-Structural.html#igraph_distances_dijkstra" title="3.2. igraph_distances_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_distances_dijkstra()</code></a> if you do not have negative
edge weights.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.5.4.10.1"></a><p class="title"><b>Example 13.2.  File <code class="code">examples/simple/bellman_ford.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_real_t weights_data_0[] = { 0, 2, 1, 0, 5, 2, 1, 1, 0, 2, 2, 8, 1, 1, 3, 1, 1, 4, 2, 1 };
    igraph_real_t weights_data_1[] = { 6, 7, 8, -4, -2, -3, 9, 2, 7 };
    igraph_real_t weights_data_2[] = { 6, 7, 2, -4, -2, -3, 9, 2, 7 };
    igraph_matrix_t res;

    <span class="emphasis"><em>/* Graph with only positive weights */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED,
                 0, 1, 0, 2, 0, 3,    1, 2, 1, 4, 1, 5,
                 2, 3, 2, 6,         3, 2, 3, 6,
                 4, 5, 4, 7,         5, 6, 5, 8, 5, 9,
                 7, 5, 7, 8,         8, 9,
                 5, 2,
                 2, 1,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights, weights_data_0,
                       <span class="strong"><strong>sizeof</strong></span>(weights_data_0) / <span class="strong"><strong>sizeof</strong></span>(weights_data_0[0]));

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;res, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_distances_bellman_ford" title="3.3. igraph_distances_bellman_ford — Weighted shortest path lengths between vertices, allowing negative weights.">igraph_distances_bellman_ford</a></strong></span>(&amp;g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                  &amp;weights, IGRAPH_OUT);
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;res);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;res);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="emphasis"><em>/***************************************/</em></span>

    <span class="emphasis"><em>/* Graph with negative weights */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 5, IGRAPH_DIRECTED,
                 0, 1, 0, 3, 1, 3, 1, 4, 2, 1, 3, 2, 3, 4, 4, 0, 4, 2, -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights, weights_data_1,
                       <span class="strong"><strong>sizeof</strong></span>(weights_data_1) / <span class="strong"><strong>sizeof</strong></span>(weights_data_1[0]));

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;res, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_distances_bellman_ford" title="3.3. igraph_distances_bellman_ford — Weighted shortest path lengths between vertices, allowing negative weights.">igraph_distances_bellman_ford</a></strong></span>(&amp;g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                  <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), &amp;weights, IGRAPH_OUT);
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;res);

    <span class="emphasis"><em>/***************************************/</em></span>

    <span class="emphasis"><em>/* Same graph with negative loop */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(<a class="link" href="igraph-Error.html#igraph_error_handler_ignore" title="2.3. igraph_error_handler_ignore — Ignore errors.">igraph_error_handler_ignore</a>);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights, weights_data_2,
                       <span class="strong"><strong>sizeof</strong></span>(weights_data_2) / <span class="strong"><strong>sizeof</strong></span>(weights_data_2[0]));
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_distances_bellman_ford" title="3.3. igraph_distances_bellman_ford — Weighted shortest path lengths between vertices, allowing negative weights.">igraph_distances_bellman_ford</a></strong></span>(&amp;g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                      <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                      &amp;weights, IGRAPH_OUT) != IGRAPH_ENEGLOOP) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;res);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_distances_johnson"></a>3.4. <code class="function">igraph_distances_johnson</code> —  Weighted shortest path lengths between vertices, using Johnson's algorithm.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_distances_johnson(const igraph_t *graph,
                                  igraph_matrix_t *res,
                                  const igraph_vs_t from,
                                  const igraph_vs_t to,
                                  const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>



See Wikipedia at <a class="ulink" href="http://en.wikipedia.org/wiki/Johnson's_algorithm" target="_top">http://en.wikipedia.org/wiki/Johnson's_algorithm</a>
for Johnson's algorithm. This algorithm works even if the graph
contains negative edge weights, and it is worth using it if we
calculate the shortest paths from many sources.

</p>
<p>
If no edge weights are supplied, then the unweighted
version, <a class="link" href="igraph-Structural.html#igraph_distances" title="3.1. igraph_distances — Length of the shortest paths between vertices."><code class="function">igraph_distances()</code></a> is called.

</p>
<p>
If all the supplied edge weights are non-negative,
then Dijkstra's algorithm is used by calling
<a class="link" href="igraph-Structural.html#igraph_distances_dijkstra" title="3.2. igraph_distances_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_distances_dijkstra()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. If negative weights are present, it
  should be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix, the result will be
  stored here, one line for each source vertex, one column for each
  target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The source vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The target vertices. It is not allowed to include a
  vertex twice or more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Optional edge weights. If it is a null-pointer, then
  the unweighted breadth-first search based <a class="link" href="igraph-Structural.html#igraph_distances" title="3.1. igraph_distances — Length of the shortest paths between vertices."><code class="function">igraph_distances()</code></a> will
  be called.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(s|V|log|V|+|V||E|), |V| and |E| are the number
of vertices and edges, s is the number of source vertices.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_distances" title="3.1. igraph_distances — Length of the shortest paths between vertices."><code class="function">igraph_distances()</code></a> for a faster unweighted version,
<a class="link" href="igraph-Structural.html#igraph_distances_dijkstra" title="3.2. igraph_distances_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_distances_dijkstra()</code></a> if you do not have negative
edge weights, <a class="link" href="igraph-Structural.html#igraph_distances_bellman_ford" title="3.3. igraph_distances_bellman_ford — Weighted shortest path lengths between vertices, allowing negative weights."><code class="function">igraph_distances_bellman_ford()</code></a> if you only
need to calculate shortest paths from a couple of sources.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_shortest_paths"></a>3.5. <code class="function">igraph_get_shortest_paths</code> —  Shortest paths from a vertex.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_shortest_paths(const igraph_t *graph,
                              igraph_vector_int_list_t *vertices,
                              igraph_vector_int_list_t *edges,
                              igraph_integer_t from, const igraph_vs_t to,
                              igraph_neimode_t mode,
                              igraph_vector_int_t *parents,
                              igraph_vector_int_t *inbound_edges);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If there is more than one geodesic between two vertices, this
function gives only one of them.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  The result, the IDs of the vertices along the paths.
       This is a list of integer vectors where each element is an
       <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> object. The list will be resized as needed.
       Supply a null pointer here if you don't need these vectors.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  The result, the IDs of the edges along the paths.
       This is a list of integer vectors where each element is an
       <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> object. The list will be resized as needed.
       Supply a null pointer here if you don't need these vectors.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the vertex from/to which the geodesics are
       calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Vertex sequence with the IDs of the vertices to/from which the
       shortest paths will be calculated. A vertex might be given multiple
       times.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>parents</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the parent of each vertex in
       the single source shortest path tree is returned here. The
       parent of vertex i in the tree is the vertex from which vertex i
       was reached. The parent of the start vertex (in the <code class="constant">from</code>
       argument) is -1. If the parent is -2, it means
       that the given vertex was not reached from the source during the
       search. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>inbound_edges</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the inbound edge of each vertex in
       the single source shortest path tree is returned here. The
       inbound edge of vertex i in the tree is the edge via which vertex i
       was reached. The start vertex and vertices that were not reached
       during the search will have -1 in the corresponding entry of the
       vector. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>from</code></em> is invalid vertex ID
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|),
|V| is the number of vertices,
|E| the number of edges in the
graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_distances" title="3.1. igraph_distances — Length of the shortest paths between vertices."><code class="function">igraph_distances()</code></a> if you only need the path lengths but
not the paths themselves.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.5.6.11.1"></a><p class="title"><b>Example 13.3.  File <code class="code">examples/simple/igraph_get_shortest_paths.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

int <span class="strong"><strong>check_evecs</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t *graph, <span class="strong"><strong>const</strong></span> igraph_vector_int_list_t *vecs,
                <span class="strong"><strong>const</strong></span> igraph_vector_int_list_t *evecs, int error_code) {

    igraph_bool_t directed = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="4.2.3. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(graph);
    igraph_integer_t i, n = <span class="strong"><strong>igraph_vector_int_list_size</strong></span>(vecs);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_list_size</strong></span>(evecs) != n) {
        <span class="strong"><strong>exit</strong></span>(error_code + 1);
    }

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        igraph_vector_int_t *vvec = <span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(vecs, i);
        igraph_vector_int_t *evec = <span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(evecs, i);
        igraph_integer_t j, n2 = <span class="strong"><strong>igraph_vector_int_size</strong></span>(evec);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_size</strong></span>(vvec) == 0 &amp;&amp; n2 == 0) {
            <span class="strong"><strong>continue</strong></span>;
        }
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_size</strong></span>(vvec) != n2 + 1) {
            <span class="strong"><strong>exit</strong></span>(error_code + 2);
        }
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; n2; j++) {
            igraph_integer_t edge = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*evec)[j];
            igraph_integer_t from = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vvec)[j];
            igraph_integer_t to = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vvec)[j + 1];
            <span class="strong"><strong>if</strong></span> (directed) {
                <span class="strong"><strong>if</strong></span> (from != <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(graph, edge) ||
                    to   != <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>  (graph, edge)) {
                    <span class="strong"><strong>exit</strong></span>(error_code);
                }
            } <span class="strong"><strong>else</strong></span> {
                igraph_integer_t from2 = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(graph, edge);
                igraph_integer_t to2 = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(graph, edge);
                igraph_integer_t min1 = from &lt; to ? from : to;
                igraph_integer_t max1 = from &lt; to ? to : from;
                igraph_integer_t min2 = from2 &lt; to2 ? from2 : to2;
                igraph_integer_t max2 = from2 &lt; to2 ? to2 : from2;
                <span class="strong"><strong>if</strong></span> (min1 != min2 || max1 != max2) {
                    <span class="strong"><strong>exit</strong></span>(error_code + 3);
                }
            }
        }
    }

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_vector_int_list_t vecs, evecs;
    igraph_vector_int_t parents, inbound;
    igraph_integer_t i;
    igraph_vs_t vs;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.11. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED, 0, 1);

    <span class="strong"><strong>igraph_vector_int_list_init</strong></span>(&amp;vecs, 0);
    <span class="strong"><strong>igraph_vector_int_list_init</strong></span>(&amp;evecs, 0);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;parents, 0);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;inbound, 0);

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_vector_small" title="2.7. igraph_vs_vector_small — Create a vertex set by giving its elements.">igraph_vs_vector_small</a></strong></span>(&amp;vs, 1, 3, 5, 2, 1,  -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="3.5. igraph_get_shortest_paths — Shortest paths from a vertex.">igraph_get_shortest_paths</a></strong></span>(&amp;g, &amp;vecs, &amp;evecs, 0, vs, IGRAPH_OUT, &amp;parents, &amp;inbound);

    <span class="strong"><strong>check_evecs</strong></span>(&amp;g, &amp;vecs, &amp;evecs, 10);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_list_size</strong></span>(&amp;vecs); i++) {
        <span class="strong"><strong>igraph_vector_int_print</strong></span>(<span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(&amp;vecs, i));
    }

    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;parents);
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;inbound);

    <span class="strong"><strong>igraph_vector_int_list_destroy</strong></span>(&amp;vecs);
    <span class="strong"><strong>igraph_vector_int_list_destroy</strong></span>(&amp;evecs);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;parents);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;inbound);

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_destroy" title="3.2. igraph_vs_destroy — Destroy a vertex set.">igraph_vs_destroy</a></strong></span>(&amp;vs);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_shortest_path"></a>3.6. <code class="function">igraph_get_shortest_path</code> —  Shortest path from one vertex to another one.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_shortest_path(const igraph_t *graph,
                             igraph_vector_int_t *vertices,
                             igraph_vector_int_t *edges,
                             igraph_integer_t from,
                             igraph_integer_t to,
                             igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Calculates and returns a single unweighted shortest path from a
given vertex to another one. If there are more than one shortest
paths between the two vertices, then an arbitrary one is returned.

</p>
<p>This function is a wrapper to <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="3.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a>, for the special case when only one
target vertex is considered.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or
       undirected. Directed paths are considered in directed
       graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
       pointer. If not a null pointer, then the vertex IDs along
       the path are stored here, including the source and target
       vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
       pointer. If not a null pointer, then the edge IDs along the
       path are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  A constant specifying how edge directions are
       considered in directed graphs. Valid modes are:
       <code class="constant">IGRAPH_OUT</code>, follows edge directions;
       <code class="constant">IGRAPH_IN</code>, follows the opposite directions; and
       <code class="constant">IGRAPH_ALL</code>, ignores edge directions. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="3.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a> for the version with more target
vertices.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_shortest_paths_dijkstra"></a>3.7. <code class="function">igraph_get_shortest_paths_dijkstra</code> —  Weighted shortest paths from a vertex.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_shortest_paths_dijkstra(const igraph_t *graph,
                                       igraph_vector_int_list_t *vertices,
                                       igraph_vector_int_list_t *edges,
                                       igraph_integer_t from,
                                       igraph_vs_t to,
                                       const igraph_vector_t *weights,
                                       igraph_neimode_t mode,
                                       igraph_vector_int_t *parents,
                                       igraph_vector_int_t *inbound_edges);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If there is more than one path with the smallest weight between two vertices, this
function gives only one of them.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  The result, the IDs of the vertices along the paths.
       This is a list of integer vectors where each element is an
       <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> object. The list will be resized as needed.
       Supply a null pointer here if you don't need these vectors.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  The result, the IDs of the edges along the paths.
       This is a list of integer vectors where each element is an
       <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> object. The list will be resized as needed.
       Supply a null pointer here if you don't need these vectors.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the vertex from/to which the geodesics are
       calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Vertex sequence with the IDs of the vertices to/from which the
       shortest paths will be calculated. A vertex might be given multiple
       times.
* </p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
      non-negative for Dijkstra's algorithm to work. Additionally, no
      edge weight may be NaN. If either case does not hold, an error
      is returned. If this is a null pointer, then the unweighted
      version, <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="3.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be use for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>parents</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the parent of each vertex in
       the single source shortest path tree is returned here. The
       parent of vertex i in the tree is the vertex from which vertex i
       was reached. The parent of the start vertex (in the <code class="constant">from</code>
       argument) is -1. If the parent is -2, it means
       that the given vertex was not reached from the source during the
       search. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>inbound_edges</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the inbound edge of each vertex in
       the single source shortest path tree is returned here. The
       inbound edge of vertex i in the tree is the edge via which vertex i
       was reached. The start vertex and vertices that were not reached
       during the search will have -1 in the corresponding entry of the
       vector. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>from</code></em> is invalid vertex ID
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|log|E|+|V|), where |V| is the number of
vertices and |E| is the number of edges

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_distances_dijkstra" title="3.2. igraph_distances_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_distances_dijkstra()</code></a> if you only need the path length but
not the paths themselves, <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="3.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a> if all edge
weights are equal.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.5.8.11.1"></a><p class="title"><b>Example 13.4.  File <code class="code">examples/simple/igraph_get_shortest_paths_dijkstra.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

int <span class="strong"><strong>check_evecs</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t *graph, <span class="strong"><strong>const</strong></span> igraph_vector_int_list_t *vecs,
                <span class="strong"><strong>const</strong></span> igraph_vector_int_list_t *evecs, int error_code) {

    igraph_bool_t directed = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="4.2.3. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(graph);
    igraph_integer_t i, n = <span class="strong"><strong>igraph_vector_int_list_size</strong></span>(vecs);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_list_size</strong></span>(evecs) != n) {
        <span class="strong"><strong>exit</strong></span>(error_code + 1);
    }

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        igraph_vector_int_t *vvec = <span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(vecs, i);
        igraph_vector_int_t *evec = <span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(evecs, i);
        igraph_integer_t j, n2 = <span class="strong"><strong>igraph_vector_int_size</strong></span>(evec);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_size</strong></span>(vvec) == 0 &amp;&amp; n2 == 0) {
            <span class="strong"><strong>continue</strong></span>;
        }
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_size</strong></span>(vvec) != n2 + 1) {
            <span class="strong"><strong>exit</strong></span>(error_code + 2);
        }
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; n2; j++) {
            igraph_integer_t edge = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*evec)[j];
            igraph_integer_t from = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vvec)[j];
            igraph_integer_t to = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vvec)[j + 1];
            <span class="strong"><strong>if</strong></span> (directed) {
                <span class="strong"><strong>if</strong></span> (from != <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(graph, edge) ||
                    to   != <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>  (graph, edge)) {
                    <span class="strong"><strong>exit</strong></span>(error_code);
                }
            } <span class="strong"><strong>else</strong></span> {
                igraph_integer_t from2 = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(graph, edge);
                igraph_integer_t to2 = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(graph, edge);
                igraph_integer_t min1 = from &lt; to ? from : to;
                igraph_integer_t max1 = from &lt; to ? to : from;
                igraph_integer_t min2 = from2 &lt; to2 ? from2 : to2;
                igraph_integer_t max2 = from2 &lt; to2 ? to2 : from2;
                <span class="strong"><strong>if</strong></span> (min1 != min2 || max1 != max2) {
                    <span class="strong"><strong>exit</strong></span>(error_code + 3);
                }
            }
        }
    }

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_parents_inbound</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* graph, <span class="strong"><strong>const</strong></span> igraph_vector_int_t* parents,
                       <span class="strong"><strong>const</strong></span> igraph_vector_int_t* inbound, int start, int error_code) {
    igraph_integer_t i, n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(graph);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_size</strong></span>(parents) != n ||
        <span class="strong"><strong>igraph_vector_int_size</strong></span>(inbound) != n) {
        <span class="strong"><strong>exit</strong></span>(error_code);
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*parents)[start] != -1 || <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*inbound)[start] != -1) {
        <span class="strong"><strong>printf</strong></span>("%" IGRAPH_PRId "\n", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*parents)[start]);
        <span class="strong"><strong>printf</strong></span>("%" IGRAPH_PRId "\n", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*inbound)[start]);
        <span class="strong"><strong>exit</strong></span>(error_code + 1);
    }

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*parents)[i] == -2) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*inbound)[i] != -1) {
                <span class="strong"><strong>exit</strong></span>(error_code + 2);
            }
        } <span class="strong"><strong>else</strong></span> <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*parents)[i] == -1) {
            <span class="strong"><strong>if</strong></span> (i != start) {
                <span class="strong"><strong>exit</strong></span>(error_code + 3);
            }
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*inbound)[i] != -1) {
                <span class="strong"><strong>exit</strong></span>(error_code + 4);
            }
        } <span class="strong"><strong>else</strong></span> {
            igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*inbound)[i];
            igraph_integer_t u = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(graph, eid), v = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(graph, eid);
            <span class="strong"><strong>if</strong></span> (v != i &amp;&amp; !<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="4.2.3. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(graph)) {
                igraph_integer_t dummy = u;
                u = v;
                v = dummy;
            }
            <span class="strong"><strong>if</strong></span> (v != i) {
                <span class="strong"><strong>exit</strong></span>(error_code + 5);
            } <span class="strong"><strong>else</strong></span> <span class="strong"><strong>if</strong></span> (u != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*parents)[i]) {
                <span class="strong"><strong>exit</strong></span>(error_code + 6);
            }
        }
    }

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_vector_int_list_t vecs, evecs;
    igraph_vector_int_t parents, inbound;
    igraph_integer_t i;
    igraph_real_t weights[] = { 1, 2, 3, 4, 5, 1, 1, 1, 1, 1 };
    igraph_real_t weights2[] = { 0, 2, 1, 0, 5, 2, 1, 1, 0, 2, 2, 8, 1, 1, 3, 1, 1, 4, 2, 1 };
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights_vec;
    igraph_vs_t vs;

    <span class="emphasis"><em>/* Simple ring graph without weights */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.11. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;g, 10, IGRAPH_UNDIRECTED, 0, 1);

    <span class="strong"><strong>igraph_vector_int_list_init</strong></span>(&amp;vecs, 0);
    <span class="strong"><strong>igraph_vector_int_list_init</strong></span>(&amp;evecs, 0);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;parents, 0);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;inbound, 0);

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_vector_small" title="2.7. igraph_vs_vector_small — Create a vertex set by giving its elements.">igraph_vs_vector_small</a></strong></span>(&amp;vs, 0, 1, 3, 5, 2, 1,  -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="3.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex.">igraph_get_shortest_paths_dijkstra</a></strong></span>(&amp;g, <span class="emphasis"><em>/*vertices=*/</em></span> &amp;vecs,
                                       <span class="emphasis"><em>/*edges=*/</em></span> &amp;evecs, <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                                       <span class="emphasis"><em>/*weights=*/</em></span> 0, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT,
                                       &amp;parents,
                                       <span class="emphasis"><em>/*inbound_edges=*/</em></span> &amp;inbound);

    <span class="strong"><strong>check_evecs</strong></span>(&amp;g, &amp;vecs, &amp;evecs, 10);
    <span class="strong"><strong>check_parents_inbound</strong></span>(&amp;g, &amp;parents, &amp;inbound, <span class="emphasis"><em>/* from= */</em></span> 0, 40);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_list_size</strong></span>(&amp;vecs); i++) {
        <span class="strong"><strong>igraph_vector_int_print</strong></span>(<span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(&amp;vecs, i));
    }

    <span class="emphasis"><em>/* Same ring, but with weights */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights_vec, weights, <span class="strong"><strong>sizeof</strong></span>(weights) / <span class="strong"><strong>sizeof</strong></span>(weights[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="3.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex.">igraph_get_shortest_paths_dijkstra</a></strong></span>(&amp;g, <span class="emphasis"><em>/*vertices=*/</em></span> &amp;vecs,
                                       <span class="emphasis"><em>/*edges=*/</em></span> &amp;evecs, <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                                       &amp;weights_vec, IGRAPH_OUT,
                                       &amp;parents,
                                       <span class="emphasis"><em>/*inbound_edges=*/</em></span> &amp;inbound);

    <span class="strong"><strong>check_evecs</strong></span>(&amp;g, &amp;vecs, &amp;evecs, 20);
    <span class="strong"><strong>check_parents_inbound</strong></span>(&amp;g, &amp;parents, &amp;inbound, <span class="emphasis"><em>/* from= */</em></span> 0, 50);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_list_size</strong></span>(&amp;vecs); i++) {
        <span class="strong"><strong>igraph_vector_int_print</strong></span>(<span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(&amp;vecs, i));
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* More complicated example */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED,
                 0, 1, 0, 2, 0, 3,    1, 2, 1, 4, 1, 5,
                 2, 3, 2, 6,         3, 2, 3, 6,
                 4, 5, 4, 7,         5, 6, 5, 8, 5, 9,
                 7, 5, 7, 8,         8, 9,
                 5, 2,
                 2, 1,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights_vec, weights2, <span class="strong"><strong>sizeof</strong></span>(weights2) / <span class="strong"><strong>sizeof</strong></span>(weights2[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="3.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex.">igraph_get_shortest_paths_dijkstra</a></strong></span>(&amp;g, <span class="emphasis"><em>/*vertices=*/</em></span> &amp;vecs,
                                       <span class="emphasis"><em>/*edges=*/</em></span> &amp;evecs, <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                                       &amp;weights_vec, IGRAPH_OUT,
                                       &amp;parents,
                                       <span class="emphasis"><em>/*inbound_edges=*/</em></span> &amp;inbound);

    <span class="strong"><strong>check_evecs</strong></span>(&amp;g, &amp;vecs, &amp;evecs, 30);
    <span class="strong"><strong>check_parents_inbound</strong></span>(&amp;g, &amp;parents, &amp;inbound, <span class="emphasis"><em>/* from= */</em></span> 0, 60);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_list_size</strong></span>(&amp;vecs); i++) {
        <span class="strong"><strong>igraph_vector_int_print</strong></span>(<span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(&amp;vecs, i));
    }

    <span class="strong"><strong>igraph_vector_int_list_destroy</strong></span>(&amp;vecs);
    <span class="strong"><strong>igraph_vector_int_list_destroy</strong></span>(&amp;evecs);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;parents);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;inbound);

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_destroy" title="3.2. igraph_vs_destroy — Destroy a vertex set.">igraph_vs_destroy</a></strong></span>(&amp;vs);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_shortest_path_dijkstra"></a>3.8. <code class="function">igraph_get_shortest_path_dijkstra</code> —  Weighted shortest path from one vertex to another one.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_shortest_path_dijkstra(const igraph_t *graph,
                                      igraph_vector_int_t *vertices,
                                      igraph_vector_int_t *edges,
                                      igraph_integer_t from,
                                      igraph_integer_t to,
                                      const igraph_vector_t *weights,
                                      igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Calculates a single (positively) weighted shortest path from
a single vertex to another one, using Dijkstra's algorithm.

</p>
<p>This function is a special case (and a wrapper) to
<a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="3.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex."><code class="function">igraph_get_shortest_paths_dijkstra()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
       pointer. If not a null pointer, then the vertex IDs along
       the path are stored here, including the source and target
       vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
       pointer. If not a null pointer, then the edge IDs along the
       path are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
      non-negative for Dijkstra's algorithm to work. Additionally, no
      edge weight may be NaN. If either case does not hold, an error
      is returned. If this is a null pointer, then the unweighted
      version, <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="3.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  A constant specifying how edge directions are
       considered in directed graphs. <code class="constant">IGRAPH_OUT</code> follows edge
       directions, <code class="constant">IGRAPH_IN</code> follows the opposite directions,
       and <code class="constant">IGRAPH_ALL</code> ignores edge directions. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|log|E|+|V|), |V| is the number of vertices,
|E| is the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="3.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex."><code class="function">igraph_get_shortest_paths_dijkstra()</code></a> for the version with
more target vertices.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_shortest_paths_bellman_ford"></a>3.9. <code class="function">igraph_get_shortest_paths_bellman_ford</code> —  Weighted shortest paths from a vertex, allowing negative weights.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_shortest_paths_bellman_ford(const igraph_t *graph,
                                        igraph_vector_int_list_t *vertices,
                                        igraph_vector_int_list_t *edges,
                                        igraph_integer_t from,
                                        igraph_vs_t to,
                                        const igraph_vector_t *weights,
                                        igraph_neimode_t mode,
                                        igraph_vector_int_t *parents,
                                        igraph_vector_int_t *inbound_edges);
</pre></div>
<p>
</p>
<p>




This function calculates weighted shortest paths from or to a single vertex,
and allows negative weights. When there is more than one shortest path between
two vertices, only one of them is returned.

If there are no negative weights, you are better off with
<a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="3.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex."><code class="function">igraph_get_shortest_paths_dijkstra()</code></a> .

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, can be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  The result, the IDs of the vertices along the paths.
       This is a list of integer vectors where each element is an
       <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> object. The list will be resized as needed.
       Supply a null pointer here if you don't need these vectors.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  The result, the IDs of the edges along the paths.
       This is a list of integer vectors where each element is an
       <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> object. The list will be resized as needed.
       Supply a null pointer here if you don't need these vectors.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the vertex from/to which the geodesics are
       calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Vertex sequence with the IDs of the vertices to/from which the
       shortest paths will be calculated. A vertex might be given multiple
       times.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. There must not be any closed loop in
   the graph that has a negative total weight (since this would allow
   us to decrease the weight of any path containing at least a single
   vertex of this loop infinitely). If this is a null pointer, then the
   unweighted version, <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="3.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graphs; whether to follow paths along edge
   directions (<code class="constant">IGRAPH_OUT</code>), or the opposite (<code class="constant">IGRAPH_IN</code>), or
   ignore edge directions completely (<code class="constant">IGRAPH_ALL</code>). It is ignored
   for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>parents</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the parent of each vertex in
       the single source shortest path tree is returned here. The
       parent of vertex i in the tree is the vertex from which vertex i
       was reached. The parent of the start vertex (in the <code class="constant">from</code>
       argument) is -1. If the parent is -2, it means
       that the given vertex was not reached from the source during the
       search. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>inbound_edges</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the inbound edge of each vertex in
       the single source shortest path tree is returned here. The
       inbound edge of vertex i in the tree is the edge via which vertex i
       was reached. The start vertex and vertices that were not reached
       during the search will have -1 in the corresponding entry of the
       vector. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          Not enough memory for temporary data.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

          The weight vector doesn't math the number of edges.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>from</code></em> is invalid vertex ID
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENEGLOOP</code></span></p></td>
<td><p>

          Bellman-ford algorithm encounted a negative loop.
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|*|V|), where |V| is the number of
vertices, |E| the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="3.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a> for a faster unweighted version
or <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="3.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex."><code class="function">igraph_get_shortest_paths_dijkstra()</code></a> if you do not have negative
edge weights.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_shortest_path_bellman_ford"></a>3.10. <code class="function">igraph_get_shortest_path_bellman_ford</code> —  Weighted shortest path from one vertex to another one.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_shortest_path_bellman_ford(const igraph_t *graph,
                                          igraph_vector_int_t *vertices,
                                          igraph_vector_int_t *edges,
                                          igraph_integer_t from,
                                          igraph_integer_t to,
                                          const igraph_vector_t *weights,
                                          igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Calculates a single (positively) weighted shortest path from
a single vertex to another one, using Bellman-Ford algorithm.

</p>
<p>
This function is a special case (and a wrapper) to
<a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_bellman_ford" title="3.9. igraph_get_shortest_paths_bellman_ford — Weighted shortest paths from a vertex, allowing negative weights."><code class="function">igraph_get_shortest_paths_bellman_ford()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
       pointer. If not a null pointer, then the vertex IDs along
       the path are stored here, including the source and target
       vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
       pointer. If not a null pointer, then the edge IDs along the
       path are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. There must not be any closed loop in
       the graph that has a negative total weight (since this would allow
       us to decrease the weight of any path containing at least a single
       vertex of this loop infinitely). If this is a null pointer, then the
       unweighted version is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  A constant specifying how edge directions are
       considered in directed graphs. <code class="constant">IGRAPH_OUT</code> follows edge
       directions, <code class="constant">IGRAPH_IN</code> follows the opposite directions,
       and <code class="constant">IGRAPH_ALL</code> ignores edge directions. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|log|E|+|V|), |V| is the number of vertices,
|E| is the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_bellman_ford" title="3.9. igraph_get_shortest_paths_bellman_ford — Weighted shortest paths from a vertex, allowing negative weights."><code class="function">igraph_get_shortest_paths_bellman_ford()</code></a> for the version with
more target vertices.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_all_shortest_paths"></a>3.11. <code class="function">igraph_get_all_shortest_paths</code> —  All shortest paths (geodesics) from a vertex.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_all_shortest_paths(const igraph_t *graph,
                                  igraph_vector_int_list_t *vertices,
                                  igraph_vector_int_list_t *edges,
                                  igraph_vector_int_t *nrgeo,
                                  igraph_integer_t from, const igraph_vs_t to,
                                  igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



When there is more than one shortest path between two vertices,
all of them will be returned.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  The result, the IDs of the vertices along the paths.
  This is a list of integer vectors where each element is an
  <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> object. Each vector object contains the vertices
  along a shortest path from <em class="parameter"><code>from</code></em> to another vertex. The vectors are
  ordered according to their target vertex: first the shortest paths to
  vertex 0, then to vertex 1, etc. No data is included for unreachable
  vertices. The list will be resized as needed. Supply a null pointer here
  if you don't need these vectors.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  The result, the IDs of the edges along the paths.
  This is a list of integer vectors where each element is an
  <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> object. Each vector object contains the edges
  along a shortest path from <em class="parameter"><code>from</code></em> to another vertex. The vectors are
  ordered according to their target vertex: first the shortest paths to
  vertex 0, then to vertex 1, etc. No data is included for unreachable
  vertices. The list will be resized as needed. Supply a null pointer here
  if you don't need these vectors.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nrgeo</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> object or
  <code class="constant">NULL</code>. If not <code class="constant">NULL</code> the number of shortest paths from <em class="parameter"><code>from</code></em> are
  stored here for every vertex in the graph. Note that the values
  will be accurate only for those vertices that are in the target
  vertex sequence (see <em class="parameter"><code>to</code></em>), since the search terminates as soon
  as all the target vertices have been found.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the vertex from/to which the geodesics are
       calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Vertex sequence with the IDs of the vertices to/from which the
       shortest paths will be calculated. A vertex might be given multiple
       times.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be use for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the lengths of the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the lengths of the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>from</code></em> is invalid vertex ID.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Added in version 0.2.</p>
<p>

Time complexity: O(|V|+|E|) for most graphs, O(|V|^2) in the worst
case.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_all_shortest_paths_dijkstra"></a>3.12. <code class="function">igraph_get_all_shortest_paths_dijkstra</code> —  All weighted shortest paths (geodesics) from a vertex.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.13.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_all_shortest_paths_dijkstra(const igraph_t *graph,
        igraph_vector_int_list_t *vertices,
        igraph_vector_int_list_t *edges,
        igraph_vector_int_t *nrgeo,
        igraph_integer_t from, igraph_vs_t to,
        const igraph_vector_t *weights,
        igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized integer vector list or NULL.
  If not NULL, then each vector object contains the vertices along a
  shortest path from <em class="parameter"><code>from</code></em> to another vertex. The vectors are
  ordered according to their target vertex: first the shortest
  paths to vertex 0, then to vertex 1, etc. No data is included
  for unreachable vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized integer vector list or NULL. If
  not NULL, then each vector object contains the edges along a
  shortest path from <em class="parameter"><code>from</code></em> to another vertex. The vectors are
  ordered according to their target vertex: first the shortest
  paths to vertex 0, then to vertex 1, etc. No data is included for
  unreachable vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nrgeo</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized igraph_vector_int_t object or
  NULL. If not NULL the number of shortest paths from <em class="parameter"><code>from</code></em> are
  stored here for every vertex in the graph. Note that the values
  will be accurate only for those vertices that are in the target
  vertex sequence (see <em class="parameter"><code>to</code></em>), since the search terminates as soon
  as all the target vertices have been found.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the vertex from/to which the geodesics are
       calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Vertex sequence with the IDs of the vertices to/from which the
       shortest paths will be calculated. A vertex might be given multiple
       times.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
      non-negative for Dijkstra's algorithm to work. Additionally, no
      edge weight may be NaN. If either case does not hold, an error
      is returned. If this is a null pointer, then the unweighted
      version, <a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths" title="3.11. igraph_get_all_shortest_paths — All shortest paths (geodesics) from a vertex."><code class="function">igraph_get_all_shortest_paths()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be use for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>from</code></em> is an invalid vertex ID
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|log|E|+|V|), where |V| is the number of
vertices and |E| is the number of edges

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_distances_dijkstra" title="3.2. igraph_distances_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_distances_dijkstra()</code></a> if you only need the path
length but not the paths themselves, <a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths" title="3.11. igraph_get_all_shortest_paths — All shortest paths (geodesics) from a vertex."><code class="function">igraph_get_all_shortest_paths()</code></a>
if all edge weights are equal.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.5.13.10.1"></a><p class="title"><b>Example 13.5.  File <code class="code">examples/simple/igraph_get_all_shortest_paths_dijkstra.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

void <span class="strong"><strong>check_nrgeo</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t *graph, igraph_vs_t vs,
                 <span class="strong"><strong>const</strong></span> igraph_vector_int_list_t *paths,
                 <span class="strong"><strong>const</strong></span> igraph_vector_int_t *nrgeo) {
    igraph_integer_t i, n;
    igraph_vector_int_t nrgeo2, *path;
    igraph_vit_t vit;

    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(graph);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;nrgeo2, n);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_size</strong></span>(nrgeo) != n) {
        <span class="strong"><strong>printf</strong></span>("nrgeo vector length must be %" IGRAPH_PRId ", was %" IGRAPH_PRId, n, <span class="strong"><strong>igraph_vector_int_size</strong></span>(nrgeo));
        <span class="strong"><strong>return</strong></span>;
    }

    n = <span class="strong"><strong>igraph_vector_int_list_size</strong></span>(paths);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        path = <span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(paths, i);
        <span class="strong"><strong>if</strong></span> (path == 0) {
            <span class="strong"><strong>printf</strong></span>("Null path found in result vector at index %" IGRAPH_PRId "\n", i);
            <span class="strong"><strong>return</strong></span>;
        }
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_size</strong></span>(path) == 0) {
            <span class="strong"><strong>printf</strong></span>("Empty path found in result vector at index %" IGRAPH_PRId "\n", i);
            <span class="strong"><strong>return</strong></span>;
        }
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(nrgeo2)[<span class="strong"><strong>igraph_vector_int_tail</strong></span>(path)] += 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vit_create" title="5.1. igraph_vit_create — Creates a vertex iterator from a vertex selector.">igraph_vit_create</a></strong></span>(graph, vs, &amp;vit);
    <span class="strong"><strong>for</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_VIT_RESET" title="5.7. IGRAPH_VIT_RESET — Reset a vertex iterator.">IGRAPH_VIT_RESET</a></strong></span>(vit); !<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_VIT_END" title="5.5. IGRAPH_VIT_END — Are we at the end?">IGRAPH_VIT_END</a></strong></span>(vit); <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_VIT_NEXT" title="5.4. IGRAPH_VIT_NEXT — Next vertex.">IGRAPH_VIT_NEXT</a></strong></span>(vit)) {
        igraph_integer_t node = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_VIT_GET" title="5.8. IGRAPH_VIT_GET — Query the current position.">IGRAPH_VIT_GET</a></strong></span>(vit);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*nrgeo)[node] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(nrgeo2)[node]) {
            <span class="strong"><strong>printf</strong></span>("nrgeo[%" IGRAPH_PRId "] invalid, observed = %" IGRAPH_PRId ", expected = %" IGRAPH_PRId "\n",
                   node, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*nrgeo)[node], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(nrgeo2)[node]);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vit_destroy" title="5.2. igraph_vit_destroy — Destroys a vertex iterator.">igraph_vit_destroy</a></strong></span>(&amp;vit);

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;nrgeo2);
}

void <span class="strong"><strong>print_and_destroy_items</strong></span>(igraph_vector_int_list_t* vec) {
    igraph_integer_t i;

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_list_size</strong></span>(vec); i++) {
        <span class="strong"><strong>igraph_vector_int_print</strong></span>(<span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(vec, i));
    }

    <span class="strong"><strong>igraph_vector_int_list_clear</strong></span>(vec);
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_vector_int_list_t vertices, edges;

    igraph_real_t weights[] = { 1, 2, 3, 4, 5, 1, 1, 1, 1, 1 };
    igraph_real_t weights2[] = { 0, 2, 1, 0, 5, 2, 1, 1, 0, 2, 2, 8, 1, 1, 3, 1, 1, 4, 2, 1 };
    igraph_integer_t dim[] = { 4, 4 };

    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights_vec;
    igraph_vector_int_t nrgeo;
    igraph_vector_int_t dim_vec;
    igraph_vs_t vs;

    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;nrgeo, 0);

    <span class="emphasis"><em>/* Simple ring graph without weights */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.11. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;g, 10, IGRAPH_UNDIRECTED, 0, 1);

    <span class="strong"><strong>igraph_vector_int_list_init</strong></span>(&amp;vertices, 0);
    <span class="strong"><strong>igraph_vector_int_list_init</strong></span>(&amp;edges, 0);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_vector_small" title="2.7. igraph_vs_vector_small — Create a vertex set by giving its elements.">igraph_vs_vector_small</a></strong></span>(&amp;vs, 1, 3, 4, 5, 2, 1,  -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths_dijkstra" title="3.12. igraph_get_all_shortest_paths_dijkstra — All weighted shortest paths (geodesics) from a vertex.">igraph_get_all_shortest_paths_dijkstra</a></strong></span>(
                &amp;g,
                <span class="emphasis"><em>/*vertices=*/</em></span> &amp;vertices, <span class="emphasis"><em>/*edges=*/</em></span> &amp;edges,  <span class="emphasis"><em>/*nrgeo=*/</em></span> &amp;nrgeo,
                <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                <span class="emphasis"><em>/*weights=*/</em></span> NULL, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);
    <span class="strong"><strong>check_nrgeo</strong></span>(&amp;g, vs, &amp;vertices, &amp;nrgeo);
    <span class="strong"><strong>print_and_destroy_items</strong></span>(&amp;vertices);
    <span class="strong"><strong>print_and_destroy_items</strong></span>(&amp;edges);

    <span class="emphasis"><em>/* Same ring, but with weights */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights_vec, weights, <span class="strong"><strong>sizeof</strong></span>(weights) / <span class="strong"><strong>sizeof</strong></span>(weights[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths_dijkstra" title="3.12. igraph_get_all_shortest_paths_dijkstra — All weighted shortest paths (geodesics) from a vertex.">igraph_get_all_shortest_paths_dijkstra</a></strong></span>(
                &amp;g,
                <span class="emphasis"><em>/*vertices=*/</em></span> &amp;vertices, <span class="emphasis"><em>/*edges=*/</em></span> NULL, <span class="emphasis"><em>/*nrgeo=*/</em></span> &amp;nrgeo,
                <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                <span class="emphasis"><em>/*weights=*/</em></span> &amp;weights_vec, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);
    <span class="strong"><strong>check_nrgeo</strong></span>(&amp;g, vs, &amp;vertices, &amp;nrgeo);
    <span class="strong"><strong>print_and_destroy_items</strong></span>(&amp;vertices);

    <span class="emphasis"><em>/* we are now testing the combination of vertices == NULL and edges != NUL */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths_dijkstra" title="3.12. igraph_get_all_shortest_paths_dijkstra — All weighted shortest paths (geodesics) from a vertex.">igraph_get_all_shortest_paths_dijkstra</a></strong></span>(
                &amp;g,
                <span class="emphasis"><em>/*vertices=*/</em></span> NULL, <span class="emphasis"><em>/*edges=*/</em></span> &amp;edges, <span class="emphasis"><em>/*nrgeo=*/</em></span> &amp;nrgeo,
                <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                <span class="emphasis"><em>/*weights=*/</em></span> &amp;weights_vec, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);
    <span class="strong"><strong>print_and_destroy_items</strong></span>(&amp;edges);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* More complicated example */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED,
                 0, 1, 0, 2, 0, 3,   1, 2, 1, 4, 1, 5,
                 2, 3, 2, 6,         3, 2, 3, 6,
                 4, 5, 4, 7,         5, 6, 5, 8, 5, 9,
                 7, 5, 7, 8,         8, 9,
                 5, 2,
                 2, 1,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights_vec, weights2, <span class="strong"><strong>sizeof</strong></span>(weights2) / <span class="strong"><strong>sizeof</strong></span>(weights2[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths_dijkstra" title="3.12. igraph_get_all_shortest_paths_dijkstra — All weighted shortest paths (geodesics) from a vertex.">igraph_get_all_shortest_paths_dijkstra</a></strong></span>(
                &amp;g,
                <span class="emphasis"><em>/*vertices=*/</em></span> &amp;vertices, <span class="emphasis"><em>/*edges=*/</em></span> &amp;edges, <span class="emphasis"><em>/*nrgeo=*/</em></span> &amp;nrgeo,
                <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                <span class="emphasis"><em>/*weights=*/</em></span> &amp;weights_vec, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);

    <span class="strong"><strong>check_nrgeo</strong></span>(&amp;g, vs, &amp;vertices, &amp;nrgeo);

    <span class="emphasis"><em>/* Sort the paths in a deterministic manner to avoid problems with</em></span>
<span class="emphasis"><em>     * different qsort() implementations on different platforms */</em></span>
    <span class="strong"><strong>igraph_vector_int_list_sort</strong></span>(&amp;vertices, igraph_vector_int_colex_cmp);
    <span class="strong"><strong>igraph_vector_int_list_sort</strong></span>(&amp;edges, igraph_vector_int_colex_cmp);
    <span class="strong"><strong>print_and_destroy_items</strong></span>(&amp;vertices);
    <span class="strong"><strong>print_and_destroy_items</strong></span>(&amp;edges);

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_destroy" title="3.2. igraph_vs_destroy — Destroy a vertex set.">igraph_vs_destroy</a></strong></span>(&amp;vs);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Regular lattice with some heavyweight edges */</em></span>
    <span class="strong"><strong>igraph_vector_int_view</strong></span>(&amp;dim_vec, dim, <span class="strong"><strong>sizeof</strong></span>(dim) / <span class="strong"><strong>sizeof</strong></span>(dim[0]));
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_square_lattice" title="1.10. igraph_square_lattice — Arbitrary dimensional square lattices.">igraph_square_lattice</a></strong></span>(&amp;g, &amp;dim_vec, 1, 0, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_vector_small" title="2.7. igraph_vs_vector_small — Create a vertex set by giving its elements.">igraph_vs_vector_small</a></strong></span>(&amp;vs, 3, 12, 15, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights_vec, 24);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_fill" title="2.3.2. igraph_vector_fill — Fill a vector with a constant element.">igraph_vector_fill</a></strong></span>(&amp;weights_vec, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(weights_vec)[2] = 100;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(weights_vec)[8] = 100; <span class="emphasis"><em>/* 1--&gt;2, 4--&gt;8 */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths_dijkstra" title="3.12. igraph_get_all_shortest_paths_dijkstra — All weighted shortest paths (geodesics) from a vertex.">igraph_get_all_shortest_paths_dijkstra</a></strong></span>(
                &amp;g,
                <span class="emphasis"><em>/*vertices=*/</em></span> 0, <span class="emphasis"><em>/*edges=*/</em></span> 0, <span class="emphasis"><em>/*nrgeo=*/</em></span> &amp;nrgeo,
                <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                <span class="emphasis"><em>/*weights=*/</em></span> &amp;weights_vec, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights_vec);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_destroy" title="3.2. igraph_vs_destroy — Destroy a vertex set.">igraph_vs_destroy</a></strong></span>(&amp;vs);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>printf</strong></span>("%" IGRAPH_PRId " ", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(nrgeo)[3]);
    <span class="strong"><strong>printf</strong></span>("%" IGRAPH_PRId " ", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(nrgeo)[12]);
    <span class="strong"><strong>printf</strong></span>("%" IGRAPH_PRId "\n", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(nrgeo)[15]);

    <span class="strong"><strong>igraph_vector_int_list_destroy</strong></span>(&amp;vertices);
    <span class="strong"><strong>igraph_vector_int_list_destroy</strong></span>(&amp;edges);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;nrgeo);

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_k_shortest_paths"></a>3.13. <code class="function">igraph_get_k_shortest_paths</code> —  k shortest paths between two vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.14.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_k_shortest_paths(
    const igraph_t *graph, const igraph_vector_t *weights,
    igraph_vector_int_list_t *vertex_paths,
    igraph_vector_int_list_t *edge_paths,
    igraph_integer_t k, igraph_integer_t from, igraph_integer_t to,
    igraph_neimode_t mode
);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights of the graph. Can be <code class="constant">NULL</code> for an
       unweighted graph. Infinite weights will be treated as missing
       edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_paths</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized list of integer vectors, the result
       will be stored here in <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> objects. Each vector
       object contains the vertex IDs along the <code class="literal">k</code>th shortest path
       between <em class="parameter"><code>from</code></em> and <em class="parameter"><code>to</code></em>, where <code class="constant">k</code> is the vector list index. May
       be <code class="constant">NULL</code> if the vertex paths are not needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_paths</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized list of integer vectors, the result
       will be stored here in <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> objects. Each vector
       object contains the edge IDs along the <code class="literal">k</code>th shortest path
       between <em class="parameter"><code>from</code></em> and <em class="parameter"><code>to</code></em>, where <code class="constant">k</code> is the vector list index. May be
       <code class="constant">NULL</code> if the edge paths are not needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>k</code></em>:</span></p></td>
<td><p>
  The number of paths.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The ID of the vertex from which the paths are calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The ID of the vertex to which the paths are calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         The outgoing paths of <em class="parameter"><code>from</code></em> are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         The incoming paths of <em class="parameter"><code>from</code></em> are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         The directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          Not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>from</code></em> or <em class="parameter"><code>to</code></em> is an invalid vertex id.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          Invalid mode argument.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

          Invalid argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity:  k |V| (|V| log|V| + |E|), where |V| is the number of vertices,
                 and |E| is the number of edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_all_simple_paths"></a>3.14. <code class="function">igraph_get_all_simple_paths</code> —  List all simple paths from one source.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.15.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_all_simple_paths(const igraph_t *graph,
                                igraph_vector_int_t *res,
                                igraph_integer_t from,
                                const igraph_vs_t to,
                                igraph_integer_t cutoff,
                                igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



A path is simple if its vertices are unique, i.e. no vertex
is visited more than once.

</p>
<p>
Note that potentially there are exponentially many
paths between two vertices of a graph, and you may
run out of memory when using this function, if your
graph is lattice-like.

</p>
<p>
This function currently ignored multiple and loop edges.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Initialized integer vector, all paths are
       returned here, separated by -1 markers. The paths
       are included in arbitrary order, as they are found.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The start vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The target vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cutoff</code></em>:</span></p></td>
<td><p>
  Maximum length of path that is considered. If
       negative, paths of all lengths are considered.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  The type of the paths to consider, it is ignored
       for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n!) in the worst case, n is the number of
vertices.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_average_path_length"></a>3.15. <code class="function">igraph_average_path_length</code> —  Calculates the average unweighted shortest path length between all vertex pairs.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.16.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_average_path_length(const igraph_t *graph,
                               igraph_real_t *res, igraph_real_t *unconn_pairs,
                               igraph_bool_t directed, igraph_bool_t unconn);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If no vertex pairs can be included in the calculation, for example because the graph
has fewer than two vertices, or if the graph has no edges and <code class="constant">unconn</code> is set to <code class="constant">true</code>,
NaN is returned.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, this will contain the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn_pairs</code></em>:</span></p></td>
<td><p>
  Pointer to a real number. If not a null pointer, the number of
   ordered vertex pairs where the second vertex is unreachable from the first one
   will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed
   paths. Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn</code></em>:</span></p></td>
<td><p>
  What to do if the graph is not connected. If
   <code class="constant">true</code>, only those vertex pairs will be included in the calculation
   between which there is a path. If <code class="constant">false</code>, <code class="constant">IGRAPH_INFINITY</code> is returned
   for disconnected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for data structures
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V| |E|), the number of vertices times the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_average_path_length_dijkstra" title="3.16. igraph_average_path_length_dijkstra — Calculates the average weighted shortest path length between all vertex pairs."><code class="function">igraph_average_path_length_dijkstra()</code></a> for the weighted version.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.5.16.11.1"></a><p class="title"><b>Example 13.6.  File <code class="code">examples/simple/igraph_average_path_length.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    igraph_real_t result;

    <span class="emphasis"><em>/* Create a random preferential attachment graph. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model.">igraph_barabasi_game</a></strong></span>(&amp;graph, 30, <span class="emphasis"><em>/*power=*/</em></span> 1, 30, 0, 0, <span class="emphasis"><em>/*A=*/</em></span> 1,
                         IGRAPH_DIRECTED, IGRAPH_BARABASI_BAG,
                         <span class="emphasis"><em>/*start_from=*/</em></span> 0);

    <span class="emphasis"><em>/* Compute the average shortest path length. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_average_path_length" title="3.15. igraph_average_path_length — Calculates the average unweighted shortest path length between all vertex pairs.">igraph_average_path_length</a></strong></span>(&amp;graph, &amp;result, NULL, IGRAPH_UNDIRECTED, 1);
    <span class="strong"><strong>printf</strong></span>("Average length of all-pairs shortest paths: %g\n", result);

    <span class="emphasis"><em>/* Destroy no-longer-needed objects. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_average_path_length_dijkstra"></a>3.16. <code class="function">igraph_average_path_length_dijkstra</code> —  Calculates the average weighted shortest path length between all vertex pairs.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.17.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_average_path_length_dijkstra(const igraph_t *graph,
                                        igraph_real_t *res, igraph_real_t *unconn_pairs,
                                        const igraph_vector_t *weights,
                                        igraph_bool_t directed, igraph_bool_t unconn);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If no vertex pairs can be included in the calculation, for example because the graph
has fewer than two vertices, or if the graph has no edges and <code class="constant">unconn</code> is set to <code class="constant">true</code>,
NaN is returned.

</p>
<p>
All distinct ordered vertex pairs are taken into account.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, this will contain the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn_pairs</code></em>:</span></p></td>
<td><p>
  Pointer to a real number. If not a null pointer, the number of
   ordered vertex pairs where the second vertex is unreachable from the first one
   will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
      non-negative for Dijkstra's algorithm to work. Additionally, no
      edge weight may be NaN. If either case does not hold, an error
      is returned. If this is a null pointer, then the unweighted
      version, <a class="link" href="igraph-Structural.html#igraph_average_path_length" title="3.15. igraph_average_path_length — Calculates the average unweighted shortest path length between all vertex pairs."><code class="function">igraph_average_path_length()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed paths.
   Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn</code></em>:</span></p></td>
<td><p>
  If <code class="constant">true</code>, only those pairs are considered for the calculation
   between which there is a path. If <code class="constant">false</code>, <code class="constant">IGRAPH_INFINITY</code> is returned
   for disconnected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

             not enough memory for data structures
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

             invalid weight vector
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V| |E| log|E| + |V|), where |V| is the number of
vertices and |E| is the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_average_path_length" title="3.15. igraph_average_path_length — Calculates the average unweighted shortest path length between all vertex pairs."><code class="function">igraph_average_path_length()</code></a> for a slightly faster unweighted version.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.5.17.12.1"></a><p class="title"><b>Example 13.7.  File <code class="code">examples/simple/igraph_grg_game.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;math.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> x, y;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_eit_t eit;
    igraph_real_t avg_dist;

    <span class="emphasis"><em>/* Set random seed for reproducible results */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Seeds a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);

    <span class="emphasis"><em>/* Create a random geometric graph and retrieve vertex coordinates */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;x, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;y, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_grg_game" title="2.1. igraph_grg_game — Generates a geometric random graph.">igraph_grg_game</a></strong></span>(&amp;graph, 200, 0.1, <span class="emphasis"><em>/* torus */</em></span> 0, &amp;x, &amp;y);

    <span class="emphasis"><em>/* Compute edge weights as geometric distance */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;graph));
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(&amp;graph, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_ID), &amp;eit);
    <span class="strong"><strong>for</strong></span> (; ! <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit); <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit)) {
        igraph_integer_t e = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        igraph_integer_t u = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(&amp;graph, e);
        igraph_integer_t v = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(&amp;graph, e);

        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(weights)[e] = <span class="strong"><strong>hypot</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(x)[u] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(x)[v], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(y)[u] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(y)[v]);
    }
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="emphasis"><em>/* Compute average path length */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_average_path_length_dijkstra" title="3.16. igraph_average_path_length_dijkstra — Calculates the average weighted shortest path length between all vertex pairs.">igraph_average_path_length_dijkstra</a></strong></span>(&amp;graph, &amp;avg_dist, NULL, &amp;weights, IGRAPH_UNDIRECTED, <span class="emphasis"><em>/* unconn */</em></span> 1);

    <span class="strong"><strong>printf</strong></span>("Average distance in the geometric graph: %g.\n", avg_dist);

    <span class="emphasis"><em>/* Destroy data structures when no longer needed */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;x);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;y);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_path_length_hist"></a>3.17. <code class="function">igraph_path_length_hist</code> — Create a histogram of all shortest path lengths.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.18.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_path_length_hist(const igraph_t *graph, igraph_vector_t *res,
                            igraph_real_t *unconnected, igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



This function calculates a histogram, by calculating the
shortest path length between each pair of vertices. For directed
graphs both directions might be considered and then every pair of vertices
appears twice in the histogram.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is stored
    here. The first (i.e. zeroth) element contains the number of
    shortest paths of length 1, etc. The supplied vector is resized
    as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconnected</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the number of
    pairs for which the second vertex is not reachable from the
    first is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Whether to consider directed paths in a directed
    graph (if not zero). This argument is ignored for undirected
    graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|), the number of vertices times the number
of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_average_path_length" title="3.15. igraph_average_path_length — Calculates the average unweighted shortest path length between all vertex pairs."><code class="function">igraph_average_path_length()</code></a> and <a class="link" href="igraph-Structural.html#igraph_distances" title="3.1. igraph_distances — Length of the shortest paths between vertices."><code class="function">igraph_distances()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_diameter"></a>3.18. <code class="function">igraph_diameter</code> —  Calculates the diameter of a graph (longest geodesic).</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.19.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_diameter(const igraph_t *graph, igraph_real_t *res,
                    igraph_integer_t *from, igraph_integer_t *to,
                    igraph_vector_int_t *vertex_path, igraph_vector_int_t *edge_path,
                    igraph_bool_t directed, igraph_bool_t unconn);
</pre></div>
<p>
</p>
<p>




The diameter of a graph is the length of the longest shortest path it has.
This function computes both the diameter, as well as the corresponding path.
The diameter of the null graph is considered be infinity by convention.

If the graph has no vertices, <code class="constant">IGRAPH_NAN</code> is returned.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, if not <code class="constant">NULL</code> then it will contain
       the diameter (the actual distance).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> it will be set to the
       source vertex of the diameter path. If the graph has no diameter path,
       it will be set to -1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> it will be set to the
       target vertex of the diameter path. If the graph has no diameter path,
       it will be set to -1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_path</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector. If not <code class="constant">NULL</code> the actual
       longest geodesic path in terms of vertices will be stored here. The vector will be
       resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_path</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector. If not <code class="constant">NULL</code> the actual
       longest geodesic path in terms of edges will be stored here. The vector will be
       resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed
       paths. Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn</code></em>:</span></p></td>
<td><p>
  What to do if the graph is not connected. If
       <code class="constant">true</code> the longest geodesic within a component
       will be returned, otherwise <code class="constant">IGRAPH_INFINITY</code> is returned.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
        temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|), the
number of vertices times the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_diameter_dijkstra" title="3.19. igraph_diameter_dijkstra — Calculates the weighted diameter of a graph using Dijkstra's algorithm."><code class="function">igraph_diameter_dijkstra()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.5.19.10.1"></a><p class="title"><b>Example 13.8.  File <code class="code">examples/simple/igraph_diameter.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_vector_int</strong></span>(igraph_vector_int_t *v) {
    igraph_integer_t i, n = <span class="strong"><strong>igraph_vector_int_size</strong></span>(v);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>printf</strong></span>(" %" IGRAPH_PRId, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i]);
    }
    <span class="strong"><strong>printf</strong></span>("\n");
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t result;
    igraph_integer_t from, to;
    igraph_vector_int_t path, path_edge;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model.">igraph_barabasi_game</a></strong></span>(&amp;g, 30, <span class="emphasis"><em>/*power=*/</em></span> 1, 30, 0, 0, <span class="emphasis"><em>/*A=*/</em></span> 1,
                         IGRAPH_DIRECTED, IGRAPH_BARABASI_BAG,
                         <span class="emphasis"><em>/*start_from=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_diameter" title="3.18. igraph_diameter — Calculates the diameter of a graph (longest geodesic).">igraph_diameter</a></strong></span>(&amp;g, &amp;result, 0, 0, 0, 0, IGRAPH_UNDIRECTED, 1);

    <span class="emphasis"><em>/*   printf("Diameter: %" IGRAPH_PRId "\n", (igraph_integer_t) result); */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.11. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED, 0, 0);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;path, 0);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;path_edge, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_diameter" title="3.18. igraph_diameter — Calculates the diameter of a graph (longest geodesic).">igraph_diameter</a></strong></span>(&amp;g, &amp;result, &amp;from, &amp;to, &amp;path, &amp;path_edge, IGRAPH_DIRECTED, 1);
    <span class="strong"><strong>printf</strong></span>(
        "diameter: %" IGRAPH_PRId ", from %" IGRAPH_PRId " to %" IGRAPH_PRId "\n",
        (igraph_integer_t) result, from, to
    );
    <span class="strong"><strong>print_vector_int</strong></span>(&amp;path);
    <span class="strong"><strong>print_vector_int</strong></span>(&amp;path_edge);

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;path);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;path_edge);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_diameter_dijkstra"></a>3.19. <code class="function">igraph_diameter_dijkstra</code> —  Calculates the weighted diameter of a graph using Dijkstra's algorithm.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.20.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_diameter_dijkstra(const igraph_t *graph,
                             const igraph_vector_t *weights,
                             igraph_real_t *res,
                             igraph_integer_t *from,
                             igraph_integer_t *to,
                             igraph_vector_int_t *vertex_path,
                             igraph_vector_int_t *edge_path,
                             igraph_bool_t directed,
                             igraph_bool_t unconn);
</pre></div>
<p>
</p>
<p>



This function computes the weighted diameter of a graph.

If the graph has no vertices, <code class="constant">IGRAPH_NAN</code> is returned.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights of the graph. Can be <code class="constant">NULL</code> for an
       unweighted graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, if not <code class="constant">NULL</code> then it will contain
       the diameter (the actual distance).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> it will be set to the
       source vertex of the diameter path. If the graph has no diameter path,
       it will be set to -1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> it will be set to the
       target vertex of the diameter path. If the graph has no diameter path,
       it will be set to -1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_path</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector. If not <code class="constant">NULL</code> the actual
       longest geodesic path in terms of vertices will be stored here. The vector will be
       resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_path</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector. If not <code class="constant">NULL</code> the actual
       longest geodesic path in terms of edges will be stored here. The vector will be
       resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed
       paths. Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn</code></em>:</span></p></td>
<td><p>
  What to do if the graph is not connected. If
       <code class="constant">true</code> the longest geodesic within a component
       will be returned, otherwise <code class="constant">IGRAPH_INFINITY</code> is
       returned.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|*log|E|), |V| is the number of vertices,
|E| is the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_diameter" title="3.18. igraph_diameter — Calculates the diameter of a graph (longest geodesic)."><code class="function">igraph_diameter()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_girth"></a>3.20. <code class="function">igraph_girth</code> —  The girth of a graph is the length of the shortest cycle in it.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.21.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_girth(const igraph_t *graph, igraph_real_t *girth,
                 igraph_vector_int_t *circle);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The current implementation works for undirected graphs only,
directed graphs are treated as undirected graphs. Self-loops and
multiple edges are ignored.

</p>
<p>
For graphs that contain no cycles, and only for such graphs,
infinity is returned.

</p>
<p>
This implementation is based on Alon Itai and Michael Rodeh:
Finding a minimum circuit in a graph
<span class="emphasis"><em> Proceedings of the ninth annual ACM symposium on Theory of
computing </em></span>, 1-10, 1977. The first implementation of this
function was done by Keith Briggs, thanks Keith.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>girth</code></em>:</span></p></td>
<td><p>
  Pointer to an <code class="constant">igraph_real_t</code>, if not <code class="constant">NULL</code> then the result
    will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>circle</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the vertex IDs in
    the shortest circle will be stored here. If <code class="constant">NULL</code> then it is
    ignored.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O((|V|+|E|)^2), |V| is the number of vertices, |E|
is the number of edges in the general case. If the graph has no
cycles at all then the function needs O(|V|+|E|) time to realize
this and then it stops.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.5.21.11.1"></a><p class="title"><b>Example 13.9.  File <code class="code">examples/simple/igraph_girth.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    igraph_real_t girth;
    igraph_vector_int_t v;
    igraph_vector_int_t circle;
    igraph_integer_t chord[] = { 0, 50 };

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.11. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;g, 100, IGRAPH_UNDIRECTED, 0, 1);
    <span class="strong"><strong>igraph_vector_int_view</strong></span>(&amp;v, chord, <span class="strong"><strong>sizeof</strong></span>(chord) / <span class="strong"><strong>sizeof</strong></span>(chord[0]));
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_add_edges" title="4.3.2. igraph_add_edges — Adds edges to a graph object.">igraph_add_edges</a></strong></span>(&amp;g, &amp;v, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_girth" title="3.20. igraph_girth — The girth of a graph is the length of the shortest cycle in it.">igraph_girth</a></strong></span>(&amp;g, &amp;girth, 0);
    <span class="strong"><strong>if</strong></span> (girth != 51) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Special case: null graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.11. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED, 0, 1);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;circle, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(circle)[0] = 2;
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_girth" title="3.20. igraph_girth — The girth of a graph is the length of the shortest cycle in it.">igraph_girth</a></strong></span>(&amp;g, &amp;girth, &amp;circle);
    <span class="strong"><strong>if</strong></span> (girth != IGRAPH_INFINITY) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;circle) != 0) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;circle);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_eccentricity"></a>3.21. <code class="function">igraph_eccentricity</code> —  Eccentricity of some vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.22.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_eccentricity(const igraph_t *graph,
                        igraph_vector_t *res,
                        igraph_vs_t vids,
                        igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



The eccentricity of a vertex is calculated by measuring the shortest
distance from (or to) the vertex, to (or from) all vertices in the
graph, and taking the maximum.

</p>
<p>
This implementation ignores vertex pairs that are in different
components. Isolated vertices have eccentricity zero.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the eccentricity is calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  What kind of paths to consider for the calculation:
   <code class="constant">IGRAPH_OUT</code>, paths that follow edge directions;
   <code class="constant">IGRAPH_IN</code>, paths that follow the opposite directions; and
   <code class="constant">IGRAPH_ALL</code>, paths that ignore edge directions. This argument
   is ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(v*(|V|+|E|)), where |V| is the number of
vertices, |E| is the number of edges and v is the number of
vertices for which eccentricity is calculated.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_radius" title="3.24. igraph_radius — Radius of a graph."><code class="function">igraph_radius()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.5.22.11.1"></a><p class="title"><b>Example 13.10.  File <code class="code">examples/simple/igraph_eccentricity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> ecc;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;ecc, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_UNDIRECTED, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_eccentricity" title="3.21. igraph_eccentricity — Eccentricity of some vertices.">igraph_eccentricity</a></strong></span>(&amp;g, &amp;ecc, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;ecc);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_OUT, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_eccentricity" title="3.21. igraph_eccentricity — Eccentricity of some vertices.">igraph_eccentricity</a></strong></span>(&amp;g, &amp;ecc, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;ecc);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_OUT, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_eccentricity" title="3.21. igraph_eccentricity — Eccentricity of some vertices.">igraph_eccentricity</a></strong></span>(&amp;g, &amp;ecc, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;ecc);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;ecc);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_eccentricity_dijkstra"></a>3.22. <code class="function">igraph_eccentricity_dijkstra</code> —  Eccentricity of some vertices, using weighted edges.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.23.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_eccentricity_dijkstra(const igraph_t *graph,
                        const igraph_vector_t *weights,
                        igraph_vector_t *res,
                        igraph_vs_t vids,
                        igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



The eccentricity of a vertex is calculated by measuring the shortest
distance from (or to) the vertex, to (or from) all vertices in the
graph, and taking the maximum.

</p>
<p>
This implementation ignores vertex pairs that are in different
components. Isolated vertices have eccentricity zero.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
   non-negative for Dijkstra's algorithm to work. Additionally, no
   edge weight may be NaN. If either case does not hold, an error
   is returned. If this is a null pointer, then the unweighted
   version, <a class="link" href="igraph-Structural.html#igraph_eccentricity" title="3.21. igraph_eccentricity — Eccentricity of some vertices."><code class="function">igraph_eccentricity()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the eccentricity is calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  What kind of paths to consider for the calculation:
   <code class="constant">IGRAPH_OUT</code>, paths that follow edge directions;
   <code class="constant">IGRAPH_IN</code>, paths that follow the opposite directions; and
   <code class="constant">IGRAPH_ALL</code>, paths that ignore edge directions. This argument
   is ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_graph_center"></a>3.23. <code class="function">igraph_graph_center</code> —  Central vertices of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.24.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_graph_center(
    const igraph_t *graph, igraph_vector_int_t *res, igraph_neimode_t mode
);
</pre></div>
<p>
</p>
<p>



The central vertices of a graph are calculated by finding the vertices
with the minimum eccentricity. This concept is typically applied to
connected graphs. In undirected disconnected graphs, the calculation
is effectively done per connected component.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  What kind of paths to consider for the calculation:
   <code class="constant">IGRAPH_OUT</code>, paths that follow edge directions;
   <code class="constant">IGRAPH_IN</code>, paths that follow the opposite directions; and
   <code class="constant">IGRAPH_ALL</code>, paths that ignore edge directions. This argument
   is ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V| (|V|+|E|)), where |V| is the number of
vertices and |E| is the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_eccentricity" title="3.21. igraph_eccentricity — Eccentricity of some vertices."><code class="function">igraph_eccentricity()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_radius"></a>3.24. <code class="function">igraph_radius</code> —  Radius of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.25.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_radius(const igraph_t *graph, igraph_real_t *radius,
                  igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



The radius of a graph is the defined as the minimum eccentricity of
its vertices, see <a class="link" href="igraph-Structural.html#igraph_eccentricity" title="3.21. igraph_eccentricity — Eccentricity of some vertices."><code class="function">igraph_eccentricity()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>radius</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored
  here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  What kind of paths to consider for the calculation:
   <code class="constant">IGRAPH_OUT</code>, paths that follow edge directions;
   <code class="constant">IGRAPH_IN</code>, paths that follow the opposite directions; and
   <code class="constant">IGRAPH_ALL</code>, paths that ignore edge directions. This argument
   is ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|(|V|+|E|)), where |V| is the number of
vertices and |E| is the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_eccentricity" title="3.21. igraph_eccentricity — Eccentricity of some vertices."><code class="function">igraph_eccentricity()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.5.25.10.1"></a><p class="title"><b>Example 13.11.  File <code class="code">examples/simple/igraph_radius.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t radius;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_UNDIRECTED, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_radius" title="3.24. igraph_radius — Radius of a graph.">igraph_radius</a></strong></span>(&amp;g, &amp;radius, IGRAPH_OUT);
    <span class="strong"><strong>if</strong></span> (radius != 1) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_OUT, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_radius" title="3.24. igraph_radius — Radius of a graph.">igraph_radius</a></strong></span>(&amp;g, &amp;radius, IGRAPH_ALL);
    <span class="strong"><strong>if</strong></span> (radius != 1) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_OUT, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_radius" title="3.24. igraph_radius — Radius of a graph.">igraph_radius</a></strong></span>(&amp;g, &amp;radius, IGRAPH_OUT);
    <span class="strong"><strong>if</strong></span> (radius != 0) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_pseudo_diameter"></a>3.25. <code class="function">igraph_pseudo_diameter</code> —  Approximation and lower bound of diameter.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.26.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_pseudo_diameter(const igraph_t *graph,
                           igraph_real_t *diameter,
                           igraph_integer_t vid_start,
                           igraph_integer_t *from,
                           igraph_integer_t *to,
                           igraph_bool_t directed,
                           igraph_bool_t unconn);
</pre></div>
<p>
</p>
<p>



This algorithm finds a pseudo-peripheral vertex and returns its
eccentricity. This value can be used as an approximation
and lower bound of the diameter of a graph.

</p>
<p>
A pseudo-peripheral vertex is a vertex v, such that for every
vertex u which is as far away from v as possible, v is also as
far away from u as possible. The process of finding one depends
on where the search starts, and for a disconnected graph the
maximum diameter found will be that of the component <em class="parameter"><code>vid_start</code></em>
is in.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, if it is directed, its edge directions
       are ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>diameter</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored
       here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vid_start</code></em>:</span></p></td>
<td><p>
  Id of the starting vertex. If this is negative, a
       random starting vertex is chosen.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> it will be set to the
       source vertex of the diameter path. If <em class="parameter"><code>unconn</code></em> is <code class="constant">false</code>, and
       a disconnected graph is detected, this is set to -1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> it will be set to the
       target vertex of the diameter path. If <em class="parameter"><code>unconn</code></em> is <code class="constant">false</code>, and
       a disconnected graph is detected, this is set to -1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed
       paths. Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn</code></em>:</span></p></td>
<td><p>
  What to do if the graph is not connected. If
       <code class="constant">true</code> the longest geodesic within a component
       will be returned, otherwise <code class="constant">IGRAPH_INFINITY</code> is returned.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|)), where |V| is the number of
vertices and |E| is the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_eccentricity" title="3.21. igraph_eccentricity — Eccentricity of some vertices."><code class="function">igraph_eccentricity()</code></a>, <a class="link" href="igraph-Structural.html#igraph_diameter" title="3.18. igraph_diameter — Calculates the diameter of a graph (longest geodesic)."><code class="function">igraph_diameter()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_vertex_path_from_edge_path"></a>3.26. <code class="function">igraph_vertex_path_from_edge_path</code> —  Converts a path of edge IDs to the traversed vertex IDs.</h3></div></div></div>
<a class="indexterm" name="id-1.14.5.27.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_vertex_path_from_edge_path(
   const igraph_t *graph, igraph_integer_t start,
   const igraph_vector_int_t *edge_path, igraph_vector_int_t *vertex_path,
   igraph_neimode_t mode
);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function is useful when you have a sequence of edge IDs representing a
continuous path in a graph and you would like to obtain the vertex IDs that
the path traverses. The function is used implicitly by several shortest path
related functions to convert a path of edge IDs to the corresponding
representation that describes the path in terms of vertex IDs instead.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  the graph that the edge IDs refer to
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>start</code></em>:</span></p></td>
<td><p>
  the start vertex of the path
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_path</code></em>:</span></p></td>
<td><p>
  the sequence of edge IDs that describe the path
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_path</code></em>:</span></p></td>
<td><p>
  the sequence of vertex IDs traversed will be returned here
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code: <code class="constant">IGRAPH_ENOMEM</code> if there is not enough memory,
        <code class="constant">IGRAPH_EINVAL</code> if the edge path does not start at the given vertex
        or if there is at least one edge whose start vertex does not match
        the end vertex of the previous edge
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="widest-path-related-functions"></a>4. Widest-path related functions</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_widest_path">4.1. <code class="function">igraph_get_widest_path</code> —  Widest path from one vertex to another one.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_widest_paths">4.2. <code class="function">igraph_get_widest_paths</code> —  Widest paths from a single vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_widest_path_widths_dijkstra">4.3. <code class="function">igraph_widest_path_widths_dijkstra</code> —  Widths of widest paths between vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_widest_path_widths_floyd_warshall">4.4. <code class="function">igraph_widest_path_widths_floyd_warshall</code> —  Widths of widest paths between vertices.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_widest_path"></a>4.1. <code class="function">igraph_get_widest_path</code> —  Widest path from one vertex to another one.</h3></div></div></div>
<a class="indexterm" name="id-1.14.6.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_widest_path(const igraph_t *graph,
                                      igraph_vector_int_t *vertices,
                                      igraph_vector_int_t *edges,
                                      igraph_integer_t from,
                                      igraph_integer_t to,
                                      const igraph_vector_t *weights,
                                      igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Calculates a single widest path from a single vertex to another
one, using Dijkstra's algorithm.

</p>
<p>This function is a special case (and a wrapper) to
<a class="link" href="igraph-Structural.html#igraph_get_widest_paths" title="4.2. igraph_get_widest_paths — Widest paths from a single vertex."><code class="function">igraph_get_widest_paths()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
       pointer. If not a null pointer, then the vertex IDs along
       the path are stored here, including the source and target
       vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
       pointer. If not a null pointer, then the edge IDs along the
       path are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. Edge weights can be negative. If this
       is a null pointer or if any edge weight is NaN, then an error
       is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  A constant specifying how edge directions are
       considered in directed graphs. <code class="constant">IGRAPH_OUT</code> follows edge
       directions, <code class="constant">IGRAPH_IN</code> follows the opposite directions,
       and <code class="constant">IGRAPH_ALL</code> ignores edge directions. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|log|E|+|V|), |V| is the number of vertices,
|E| is the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_widest_paths" title="4.2. igraph_get_widest_paths — Widest paths from a single vertex."><code class="function">igraph_get_widest_paths()</code></a> for the version with
more target vertices.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_widest_paths"></a>4.2. <code class="function">igraph_get_widest_paths</code> —  Widest paths from a single vertex.</h3></div></div></div>
<a class="indexterm" name="id-1.14.6.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_widest_paths(const igraph_t *graph,
                                       igraph_vector_int_list_t *vertices,
                                       igraph_vector_int_list_t *edges,
                                       igraph_integer_t from,
                                       igraph_vs_t to,
                                       const igraph_vector_t *weights,
                                       igraph_neimode_t mode,
                                       igraph_vector_int_t *parents,
                                       igraph_vector_int_t *inbound_edges);
</pre></div>
<p>
</p>
<p>



Calculates the widest paths from a single node to all other specified nodes,
using a modified Dijkstra's algorithm.  If there is more than one path with
the largest width between two vertices, this function gives only one of them.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  The result, the IDs of the vertices along the paths.
       This is a list of integer vectors where each element is an
       <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> object. The list will be resized as needed.
       Supply a null pointer here if you don't need these vectors.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  The result, the IDs of the edges along the paths.
       This is a list of integer vectors where each element is an
       <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_int_t</code></a> object. The list will be resized as needed.
       Supply a null pointer here if you don't need these vectors.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the vertex from/to which the widest paths are
       calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Vertex sequence with the IDs of the vertices to/from which the
       widest paths will be calculated. A vertex might be given multiple
       times.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. Edge weights can be negative. If this
       is a null pointer or if any edge weight is NaN, then an error
       is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of widest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>parents</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the parent of each vertex in
       the single source widest path tree is returned here. The
       parent of vertex i in the tree is the vertex from which vertex i
       was reached. The parent of the start vertex (in the <code class="constant">from</code>
       argument) is -1. If the parent is -2, it means
       that the given vertex was not reached from the source during the
       search. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>inbound_edges</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the inbound edge of each vertex in
       the single source widest path tree is returned here. The
       inbound edge of vertex i in the tree is the edge via which vertex i
       was reached. The start vertex and vertices that were not reached
       during the search will have -1 in the corresponding entry of the
       vector. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>from</code></em> is invalid vertex ID
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|log|E|+|V|), where |V| is the number of
vertices in the graph and |E| is the number of edges

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_widest_path_widths_dijkstra" title="4.3. igraph_widest_path_widths_dijkstra — Widths of widest paths between vertices."><code class="function">igraph_widest_path_widths_dijkstra()</code></a> or
<a class="link" href="igraph-Structural.html#igraph_widest_path_widths_floyd_warshall" title="4.4. igraph_widest_path_widths_floyd_warshall — Widths of widest paths between vertices."><code class="function">igraph_widest_path_widths_floyd_warshall()</code></a> if you only need the
widths of the paths but not the paths themselves.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_widest_path_widths_dijkstra"></a>4.3. <code class="function">igraph_widest_path_widths_dijkstra</code> —  Widths of widest paths between vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.6.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_widest_path_widths_dijkstra(const igraph_t *graph,
                                   igraph_matrix_t *res,
                                   const igraph_vs_t from,
                                   const igraph_vs_t to,
                                   const igraph_vector_t *weights,
                                   igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



This function implements a modified Dijkstra's algorithm, which
can find the widest path widths from a source vertex to all
other vertices. This function allows specifying a set of source
and target vertices. The algorithm is run independently for each
source and the results are retained only for the specified targets.
This implementation uses a binary heap for efficiency.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, can be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result, a matrix. A pointer to an initialized matrix
   should be passed here. The matrix will be resized as needed.
   Each row contains the widths from a single source, to the
   vertices given in the <code class="constant">to</code> argument.
   Unreachable vertices have width <code class="constant">IGRAPH_NEGINFINITY</code>, and vertices
   have a width of <code class="constant">IGRAPH_POSINFINITY</code> to themselves.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The source vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The target vertices. It is not allowed to include a
   vertex twice or more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. Edge weights can be negative. If this
       is a null pointer or if any edge weight is NaN, then an error
       is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graphs; whether to follow paths along edge
   directions (<code class="constant">IGRAPH_OUT</code>), or the opposite (<code class="constant">IGRAPH_IN</code>), or
   ignore edge directions completely (<code class="constant">IGRAPH_ALL</code>). It is ignored
   for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(s*(|E|log|E|+|V|)), where |V| is the number of
vertices in the graph, |E| the number of edges and s the number of sources.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_widest_path_widths_floyd_warshall" title="4.4. igraph_widest_path_widths_floyd_warshall — Widths of widest paths between vertices."><code class="function">igraph_widest_path_widths_floyd_warshall()</code></a> for a variant that runs faster
on dense graphs.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_widest_path_widths_floyd_warshall"></a>4.4. <code class="function">igraph_widest_path_widths_floyd_warshall</code> —  Widths of widest paths between vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.6.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_widest_path_widths_floyd_warshall(const igraph_t *graph,
                                   igraph_matrix_t *res,
                                   const igraph_vs_t from,
                                   const igraph_vs_t to,
                                   const igraph_vector_t *weights,
                                   igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



This function implements a modified Floyd Warshalls algorithm,
to find the widest path widths from a set of source vertices to
all other target vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, can be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result, a matrix. A pointer to an initialized matrix
   should be passed here. The matrix will be resized as needed.
   Each row contains the widths from a single source, to the
   vertices given in the <code class="constant">to</code> argument.
   Unreachable vertices have width <code class="constant">IGRAPH_NEGINFINITY</code>, and vertices
   have a width of <code class="constant">IGRAPH_POSINFINITY</code> to themselves.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The source vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The target vertices. It is not allowed to include a
   vertex twice or more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. Edge weights can be negative. If this
       is a null pointer or if any edge weight is NaN, then an error
       is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graphs; whether to follow paths along edge
   directions (<code class="constant">IGRAPH_OUT</code>), or the opposite (<code class="constant">IGRAPH_IN</code>), or
   ignore edge directions completely (<code class="constant">IGRAPH_ALL</code>). It is ignored
   for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^3), where |V| is the number of vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_widest_path_widths_dijkstra" title="4.3. igraph_widest_path_widths_dijkstra — Widths of widest paths between vertices."><code class="function">igraph_widest_path_widths_dijkstra()</code></a> for a variant that runs faster
on sparse graphs.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="efficiency-measures"></a>5. Efficiency measures</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_global_efficiency">5.1. <code class="function">igraph_global_efficiency</code> —  Calculates the global efficiency of a network.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_efficiency">5.2. <code class="function">igraph_local_efficiency</code> —  Calculates the local efficiency around each vertex in a network.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_average_local_efficiency">5.3. <code class="function">igraph_average_local_efficiency</code> —  Calculates the average local efficiency in a network.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_global_efficiency"></a>5.1. <code class="function">igraph_global_efficiency</code> —  Calculates the global efficiency of a network.</h3></div></div></div>
<a class="indexterm" name="id-1.14.7.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_global_efficiency(const igraph_t *graph, igraph_real_t *res,
                             const igraph_vector_t *weights,
                             igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The global efficiency of a network is defined as the average of inverse distances
between all pairs of vertices: <code class="literal">E_g = 1/(N*(N-1)) sum_{i!=j} 1/d_ij</code>,
where N is the number of vertices.
The inverse distance between pairs that are not reachable from each other is considered
to be zero. For graphs with fewer than 2 vertices, NaN is returned.

</p>
<p>
Reference:
V. Latora and M. Marchiori,
Efficient Behavior of Small-World Networks,
Phys. Rev. Lett. 87, 198701 (2001).
<a class="ulink" href="https://dx.doi.org/10.1103/PhysRevLett.87.198701" target="_top">https://dx.doi.org/10.1103/PhysRevLett.87.198701</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, this will contain the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
      non-negative for Dijkstra's algorithm to work. Additionally, no
      edge weight may be NaN. If either case does not hold, an error
      is returned. If this is a null pointer, then the unweighted
      version, <a class="link" href="igraph-Structural.html#igraph_average_path_length" title="3.15. igraph_average_path_length — Calculates the average unweighted shortest path length between all vertex pairs."><code class="function">igraph_average_path_length()</code></a> is used in calculating
      the global efficiency.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed paths.
   Ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

             not enough memory for data structures
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

             invalid weight vector
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V| |E| log|E| + |V|) for weighted graphs and
O(|V| |E|) for unweighted ones. |V| denotes the number of
vertices and |E| denotes the number of edges.

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_local_efficiency"></a>5.2. <code class="function">igraph_local_efficiency</code> —  Calculates the local efficiency around each vertex in a network.</h3></div></div></div>
<a class="indexterm" name="id-1.14.7.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_local_efficiency(const igraph_t *graph, igraph_vector_t *res,
                            const igraph_vs_t vids,
                            const igraph_vector_t *weights,
                            igraph_bool_t directed, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The local efficiency of a network around a vertex is defined as follows:
We remove the vertex and compute the distances (shortest path lengths) between
its neighbours through the rest of the network. The local efficiency around the
removed vertex is the average of the inverse of these distances.

</p>
<p>
The inverse distance between two vertices which are not reachable from each other
is considered to be zero. The local efficiency around a vertex with fewer than two
neighbours is taken to be zero by convention.

</p>
<p>
Reference:
I. Vragović, E. Louis, and A. Díaz-Guilera,
Efficiency of informational transfer in regular and complex networks,
Phys. Rev. E 71, 1 (2005).
<a class="ulink" href="http://dx.doi.org/10.1103/PhysRevE.71.036122" target="_top">http://dx.doi.org/10.1103/PhysRevE.71.036122</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, this will contain the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices around which the local efficiency will be calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
      non-negative. Additionally, no edge weight may be NaN. If either
      case does not hold, an error is returned. If this is a null
      pointer, then the unweighted version,
      <a class="link" href="igraph-Structural.html#igraph_average_path_length" title="3.15. igraph_average_path_length — Calculates the average unweighted shortest path length between all vertex pairs."><code class="function">igraph_average_path_length()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed paths.
   Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  How to determine the local neighborhood of each vertex
   in directed graphs. Ignored in undirected graphs.
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

             take both in- and out-neighbours;
             this is a reasonable default for high-level interfaces.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

             take only out-neighbours
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

             take only in-neighbours
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

             not enough memory for data structures
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

             invalid weight vector
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|^2 log|E|) for weighted graphs and
O(|E|^2) for unweighted ones. |E| denotes the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_average_local_efficiency" title="5.3. igraph_average_local_efficiency — Calculates the average local efficiency in a network."><code class="function">igraph_average_local_efficiency()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_average_local_efficiency"></a>5.3. <code class="function">igraph_average_local_efficiency</code> —  Calculates the average local efficiency in a network.</h3></div></div></div>
<a class="indexterm" name="id-1.14.7.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_average_local_efficiency(const igraph_t *graph, igraph_real_t *res,
                                    const igraph_vector_t *weights,
                                    igraph_bool_t directed, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




For the null graph, zero is returned by convention.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, this will contain the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. They must be all non-negative.
   If a null pointer is given, all weights are assumed to be 1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed paths.
   Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  How to determine the local neighborhood of each vertex
   in directed graphs. Ignored in undirected graphs.
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

             take both in- and out-neighbours;
             this is a reasonable default for high-level interfaces.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

             take only out-neighbours
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

             take only in-neighbours
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

             not enough memory for data structures
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

             invalid weight vector
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|^2 log|E|) for weighted graphs and
O(|E|^2) for unweighted ones. |E| denotes the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_local_efficiency" title="5.2. igraph_local_efficiency — Calculates the local efficiency around each vertex in a network."><code class="function">igraph_local_efficiency()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="neighborhood-of-a-vertex"></a>6. Neighborhood of a vertex</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_neighborhood_size">6.1. <code class="function">igraph_neighborhood_size</code> —  Calculates the size of the neighborhood of a given vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_neighborhood">6.2. <code class="function">igraph_neighborhood</code> —  Calculate the neighborhood of vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_neighborhood_graphs">6.3. <code class="function">igraph_neighborhood_graphs</code> —  Create graphs from the neighborhood(s) of some vertex/vertices.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_neighborhood_size"></a>6.1. <code class="function">igraph_neighborhood_size</code> —  Calculates the size of the neighborhood of a given vertex.</h3></div></div></div>
<a class="indexterm" name="id-1.14.8.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_neighborhood_size(const igraph_t *graph, igraph_vector_int_t *res,
                             igraph_vs_t vids, igraph_integer_t order,
                             igraph_neimode_t mode,
                             igraph_integer_t mindist);
</pre></div>
<p>
</p>
<p>



The neighborhood of a given order of a vertex includes all vertices
which are closer to the vertex than the order. I.e., order 0 is
always the vertex itself, order 1 is the vertex plus its immediate
neighbors, order 2 is order 1 plus the immediate neighbors of the
vertices in order 1, etc.

</p>
<p>
This function calculates the size of the neighborhood
of the given order for the given vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result will be
   stored here. It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>order</code></em>:</span></p></td>
<td><p>
  Integer giving the order of the neighborhood.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies how to use the direction of the edges if a
  directed graph is analyzed. For <code class="constant">IGRAPH_OUT</code> only the outgoing
  edges are followed, so all vertices reachable from the source
  vertex in at most <code class="constant">order</code> steps are counted. For <code class="constant">IGRAPH_IN</code>
  all vertices from which the source vertex is reachable in at most
  <code class="constant">order</code> steps are counted. <code class="constant">IGRAPH_ALL</code> ignores the direction
  of the edges. This argument is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mindist</code></em>:</span></p></td>
<td><p>
  The minimum distance to include a vertex in the counting.
  Vertices reachable with a path shorter than this value are excluded.
  If this is one, then the starting vertex is not counted. If this is
  two, then its neighbors are not counted either, etc.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_neighborhood" title="6.2. igraph_neighborhood — Calculate the neighborhood of vertices."><code class="function">igraph_neighborhood()</code></a> for calculating the actual neighborhood,
<a class="link" href="igraph-Structural.html#igraph_neighborhood_graphs" title="6.3. igraph_neighborhood_graphs — Create graphs from the neighborhood(s) of some vertex/vertices."><code class="function">igraph_neighborhood_graphs()</code></a> for creating separate graphs from
the neighborhoods.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*d*o), where n is the number vertices for which
the calculation is performed, d is the average degree, o is the order.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_neighborhood"></a>6.2. <code class="function">igraph_neighborhood</code> —  Calculate the neighborhood of vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.8.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_neighborhood(const igraph_t *graph, igraph_vector_int_list_t *res,
                        igraph_vs_t vids, igraph_integer_t order,
                        igraph_neimode_t mode, igraph_integer_t mindist);
</pre></div>
<p>
</p>
<p>



The neighborhood of a given order of a vertex includes all vertices
which are closer to the vertex than the order. I.e., order 0 is
always the vertex itself, order 1 is the vertex plus its immediate
neighbors, order 2 is order 1 plus the immediate neighbors of the
vertices in order 1, etc.

</p>
<p>
This function calculates the vertices within the
neighborhood of the specified vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized list of integer vectors. The result of the
   calculation will be stored here. The list will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>order</code></em>:</span></p></td>
<td><p>
  Integer giving the order of the neighborhood.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies how to use the direction of the edges if a
  directed graph is analyzed. For <code class="constant">IGRAPH_OUT</code> only the outgoing
  edges are followed, so all vertices reachable from the source
  vertex in at most <em class="parameter"><code>order</code></em> steps are included. For <code class="constant">IGRAPH_IN</code>
  all vertices from which the source vertex is reachable in at most
  <em class="parameter"><code>order</code></em> steps are included. <code class="constant">IGRAPH_ALL</code> ignores the direction
  of the edges. This argument is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mindist</code></em>:</span></p></td>
<td><p>
  The minimum distance to include a vertex in the counting.
  Vertices reachable with a path shorter than this value are excluded.
  If this is one, then the starting vertex is not counted. If this is
  two, then its neighbors are not counted either, etc.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_neighborhood_size" title="6.1. igraph_neighborhood_size — Calculates the size of the neighborhood of a given vertex."><code class="function">igraph_neighborhood_size()</code></a> to calculate the size of the
neighborhood, <a class="link" href="igraph-Structural.html#igraph_neighborhood_graphs" title="6.3. igraph_neighborhood_graphs — Create graphs from the neighborhood(s) of some vertex/vertices."><code class="function">igraph_neighborhood_graphs()</code></a> for creating
graphs from the neighborhoods.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*d*o), n is the number of vertices for which
the calculation is performed, d is the average degree, o is the
order.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_neighborhood_graphs"></a>6.3. <code class="function">igraph_neighborhood_graphs</code> —  Create graphs from the neighborhood(s) of some vertex/vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.8.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_neighborhood_graphs(const igraph_t *graph, igraph_graph_list_t *res,
                               igraph_vs_t vids, igraph_integer_t order,
                               igraph_neimode_t mode,
                               igraph_integer_t mindist);
</pre></div>
<p>
</p>
<p>



The neighborhood of a given order of a vertex includes all vertices
which are closer to the vertex than the order. Ie. order 0 is
always the vertex itself, order 1 is the vertex plus its immediate
neighbors, order 2 is order 1 plus the immediate neighbors of the
vertices in order 1, etc.

</p>
<p>
This function finds every vertex in the neighborhood
of a given parameter vertex and creates the induced subgraph from these
vertices.

</p>
<p>
The first version of this function was written by
Vincent Matossian, thanks Vincent.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a list of graphs, the result will be stored
  here. Each item in the list is an <code class="constant">igraph_t</code> object. The list will be
  resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>order</code></em>:</span></p></td>
<td><p>
  Integer giving the order of the neighborhood.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies how to use the direction of the edges if a
  directed graph is analyzed. For <code class="constant">IGRAPH_OUT</code> only the outgoing
  edges are followed, so all vertices reachable from the source
  vertex in at most <em class="parameter"><code>order</code></em> steps are counted. For <code class="constant">IGRAPH_IN</code>
  all vertices from which the source vertex is reachable in at most
  <em class="parameter"><code>order</code></em> steps are counted. <code class="constant">IGRAPH_ALL</code> ignores the direction
  of the edges. This argument is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mindist</code></em>:</span></p></td>
<td><p>
  The minimum distance to include a vertex in the counting.
  Vertices reachable with a path shorter than this value are excluded.
  If this is one, then the starting vertex is not counted. If this is
  two, then its neighbors are not counted either, etc.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_neighborhood_size" title="6.1. igraph_neighborhood_size — Calculates the size of the neighborhood of a given vertex."><code class="function">igraph_neighborhood_size()</code></a> for calculating the neighborhood
sizes only, <a class="link" href="igraph-Structural.html#igraph_neighborhood" title="6.2. igraph_neighborhood — Calculate the neighborhood of vertices."><code class="function">igraph_neighborhood()</code></a> for calculating the
neighborhoods (but not creating graphs).
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*(|V|+|E|)), where n is the number vertices for
which the calculation is performed, |V| and |E| are the number of
vertices and edges in the original input graph.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="local-scan-statistics"></a>7. Local scan statistics</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#us-statistics">7.1. "Us" statistics</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#them-statistics">7.2. "Them" statistics</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#pre-calculated-subsets">7.3. Pre-calculated subsets</a></span></dt>
</dl></div>
<p>
The scan statistic is a summary of the locality statistics that is computed
from the local neighborhood of each vertex. For details, see
Priebe, C. E., Conroy, J. M., Marchette, D. J., Park, Y. (2005).
Scan Statistics on Enron Graphs. Computational and Mathematical Organization Theory.
</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="us-statistics"></a>7.1. "Us" statistics</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_0">7.1.1. <code class="function">igraph_local_scan_0</code> — Local scan-statistics, k=0</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_1_ecount">7.1.2. <code class="function">igraph_local_scan_1_ecount</code> — Local scan-statistics, k=1, edge count and sum of weights</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_k_ecount">7.1.3. <code class="function">igraph_local_scan_k_ecount</code> —  Sum the number of edges or the weights in k-neighborhood of every vertex.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_0"></a>7.1.1. <code class="function">igraph_local_scan_0</code> — Local scan-statistics, k=0</h4></div></div></div>
<a class="indexterm" name="id-1.14.9.3.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_local_scan_0(const igraph_t *graph, igraph_vector_t *res,
                        const igraph_vector_t *weights,
                        igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



K=0 scan-statistics is arbitrarily defined as the vertex degree for
unweighted, and the vertex strength for weighted graphs. See <a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a> and <a class="link" href="igraph-Structural.html#igraph_strength" title="10.11. igraph_strength — Strength of the vertices, also called weighted vertex degree."><code class="function">igraph_strength()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the results are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of the neighborhood, <code class="constant">IGRAPH_OUT</code> means outgoing,
       <code class="constant">IGRAPH_IN</code> means incoming and <code class="constant">IGRAPH_ALL</code> means all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_1_ecount"></a>7.1.2. <code class="function">igraph_local_scan_1_ecount</code> — Local scan-statistics, k=1, edge count and sum of weights</h4></div></div></div>
<a class="indexterm" name="id-1.14.9.3.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_local_scan_1_ecount(const igraph_t *graph, igraph_vector_t *res,
                               const igraph_vector_t *weights,
                               igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Count the number of edges or the sum the edge weights in the
1-neighborhood of vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the results are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of the neighborhood, <code class="constant">IGRAPH_OUT</code> means outgoing,
       <code class="constant">IGRAPH_IN</code> means incoming and <code class="constant">IGRAPH_ALL</code> means all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_k_ecount"></a>7.1.3. <code class="function">igraph_local_scan_k_ecount</code> —  Sum the number of edges or the weights in k-neighborhood of every vertex.</h4></div></div></div>
<a class="indexterm" name="id-1.14.9.3.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_local_scan_k_ecount(const igraph_t *graph, igraph_integer_t k,
                               igraph_vector_t *res,
                               const igraph_vector_t *weights,
                               igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>k</code></em>:</span></p></td>
<td><p>
  The size of the neighborhood, non-negative integer.
       The k=0 case is special, see <a class="link" href="igraph-Structural.html#igraph_local_scan_0" title="7.1.1. igraph_local_scan_0 — Local scan-statistics, k=0"><code class="function">igraph_local_scan_0()</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the results are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of the neighborhood, <code class="constant">IGRAPH_OUT</code> means outgoing,
       <code class="constant">IGRAPH_IN</code> means incoming and <code class="constant">IGRAPH_ALL</code> means all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="them-statistics"></a>7.2. "Them" statistics</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_0_them">7.2.1. <code class="function">igraph_local_scan_0_them</code> — Local THEM scan-statistics, k=0</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_1_ecount_them">7.2.2. <code class="function">igraph_local_scan_1_ecount_them</code> — Local THEM scan-statistics, k=1, edge count and sum of weights</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_k_ecount_them">7.2.3. <code class="function">igraph_local_scan_k_ecount_them</code> —  Local THEM scan-statistics, edge count or sum of weights.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_0_them"></a>7.2.1. <code class="function">igraph_local_scan_0_them</code> — Local THEM scan-statistics, k=0</h4></div></div></div>
<a class="indexterm" name="id-1.14.9.4.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_local_scan_0_them(const igraph_t *us, const igraph_t *them,
                             igraph_vector_t *res,
                             const igraph_vector_t *weights_them,
                             igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



K=0 scan-statistics is arbitrarily defined as the vertex degree for
unweighted, and the vertex strength for weighted graphs. See <a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a> and <a class="link" href="igraph-Structural.html#igraph_strength" title="10.11. igraph_strength — Strength of the vertices, also called weighted vertex degree."><code class="function">igraph_strength()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>us</code></em>:</span></p></td>
<td><p>
  The input graph, to use to extract the neighborhoods.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>them</code></em>:</span></p></td>
<td><p>
  The input graph to use for the actually counting.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the results are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights_them</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of the neighborhood, <code class="constant">IGRAPH_OUT</code> means outgoing,
       <code class="constant">IGRAPH_IN</code> means incoming and <code class="constant">IGRAPH_ALL</code> means all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_1_ecount_them"></a>7.2.2. <code class="function">igraph_local_scan_1_ecount_them</code> — Local THEM scan-statistics, k=1, edge count and sum of weights</h4></div></div></div>
<a class="indexterm" name="id-1.14.9.4.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_local_scan_1_ecount_them(const igraph_t *us, const igraph_t *them,
                                    igraph_vector_t *res,
                                    const igraph_vector_t *weights_them,
                                    igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Count the number of edges or the sum the edge weights in the
1-neighborhood of vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>us</code></em>:</span></p></td>
<td><p>
  The input graph to extract the neighborhoods.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>them</code></em>:</span></p></td>
<td><p>
  The input graph to perform the counting.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights_them</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of the neighborhood, <code class="constant">IGRAPH_OUT</code> means outgoing,
       <code class="constant">IGRAPH_IN</code> means incoming and <code class="constant">IGRAPH_ALL</code> means all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_local_scan_1_ecount" title="7.1.2. igraph_local_scan_1_ecount — Local scan-statistics, k=1, edge count and sum of weights"><code class="function">igraph_local_scan_1_ecount()</code></a> for the US statistics.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_k_ecount_them"></a>7.2.3. <code class="function">igraph_local_scan_k_ecount_them</code> —  Local THEM scan-statistics, edge count or sum of weights.</h4></div></div></div>
<a class="indexterm" name="id-1.14.9.4.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_local_scan_k_ecount_them(const igraph_t *us, const igraph_t *them,
                                    igraph_integer_t k, igraph_vector_t *res,
                                    const igraph_vector_t *weights_them,
                                    igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Count the number of edges or the sum the edge weights in the
k-neighborhood of vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>us</code></em>:</span></p></td>
<td><p>
  The input graph to extract the neighborhoods.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>them</code></em>:</span></p></td>
<td><p>
  The input graph to perform the counting.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>k</code></em>:</span></p></td>
<td><p>
  The size of the neighborhood, non-negative integer.
       The k=0 case is special, see <a class="link" href="igraph-Structural.html#igraph_local_scan_0_them" title="7.2.1. igraph_local_scan_0_them — Local THEM scan-statistics, k=0"><code class="function">igraph_local_scan_0_them()</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights_them</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of the neighborhood, <code class="constant">IGRAPH_OUT</code> means outgoing,
       <code class="constant">IGRAPH_IN</code> means incoming and <code class="constant">IGRAPH_ALL</code> means all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_local_scan_1_ecount" title="7.1.2. igraph_local_scan_1_ecount — Local scan-statistics, k=1, edge count and sum of weights"><code class="function">igraph_local_scan_1_ecount()</code></a> for the US statistics.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="pre-calculated-subsets"></a>7.3. Pre-calculated subsets</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_neighborhood_ecount">7.3.1. <code class="function">igraph_local_scan_neighborhood_ecount</code> — Local scan-statistics with pre-calculated neighborhoods</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_subset_ecount">7.3.2. <code class="function">igraph_local_scan_subset_ecount</code> —  Local scan-statistics of subgraphs induced by subsets of vertices.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_neighborhood_ecount"></a>7.3.1. <code class="function">igraph_local_scan_neighborhood_ecount</code> — Local scan-statistics with pre-calculated neighborhoods</h4></div></div></div>
<a class="indexterm" name="id-1.14.9.5.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_local_scan_neighborhood_ecount(const igraph_t *graph,
        igraph_vector_t *res,
        const igraph_vector_t *weights,
        const igraph_vector_int_list_t *neighborhoods);
</pre></div>
<p>
</p>
<p>



Count the number of edges, or sum the edge weights in
neighborhoods given as a parameter.

</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.10.0. Please do not use this function in new
code; use <a class="link" href="igraph-Structural.html#igraph_local_scan_subset_ecount" title="7.3.2. igraph_local_scan_subset_ecount — Local scan-statistics of subgraphs induced by subsets of vertices."><code class="function">igraph_local_scan_subset_ecount()</code></a>
instead.</p>
</div>
<p>
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph to perform the counting/summing in.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Initialized vector, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>neighborhoods</code></em>:</span></p></td>
<td><p>
  List of <span class="type">igraph_vector_int_t</span>
       objects, the neighborhoods, one for each vertex in the
       graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_subset_ecount"></a>7.3.2. <code class="function">igraph_local_scan_subset_ecount</code> —  Local scan-statistics of subgraphs induced by subsets of vertices.</h4></div></div></div>
<a class="indexterm" name="id-1.14.9.5.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_local_scan_subset_ecount(const igraph_t *graph,
        igraph_vector_t *res,
        const igraph_vector_t *weights,
        const igraph_vector_int_list_t *subsets);
</pre></div>
<p>
</p>
<p>



Count the number of edges, or sum the edge weights in
induced subgraphs from vertices given as a parameter.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph to perform the counting/summing in.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Initialized vector, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>subsets</code></em>:</span></p></td>
<td><p>
  List of <span class="type">igraph_vector_int_t</span>
       objects, the vertex subsets.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="graph-components"></a>8. Graph components</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_subcomponent">8.1. <code class="function">igraph_subcomponent</code> —  The vertices in the same component as a given vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_connected_components">8.2. <code class="function">igraph_connected_components</code> —  Calculates the (weakly or strongly) connected components in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_clusters">8.3. <code class="function">igraph_clusters</code> —  Calculates the (weakly or strongly) connected components in a graph (deprecated alias).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_connected">8.4. <code class="function">igraph_is_connected</code> —  Decides whether the graph is (weakly or strongly) connected.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_decompose">8.5. <code class="function">igraph_decompose</code> —  Decomposes a graph into connected components.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_decompose_destroy">8.6. <code class="function">igraph_decompose_destroy</code> —  Frees the contents of a pointer vector holding graphs.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_biconnected_components">8.7. <code class="function">igraph_biconnected_components</code> —  Calculates biconnected components.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_articulation_points">8.8. <code class="function">igraph_articulation_points</code> —  Finds the articulation points in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_bridges">8.9. <code class="function">igraph_bridges</code> —  Finds all bridges in a graph.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subcomponent"></a>8.1. <code class="function">igraph_subcomponent</code> —  The vertices in the same component as a given vertex.</h3></div></div></div>
<a class="indexterm" name="id-1.14.10.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_subcomponent(
    const igraph_t *graph, igraph_vector_int_t *res, igraph_integer_t vertex,
    igraph_neimode_t mode
);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result, vector with the IDs of the vertices in the
       same component.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex</code></em>:</span></p></td>
<td><p>
  The id of the vertex of which the component is
       searched.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  Type of the component for directed graphs, possible
       values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the set of vertices reachable <span class="emphasis"><em>from</em></span> the
         <em class="parameter"><code>vertex</code></em>,
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the set of vertices from which the
         <em class="parameter"><code>vertex</code></em> is reachable.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the graph is considered as an
         undirected graph. Note that this is <span class="emphasis"><em>not</em></span> the same
         as the union of the previous two.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

         not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>vertex</code></em> is an invalid vertex ID
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument passed.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|),
|V| and
|E| are the number of vertices and
edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Operators.html#igraph_induced_subgraph" title="3.3. igraph_induced_subgraph — Creates a subgraph induced by the specified vertices."><code class="function">igraph_induced_subgraph()</code></a> if you want a graph object consisting only
a given set of vertices and the edges between them.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_connected_components"></a>8.2. <code class="function">igraph_connected_components</code> —  Calculates the (weakly or strongly) connected components in a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.10.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_connected_components(
    const igraph_t *graph, igraph_vector_int_t *membership,
    igraph_vector_int_t *csize, igraph_integer_t *no, igraph_connectedness_t mode
);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  First half of the result will be stored here. For
       every vertex the id of its component is given. The vector
       has to be preinitialized and will be resized. Alternatively
       this argument can be <code class="constant">NULL</code>, in which case it is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>csize</code></em>:</span></p></td>
<td><p>
  The second half of the result. For every component it
       gives its size, the order is defined by the component ids.
       The vector has to be preinitialized and will be resized.
       Alternatively this argument can be <code class="constant">NULL</code>, in which
       case it is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> then the number of
       clusters will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graph this specifies whether to calculate
       weakly or strongly connected components. Possible values:
       <code class="constant">IGRAPH_WEAK</code>,
       <code class="constant">IGRAPH_STRONG</code>. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid mode argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|),
|V| and
|E| are the number of vertices and
edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_clusters"></a>8.3. <code class="function">igraph_clusters</code> —  Calculates the (weakly or strongly) connected components in a graph (deprecated alias).</h3></div></div></div>
<a class="indexterm" name="id-1.14.10.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_clusters(const igraph_t *graph, igraph_vector_int_t *membership,
                    igraph_vector_int_t *csize, igraph_integer_t *no,
                    igraph_connectedness_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.10. Please do not use this function in new
code; use <a class="link" href="igraph-Structural.html#igraph_connected_components" title="8.2. igraph_connected_components — Calculates the (weakly or strongly) connected components in a graph."><code class="function">igraph_connected_components()</code></a>
instead.</p>
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_connected"></a>8.4. <code class="function">igraph_is_connected</code> —  Decides whether the graph is (weakly or strongly) connected.</h3></div></div></div>
<a class="indexterm" name="id-1.14.10.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_connected(const igraph_t *graph, igraph_bool_t *res,
                        igraph_connectedness_t mode);
</pre></div>
<p>
</p>
<p>




A graph is considered connected when any of its vertices is reachable
from any other. A directed graph with this property is called
<span class="emphasis"><em>strongly</em></span> connected. A directed graph that would be connected when
ignoring the directions of its edges is called <span class="emphasis"><em>weakly</em></span> connected.

</p>
<p>
A graph with zero vertices (i.e. the null graph) is <span class="emphasis"><em>not</em></span> connected by
definition. This behaviour changed in igraph 0.9; earlier versions assumed
that the null graph is connected. See the following issue on Github for the
argument that led us to change the definition:
<a class="ulink" href="https://github.com/igraph/igraph/issues/1539" target="_top">https://github.com/igraph/igraph/issues/1539</a>

</p>
<p>
The return value of this function is cached in the graph itself, separately
for weak and strong connectivity. Calling the function multiple times with
no modifications to the graph in between will return a cached value in O(1)
time.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a logical variable, the result will be stored
       here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For a directed graph this specifies whether to calculate
       weak or strong connectedness. Possible values:
       <code class="constant">IGRAPH_WEAK</code>,
       <code class="constant">IGRAPH_STRONG</code>. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_EINVAL</code>: invalid mode argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the
number of vertices
plus the number of edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_decompose"></a>8.5. <code class="function">igraph_decompose</code> —  Decomposes a graph into connected components.</h3></div></div></div>
<a class="indexterm" name="id-1.14.10.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_decompose(const igraph_t *graph, igraph_graph_list_t *components,
                     igraph_connectedness_t mode,
                     igraph_integer_t maxcompno, igraph_integer_t minelements);
</pre></div>
<p>
</p>
<p>



Creates a separate graph for each component of a graph. Note that the
vertex IDs in the new graphs will be different than in the original
graph, except when there is only a single component in the original graph.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The original graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>components</code></em>:</span></p></td>
<td><p>
  This list of graphs will contain the individual components.
  It should be initialized before calling this function and will be resized
  to hold the graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Either <code class="constant">IGRAPH_WEAK</code> or <code class="constant">IGRAPH_STRONG</code> for weakly
   and strongly connected components respectively.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maxcompno</code></em>:</span></p></td>
<td><p>
  The maximum number of components to return. The
   first <em class="parameter"><code>maxcompno</code></em> components will be returned (which hold at
   least <em class="parameter"><code>minelements</code></em> vertices, see the next parameter), the
   others will be ignored. Supply -1 here if you don't want to limit
   the number of components.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>minelements</code></em>:</span></p></td>
<td><p>
  The minimum number of vertices a component
   should contain in order to place it in the <em class="parameter"><code>components</code></em>
   vector. Eg. supply 2 here to ignore isolated vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, <code class="constant">IGRAPH_ENOMEM</code> if there is not enough memory
  to perform the operation.
  </p></td>
</tr></tbody>
</table></div>
<p>

Added in version 0.2.</p>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.10.6.9.1"></a><p class="title"><b>Example 13.12.  File <code class="code">examples/simple/igraph_decompose.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t ring, g, *component;
    igraph_graph_list_t complist;
    igraph_integer_t i;
    igraph_integer_t edges[] = { 0, 1, 1, 2, 2, 0,
                              3, 4, 4, 5, 5, 6,
                              8, 9, 9, 10
                            };
    igraph_vector_int_t v;

    <span class="strong"><strong>igraph_graph_list_init</strong></span>(&amp;complist, 0);

    <span class="emphasis"><em>/* A ring, a single component */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.11. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;ring, 10, IGRAPH_UNDIRECTED, 0, 1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_decompose" title="8.5. igraph_decompose — Decomposes a graph into connected components.">igraph_decompose</a></strong></span>(&amp;ring, &amp;complist, IGRAPH_WEAK, -1, 0);
    component = <span class="strong"><strong>igraph_graph_list_get_ptr</strong></span>(&amp;complist, 0);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(component, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring);
    <span class="strong"><strong>igraph_graph_list_clear</strong></span>(&amp;complist);

    <span class="emphasis"><em>/* Random graph with a giant component */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game" title="2.3. igraph_erdos_renyi_game — Generates a random (Erdős-Rényi) graph.">igraph_erdos_renyi_game</a></strong></span>(&amp;g, IGRAPH_ERDOS_RENYI_GNP, 100, 4.0 / 100,
                            IGRAPH_UNDIRECTED, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_decompose" title="8.5. igraph_decompose — Decomposes a graph into connected components.">igraph_decompose</a></strong></span>(&amp;g, &amp;complist, IGRAPH_WEAK, -1, 20);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_graph_list_size</strong></span>(&amp;complist) != 1) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>igraph_graph_list_clear</strong></span>(&amp;complist);

    <span class="emphasis"><em>/* A toy graph, three components maximum, with at least 2 vertices each */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_create" title="1.1. igraph_create — Creates a graph with the specified edges.">igraph_create</a></strong></span>(&amp;g,
                  <span class="strong"><strong>igraph_vector_int_view</strong></span>(&amp;v, edges, <span class="strong"><strong>sizeof</strong></span>(edges) / <span class="strong"><strong>sizeof</strong></span>(edges[0])),
                  0, IGRAPH_DIRECTED);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_decompose" title="8.5. igraph_decompose — Decomposes a graph into connected components.">igraph_decompose</a></strong></span>(&amp;g, &amp;complist, IGRAPH_WEAK, 3, 2);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_graph_list_size</strong></span>(&amp;complist); i++) {
        component = <span class="strong"><strong>igraph_graph_list_get_ptr</strong></span>(&amp;complist, i);
        <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(component, stdout);
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>igraph_graph_list_destroy</strong></span>(&amp;complist);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_decompose_destroy"></a>8.6. <code class="function">igraph_decompose_destroy</code> —  Frees the contents of a pointer vector holding graphs.</h3></div></div></div>
<a class="indexterm" name="id-1.14.10.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_decompose_destroy(igraph_vector_ptr_t *complist);
</pre></div>
<p>
</p>
<p>



This function destroys and frees all <span class="type">igraph_t</span>
objects held in <em class="parameter"><code>complist</code></em>. However, it does not destroy
<em class="parameter"><code>complist</code></em> itself. Use <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.17.3. igraph_vector_ptr_destroy — Destroys a pointer vector."><code class="function">igraph_vector_ptr_destroy()</code></a> to destroy
<em class="parameter"><code>complist</code></em>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>complist</code></em>:</span></p></td>
<td><p>
  The list of graphs to destroy.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(n), n is the number of items.

</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.10.0. Please do not use this function in new
code.</p>
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_biconnected_components"></a>8.7. <code class="function">igraph_biconnected_components</code> —  Calculates biconnected components.</h3></div></div></div>
<a class="indexterm" name="id-1.14.10.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_biconnected_components(const igraph_t *graph,
                                  igraph_integer_t *no,
                                  igraph_vector_int_list_t *tree_edges,
                                  igraph_vector_int_list_t *component_edges,
                                  igraph_vector_int_list_t *components,
                                  igraph_vector_int_t *articulation_points);
</pre></div>
<p>
</p>
<p>



A graph is biconnected if the removal of any single vertex (and
its incident edges) does not disconnect it.

</p>
<p>
A biconnected component of a graph is a maximal biconnected
subgraph of it. The biconnected components of a graph can be given
by the partition of its edges: every edge is a member of exactly
one biconnected component. Note that this is not true for
vertices: the same vertex can be part of many biconnected
components.

</p>
<p>
Note that some authors do not consider the graph consisting of
two connected vertices as biconnected, however, igraph does.

</p>
<p>
Somewhat arbitrarily, igraph does not consider components containing
a single vertex only as being biconnected. Isolated vertices will
not be part of any of the biconnected components.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no</code></em>:</span></p></td>
<td><p>
  If not a NULL pointer, the number of biconnected components will
    be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>tree_edges</code></em>:</span></p></td>
<td><p>
  If not a NULL pointer, then the found components
    are stored here, in a list of vectors. Every vector in the list
    is a biconnected component, represented by its edges. More precisely,
    a spanning tree of the biconnected component is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>component_edges</code></em>:</span></p></td>
<td><p>
  If not a NULL pointer, then the edges of the
    biconnected components are stored here, in the same form as for
    <code class="constant">tree_edges</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>components</code></em>:</span></p></td>
<td><p>
  If not a NULL pointer, then the vertices of the
    biconnected components are stored here, in the same format as
    for the previous two arguments.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>articulation_points</code></em>:</span></p></td>
<td><p>
  If not a NULL pointer, then the
    articulation points of the graph are stored in this vector.
    A vertex is an articulation point if its removal increases the
    number of (weakly) connected components in the graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges, but only if you do not calculate <code class="constant">components</code> and
<code class="constant">component_edges</code>. If you calculate <code class="constant">components</code>, then it is
quadratic in the number of vertices. If you calculate <code class="constant">component_edges</code> as well, then it is cubic in the number of
vertices.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_articulation_points" title="8.8. igraph_articulation_points — Finds the articulation points in a graph."><code class="function">igraph_articulation_points()</code></a>, <a class="link" href="igraph-Structural.html#igraph_clusters" title="8.3. igraph_clusters — Calculates the (weakly or strongly) connected components in a graph (deprecated alias)."><code class="function">igraph_clusters()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.10.8.13.1"></a><p class="title"><b>Example 13.13.  File <code class="code">examples/simple/igraph_biconnected_components.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

void <span class="strong"><strong>sort_and_print_vector</strong></span>(igraph_vector_int_t *v) {
    igraph_integer_t i, n = <span class="strong"><strong>igraph_vector_int_size</strong></span>(v);
    <span class="strong"><strong>igraph_vector_int_sort</strong></span>(v);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>printf</strong></span>(" %" IGRAPH_PRId, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i]);
    }
    <span class="strong"><strong>printf</strong></span>("\n");
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_vector_int_list_t result;
    igraph_integer_t no;
    igraph_integer_t i;

    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_warning_handler" title="4.2. igraph_set_warning_handler — Installs a warning handler.">igraph_set_warning_handler</a></strong></span>(<a class="link" href="igraph-Error.html#igraph_warning_handler_ignore" title="4.7. igraph_warning_handler_ignore — Ignores all warnings.">igraph_warning_handler_ignore</a>);

    <span class="strong"><strong>igraph_vector_int_list_init</strong></span>(&amp;result, 0);
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 7, 0, 0, 1, 1, 2, 2, 3, 3, 0, 2, 4, 4, 5, 2, 5, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_biconnected_components" title="8.7. igraph_biconnected_components — Calculates biconnected components.">igraph_biconnected_components</a></strong></span>(&amp;g, &amp;no, 0, 0, &amp;result, 0);
    <span class="strong"><strong>if</strong></span> (no != 2 || no != <span class="strong"><strong>igraph_vector_int_list_size</strong></span>(&amp;result)) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; no; i++) {
        <span class="strong"><strong>sort_and_print_vector</strong></span>(<span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(&amp;result, i));
    }
    <span class="strong"><strong>igraph_vector_int_list_clear</strong></span>(&amp;result);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_biconnected_components" title="8.7. igraph_biconnected_components — Calculates biconnected components.">igraph_biconnected_components</a></strong></span>(&amp;g, &amp;no, 0, &amp;result, 0, 0);
    <span class="strong"><strong>if</strong></span> (no != 2 || no != <span class="strong"><strong>igraph_vector_int_list_size</strong></span>(&amp;result)) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; no; i++) {
        <span class="strong"><strong>sort_and_print_vector</strong></span>(<span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(&amp;result, i));
    }
    <span class="strong"><strong>igraph_vector_int_list_clear</strong></span>(&amp;result);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_biconnected_components" title="8.7. igraph_biconnected_components — Calculates biconnected components.">igraph_biconnected_components</a></strong></span>(&amp;g, &amp;no, &amp;result, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (no != 2 || no != <span class="strong"><strong>igraph_vector_int_list_size</strong></span>(&amp;result)) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; no; i++) {
        <span class="strong"><strong>sort_and_print_vector</strong></span>(<span class="strong"><strong>igraph_vector_int_list_get_ptr</strong></span>(&amp;result, i));
    }

    <span class="strong"><strong>igraph_vector_int_list_destroy</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_articulation_points"></a>8.8. <code class="function">igraph_articulation_points</code> —  Finds the articulation points in a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.10.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_articulation_points(const igraph_t *graph, igraph_vector_int_t *res);
</pre></div>
<p>
</p>
<p>



A vertex is an articulation point if its removal increases
the number of connected components in the graph.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the
   articulation points will be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_biconnected_components" title="8.7. igraph_biconnected_components — Calculates biconnected components."><code class="function">igraph_biconnected_components()</code></a>, <a class="link" href="igraph-Structural.html#igraph_clusters" title="8.3. igraph_clusters — Calculates the (weakly or strongly) connected components in a graph (deprecated alias)."><code class="function">igraph_clusters()</code></a>, <a class="link" href="igraph-Structural.html#igraph_bridges" title="8.9. igraph_bridges — Finds all bridges in a graph."><code class="function">igraph_bridges()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bridges"></a>8.9. <code class="function">igraph_bridges</code> —  Finds all bridges in a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.10.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_bridges(const igraph_t *graph, igraph_vector_int_t *bridges);
</pre></div>
<p>
</p>
<p>



An edge is a bridge if its removal increases the number of (weakly)
connected components in the graph.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It will be treated as undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the
   bridges will be stored here as edge indices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_articulation_points" title="8.8. igraph_articulation_points — Finds the articulation points in a graph."><code class="function">igraph_articulation_points()</code></a>, <a class="link" href="igraph-Structural.html#igraph_biconnected_components" title="8.7. igraph_biconnected_components — Calculates biconnected components."><code class="function">igraph_biconnected_components()</code></a>, <a class="link" href="igraph-Structural.html#igraph_clusters" title="8.3. igraph_clusters — Calculates the (weakly or strongly) connected components in a graph (deprecated alias)."><code class="function">igraph_clusters()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="degree-sequences"></a>9. Degree sequences</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_graphical">9.1. <code class="function">igraph_is_graphical</code> —  Is there a graph with the given degree sequence?</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_bigraphical">9.2. <code class="function">igraph_is_bigraphical</code> —  Is there a bipartite graph with the given bi-degree-sequence?</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_graphical"></a>9.1. <code class="function">igraph_is_graphical</code> —  Is there a graph with the given degree sequence?</h3></div></div></div>
<a class="indexterm" name="id-1.14.11.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_graphical(const igraph_vector_int_t *out_degrees,
                        const igraph_vector_int_t *in_degrees,
                        const igraph_edge_type_sw_t allowed_edge_types,
                        igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>



Determines whether a sequence of integers can be the degree sequence of some graph.
The classical concept of graphicality assumes simple graphs. This function can perform
the check also when either self-loops, multi-edge, or both are allowed in the graph.

</p>
<p>
For simple undirected graphs, the Erdős-Gallai conditions are checked using the linear-time
algorithm of Cloteaux. If both self-loops and multi-edges are allowed,
it is sufficient to chek that that sum of degrees is even. If only multi-edges are allowed, but
not self-loops, there is an additional condition that the sum of degrees be no smaller than twice
the maximum degree. If at most one self-loop is allowed per vertex, but no multi-edges, a modified
version of the Erdős-Gallai conditions are used (see Cairns &amp; Mendan).

</p>
<p>
For simple directed graphs, the Fulkerson-Chen-Anstee theorem is used with the relaxation by Berger.
If both self-loops and multi-edges are allowed, then it is sufficient to check that the sum of
in- and out-degrees is the same. If only multi-edges are allowed, but not self loops, there is an
additional condition that the sum of out-degrees (or equivalently, in-degrees) is no smaller than
the maximum total degree. If single self-loops are allowed, but not multi-edges, the problem is equivalent
to realizability as a simple bipartite graph, thus the Gale-Ryser theorem can be used; see
<a class="link" href="igraph-Structural.html#igraph_is_bigraphical" title="9.2. igraph_is_bigraphical — Is there a bipartite graph with the given bi-degree-sequence?"><code class="function">igraph_is_bigraphical()</code></a> for more information.

</p>
<p>
References:

</p>
<p>
P. Erdős and T. Gallai, Gráfok előírt fokú pontokkal, Matematikai Lapok 11, pp. 264–274 (1960).
<a class="ulink" href="https://users.renyi.hu/~p_erdos/1961-05.pdf" target="_top">https://users.renyi.hu/~p_erdos/1961-05.pdf</a>

</p>
<p>
Z Király, Recognizing graphic degree sequences and generating all realizations.
TR-2011-11, Egerváry Research Group, H-1117, Budapest, Hungary. ISSN 1587-4451 (2012).
<a class="ulink" href="http://bolyai.cs.elte.hu/egres/tr/egres-11-11.pdf" target="_top">http://bolyai.cs.elte.hu/egres/tr/egres-11-11.pdf</a>

</p>
<p>
B. Cloteaux, Is This for Real? Fast Graphicality Testing, Comput. Sci. Eng. 17, 91 (2015).
<a class="ulink" href="https://dx.doi.org/10.1109/MCSE.2015.125" target="_top">https://dx.doi.org/10.1109/MCSE.2015.125</a>

</p>
<p>
A. Berger, A note on the characterization of digraphic sequences, Discrete Math. 314, 38 (2014).
<a class="ulink" href="https://dx.doi.org/10.1016/j.disc.2013.09.010" target="_top">https://dx.doi.org/10.1016/j.disc.2013.09.010</a>

</p>
<p>
G. Cairns and S. Mendan, Degree Sequence for Graphs with Loops (2013).
<a class="ulink" href="https://arxiv.org/abs/1303.2145v1" target="_top">https://arxiv.org/abs/1303.2145v1</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>out_degrees</code></em>:</span></p></td>
<td><p>
  A vector of integers specifying the degree sequence for
    undirected graphs or the out-degree sequence for directed graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>in_degrees</code></em>:</span></p></td>
<td><p>
  A vector of integers specifying the in-degree sequence for
    directed graphs. For undirected graphs, it must be <code class="constant">NULL</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>allowed_edge_types</code></em>:</span></p></td>
<td>
<p>
  The types of edges to allow in the graph:
    </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_SIMPLE_SW</code></span></p></td>
<td><p>

      simple graphs (i.e. no self-loops or multi-edges allowed).
    
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LOOPS_SW</code></span></p></td>
<td><p>

      single self-loops are allowed, but not multi-edges.
    
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_MULTI_SW</code></span></p></td>
<td><p>

      multi-edges are allowed, but not self-loops.
    
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LOOPS_SW | IGRAPH_MULTI_SW</code></span></p></td>
<td><p>

      both self-loops and multi-edges are allowed.
    
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a Boolean. The result will be stored here.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_bigraphical" title="9.2. igraph_is_bigraphical — Is there a bipartite graph with the given bi-degree-sequence?"><code class="function">igraph_is_bigraphical()</code></a> to check if a bi-degree-sequence can be realized as a bipartite graph;
<a class="link" href="igraph-Generators.html#igraph_realize_degree_sequence" title="1.19. igraph_realize_degree_sequence — Generates a graph with the given degree sequence."><code class="function">igraph_realize_degree_sequence()</code></a> to construct a graph with a given degree sequence.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n^2) for simple directed graphs, O(n log n) for graphs with self-loops,
and O(n) for all other cases, where n is the length of the degree sequence(s).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_bigraphical"></a>9.2. <code class="function">igraph_is_bigraphical</code> —  Is there a bipartite graph with the given bi-degree-sequence?</h3></div></div></div>
<a class="indexterm" name="id-1.14.11.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_bigraphical(const igraph_vector_int_t *degrees1,
                          const igraph_vector_int_t *degrees2,
                          const igraph_edge_type_sw_t allowed_edge_types,
                          igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>



Determines whether two sequences of integers can be the degree sequences of
a bipartite graph. Such a pair of degree sequence is called <span class="emphasis"><em>bigraphical.</em></span>

</p>
<p>
When multi-edges are allowed, it is sufficient to check that the sum of degrees is the
same in the two partitions. For simple graphs, the Gale-Ryser theorem is used
with Berger's relaxation.

</p>
<p>
References:

</p>
<p>
H. J. Ryser, Combinatorial Properties of Matrices of Zeros and Ones, Can. J. Math. 9, 371 (1957).
<a class="ulink" href="https://dx.doi.org/10.4153/cjm-1957-044-3" target="_top">https://dx.doi.org/10.4153/cjm-1957-044-3</a>

</p>
<p>
D. Gale, A theorem on flows in networks, Pacific J. Math. 7, 1073 (1957).
<a class="ulink" href="https://dx.doi.org/10.2140/pjm.1957.7.1073" target="_top">https://dx.doi.org/10.2140/pjm.1957.7.1073</a>

</p>
<p>
A. Berger, A note on the characterization of digraphic sequences, Discrete Math. 314, 38 (2014).
<a class="ulink" href="https://dx.doi.org/10.1016/j.disc.2013.09.010" target="_top">https://dx.doi.org/10.1016/j.disc.2013.09.010</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>degrees1</code></em>:</span></p></td>
<td><p>
  A vector of integers specifying the degrees in the first partition
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>degrees2</code></em>:</span></p></td>
<td><p>
  A vector of integers specifying the degrees in the second partition
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>allowed_edge_types</code></em>:</span></p></td>
<td>
<p>
  The types of edges to allow in the graph:
    </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_SIMPLE_SW</code></span></p></td>
<td><p>

      simple graphs (i.e. no multi-edges allowed).
    
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_MULTI_SW</code></span></p></td>
<td><p>

      multi-edges are allowed.
    
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a Boolean. The result will be stored here.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_graphical" title="9.1. igraph_is_graphical — Is there a graph with the given degree sequence?"><code class="function">igraph_is_graphical()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n log n) for simple graphs, O(n) for multigraphs,
where n is the length of the larger degree sequence.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="centrality-measures"></a>10. Centrality measures</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_closeness">10.1. <code class="function">igraph_closeness</code> —  Closeness centrality calculations for some vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_harmonic_centrality">10.2. <code class="function">igraph_harmonic_centrality</code> —  Harmonic centrality for some vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_betweenness">10.3. <code class="function">igraph_betweenness</code> —  Betweenness centrality of some vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_edge_betweenness">10.4. <code class="function">igraph_edge_betweenness</code> —  Betweenness centrality of the edges.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_pagerank_algo_t">10.5. <code class="function">igraph_pagerank_algo_t</code> —  PageRank algorithm implementation</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_pagerank">10.6. <code class="function">igraph_pagerank</code> —  Calculates the Google PageRank for the specified vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_personalized_pagerank">10.7. <code class="function">igraph_personalized_pagerank</code> —  Calculates the personalized Google PageRank for the specified vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_personalized_pagerank_vs">10.8. <code class="function">igraph_personalized_pagerank_vs</code> —  Calculates the personalized Google PageRank for the specified vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_constraint">10.9. <code class="function">igraph_constraint</code> —  Burt's constraint scores.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_maxdegree">10.10. <code class="function">igraph_maxdegree</code> —  The maximum degree in a graph (or set of vertices).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_strength">10.11. <code class="function">igraph_strength</code> —  Strength of the vertices, also called weighted vertex degree.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_eigenvector_centrality">10.12. <code class="function">igraph_eigenvector_centrality</code> —  Eigenvector centrality of the vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_hub_score">10.13. <code class="function">igraph_hub_score</code> —  Kleinberg's hub scores.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_authority_score">10.14. <code class="function">igraph_authority_score</code> —  Kleinerg's authority scores.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_convergence_degree">10.15. <code class="function">igraph_convergence_degree</code> —  Calculates the convergence degree of each edge in a graph.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_closeness"></a>10.1. <code class="function">igraph_closeness</code> —  Closeness centrality calculations for some vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_closeness(const igraph_t *graph, igraph_vector_t *res,
                     igraph_vector_int_t *reachable_count, igraph_bool_t *all_reachable,
                     const igraph_vs_t vids, igraph_neimode_t mode,
                     const igraph_vector_t *weights,
                     igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>




The closeness centrality of a vertex measures how easily other
vertices can be reached from it (or the other way: how easily it
can be reached from the other vertices). It is defined as
the inverse of the mean distance to (or from) all other vertices.

</p>
<p>
Closeness centrality is meaningful only for connected graphs.
If the graph is not connected, igraph computes the inverse of the
mean distance to (or from) all <span class="emphasis"><em>reachable</em></span> vertices. In undirected
graphs, this is equivalent to computing the closeness separately in
each connected component. The optional <em class="parameter"><code>all_reachable</code></em> output
parameter is provided to help detect when the graph is disconnected.

</p>
<p>
While there is no universally adopted definition of closeness centrality
for disconnected graphs, there have been some attempts for generalizing
the concept to the disconnected case. One type of approach considers the mean distance
only to reachable vertices, then re-scales the obtained certrality score
by a factor that depends on the number of reachable vertices
(i.e. the size of the component in the undirected case).
To facilitate computing these generalizations of closeness centrality,
the number of reachable vertices (not including the starting vertex)
is returned in <em class="parameter"><code>reachable_count</code></em>.

</p>
<p>
In disconnected graphs, consider using the harmonic centrality,
computable using <a class="link" href="igraph-Structural.html#igraph_harmonic_centrality" title="10.2. igraph_harmonic_centrality — Harmonic centrality for some vertices."><code class="function">igraph_harmonic_centrality()</code></a>.

</p>
<p>
For isolated vertices, i.e. those having no associated paths, NaN is returned.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
       closeness centrality scores for the given vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>reachable_count</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code>, this vector will contain the number of
       vertices reachable from each vertex for which the closeness is calculated
       (not including that vertex).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>all_reachable</code></em>:</span></p></td>
<td><p>
  Pointer to a Boolean. If not <code class="constant">NULL</code>, it indicates if all
       vertices of the graph were reachable from each vertex in <em class="parameter"><code>vids</code></em>.
       If false, the graph is non-connected. If true, and the graph is undirected,
       or if the graph is directed and <em class="parameter"><code>vids</code></em> contains all vertices, then the
       graph is connected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the closeness centrality will be computed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the lengths of the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the lengths of the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       weighted closeness. No edge weight may be NaN. Supply a null
       pointer here for traditional, unweighted closeness.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  If true, the inverse of the mean distance to reachable
       vetices is returned. If false, the inverse of the sum of distances
       is returned.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex ID passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n|E|),
n is the number
of vertices for which the calculation is done and
|E| is the number
of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Other centrality types: <a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a>, <a class="link" href="igraph-Structural.html#igraph_betweenness" title="10.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a>,
  <a class="link" href="igraph-Structural.html#igraph_harmonic_centrality" title="10.2. igraph_harmonic_centrality — Harmonic centrality for some vertices."><code class="function">igraph_harmonic_centrality()</code></a>.
  See <a class="link" href="igraph-Structural.html#igraph_closeness_cutoff" title="11.1. igraph_closeness_cutoff — Range limited closeness centrality."><code class="function">igraph_closeness_cutoff()</code></a> for the range-limited closeness centrality.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_harmonic_centrality"></a>10.2. <code class="function">igraph_harmonic_centrality</code> —  Harmonic centrality for some vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_harmonic_centrality(const igraph_t *graph, igraph_vector_t *res,
                               const igraph_vs_t vids, igraph_neimode_t mode,
                               const igraph_vector_t *weights,
                               igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>




The harmonic centrality of a vertex is the mean inverse distance to
all other vertices. The inverse distance to an unreachable vertex
is considered to be zero.

</p>
<p>
References:

</p>
<p>
M. Marchiori and V. Latora, Harmony in the small-world, Physica A 285, pp. 539-546 (2000).
<a class="ulink" href="https://doi.org/10.1016/S0378-4371%2800%2900311-3" target="_top">https://doi.org/10.1016/S0378-4371%2800%2900311-3</a>

</p>
<p>
Y. Rochat, Closeness Centrality Extended to Unconnected Graphs: the Harmonic Centrality Index, ASNA 2009.
<a class="ulink" href="https://infoscience.epfl.ch/record/200525" target="_top">https://infoscience.epfl.ch/record/200525</a>

</p>
<p>
S. Vigna and P. Boldi, Axioms for Centrality, Internet Mathematics 10, (2014).
<a class="ulink" href="https://doi.org/10.1080/15427951.2013.865686" target="_top">https://doi.org/10.1080/15427951.2013.865686</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
       harmonic centrality scores for the given vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the harmonic centrality will be computed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the lengths of the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the lengths of the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       weighted harmonic centrality. No edge weight may be NaN.
       If <code class="constant">NULL</code>, all weights are considered to be one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to normalize the result. If true,
       the result is the mean inverse path length to other vertices,
       i.e. it is normalized by the number of vertices minus one.
       If false, the result is the sum of inverse path lengths to other
       vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex ID passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n|E|), where
n is the numberof vertices for which the calculation is done and
|E| is the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Other centrality types: <a class="link" href="igraph-Structural.html#igraph_closeness" title="10.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a>, <a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a>, <a class="link" href="igraph-Structural.html#igraph_betweenness" title="10.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_betweenness"></a>10.3. <code class="function">igraph_betweenness</code> —  Betweenness centrality of some vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_betweenness(const igraph_t *graph, igraph_vector_t *res,
                       const igraph_vs_t vids, igraph_bool_t directed,
                       const igraph_vector_t* weights);
</pre></div>
<p>
</p>
<p>




The betweenness centrality of a vertex is the number of geodesics
going through it. If there are more than one geodesic between two
vertices, the value of these geodesics are weighted by one over the
number of geodesics.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
       betweenness scores for the specified vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices of which the betweenness centrality scores
       will be calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, if true directed paths will be considered
       for directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       calculating weighted betweenness. No edge weight may be NaN.
       Supply a null pointer here for unweighted betweenness.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
       temporary data.
       <code class="constant">IGRAPH_EINVVID</code>, invalid vertex ID passed in
       <em class="parameter"><code>vids</code></em>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|),
|V| and
|E| are the number of vertices and
edges in the graph.
Note that the time complexity is independent of the number of
vertices for which the score is calculated.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Other centrality types: <a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a>, <a class="link" href="igraph-Structural.html#igraph_closeness" title="10.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a>.
    See <a class="link" href="igraph-Structural.html#igraph_edge_betweenness" title="10.4. igraph_edge_betweenness — Betweenness centrality of the edges."><code class="function">igraph_edge_betweenness()</code></a> for calculating the betweenness score
    of the edges in a graph. See <a class="link" href="igraph-Structural.html#igraph_betweenness_cutoff" title="11.3. igraph_betweenness_cutoff — Range-limited betweenness centrality."><code class="function">igraph_betweenness_cutoff()</code></a> to
    calculate the range-limited betweenness of the vertices in a graph.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_edge_betweenness"></a>10.4. <code class="function">igraph_edge_betweenness</code> —  Betweenness centrality of the edges.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_edge_betweenness(const igraph_t *graph, igraph_vector_t *result,
                            igraph_bool_t directed,
                            const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The betweenness centrality of an edge is the number of geodesics
going through it. If there are more than one geodesics between two
vertices, the value of these geodesics are weighted by one over the
number of geodesics.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  The result of the computation, vector containing the
       betweenness scores for the edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, if true directed paths will be considered
       for directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional weight vector for weighted edge
       betweenness. No edge weight may be NaN. Supply a null
       pointer here for the unweighted version.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
       temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|),
|V| and
|E| are the number of vertices and
edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Other centrality types: <a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a>, <a class="link" href="igraph-Structural.html#igraph_closeness" title="10.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a>.
    See <a class="link" href="igraph-Structural.html#igraph_edge_betweenness" title="10.4. igraph_edge_betweenness — Betweenness centrality of the edges."><code class="function">igraph_edge_betweenness()</code></a> for calculating the betweenness score
    of the edges in a graph. See <a class="link" href="igraph-Structural.html#igraph_edge_betweenness_cutoff" title="11.4. igraph_edge_betweenness_cutoff — Range-limited betweenness centrality of the edges."><code class="function">igraph_edge_betweenness_cutoff()</code></a> to
    compute the range-limited betweenness score of the edges in a graph.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_pagerank_algo_t"></a>10.5. <code class="function">igraph_pagerank_algo_t</code> —  PageRank algorithm implementation</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.6.2"></a><p>
</p>
<pre class="programlisting">
typedef enum {
    IGRAPH_PAGERANK_ALGO_ARPACK = 1,
    IGRAPH_PAGERANK_ALGO_PRPACK = 2
} igraph_pagerank_algo_t;
</pre>
<p>
</p>
<p>


Algorithms to calculate PageRank.
</p>
<p><b>Values: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_PAGERANK_ALGO_ARPACK</code>:</span></p></td>
<td><p>
  Use the ARPACK library, this
  was the PageRank implementation in igraph from version 0.5, until
  version 0.7.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_PAGERANK_ALGO_PRPACK</code>:</span></p></td>
<td><p>
  Use the PRPACK
  library. Currently this implementation is recommended.</p></td>
</tr>
</tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_pagerank"></a>10.6. <code class="function">igraph_pagerank</code> —  Calculates the Google PageRank for the specified vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_pagerank(const igraph_t *graph, igraph_pagerank_algo_t algo,
                    igraph_vector_t *vector,
                    igraph_real_t *value, const igraph_vs_t vids,
                    igraph_bool_t directed, igraph_real_t damping,
                    const igraph_vector_t *weights, igraph_arpack_options_t *options);
</pre></div>
<p>
</p>
<p>



The PageRank centrality of a vertex is the fraction of time a
random walker traversing the graph would spend on that vertex.
The walker follows the out-edges with probabilities proportional
to their weights. Additionally, in each step, it restarts the walk
from a random vertex with probability <code class="literal">1 - damping</code>.
If the random walker gets stuck in a sink vertex, it will also restart
from a random vertex.

</p>
<p>
The PageRank centrality is mainly useful for directed graphs. In undirected
graphs it converges to trivial values proportional to degrees as the damping
factor approaches 1.

</p>
<p>
Starting from version 0.9, igraph has two PageRank implementations,
and the user can choose between them. The first implementation is
<code class="constant">IGRAPH_PAGERANK_ALGO_ARPACK</code>, based on the ARPACK library. This
was the default before igraph version 0.7. The second and recommended
implementation is <code class="constant">IGRAPH_PAGERANK_ALGO_PRPACK</code>. This is using the
PRPACK package, see <a class="ulink" href="https://github.com/dgleich/prpack" target="_top">https://github.com/dgleich/prpack</a> .

</p>
<p>
Note that the PageRank of a given vertex depends on the PageRank
of all other vertices, so even if you want to calculate the PageRank for
only some of the vertices, all of them must be calculated. Requesting
the PageRank for only some of the vertices does not result in any
performance increase at all.

</p>
<p>
References:

</p>
<p>
Sergey Brin and Larry Page: The Anatomy of a Large-Scale Hypertextual
Web Search Engine. Proceedings of the 7th World-Wide Web Conference,
Brisbane, Australia, April 1998.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td><p>
  The PageRank implementation to use. Possible values:
   <code class="constant">IGRAPH_PAGERANK_ALGO_ARPACK</code>, <code class="constant">IGRAPH_PAGERANK_ALGO_PRPACK</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is
   stored here. It is resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the eigenvalue
   corresponding to the PageRank vector is stored here. It should
   be always exactly one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex IDs for which the PageRank is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider the directedness of
   the edges. This is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>damping</code></em>:</span></p></td>
<td><p>
  The damping factor ("d" in the original paper).
   Must be a probability in the range [0, 1]. A commonly used value is 0.85.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Optional edge weights. May be a <code class="constant">NULL</code> pointer,
   meaning unweighted edges, or a vector of non-negative values
   of the same length as the number of edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options for the ARPACK method. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Supply <code class="constant">NULL</code> here to use the defaults. Note that the function
   overwrites the <code class="literal">n</code> (number of vertices), <code class="literal">nev</code> (1),
   <code class="literal">ncv</code> (3) and <code class="literal">which</code> (LM) parameters and it always
   starts the calculation from a non-random vector calculated based on the
   degree of the vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for temporary data.
        <code class="constant">IGRAPH_EINVVID</code>, invalid vertex ID in <em class="parameter"><code>vids</code></em>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the input graph, usually it is O(|E|),
the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_personalized_pagerank" title="10.7. igraph_personalized_pagerank — Calculates the personalized Google PageRank for the specified vertices."><code class="function">igraph_personalized_pagerank()</code></a> and <a class="link" href="igraph-Structural.html#igraph_personalized_pagerank_vs" title="10.8. igraph_personalized_pagerank_vs — Calculates the personalized Google PageRank for the specified vertices."><code class="function">igraph_personalized_pagerank_vs()</code></a>
for the personalized PageRank measure. See <a class="link" href="igraph-Arpack.html#igraph_arpack_rssolve" title="3.2.1. igraph_arpack_rssolve — ARPACK solver for symmetric matrices."><code class="function">igraph_arpack_rssolve()</code></a> and
<a class="link" href="igraph-Arpack.html#igraph_arpack_rnsolve" title="3.2.2. igraph_arpack_rnsolve — ARPACK solver for non-symmetric matrices."><code class="function">igraph_arpack_rnsolve()</code></a> for the underlying machinery used by
<code class="constant">IGRAPH_PAGERANK_ALGO_ARPACK</code>.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.12.7.15.1"></a><p class="title"><b>Example 13.14.  File <code class="code">examples/simple/igraph_pagerank.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;float.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pagerank;
    igraph_real_t value;

    <span class="emphasis"><em>/* Create a directed graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_kautz" title="1.26. igraph_kautz — Generate a Kautz graph.">igraph_kautz</a></strong></span>(&amp;graph, 2, 3);

    <span class="emphasis"><em>/* Initialize the vector where the results will be stored */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pagerank, 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_pagerank" title="10.6. igraph_pagerank — Calculates the Google PageRank for the specified vertices.">igraph_pagerank</a></strong></span>(&amp;graph, IGRAPH_PAGERANK_ALGO_PRPACK,
                    &amp;pagerank, &amp;value,
                    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_DIRECTED,
                    <span class="emphasis"><em>/* damping */</em></span> 0.85, <span class="emphasis"><em>/* weights */</em></span> NULL,
                    NULL <span class="emphasis"><em>/* not needed with PRPACK method */</em></span>);

    <span class="emphasis"><em>/* Check that the eigenvalue is 1, as expected. */</em></span>
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(value - 1.0) &gt; 32*DBL_EPSILON) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "PageRank failed to converge.\n");
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="emphasis"><em>/* Output the result */</em></span>
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;pagerank);

    <span class="emphasis"><em>/* Destroy data structure when no longer needed */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pagerank);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_personalized_pagerank"></a>10.7. <code class="function">igraph_personalized_pagerank</code> —  Calculates the personalized Google PageRank for the specified vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_personalized_pagerank(const igraph_t *graph,
                                 igraph_pagerank_algo_t algo, igraph_vector_t *vector,
                                 igraph_real_t *value, const igraph_vs_t vids,
                                 igraph_bool_t directed, igraph_real_t damping,
                                 const igraph_vector_t *reset,
                                 const igraph_vector_t *weights,
                                 igraph_arpack_options_t *options);
</pre></div>
<p>
</p>
<p>



The personalized PageRank is similar to the original PageRank measure, but
when the random walk is restarted, a new starting vertex is chosen non-uniformly,
according to the distribution specified in <em class="parameter"><code>reset</code></em>
(instead of the uniform distribution in the original PageRank measure).
The <em class="parameter"><code>reset</code></em> distribution is used both when restarting randomly with probability
<code class="literal">1 - damping</code>, and when the walker is forced to restart due to being
stuck in a sink vertex (a vertex with no outgoing edges).

</p>
<p>
Note that the personalized PageRank of a given vertex depends on the
personalized PageRank of all other vertices, so even if you want to calculate
the personalized PageRank for only some of the vertices, all of them must be
calculated. Requesting the personalized PageRank for only some of the vertices
does not result in any performance increase at all.
</p>
<p>
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td><p>
  The PageRank implementation to use. Possible values:
   <code class="constant">IGRAPH_PAGERANK_ALGO_ARPACK</code>, <code class="constant">IGRAPH_PAGERANK_ALGO_PRPACK</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is
   stored here. It is resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the eigenvalue
   corresponding to the PageRank vector is stored here. It should
   be always exactly one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex IDs for which the PageRank is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider the directedness of
   the edges. This is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>damping</code></em>:</span></p></td>
<td><p>
  The damping factor ("d" in the original paper).
   Must be a probability in the range [0, 1]. A commonly used value is 0.85.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>reset</code></em>:</span></p></td>
<td><p>
  The probability distribution over the vertices used when
   resetting the random walk. It is either a <code class="constant">NULL</code> pointer (denoting
   a uniform choice that results in the original PageRank measure)
   or a vector of the same length as the number of vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Optional edge weights. May be a <code class="constant">NULL</code> pointer,
   meaning unweighted edges, or a vector of non-negative values
   of the same length as the number of edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options for the ARPACK method. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Supply <code class="constant">NULL</code> here to use the defaults. Note that the function
   overwrites the <code class="literal">n</code> (number of vertices), <code class="literal">nev</code> (1),
   <code class="literal">ncv</code> (3) and <code class="literal">which</code> (LM) parameters and it always
   starts the calculation from a non-random vector calculated based on the
   degree of the vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
        temporary data.
        <code class="constant">IGRAPH_EINVVID</code>, invalid vertex ID in
        <em class="parameter"><code>vids</code></em> or an invalid reset vector in <em class="parameter"><code>reset</code></em>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the input graph, usually it is O(|E|),
the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_pagerank" title="10.6. igraph_pagerank — Calculates the Google PageRank for the specified vertices."><code class="function">igraph_pagerank()</code></a> for the non-personalized implementation,
<a class="link" href="igraph-Structural.html#igraph_personalized_pagerank_vs" title="10.8. igraph_personalized_pagerank_vs — Calculates the personalized Google PageRank for the specified vertices."><code class="function">igraph_personalized_pagerank_vs()</code></a> for a personalized implementation
with resetting to specific vertices.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_personalized_pagerank_vs"></a>10.8. <code class="function">igraph_personalized_pagerank_vs</code> —  Calculates the personalized Google PageRank for the specified vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_personalized_pagerank_vs(const igraph_t *graph,
                                    igraph_pagerank_algo_t algo, igraph_vector_t *vector,
                                    igraph_real_t *value, const igraph_vs_t vids,
                                    igraph_bool_t directed, igraph_real_t damping,
                                    igraph_vs_t reset_vids,
                                    const igraph_vector_t *weights,
                                    igraph_arpack_options_t *options);
</pre></div>
<p>
</p>
<p>



The personalized PageRank is similar to the original PageRank measure, but
when the random walk is restarted, a new starting vertex is chosen according to
a specified distribution.
This distribution is used both when restarting randomly with probability
<code class="literal">1 - damping</code>, and when the walker is forced to restart due to being
stuck in a sink vertex (a vertex with no outgoing edges).

</p>
<p>
This simplified interface takes a vertex sequence and resets the random walk to
one of the vertices in the specified vertex sequence, chosen uniformly. A typical
application of personalized PageRank is when the random walk is reset to the same
vertex every time - this can easily be achieved using <a class="link" href="igraph-Iterators.html#igraph_vss_1" title="4.3. igraph_vss_1 — Vertex set with a single vertex (immediate version)."><code class="function">igraph_vss_1()</code></a> which
generates a vertex sequence containing only a single vertex.

</p>
<p>
Note that the personalized PageRank of a given vertex depends on the
personalized PageRank of all other vertices, so even if you want to calculate
the personalized PageRank for only some of the vertices, all of them must be
calculated. Requesting the personalized PageRank for only some of the vertices
does not result in any performance increase at all.
</p>
<p>
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td><p>
  The PageRank implementation to use. Possible values:
   <code class="constant">IGRAPH_PAGERANK_ALGO_ARPACK</code>, <code class="constant">IGRAPH_PAGERANK_ALGO_PRPACK</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is
   stored here. It is resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the eigenvalue
   corresponding to the PageRank vector is stored here. It should
   be always exactly one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex IDs for which the PageRank is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider the directedness of
   the edges. This is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>damping</code></em>:</span></p></td>
<td><p>
  The damping factor ("d" in the original paper).
   Must be a probability in the range [0, 1]. A commonly used value is 0.85.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>reset_vids</code></em>:</span></p></td>
<td><p>
  IDs of the vertices used when resetting the random walk.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Optional edge weights, it is either a null pointer,
   then the edges are not weighted, or a vector of the same length
   as the number of edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options for the ARPACK method. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Supply <code class="constant">NULL</code> here to use the defaults. Note that the function
   overwrites the <code class="literal">n</code> (number of vertices), <code class="literal">nev</code> (1),
   <code class="literal">ncv</code> (3) and <code class="literal">which</code> (LM) parameters and it always
   starts the calculation from a non-random vector calculated based on the
   degree of the vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
        temporary data.
        <code class="constant">IGRAPH_EINVVID</code>, invalid vertex ID in
        <em class="parameter"><code>vids</code></em> or an empty reset vertex sequence in
        <em class="parameter"><code>vids_reset</code></em>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the input graph, usually it is O(|E|),
the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_pagerank" title="10.6. igraph_pagerank — Calculates the Google PageRank for the specified vertices."><code class="function">igraph_pagerank()</code></a> for the non-personalized implementation.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_constraint"></a>10.9. <code class="function">igraph_constraint</code> —  Burt's constraint scores.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_constraint(const igraph_t *graph, igraph_vector_t *res,
                      igraph_vs_t vids, const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function calculates Burt's constraint scores for the given
vertices, also known as structural holes.

</p>
<p>
Burt's constraint is higher if ego has less, or mutually stronger
related (i.e. more redundant) contacts. Burt's measure of
constraint, C[i], of vertex i's ego network V[i], is defined for
directed and valued graphs,
</p>
<div class="blockquote"><blockquote class="blockquote"><p>
C[i] = sum( sum( (p[i,q] p[q,j])^2, q in V[i], q != i,j ), j in
V[], j != i)
</p></blockquote></div>
<p>
for a graph of order (i.e. number of vertices) N, where proportional
tie strengths are defined as
</p>
<div class="blockquote"><blockquote class="blockquote"><p>
p[i,j]=(a[i,j]+a[j,i]) / sum(a[i,k]+a[k,i], k in V[i], k != i),
</p></blockquote></div>
<p>
a[i,j] are elements of A and
the latter being the graph adjacency matrix. For isolated vertices,
constraint is undefined.

</p>
<p>
Burt, R.S. (2004). Structural holes and good ideas. American
Journal of Sociology 110, 349-399.

</p>
<p>
The first R version of this function was contributed by Jeroen
Bruggeman.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  A graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result will be
       stored here. The vector will be resized to have the
       appropriate size for holding the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  Vertex selector containing the vertices for which the
       constraint should be calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Vector giving the weights of the edges. If it is
       <code class="constant">NULL</code> then each edge is supposed to have the same weight.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+E|+n*d^2), n is the number of vertices for
which the constraint is calculated and d is the average degree, |V|
is the number of vertices, |E| the number of edges in the
graph. If the weights argument is <code class="constant">NULL</code> then the time complexity
is O(|V|+n*d^2).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_maxdegree"></a>10.10. <code class="function">igraph_maxdegree</code> —  The maximum degree in a graph (or set of vertices).</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_maxdegree(const igraph_t *graph, igraph_integer_t *res,
                     igraph_vs_t vids, igraph_neimode_t mode,
                     igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>



The largest in-, out- or total degree of the specified vertices is
calculated. If the graph has no vertices, or <em class="parameter"><code>vids</code></em> is empty,
0 is returned, as this is the smallest possible value for degrees.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an integer (<code class="constant">igraph_integer_t</code>), the result
       will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  Vector giving the vertex IDs for which the maximum degree will
       be calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Defines the type of the degree.
       <code class="constant">IGRAPH_OUT</code>, out-degree,
       <code class="constant">IGRAPH_IN</code>, in-degree,
       <code class="constant">IGRAPH_ALL</code>, total degree (sum of the
       in- and out-degree).
       This parameter is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Boolean, gives whether the self-loops should be
       counted.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVVID</code>: invalid vertex ID.
        <code class="constant">IGRAPH_EINVMODE</code>: invalid mode argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(v) if <em class="parameter"><code>loops</code></em> is <code class="constant">true</code>, and O(v*d) otherwise. v is the number
of vertices for which the degree will be calculated, and d is their
(average) degree.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strength"></a>10.11. <code class="function">igraph_strength</code> —  Strength of the vertices, also called weighted vertex degree.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_strength(const igraph_t *graph, igraph_vector_t *res,
                    const igraph_vs_t vids, igraph_neimode_t mode,
                    igraph_bool_t loops, const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>



In a weighted network the strength of a vertex is the sum of the
weights of all incident edges. In a non-weighted network this is
exactly the vertex degree.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is stored
  here. It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Gives whether to count only outgoing (<code class="constant">IGRAPH_OUT</code>),
  incoming (<code class="constant">IGRAPH_IN</code>) edges or both (<code class="constant">IGRAPH_ALL</code>).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  A logical scalar, whether to count loop edges as well.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A vector giving the edge weights. If this is a <code class="constant">NULL</code>
  pointer, then <a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a> is called to perform the
  calculation.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number vertices and
edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a> for the traditional, non-weighted version.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_eigenvector_centrality"></a>10.12. <code class="function">igraph_eigenvector_centrality</code> —  Eigenvector centrality of the vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.13.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_eigenvector_centrality(const igraph_t *graph,
                                  igraph_vector_t *vector,
                                  igraph_real_t *value,
                                  igraph_bool_t directed, igraph_bool_t scale,
                                  const igraph_vector_t *weights,
                                  igraph_arpack_options_t *options);
</pre></div>
<p>
</p>
<p>



Eigenvector centrality is a measure of the importance of a node in a
network. It assigns relative scores to all nodes in the network based
on the principle that connections from high-scoring nodes contribute
more to the score of the node in question than equal connections from
low-scoring nodes. Specifically, the eigenvector centrality of each
vertex is proportional to the sum of eigenvector centralities of its
neighbors. In practice, the centralities are determined by calculating the
eigenvector corresponding to the largest positive eigenvalue of the
adjacency matrix. In the undirected case, this function considers
the diagonal entries of the adjacency matrix to be <span class="emphasis"><em>twice</em></span> the number of
self-loops on the corresponding vertex.

</p>
<p>
In the weighted case, the eigenvector centrality of a vertex is proportional
to the weighted sum of centralities of its neighbours, i.e.
<code class="literal">c_i = sum_j w_ij c_j</code>, where <code class="literal">w_ij</code> is the weight
of the edge connecting vertices <code class="constant">i</code> and <code class="constant">j</code>. The weights of parallel edges
are added up.

</p>
<p>
The centrality scores returned by igraph can be normalized
(using the <em class="parameter"><code>scale</code></em> parameter) such that the largest eigenvector centrality
score is 1 (with one exception, see below).

</p>
<p>
In the directed case, the left eigenvector of the adjacency matrix is
calculated. In other words, the centrality of a vertex is proportional
to the sum of centralities of vertices pointing to it.

</p>
<p>
Eigenvector centrality is meaningful only for (strongly) connected graphs.
Undirected graphs that are not connected should be decomposed into connected
components, and the eigenvector centrality calculated for each separately.
This function does not verify that the graph is connected. If it is not,
in the undirected case the scores of all but one component will be zeros.

</p>
<p>
Also note that the adjacency matrix of a directed acyclic graph or the
adjacency matrix of an empty graph does not possess positive eigenvalues,
therefore the eigenvector centrality is not defined for these graphs.
igraph will return an eigenvalue of zero in such cases. The eigenvector
centralities will all be equal for an empty graph and will all be zeros
for a directed acyclic graph. Such pathological cases can be detected
by asking igraph to calculate the eigenvalue as well (using the <em class="parameter"><code>value</code></em>
parameter, see below) and checking whether the eigenvalue is very close
to zero.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It may be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, it will be resized
    as needed. The result of the computation is stored here. It can
    be a null pointer, then it is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then the eigenvalue
    corresponding to the found eigenvector is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean scalar, whether to consider edge directions
    in a directed graph. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scale</code></em>:</span></p></td>
<td><p>
  If not zero then the result will be scaled such that
    the absolute value of the maximum centrality is one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A null pointer (indicating no edge weights), or a vector
    giving the weights of the edges. Weights should be positive to guarantee
    a meaningful result. The algorithm might produce complex numbers when some
    weights are negative and the graph is directed. In this case only
    the real part is reported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options to ARPACK. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Supply <code class="constant">NULL</code> here to use the defaults. Note that the
   function overwrites the <code class="literal">n</code> (number of vertices) parameter and
   it always starts the calculation from a non-random vector
   calculated based on the degree of the vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the input graph, usually it is O(|V|+|E|).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_pagerank" title="10.6. igraph_pagerank — Calculates the Google PageRank for the specified vertices."><code class="function">igraph_pagerank</code></a> and <a class="link" href="igraph-Structural.html#igraph_personalized_pagerank" title="10.7. igraph_personalized_pagerank — Calculates the personalized Google PageRank for the specified vertices."><code class="function">igraph_personalized_pagerank</code></a> for
  modifications of eigenvector centrality.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.12.13.15.1"></a><p class="title"><b>Example 13.15.  File <code class="code">examples/simple/eigenvector_centrality.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> "igraph.h"

<span class="strong"><strong>#include</strong></span> &lt;math.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> v, weights;
    igraph_real_t value;
    <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK">igraph_arpack_options_t</a> options;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_UNDIRECTED, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, 9);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_fill" title="2.3.2. igraph_vector_fill — Fill a vector with a constant element.">igraph_vector_fill</a></strong></span>(&amp;weights, 1);

    <span class="strong"><strong><a class="link" href="igraph-Arpack.html#igraph_arpack_options_init" title="3.1.4. igraph_arpack_options_init — Initialize ARPACK options">igraph_arpack_options_init</a></strong></span>(&amp;options);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="10.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices.">igraph_eigenvector_centrality</a></strong></span>(&amp;g, &amp;v, &amp;value, <span class="emphasis"><em>/*directed=*/</em></span> 0,
                                  <span class="emphasis"><em>/*scale=*/</em></span>1, &amp;weights,
                                  &amp;options);

    <span class="strong"><strong>if</strong></span> (options.info != 0) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>printf</strong></span>("eigenvalue: %g\n", value);
    <span class="strong"><strong>printf</strong></span>("eigenvector:\n");
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;v);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_hub_score"></a>10.13. <code class="function">igraph_hub_score</code> —  Kleinberg's hub scores.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.14.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_hub_score(const igraph_t *graph, igraph_vector_t *vector,
                     igraph_real_t *value, igraph_bool_t scale,
                     const igraph_vector_t *weights,
                     igraph_arpack_options_t *options);
</pre></div>
<p>
</p>
<p>



The hub scores of the vertices are defined as the principal
eigenvector of <code class="literal">A*A^T</code>, where <code class="literal">A</code> is the adjacency
matrix of the graph, <code class="literal">A^T</code> is its transposed.
</p>
<p>
See the following reference on the meaning of this score:
J. Kleinberg. Authoritative sources in a hyperlinked
environment. <span class="emphasis"><em> Proc. 9th ACM-SIAM Symposium on Discrete
Algorithms, </em></span> 1998. Extended version in <span class="emphasis"><em> Journal of the
ACM </em></span> 46(1999). Also appears as IBM Research Report RJ 10076, May
1997.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Can be directed and undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is
   stored here. If a null pointer then it is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  If not a null pointer then the eigenvalue
   corresponding to the calculated eigenvector is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scale</code></em>:</span></p></td>
<td><p>
  If not zero then the result will be scaled such that
    the absolute value of the maximum centrality is one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A null pointer (=no edge weights), or a vector
    giving the weights of the edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options to ARPACK. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Note that the function overwrites the
   <code class="literal">n</code> (number of vertices) parameter and
   it always starts the calculation from a non-random vector
   calculated based on the degree of the vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the input graph, usually it is O(|V|),
the number of vertices.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_authority_score" title="10.14. igraph_authority_score — Kleinerg's authority scores."><code class="function">igraph_authority_score()</code></a> for the companion measure,
<a class="link" href="igraph-Structural.html#igraph_pagerank" title="10.6. igraph_pagerank — Calculates the Google PageRank for the specified vertices."><code class="function">igraph_pagerank()</code></a>, <a class="link" href="igraph-Structural.html#igraph_personalized_pagerank" title="10.7. igraph_personalized_pagerank — Calculates the personalized Google PageRank for the specified vertices."><code class="function">igraph_personalized_pagerank()</code></a>,
<a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="10.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices."><code class="function">igraph_eigenvector_centrality()</code></a> for similar measures.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_authority_score"></a>10.14. <code class="function">igraph_authority_score</code> —  Kleinerg's authority scores.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.15.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_authority_score(const igraph_t *graph, igraph_vector_t *vector,
                           igraph_real_t *value, igraph_bool_t scale,
                           const igraph_vector_t *weights,
                           igraph_arpack_options_t *options);
</pre></div>
<p>
</p>
<p>



The authority scores of the vertices are defined as the principal
eigenvector of <code class="literal">A^T*A</code>, where <code class="literal">A</code> is the adjacency
matrix of the graph, <code class="literal">A^T</code> is its transposed.
</p>
<p>
See the following reference on the meaning of this score:
J. Kleinberg. Authoritative sources in a hyperlinked
environment. <span class="emphasis"><em> Proc. 9th ACM-SIAM Symposium on Discrete
Algorithms, </em></span> 1998. Extended version in <span class="emphasis"><em> Journal of the
ACM </em></span> 46(1999). Also appears as IBM Research Report RJ 10076, May
1997.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Can be directed and undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is
   stored here. If a null pointer then it is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  If not a null pointer then the eigenvalue
   corresponding to the calculated eigenvector is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scale</code></em>:</span></p></td>
<td><p>
  If not zero then the result will be scaled such that
    the absolute value of the maximum centrality is one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A null pointer (=no edge weights), or a vector
    giving the weights of the edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options to ARPACK. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Note that the function overwrites the
   <code class="literal">n</code> (number of vertices) parameter and
   it always starts the calculation from a non-random vector
   calculated based on the degree of the vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the input graph, usually it is O(|V|),
the number of vertices.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_hub_score" title="10.13. igraph_hub_score — Kleinberg's hub scores."><code class="function">igraph_hub_score()</code></a> for the companion measure,
<a class="link" href="igraph-Structural.html#igraph_pagerank" title="10.6. igraph_pagerank — Calculates the Google PageRank for the specified vertices."><code class="function">igraph_pagerank()</code></a>, <a class="link" href="igraph-Structural.html#igraph_personalized_pagerank" title="10.7. igraph_personalized_pagerank — Calculates the personalized Google PageRank for the specified vertices."><code class="function">igraph_personalized_pagerank()</code></a>,
<a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="10.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices."><code class="function">igraph_eigenvector_centrality()</code></a> for similar measures.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_convergence_degree"></a>10.15. <code class="function">igraph_convergence_degree</code> —  Calculates the convergence degree of each edge in a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.12.16.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_convergence_degree(const igraph_t *graph, igraph_vector_t *result,
                              igraph_vector_t *ins, igraph_vector_t *outs);
</pre></div>
<p>
</p>
<p>



Let us define the input set of an edge (i, j) as the set of vertices where
the shortest paths passing through (i, j) originate, and similarly, let us
defined the output set of an edge (i, j) as the set of vertices where the
shortest paths passing through (i, j) terminate. The convergence degree of
an edge is defined as the normalized value of the difference between the
size of the input set and the output set, i.e. the difference of them
divided by the sum of them. Convergence degrees are in the range (-1, 1); a
positive value indicates that the edge is <span class="emphasis"><em>convergent</em></span> since the shortest
paths passing through it originate from a larger set and terminate in a
smaller set, while a negative value indicates that the edge is <span class="emphasis"><em>divergent</em></span>
since the paths originate from a small set and terminate in a larger set.

</p>
<p>
Note that the convergence degree as defined above does not make sense in
undirected graphs as there is no distinction between the input and output
set. Therefore, for undirected graphs, the input and output sets of an edge
are determined by orienting the edge arbitrarily while keeping the remaining
edges undirected, and then taking the absolute value of the convergence
degree.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be either directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector; the convergence degrees of
  each edge will be stored here. May be <code class="constant">NULL</code> if we are not interested in
  the exact convergence degrees.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ins</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector; the size of the input set of
  each edge will be stored here. May be <code class="constant">NULL</code> if we are not interested in
  the sizes of the input sets.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>outs</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector; the size of the output set of
  each edge will be stored here. May be <code class="constant">NULL</code> if we are not interested in
  the sizes of the output sets.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|), the number of vertices times the number of edges.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="range-limited-centrality-measures"></a>11. Range-limited centrality measures</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_closeness_cutoff">11.1. <code class="function">igraph_closeness_cutoff</code> —  Range limited closeness centrality.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_harmonic_centrality_cutoff">11.2. <code class="function">igraph_harmonic_centrality_cutoff</code> —  Range limited harmonic centrality.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_betweenness_cutoff">11.3. <code class="function">igraph_betweenness_cutoff</code> —  Range-limited betweenness centrality.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_edge_betweenness_cutoff">11.4. <code class="function">igraph_edge_betweenness_cutoff</code> —  Range-limited betweenness centrality of the edges.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_closeness_cutoff"></a>11.1. <code class="function">igraph_closeness_cutoff</code> —  Range limited closeness centrality.</h3></div></div></div>
<a class="indexterm" name="id-1.14.13.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_closeness_cutoff(const igraph_t *graph, igraph_vector_t *res,
                            igraph_vector_int_t *reachable_count, igraph_bool_t *all_reachable,
                            const igraph_vs_t vids, igraph_neimode_t mode,
                            const igraph_vector_t *weights,
                            igraph_bool_t normalized,
                            igraph_real_t cutoff);
</pre></div>
<p>
</p>
<p>




This function computes a range-limited version of closeness centrality
by considering only those shortest paths whose length is no greater
then the given cutoff value.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
       range-limited closeness centrality scores for the given vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>reachable_count</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code>, this vector will contain the number of
       vertices reachable within the cutoff distance from each vertex for which
       the range-limited closeness is calculated (not including that vertex).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>all_reachable</code></em>:</span></p></td>
<td><p>
  Pointer to a Boolean. If not <code class="constant">NULL</code>, it indicates if all
       vertices of the graph were reachable from each vertex in <em class="parameter"><code>vids</code></em> within
       the given cutoff distance.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the range limited closeness centrality
            will be computed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the lengths of the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the lengths of the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       weighted closeness. No edge weight may be NaN. Supply a null
       pointer here for traditional, unweighted closeness.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  If true, the inverse of the mean distance to vertices
       reachable within the cutoff is returned. If false, the inverse
       of the sum of distances is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cutoff</code></em>:</span></p></td>
<td><p>
  The maximal length of paths that will be considered.
       If negative, the exact closeness will be calculated (no upper
       limit on path lengths).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex ID passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n|E|),
n is the number
of vertices for which the calculation is done and
|E| is the number
of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_closeness" title="10.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a> to calculate the exact closeness centrality.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_harmonic_centrality_cutoff"></a>11.2. <code class="function">igraph_harmonic_centrality_cutoff</code> —  Range limited harmonic centrality.</h3></div></div></div>
<a class="indexterm" name="id-1.14.13.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_harmonic_centrality_cutoff(const igraph_t *graph, igraph_vector_t *res,
                                      const igraph_vs_t vids, igraph_neimode_t mode,
                                      const igraph_vector_t *weights,
                                      igraph_bool_t normalized,
                                      igraph_real_t cutoff);
</pre></div>
<p>
</p>
<p>




This function computes the range limited version of harmonic centrality:
only those shortest paths are considered whose length is not above the given cutoff.
The inverse distance to vertices not reachable within the cutoff is considered
to be zero.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
       range limited harmonic centrality scores for the given vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the harmonic centrality will be computed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the lengths of the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the lengths of the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       weighted harmonic centrality. No edge weight may be NaN.
       If <code class="constant">NULL</code>, all weights are considered to be one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to normalize the result. If true,
       the result is the mean inverse path length to other vertices.
       i.e. it is normalized by the number of vertices minus one.
       If false, the result is the sum of inverse path lengths to other
       vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cutoff</code></em>:</span></p></td>
<td><p>
  The maximal length of paths that will be considered.
       The inverse distance to vertices that are not reachable within
       the cutoff path length is considered to be zero.
       Supply a negative value to compute the exact harmonic centrality,
       without any upper limit on the length of paths.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex ID passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n|E|), where
n is the number of vertices for which the calculation is done and
|E| is the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Other centrality types: <a class="link" href="igraph-Structural.html#igraph_closeness" title="10.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a>, <a class="link" href="igraph-Structural.html#igraph_betweenness" title="10.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_betweenness_cutoff"></a>11.3. <code class="function">igraph_betweenness_cutoff</code> —  Range-limited betweenness centrality.</h3></div></div></div>
<a class="indexterm" name="id-1.14.13.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_betweenness_cutoff(const igraph_t *graph, igraph_vector_t *res,
                              const igraph_vs_t vids, igraph_bool_t directed,
                              const igraph_vector_t *weights, igraph_real_t cutoff);
</pre></div>
<p>
</p>
<p>




This function computes a range-limited version of betweenness centrality
by considering only those shortest paths whose length is no greater
then the given cutoff value.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
       range-limited betweenness scores for the specified vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the range-limited betweenness centrality
       scores will be computed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, if true directed paths will be considered
       for directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       calculating weighted betweenness. No edge weight may be NaN.
       Supply a null pointer here for unweighted betweenness.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cutoff</code></em>:</span></p></td>
<td><p>
  The maximal length of paths that will be considered.
       If negative, the exact betweenness will be calculated, and
       there will be no upper limit on path lengths.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
       temporary data.
       <code class="constant">IGRAPH_EINVVID</code>, invalid vertex ID passed in
       <em class="parameter"><code>vids</code></em>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|),
|V| and
|E| are the number of vertices and
edges in the graph.
Note that the time complexity is independent of the number of
vertices for which the score is calculated.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_betweenness" title="10.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a> to calculate the exact betweenness and
<a class="link" href="igraph-Structural.html#igraph_edge_betweenness_cutoff" title="11.4. igraph_edge_betweenness_cutoff — Range-limited betweenness centrality of the edges."><code class="function">igraph_edge_betweenness_cutoff()</code></a> to calculate the range-limited
edge betweenness.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_edge_betweenness_cutoff"></a>11.4. <code class="function">igraph_edge_betweenness_cutoff</code> —  Range-limited betweenness centrality of the edges.</h3></div></div></div>
<a class="indexterm" name="id-1.14.13.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_edge_betweenness_cutoff(const igraph_t *graph, igraph_vector_t *result,
                                   igraph_bool_t directed,
                                   const igraph_vector_t *weights, igraph_real_t cutoff);
</pre></div>
<p>
</p>
<p>




</p>
<p>
</p>
<p>
This function computes a range-limited version of edge betweenness centrality
by considering only those shortest paths whose length is no greater
then the given cutoff value.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  The result of the computation, vector containing the
       betweenness scores for the edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, if true directed paths will be considered
       for directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional weight vector for weighted
       betweenness. No edge weight may be NaN. Supply a null
       pointer here for unweighted betweenness.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cutoff</code></em>:</span></p></td>
<td><p>
  The maximal length of paths that will be considered.
       If negative, the exact betweenness will be calculated (no
       upper limit on path lengths).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
       temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|),
|V| and
|E| are the number of vertices and
edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_edge_betweenness" title="10.4. igraph_edge_betweenness — Betweenness centrality of the edges."><code class="function">igraph_edge_betweenness()</code></a> to compute the exact edge betweenness and
<a class="link" href="igraph-Structural.html#igraph_betweenness_cutoff" title="11.3. igraph_betweenness_cutoff — Range-limited betweenness centrality."><code class="function">igraph_betweenness_cutoff()</code></a> to compute the range-limited vertex betweenness.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="subset-limited-centrality-measures"></a>12. Subset-limited Centrality Measures</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_betweenness_subset">12.1. <code class="function">igraph_betweenness_subset</code> —  Betweenness centrality for a subset of source and target vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_edge_betweenness_subset">12.2. <code class="function">igraph_edge_betweenness_subset</code> —  Edge betweenness centrality for a subset of source and target vertices.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_betweenness_subset"></a>12.1. <code class="function">igraph_betweenness_subset</code> —  Betweenness centrality for a subset of source and target vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.14.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_betweenness_subset(const igraph_t *graph, igraph_vector_t *res,
                              const igraph_vs_t vids, igraph_bool_t directed,
                              const igraph_vs_t sources, const igraph_vs_t targets,
                              const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function computes the subset-limited version of betweenness centrality
by considering only those shortest paths that lie between vertices in a given
source and target subset.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
        betweenness score for the subset of vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the subset-limited betweenness centrality
       scores will be computed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, if true directed paths will be considered
       for directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       calculating weighted betweenness. No edge weight may be NaN.
       Supply a null pointer here for unweighted betweenness.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sources</code></em>:</span></p></td>
<td><p>
  A vertex selector for the sources of the shortest paths taken
       into considuration in the betweenness calculation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>targets</code></em>:</span></p></td>
<td><p>
  A vertex selector for the targets of the shortest paths taken
       into considuration in the betweenness calculation.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for temporary data.
       <code class="constant">IGRAPH_EINVVID</code>, invalid vertex ID passed in <em class="parameter"><code>vids</code></em>,
       <em class="parameter"><code>sources</code></em> or <em class="parameter"><code>targets</code></em>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|S||E|),
|S| The number of vertices in the subset
|E| The number of edges in the graph

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_betweenness" title="10.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a> to calculate the exact vertex betweenness and
<a class="link" href="igraph-Structural.html#igraph_betweenness_cutoff" title="11.3. igraph_betweenness_cutoff — Range-limited betweenness centrality."><code class="function">igraph_betweenness_cutoff()</code></a> to calculate the range-limited vertex
betweenness.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_edge_betweenness_subset"></a>12.2. <code class="function">igraph_edge_betweenness_subset</code> —  Edge betweenness centrality for a subset of source and target vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.14.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_edge_betweenness_subset(const igraph_t *graph, igraph_vector_t *res,
                                   const igraph_es_t eids, igraph_bool_t directed,
                                   const igraph_vs_t sources, const igraph_vs_t targets,
                                   const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function computes the subset-limited version of edge betweenness centrality
by considering only those shortest paths that lie between vertices in a given
source and target subset.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, vector containing the
       betweenness scores for the edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>eids</code></em>:</span></p></td>
<td><p>
  The edges for which the subset-limited betweenness centrality
       scores will be computed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, if true directed paths will be considered
       for directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional weight vector for weighted
       betweenness. No edge weight may be NaN. Supply a null
       pointer here for unweighted betweenness.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sources</code></em>:</span></p></td>
<td><p>
  A vertex selector for the sources of the shortest paths taken
       into considuration in the betweenness calculation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>targets</code></em>:</span></p></td>
<td><p>
  A vertex selector for the targets of the shortest paths taken
       into considuration in the betweenness calculation.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for temporary data.
       <code class="constant">IGRAPH_EINVVID</code>, invalid vertex ID passed in <em class="parameter"><code>sources</code></em> or <em class="parameter"><code>targets</code></em>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|S||E|),
|S| The number of vertices in the subset
|E| The number of edges in the graph

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_edge_betweenness" title="10.4. igraph_edge_betweenness — Betweenness centrality of the edges."><code class="function">igraph_edge_betweenness()</code></a> to compute the exact edge betweenness and
<a class="link" href="igraph-Structural.html#igraph_edge_betweenness_cutoff" title="11.4. igraph_edge_betweenness_cutoff — Range-limited betweenness centrality of the edges."><code class="function">igraph_edge_betweenness_cutoff()</code></a> to compute the range-limited edge betweenness.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="centralization"></a>13. Centralization</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization">13.1. <code class="function">igraph_centralization</code> —  Calculate the centralization score from the node level scores.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_degree">13.2. <code class="function">igraph_centralization_degree</code> —  Calculate vertex degree and graph centralization.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_betweenness">13.3. <code class="function">igraph_centralization_betweenness</code> —  Calculate vertex betweenness and graph centralization.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_closeness">13.4. <code class="function">igraph_centralization_closeness</code> —  Calculate vertex closeness and graph centralization.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_eigenvector_centrality">13.5. <code class="function">igraph_centralization_eigenvector_centrality</code> —  Calculate eigenvector centrality scores and graph centralization.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_degree_tmax">13.6. <code class="function">igraph_centralization_degree_tmax</code> —  Theoretical maximum for graph centralization based on degree.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_betweenness_tmax">13.7. <code class="function">igraph_centralization_betweenness_tmax</code> —  Theoretical maximum for graph centralization based on betweenness.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_closeness_tmax">13.8. <code class="function">igraph_centralization_closeness_tmax</code> —  Theoretical maximum for graph centralization based on closeness.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_eigenvector_centrality_tmax">13.9. <code class="function">igraph_centralization_eigenvector_centrality_tmax</code> —  Theoretical maximum centralization for eigenvector centrality.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization"></a>13.1. <code class="function">igraph_centralization</code> —  Calculate the centralization score from the node level scores.</h3></div></div></div>
<a class="indexterm" name="id-1.14.15.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_centralization(const igraph_vector_t *scores,
                                    igraph_real_t theoretical_max,
                                    igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>



For a centrality score defined on the vertices of a graph, it is
possible to define a graph level centralization index, by
calculating the sum of the deviation from the maximum centrality
score. Consequently, the higher the centralization index of the
graph, the more centralized the structure is.

</p>
<p>In order to make graphs of different sizes comparable,
the centralization index is usually normalized to a number between
zero and one, by dividing the (unnormalized) centralization score
of the most centralized structure with the same number of vertices.

</p>
<p>For most centrality indices the most centralized
structure is the star graph, a single center connected to all other
nodes in the network. There are some variation depending on whether
the graph is directed or not, whether loop edges are allowed, etc.

</p>
<p>
This function simply calculates the graph level index, if the node
level scores and the theoretical maximum are given. It is called by
all the measure-specific centralization functions.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>scores</code></em>:</span></p></td>
<td><p>
  A vector containing the node-level centrality
    scores.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>theoretical_max</code></em>:</span></p></td>
<td><p>
  The graph level centrality score of the most
    centralized graph with the same number of vertices. Only used
    if <code class="constant">normalized</code> set to true.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to normalize the centralization
    by dividing the supplied theoretical maximum.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The graph level index.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization_degree" title="13.2. igraph_centralization_degree — Calculate vertex degree and graph centralization."><code class="function">igraph_centralization_degree()</code></a>, <a class="link" href="igraph-Structural.html#igraph_centralization_betweenness" title="13.3. igraph_centralization_betweenness — Calculate vertex betweenness and graph centralization."><code class="function">igraph_centralization_betweenness()</code></a>, <a class="link" href="igraph-Structural.html#igraph_centralization_closeness" title="13.4. igraph_centralization_closeness — Calculate vertex closeness and graph centralization."><code class="function">igraph_centralization_closeness()</code></a>, and <a class="link" href="igraph-Structural.html#igraph_centralization_eigenvector_centrality" title="13.5. igraph_centralization_eigenvector_centrality — Calculate eigenvector centrality scores and graph centralization."><code class="function">igraph_centralization_eigenvector_centrality()</code></a> for specific
centralization functions.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the length of the score vector.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.15.2.13.1"></a><p class="title"><b>Example 13.16.  File <code class="code">examples/simple/centralization.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;math.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t cent;
    <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK">igraph_arpack_options_t</a> arpack_options;

    <span class="emphasis"><em>/****************************/</em></span>
    <span class="emphasis"><em>/* in-star */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_IN, <span class="emphasis"><em>/*center=*/</em></span> 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_degree" title="13.2. igraph_centralization_degree — Calculate vertex degree and graph centralization.">igraph_centralization_degree</a></strong></span>(&amp;g,
                                 <span class="emphasis"><em>/*res=*/</em></span> NULL,
                                 <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_IN, IGRAPH_NO_LOOPS,
                                 &amp;cent, <span class="emphasis"><em>/*theoretical_max=*/</em></span> NULL,
                                 <span class="emphasis"><em>/*normalized=*/</em></span> true);
    <span class="strong"><strong>if</strong></span> (cent != 1.0) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "in-star, degree: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_betweenness" title="13.3. igraph_centralization_betweenness — Calculate vertex betweenness and graph centralization.">igraph_centralization_betweenness</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> NULL,
                                      IGRAPH_UNDIRECTED, &amp;cent,
                                      <span class="emphasis"><em>/*theoretical_max=*/</em></span> NULL,
                                      <span class="emphasis"><em>/*normalized=*/</em></span> true);
    <span class="strong"><strong>if</strong></span> (cent != 1.0) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "in-star, betweenness: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="emphasis"><em>/* Skip closeness, as it is not well-defined for disconnected graphs such as an in-star. */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/****************************/</em></span>
    <span class="emphasis"><em>/* out-star */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_OUT, <span class="emphasis"><em>/*center=*/</em></span> 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_degree" title="13.2. igraph_centralization_degree — Calculate vertex degree and graph centralization.">igraph_centralization_degree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> NULL,
                                 <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT, IGRAPH_NO_LOOPS,
                                 &amp;cent, <span class="emphasis"><em>/*theoretical_max=*/</em></span> NULL,
                                 <span class="emphasis"><em>/*normalized=*/</em></span> true);
    <span class="strong"><strong>if</strong></span> (cent != 1.0) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "out-star, degree: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 11;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_betweenness" title="13.3. igraph_centralization_betweenness — Calculate vertex betweenness and graph centralization.">igraph_centralization_betweenness</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> NULL,
                                      IGRAPH_UNDIRECTED, &amp;cent,
                                      <span class="emphasis"><em>/*theoretical_max=*/</em></span> NULL,
                                      <span class="emphasis"><em>/*normalized=*/</em></span> true);
    <span class="strong"><strong>if</strong></span> (cent != 1.0) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "out-star, betweenness: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 12;
    }

    <span class="emphasis"><em>/* Skip closeness, as it is not well-defined for disconnected graphs such as an out-star. */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/****************************/</em></span>
    <span class="emphasis"><em>/* undirected star */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_UNDIRECTED, <span class="emphasis"><em>/*center=*/</em></span> 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_degree" title="13.2. igraph_centralization_degree — Calculate vertex degree and graph centralization.">igraph_centralization_degree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> NULL,
                                 <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_ALL, IGRAPH_NO_LOOPS,
                                 &amp;cent, <span class="emphasis"><em>/*theoretical_max=*/</em></span> NULL,
                                 <span class="emphasis"><em>/*normalized=*/</em></span> true);
    <span class="strong"><strong>if</strong></span> (cent != 1.0) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "undirected star, degree: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 21;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_betweenness" title="13.3. igraph_centralization_betweenness — Calculate vertex betweenness and graph centralization.">igraph_centralization_betweenness</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> NULL,
                                      IGRAPH_UNDIRECTED, &amp;cent,
                                      <span class="emphasis"><em>/*theoretical_max=*/</em></span> NULL,
                                      <span class="emphasis"><em>/*normalized=*/</em></span> true);
    <span class="strong"><strong>if</strong></span> (cent != 1.0) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "undirected star, betweenness: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 22;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_closeness" title="13.4. igraph_centralization_closeness — Calculate vertex closeness and graph centralization.">igraph_centralization_closeness</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> NULL,
                                    IGRAPH_ALL, &amp;cent,
                                    <span class="emphasis"><em>/*theoretical_max=*/</em></span> NULL,
                                    <span class="emphasis"><em>/*normalized=*/</em></span> true);

    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Nongraph.html#igraph_almost_equals" title="7.2. igraph_almost_equals — Compare two double-precision floats with a tolerance.">igraph_almost_equals</a></strong></span>(cent, 1.0, 1e-8)) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "undirected star, closeness: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 23;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/****************************/</em></span>
    <span class="emphasis"><em>/* single dyad */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, <span class="emphasis"><em>/*n=*/</em></span> 10, <span class="emphasis"><em>/*directed=*/</em></span> 0,
                 0, 1, -1);

    <span class="strong"><strong><a class="link" href="igraph-Arpack.html#igraph_arpack_options_init" title="3.1.4. igraph_arpack_options_init — Initialize ARPACK options">igraph_arpack_options_init</a></strong></span>(&amp;arpack_options);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_eigenvector_centrality" title="13.5. igraph_centralization_eigenvector_centrality — Calculate eigenvector centrality scores and graph centralization.">igraph_centralization_eigenvector_centrality</a></strong></span>(
                &amp;g,
                <span class="emphasis"><em>/*vector=*/</em></span> NULL,
                <span class="emphasis"><em>/*value=*/</em></span> NULL,
                IGRAPH_DIRECTED,
                <span class="emphasis"><em>/*scale=*/</em></span> true,
                &amp;arpack_options, &amp;cent,
                <span class="emphasis"><em>/*theoretical_max=*/</em></span> NULL,
                <span class="emphasis"><em>/*normalized=*/</em></span> true);

    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Nongraph.html#igraph_almost_equals" title="7.2. igraph_almost_equals — Compare two double-precision floats with a tolerance.">igraph_almost_equals</a></strong></span>(cent, 1.0, 1e-8)) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "dyad, eigenvector centrality: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 24;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_eigenvector_centrality" title="13.5. igraph_centralization_eigenvector_centrality — Calculate eigenvector centrality scores and graph centralization.">igraph_centralization_eigenvector_centrality</a></strong></span>(
                &amp;g,
                <span class="emphasis"><em>/*vector=*/</em></span> NULL,
                <span class="emphasis"><em>/*value=*/</em></span> NULL,
                IGRAPH_DIRECTED,
                <span class="emphasis"><em>/*scale=*/</em></span> false,
                &amp;arpack_options, &amp;cent,
                <span class="emphasis"><em>/*theoretical_max=*/</em></span> NULL,
                <span class="emphasis"><em>/*normalized=*/</em></span> true);

    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Nongraph.html#igraph_almost_equals" title="7.2. igraph_almost_equals — Compare two double-precision floats with a tolerance.">igraph_almost_equals</a></strong></span>(cent, 1.0, 1e-8)) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "dyad, eigenvector centrality, not scaled: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 25;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_degree"></a>13.2. <code class="function">igraph_centralization_degree</code> —  Calculate vertex degree and graph centralization.</h3></div></div></div>
<a class="indexterm" name="id-1.14.15.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_centralization_degree(const igraph_t *graph, igraph_vector_t *res,
                                 igraph_neimode_t mode, igraph_bool_t loops,
                                 igraph_real_t *centralization,
                                 igraph_real_t *theoretical_max,
                                 igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>



This function calculates the degree of the vertices by passing its
arguments to <a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a>; and it calculates the graph
level centralization index based on the results by calling <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  A vector if you need the node-level degree scores, or a
    null pointer otherwise.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant the specifies the type of degree for directed
    graphs. Possible values: <code class="constant">IGRAPH_IN</code>, <code class="constant">IGRAPH_OUT</code> and <code class="constant">IGRAPH_ALL</code>. This argument is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider loop edges when
    calculating the degree (and the centralization).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>centralization</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the centralization
    score is placed here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>theoretical_max</code></em>:</span></p></td>
<td><p>
  Pointer to real number or a null pointer. If
    not a null pointer, then the theoretical maximum graph
    centrality score for a graph with the same number vertices is
    stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to calculate a normalized
    centralization score. See <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a> for how
    the normalization is done.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a>, <a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: the complexity of <a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a> plus O(n),
the number of vertices queried, for calculating the centralization
score.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_betweenness"></a>13.3. <code class="function">igraph_centralization_betweenness</code> —  Calculate vertex betweenness and graph centralization.</h3></div></div></div>
<a class="indexterm" name="id-1.14.15.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_centralization_betweenness(const igraph_t *graph,
                                      igraph_vector_t *res,
                                      igraph_bool_t directed,
                                      igraph_real_t *centralization,
                                      igraph_real_t *theoretical_max,
                                      igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>



This function calculates the betweenness centrality of the vertices
by passing its arguments to <a class="link" href="igraph-Structural.html#igraph_betweenness" title="10.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a>; and it
calculates the graph level centralization index based on the
results by calling <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  A vector if you need the node-level betweenness scores, or a
    null pointer otherwise.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed paths when
    calculating betweenness.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>centralization</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the centralization
    score is placed here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>theoretical_max</code></em>:</span></p></td>
<td><p>
  Pointer to real number or a null pointer. If
    not a null pointer, then the theoretical maximum graph
    centrality score for a graph with the same number vertices is
    stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to calculate a normalized
    centralization score. See <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a> for how
    the normalization is done.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a>, <a class="link" href="igraph-Structural.html#igraph_betweenness" title="10.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: the complexity of <a class="link" href="igraph-Structural.html#igraph_betweenness" title="10.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a> plus
O(n), the number of vertices queried, for calculating the
centralization score.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_closeness"></a>13.4. <code class="function">igraph_centralization_closeness</code> —  Calculate vertex closeness and graph centralization.</h3></div></div></div>
<a class="indexterm" name="id-1.14.15.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_centralization_closeness(const igraph_t *graph,
                                    igraph_vector_t *res,
                                    igraph_neimode_t mode,
                                    igraph_real_t *centralization,
                                    igraph_real_t *theoretical_max,
                                    igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>



This function calculates the closeness centrality of the vertices
by passing its arguments to <a class="link" href="igraph-Structural.html#igraph_closeness" title="10.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a>; and it
calculates the graph level centralization index based on the
results by calling <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  A vector if you need the node-level closeness scores, or a
    null pointer otherwise.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant the specifies the type of closeness for directed
    graphs. Possible values: <code class="constant">IGRAPH_IN</code>, <code class="constant">IGRAPH_OUT</code> and <code class="constant">IGRAPH_ALL</code>. This argument is ignored for undirected graphs. See
    <a class="link" href="igraph-Structural.html#igraph_closeness" title="10.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a> argument with the same name for more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>centralization</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the centralization
    score is placed here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>theoretical_max</code></em>:</span></p></td>
<td><p>
  Pointer to real number or a null pointer. If
    not a null pointer, then the theoretical maximum graph
    centrality score for a graph with the same number vertices is
    stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to calculate a normalized
    centralization score. See <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a> for how
    the normalization is done.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a>, <a class="link" href="igraph-Structural.html#igraph_closeness" title="10.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: the complexity of <a class="link" href="igraph-Structural.html#igraph_closeness" title="10.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a> plus
O(n), the number of vertices queried, for calculating the
centralization score.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_eigenvector_centrality"></a>13.5. <code class="function">igraph_centralization_eigenvector_centrality</code> —  Calculate eigenvector centrality scores and graph centralization.</h3></div></div></div>
<a class="indexterm" name="id-1.14.15.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_centralization_eigenvector_centrality(
    const igraph_t *graph,
    igraph_vector_t *vector,
    igraph_real_t *value,
    igraph_bool_t directed,
    igraph_bool_t scale,
    igraph_arpack_options_t *options,
    igraph_real_t *centralization,
    igraph_real_t *theoretical_max,
    igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>



This function calculates the eigenvector centrality of the vertices
by passing its arguments to <a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="10.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices."><code class="function">igraph_eigenvector_centrality</code></a>);
and it calculates the graph level centralization index based on the
results by calling <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  A vector if you need the node-level eigenvector
     centrality scores, or a null pointer otherwise.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then the leading eigenvalue is
     stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scale</code></em>:</span></p></td>
<td><p>
  If not zero then the result will be scaled, such that
    the absolute value of the maximum centrality is one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options to ARPACK. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Note that the function overwrites the
   <code class="literal">n</code> (number of vertices) parameter and
   it always starts the calculation from a non-random vector
   calculated based on the degree of the vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>centralization</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the centralization
    score is placed here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>theoretical_max</code></em>:</span></p></td>
<td><p>
  Pointer to real number or a null pointer. If
    not a null pointer, then the theoretical maximum graph
    centrality score for a graph with the same number vertices is
    stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to calculate a normalized
    centralization score. See <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a> for how
    the normalization is done.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a>, <a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="10.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices."><code class="function">igraph_eigenvector_centrality()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: the complexity of <a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="10.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices."><code class="function">igraph_eigenvector_centrality()</code></a> plus O(|V|), the number of vertices
for the calculating the centralization.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_degree_tmax"></a>13.6. <code class="function">igraph_centralization_degree_tmax</code> —  Theoretical maximum for graph centralization based on degree.</h3></div></div></div>
<a class="indexterm" name="id-1.14.15.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_centralization_degree_tmax(const igraph_t *graph,
                                      igraph_integer_t nodes,
                                      igraph_neimode_t mode,
                                      igraph_bool_t loops,
                                      igraph_real_t *res);
</pre></div>
<p>
</p>
<p>



This function returns the theoretical maximum graph centrality
based on vertex degree.

</p>
<p>
There are two ways to call this function, the first is to supply a
graph as the <code class="literal">graph</code> argument, and then the number of
vertices is taken from this object, and its directedness is
considered as well. The <code class="literal">nodes</code> argument is ignored in
this case. The <code class="literal">mode</code> argument is also ignored if the
supplied graph is undirected.

</p>
<p>
The other way is to supply a null pointer as the <code class="literal">graph</code>
argument. In this case the <code class="literal">nodes</code> and <code class="literal">mode</code>
arguments are considered.

</p>
<p>
The most centralized structure is the star. More specifically, for
undirected graphs it is the star, for directed graphs it is the
in-star or the out-star.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  A graph object or a null pointer, see the description
    above.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of nodes. This is ignored if the
    <code class="literal">graph</code> argument is not a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant, whether the calculation is based on in-degree
    (<code class="literal">IGRAPH_IN</code>), out-degree (<code class="literal">IGRAPH_OUT</code>)
    or total degree (<code class="literal">IGRAPH_ALL</code>). This is ignored if
    the <code class="literal">graph</code> argument is not a null pointer and the
    given graph is undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Boolean scalar, whether to consider loop edges in the
    calculation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization_degree" title="13.2. igraph_centralization_degree — Calculate vertex degree and graph centralization."><code class="function">igraph_centralization_degree()</code></a> and <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_betweenness_tmax"></a>13.7. <code class="function">igraph_centralization_betweenness_tmax</code> —  Theoretical maximum for graph centralization based on betweenness.</h3></div></div></div>
<a class="indexterm" name="id-1.14.15.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_centralization_betweenness_tmax(const igraph_t *graph,
        igraph_integer_t nodes,
        igraph_bool_t directed,
        igraph_real_t *res);
</pre></div>
<p>
</p>
<p>



This function returns the theoretical maximum graph centrality
based on vertex betweenness.

</p>
<p>
There are two ways to call this function, the first is to supply a
graph as the <code class="literal">graph</code> argument, and then the number of
vertices is taken from this object, and its directedness is
considered as well. The <code class="literal">nodes</code> argument is ignored in
this case. The <code class="literal">directed</code> argument is also ignored if the
supplied graph is undirected.

</p>
<p>
The other way is to supply a null pointer as the <code class="literal">graph</code>
argument. In this case the <code class="literal">nodes</code> and <code class="literal">directed</code>
arguments are considered.

</p>
<p>
The most centralized structure is the star.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  A graph object or a null pointer, see the description
    above.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of nodes. This is ignored if the
    <code class="literal">graph</code> argument is not a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean scalar, whether to use directed paths in
    the betweenness calculation. This argument is ignored if
    <code class="literal">graph</code> is not a null pointer and it is undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization_betweenness" title="13.3. igraph_centralization_betweenness — Calculate vertex betweenness and graph centralization."><code class="function">igraph_centralization_betweenness()</code></a> and <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_closeness_tmax"></a>13.8. <code class="function">igraph_centralization_closeness_tmax</code> —  Theoretical maximum for graph centralization based on closeness.</h3></div></div></div>
<a class="indexterm" name="id-1.14.15.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_centralization_closeness_tmax(const igraph_t *graph,
        igraph_integer_t nodes,
        igraph_neimode_t mode,
        igraph_real_t *res);
</pre></div>
<p>
</p>
<p>



This function returns the theoretical maximum graph centrality
based on vertex closeness.

</p>
<p>
There are two ways to call this function, the first is to supply a
graph as the <code class="literal">graph</code> argument, and then the number of
vertices is taken from this object, and its directedness is
considered as well. The <code class="literal">nodes</code> argument is ignored in
this case. The <code class="literal">mode</code> argument is also ignored if the
supplied graph is undirected.

</p>
<p>
The other way is to supply a null pointer as the <code class="literal">graph</code>
argument. In this case the <code class="literal">nodes</code> and <code class="literal">mode</code>
arguments are considered.

</p>
<p>
The most centralized structure is the star.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  A graph object or a null pointer, see the description
    above.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of nodes. This is ignored if the
    <code class="literal">graph</code> argument is not a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant, specifies what kinf of distances to consider
    to calculate closeness. See the <code class="literal">mode</code> argument of
    <a class="link" href="igraph-Structural.html#igraph_closeness" title="10.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a> for details. This argument is ignored
    if <code class="literal">graph</code> is not a null pointer and it is
    undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization_closeness" title="13.4. igraph_centralization_closeness — Calculate vertex closeness and graph centralization."><code class="function">igraph_centralization_closeness()</code></a> and <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_eigenvector_centrality_tmax"></a>13.9. <code class="function">igraph_centralization_eigenvector_centrality_tmax</code> —  Theoretical maximum centralization for eigenvector centrality.</h3></div></div></div>
<a class="indexterm" name="id-1.14.15.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_centralization_eigenvector_centrality_tmax(
    const igraph_t *graph,
    igraph_integer_t nodes,
    igraph_bool_t directed,
    igraph_bool_t scale,
    igraph_real_t *res);
</pre></div>
<p>
</p>
<p>



This function returns the theoretical maximum graph centrality
based on vertex eigenvector centrality.

</p>
<p>
There are two ways to call this function, the first is to supply a
graph as the <code class="literal">graph</code> argument, and then the number of
vertices is taken from this object, and its directedness is
considered as well. The <code class="literal">nodes</code> argument is ignored in
this case. The <code class="literal">directed</code> argument is also ignored if the
supplied graph is undirected.

</p>
<p>
The other way is to supply a null pointer as the <code class="literal">graph</code>
argument. In this case the <code class="literal">nodes</code> and <code class="literal">directed</code>
arguments are considered.

</p>
<p>
The most centralized directed structure is the in-star. The most
centralized undirected structure is the graph with a single edge.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  A graph object or a null pointer, see the description
    above.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of nodes. This is ignored if the
    <code class="literal">graph</code> argument is not a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean scalar, whether to consider edge
    directions. This argument is ignored if
    <code class="literal">graph</code> is not a null pointer and it is undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scale</code></em>:</span></p></td>
<td><p>
  Whether to rescale the node-level centrality scores to
    have a maximum of one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization_closeness" title="13.4. igraph_centralization_closeness — Calculate vertex closeness and graph centralization."><code class="function">igraph_centralization_closeness()</code></a> and <a class="link" href="igraph-Structural.html#igraph_centralization" title="13.1. igraph_centralization — Calculate the centralization score from the node level scores."><code class="function">igraph_centralization()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="similarity-measures"></a>14. Similarity measures</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_bibcoupling">14.1. <code class="function">igraph_bibcoupling</code> —  Bibliographic coupling.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_cocitation">14.2. <code class="function">igraph_cocitation</code> —  Cocitation coupling.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_jaccard">14.3. <code class="function">igraph_similarity_jaccard</code> —  Jaccard similarity coefficient for the given vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_jaccard_pairs">14.4. <code class="function">igraph_similarity_jaccard_pairs</code> —  Jaccard similarity coefficient for given vertex pairs.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_jaccard_es">14.5. <code class="function">igraph_similarity_jaccard_es</code> —  Jaccard similarity coefficient for a given edge selector.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_dice">14.6. <code class="function">igraph_similarity_dice</code> —  Dice similarity coefficient.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_dice_pairs">14.7. <code class="function">igraph_similarity_dice_pairs</code> —  Dice similarity coefficient for given vertex pairs.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_dice_es">14.8. <code class="function">igraph_similarity_dice_es</code> —  Dice similarity coefficient for a given edge selector.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_inverse_log_weighted">14.9. <code class="function">igraph_similarity_inverse_log_weighted</code> —  Vertex similarity based on the inverse logarithm of vertex degrees.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bibcoupling"></a>14.1. <code class="function">igraph_bibcoupling</code> —  Bibliographic coupling.</h3></div></div></div>
<a class="indexterm" name="id-1.14.16.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_bibcoupling(const igraph_t *graph, igraph_matrix_t *res,
                       const igraph_vs_t vids);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The bibliographic coupling of two vertices is the number
of other vertices they both cite, <a class="link" href="igraph-Structural.html#igraph_bibcoupling" title="14.1. igraph_bibcoupling — Bibliographic coupling."><code class="function">igraph_bibcoupling()</code></a> calculates
this.
The bibliographic coupling  score for each given vertex and all
other vertices in the graph will be calculated.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a matrix, the result of the calculation will
       be stored here. The number of its rows is the same as the
       number of vertex IDs in <em class="parameter"><code>vids</code></em>, the number of
       columns is the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex IDs of the vertices for which the
       calculation will be done.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVVID</code>: invalid vertex ID.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|d^2),
|V| is the number of vertices in
the graph, d is the (maximum)
degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_cocitation" title="14.2. igraph_cocitation — Cocitation coupling."><code class="function">igraph_cocitation()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.16.2.11.1"></a><p class="title"><b>Example 13.17.  File <code class="code">examples/simple/igraph_cocitation.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    igraph_matrix_t matrix;

    <span class="emphasis"><em>/* Create a small test graph. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="emphasis"><em>/* As usual with igraph functions, the data structure in which the result</em></span>
<span class="emphasis"><em>       will be returned must be initialized in advance. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;matrix, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_bibcoupling" title="14.1. igraph_bibcoupling — Bibliographic coupling.">igraph_bibcoupling</a></strong></span>(&amp;graph, &amp;matrix, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>());
    <span class="strong"><strong>printf</strong></span>("Bibliographic coupling matrix:\n");
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;matrix);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_cocitation" title="14.2. igraph_cocitation — Cocitation coupling.">igraph_cocitation</a></strong></span>(&amp;graph, &amp;matrix, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>());
    <span class="strong"><strong>printf</strong></span>("\nCocitation matrix:\n");
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;matrix);

    <span class="emphasis"><em>/* Destroy data structures when we are done with them. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;matrix);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_cocitation"></a>14.2. <code class="function">igraph_cocitation</code> —  Cocitation coupling.</h3></div></div></div>
<a class="indexterm" name="id-1.14.16.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_cocitation(const igraph_t *graph, igraph_matrix_t *res,
                      const igraph_vs_t vids);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Two vertices are cocited if there is another vertex citing both of
them. <a class="link" href="igraph-Structural.html#igraph_cocitation" title="14.2. igraph_cocitation — Cocitation coupling."><code class="function">igraph_cocitation()</code></a> simply counts how many times two vertices are
cocited.
The cocitation score for each given vertex and all other vertices
in the graph will be calculated.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a matrix, the result of the calculation will
       be stored here. The number of its rows is the same as the
       number of vertex IDs in <em class="parameter"><code>vids</code></em>, the number of
       columns is the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex IDs of the vertices for which the
       calculation will be done.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVVID</code>: invalid vertex ID.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|d^2), |V| is
the number of vertices in the graph,
d is the (maximum) degree of
the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_bibcoupling" title="14.1. igraph_bibcoupling — Bibliographic coupling."><code class="function">igraph_bibcoupling()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.16.3.11.1"></a><p class="title"><b>Example 13.18.  File <code class="code">examples/simple/igraph_cocitation.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    igraph_matrix_t matrix;

    <span class="emphasis"><em>/* Create a small test graph. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="emphasis"><em>/* As usual with igraph functions, the data structure in which the result</em></span>
<span class="emphasis"><em>       will be returned must be initialized in advance. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;matrix, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_bibcoupling" title="14.1. igraph_bibcoupling — Bibliographic coupling.">igraph_bibcoupling</a></strong></span>(&amp;graph, &amp;matrix, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>());
    <span class="strong"><strong>printf</strong></span>("Bibliographic coupling matrix:\n");
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;matrix);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_cocitation" title="14.2. igraph_cocitation — Cocitation coupling.">igraph_cocitation</a></strong></span>(&amp;graph, &amp;matrix, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>());
    <span class="strong"><strong>printf</strong></span>("\nCocitation matrix:\n");
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;matrix);

    <span class="emphasis"><em>/* Destroy data structures when we are done with them. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;matrix);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_jaccard"></a>14.3. <code class="function">igraph_similarity_jaccard</code> —  Jaccard similarity coefficient for the given vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.16.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_similarity_jaccard(const igraph_t *graph, igraph_matrix_t *res,
                              const igraph_vs_t vids, igraph_neimode_t mode, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The Jaccard similarity coefficient of two vertices is the number of common
neighbors divided by the number of vertices that are neighbors of at
least one of the two vertices being considered. This function calculates
the pairwise Jaccard similarities for some (or all) of the vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a matrix, the result of the calculation will
       be stored here. The number of its rows and columns is the same
       as the number of vertex IDs in <em class="parameter"><code>vids</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex IDs of the vertices for which the
       calculation will be done.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to include the vertices themselves in the neighbor
       sets.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex ID passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^2 d),
|V| is the number of vertices in the vertex iterator given, d is the
(maximum) degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="14.6. igraph_similarity_dice — Dice similarity coefficient."><code class="function">igraph_similarity_dice()</code></a>, a measure very similar to the Jaccard
  coefficient
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.16.4.11.1"></a><p class="title"><b>Example 13.19.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="14.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="14.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="14.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="14.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="14.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_range" title="4.5. igraph_vss_range — An interval of vertices (immediate version).">igraph_vss_range</a></strong></span>(1, 3), IGRAPH_ALL, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_jaccard_pairs"></a>14.4. <code class="function">igraph_similarity_jaccard_pairs</code> —  Jaccard similarity coefficient for given vertex pairs.</h3></div></div></div>
<a class="indexterm" name="id-1.14.16.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_similarity_jaccard_pairs(const igraph_t *graph, igraph_vector_t *res,
                                    const igraph_vector_int_t *pairs, igraph_neimode_t mode, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The Jaccard similarity coefficient of two vertices is the number of common
neighbors divided by the number of vertices that are neighbors of at
least one of the two vertices being considered. This function calculates
the pairwise Jaccard similarities for a list of vertex pairs.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result of the calculation will
       be stored here. The number of elements is the same as the number
       of pairs in <em class="parameter"><code>pairs</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pairs</code></em>:</span></p></td>
<td><p>
  A vector that contains the pairs for which the similarity
       will be calculated. Each pair is defined by two consecutive elements,
       i.e. the first and second element of the vector specifies the first
       pair, the third and fourth element specifies the second pair and so on.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to include the vertices themselves in the neighbor
       sets.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex ID passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nd), n is the number of pairs in the given vector, d is
the (maximum) degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices."><code class="function">igraph_similarity_jaccard()</code></a> to calculate the Jaccard similarity
  between all pairs of a vertex set, or <a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="14.6. igraph_similarity_dice — Dice similarity coefficient."><code class="function">igraph_similarity_dice()</code></a> and
  <a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="14.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs."><code class="function">igraph_similarity_dice_pairs()</code></a> for a measure very similar to the
  Jaccard coefficient
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.16.5.11.1"></a><p class="title"><b>Example 13.20.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="14.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="14.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="14.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="14.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="14.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_range" title="4.5. igraph_vss_range — An interval of vertices (immediate version).">igraph_vss_range</a></strong></span>(1, 3), IGRAPH_ALL, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_jaccard_es"></a>14.5. <code class="function">igraph_similarity_jaccard_es</code> —  Jaccard similarity coefficient for a given edge selector.</h3></div></div></div>
<a class="indexterm" name="id-1.14.16.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_similarity_jaccard_es(const igraph_t *graph, igraph_vector_t *res,
                                 const igraph_es_t es, igraph_neimode_t mode, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The Jaccard similarity coefficient of two vertices is the number of common
neighbors divided by the number of vertices that are neighbors of at
least one of the two vertices being considered. This function calculates
the pairwise Jaccard similarities for the endpoints of edges in a given edge
selector.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result of the calculation will
       be stored here. The number of elements is the same as the number
       of edges in <em class="parameter"><code>es</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>es</code></em>:</span></p></td>
<td><p>
  An edge selector that specifies the edges to be included in the
       result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to include the vertices themselves in the neighbor
       sets.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex ID passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nd), n is the number of edges in the edge selector, d is
the (maximum) degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices."><code class="function">igraph_similarity_jaccard()</code></a> and <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="14.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs."><code class="function">igraph_similarity_jaccard_pairs()</code></a>
  to calculate the Jaccard similarity between all pairs of a vertex set or
  some selected vertex pairs, or <a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="14.6. igraph_similarity_dice — Dice similarity coefficient."><code class="function">igraph_similarity_dice()</code></a>,
  <a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="14.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs."><code class="function">igraph_similarity_dice_pairs()</code></a> and <a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="14.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector."><code class="function">igraph_similarity_dice_es()</code></a> for a
  measure very similar to the Jaccard coefficient
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.16.6.11.1"></a><p class="title"><b>Example 13.21.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="14.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="14.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="14.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="14.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="14.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_range" title="4.5. igraph_vss_range — An interval of vertices (immediate version).">igraph_vss_range</a></strong></span>(1, 3), IGRAPH_ALL, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_dice"></a>14.6. <code class="function">igraph_similarity_dice</code> —  Dice similarity coefficient.</h3></div></div></div>
<a class="indexterm" name="id-1.14.16.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_similarity_dice(const igraph_t *graph, igraph_matrix_t *res,
                                      const igraph_vs_t vids,
                                      igraph_neimode_t mode, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




The Dice similarity coefficient of two vertices is twice the number of common
neighbors divided by the sum of the degrees of the vertices. This function
calculates the pairwise Dice similarities for some (or all) of the vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a matrix, the result of the calculation will
       be stored here. The number of its rows and columns is the same
       as the number of vertex IDs in <em class="parameter"><code>vids</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex IDs of the vertices for which the
       calculation will be done.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to include the vertices themselves as their own
       neighbors.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex ID passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^2 d),
where |V| is the number of vertices in the vertex iterator given, and
d is the (maximum) degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices."><code class="function">igraph_similarity_jaccard()</code></a>, a measure very similar to the Dice
  coefficient
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.16.7.10.1"></a><p class="title"><b>Example 13.22.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="14.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="14.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="14.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="14.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="14.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_range" title="4.5. igraph_vss_range — An interval of vertices (immediate version).">igraph_vss_range</a></strong></span>(1, 3), IGRAPH_ALL, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_dice_pairs"></a>14.7. <code class="function">igraph_similarity_dice_pairs</code> —  Dice similarity coefficient for given vertex pairs.</h3></div></div></div>
<a class="indexterm" name="id-1.14.16.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_similarity_dice_pairs(const igraph_t *graph, igraph_vector_t *res,
                                 const igraph_vector_int_t *pairs, igraph_neimode_t mode, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The Dice similarity coefficient of two vertices is twice the number of common
neighbors divided by the sum of the degrees of the vertices. This function
calculates the pairwise Dice similarities for a list of vertex pairs.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result of the calculation will
       be stored here. The number of elements is the same as the number
       of pairs in <em class="parameter"><code>pairs</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pairs</code></em>:</span></p></td>
<td><p>
  A vector that contains the pairs for which the similarity
       will be calculated. Each pair is defined by two consecutive elements,
       i.e. the first and second element of the vector specifies the first
       pair, the third and fourth element specifies the second pair and so on.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to include the vertices themselves as their own
       neighbors.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex ID passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nd), n is the number of pairs in the given vector, d is
the (maximum) degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="14.6. igraph_similarity_dice — Dice similarity coefficient."><code class="function">igraph_similarity_dice()</code></a> to calculate the Dice similarity
  between all pairs of a vertex set, or <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices."><code class="function">igraph_similarity_jaccard()</code></a>,
  <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="14.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs."><code class="function">igraph_similarity_jaccard_pairs()</code></a> and <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="14.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector."><code class="function">igraph_similarity_jaccard_es()</code></a>
  for a measure very similar to the Dice coefficient
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.16.8.11.1"></a><p class="title"><b>Example 13.23.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="14.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="14.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="14.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="14.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="14.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_range" title="4.5. igraph_vss_range — An interval of vertices (immediate version).">igraph_vss_range</a></strong></span>(1, 3), IGRAPH_ALL, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_dice_es"></a>14.8. <code class="function">igraph_similarity_dice_es</code> —  Dice similarity coefficient for a given edge selector.</h3></div></div></div>
<a class="indexterm" name="id-1.14.16.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_similarity_dice_es(const igraph_t *graph, igraph_vector_t *res,
                              const igraph_es_t es, igraph_neimode_t mode, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The Dice similarity coefficient of two vertices is twice the number of common
neighbors divided by the sum of the degrees of the vertices. This function
calculates the pairwise Dice similarities for the endpoints of edges in a given
edge selector.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result of the calculation will
       be stored here. The number of elements is the same as the number
       of edges in <em class="parameter"><code>es</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>es</code></em>:</span></p></td>
<td><p>
  An edge selector that specifies the edges to be included in the
       result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to include the vertices themselves as their own
       neighbors.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex ID passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nd), n is the number of pairs in the given vector, d is
the (maximum) degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="14.6. igraph_similarity_dice — Dice similarity coefficient."><code class="function">igraph_similarity_dice()</code></a> and <a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="14.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs."><code class="function">igraph_similarity_dice_pairs()</code></a>
  to calculate the Dice similarity between all pairs of a vertex set or
  some selected vertex pairs, or <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices."><code class="function">igraph_similarity_jaccard()</code></a>,
  <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="14.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs."><code class="function">igraph_similarity_jaccard_pairs()</code></a> and <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="14.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector."><code class="function">igraph_similarity_jaccard_es()</code></a>
  for a measure very similar to the Dice coefficient
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.16.9.11.1"></a><p class="title"><b>Example 13.24.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="14.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="14.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="14.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="14.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="14.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_range" title="4.5. igraph_vss_range — An interval of vertices (immediate version).">igraph_vss_range</a></strong></span>(1, 3), IGRAPH_ALL, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_inverse_log_weighted"></a>14.9. <code class="function">igraph_similarity_inverse_log_weighted</code> —  Vertex similarity based on the inverse logarithm of vertex degrees.</h3></div></div></div>
<a class="indexterm" name="id-1.14.16.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_similarity_inverse_log_weighted(const igraph_t *graph,
        igraph_matrix_t *res, const igraph_vs_t vids, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The inverse log-weighted similarity of two vertices is the number of
their common neighbors, weighted by the inverse logarithm of their degrees.
It is based on the assumption that two vertices should be considered
more similar if they share a low-degree common neighbor, since high-degree
common neighbors are more likely to appear even by pure chance.

</p>
<p>
Isolated vertices will have zero similarity to any other vertex.
Self-similarities are not calculated.

</p>
<p>
See the following paper for more details: Lada A. Adamic and Eytan Adar:
Friends and neighbors on the Web. Social Networks, 25(3):211-230, 2003.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a matrix, the result of the calculation will
       be stored here. The number of its rows is the same as the
       number of vertex IDs in <em class="parameter"><code>vids</code></em>, the number of
       columns is the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex IDs of the vertices for which the
       calculation will be done.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node. Nodes
         will be weighted according to their in-degree.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node. Nodes
         will be weighted according to their out-degree.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation. Every node is weighted according to its undirected
         degree.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVVID</code>: invalid vertex ID.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|d^2),
|V| is the number of vertices in
the graph, d is the (maximum)
degree of the vertices in the graph.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.16.10.11.1"></a><p class="title"><b>Example 13.25.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="14.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="14.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    igraph_vector_int_t pairs;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    igraph_integer_t i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="14.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, i);
            <span class="strong"><strong>igraph_vector_int_push_back</strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="14.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %" IGRAPH_PRId "-%" IGRAPH_PRId " "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="14.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        igraph_integer_t eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %" IGRAPH_PRId "-%" IGRAPH_PRId " (ID=%" IGRAPH_PRId ") "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="14.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_range" title="4.5. igraph_vss_range — An interval of vertices (immediate version).">igraph_vss_range</a></strong></span>(1, 3), IGRAPH_ALL, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="14.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>igraph_matrix_printf</strong></span>(&amp;m, "%.2f");
    <span class="strong"><strong>printf</strong></span>("==========\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="trees"></a>15. Trees and forests</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_minimum_spanning_tree">15.1. <code class="function">igraph_minimum_spanning_tree</code> —  Calculates one minimum spanning tree of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_minimum_spanning_tree_unweighted">15.2. <code class="function">igraph_minimum_spanning_tree_unweighted</code> —  Calculates one minimum spanning tree of an unweighted graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_minimum_spanning_tree_prim">15.3. <code class="function">igraph_minimum_spanning_tree_prim</code> —  Calculates one minimum spanning tree of a weighted graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_random_spanning_tree">15.4. <code class="function">igraph_random_spanning_tree</code> —  Uniformly samples the spanning trees of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_tree">15.5. <code class="function">igraph_is_tree</code> —  Decides whether the graph is a tree.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_forest">15.6. <code class="function">igraph_is_forest</code> —  Decides whether the graph is a forest.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_to_prufer">15.7. <code class="function">igraph_to_prufer</code> —  Converts a tree to its Prüfer sequence.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_minimum_spanning_tree"></a>15.1. <code class="function">igraph_minimum_spanning_tree</code> —  Calculates one minimum spanning tree of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.17.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_minimum_spanning_tree(
    const igraph_t* graph, igraph_vector_int_t* res, const igraph_vector_t* weights
);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If the graph has more minimum spanning trees (this is always the
case, except if it is a forest) this implementation returns only
the same one.

</p>
<p>
Directed graphs are considered as undirected for this computation.

</p>
<p>
If the graph is not connected then its minimum spanning forest is
returned. This is the set of the minimum spanning trees of each
component.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the IDs of the edges that constitute
       a spanning tree will be returned here. Use
       <a class="link" href="igraph-Operators.html#igraph_subgraph_edges" title="3.6. igraph_subgraph_edges — Creates a subgraph with the specified edges and their endpoints."><code class="function">igraph_subgraph_edges()</code></a> to extract the spanning tree as
       a separate graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A vector containing the weights of the edges
       in the same order as the simple edge iterator visits them
       (i.e. in increasing order of edge IDs).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
        temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|) for the unweighted case, O(|E| log |V|)
for the weighted case. |V| is the number of vertices, |E| the
number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree_unweighted" title="15.2. igraph_minimum_spanning_tree_unweighted — Calculates one minimum spanning tree of an unweighted graph."><code class="function">igraph_minimum_spanning_tree_unweighted()</code></a> and
    <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree_prim" title="15.3. igraph_minimum_spanning_tree_prim — Calculates one minimum spanning tree of a weighted graph."><code class="function">igraph_minimum_spanning_tree_prim()</code></a> if you only need the
    tree as a separate graph object.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.17.2.13.1"></a><p class="title"><b>Example 13.26.  File <code class="code">examples/simple/igraph_minimum_spanning_tree.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t graph, tree;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> eb;
    igraph_vector_int_t edges;

    <span class="emphasis"><em>/* Create the Frucht graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_famous" title="1.20. igraph_famous — Create a famous graph by simply providing its name.">igraph_famous</a></strong></span>(&amp;graph, "Frucht");

    <span class="emphasis"><em>/* Compute the edge betweenness. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;eb, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;graph));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_edge_betweenness" title="10.4. igraph_edge_betweenness — Betweenness centrality of the edges.">igraph_edge_betweenness</a></strong></span>(&amp;graph, &amp;eb, IGRAPH_UNDIRECTED, <span class="emphasis"><em>/*weights=*/</em></span> NULL);

    <span class="emphasis"><em>/* Compute and output a minimum weight spanning tree using edge betweenness</em></span>
<span class="emphasis"><em>     * values as weights. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree_prim" title="15.3. igraph_minimum_spanning_tree_prim — Calculates one minimum spanning tree of a weighted graph.">igraph_minimum_spanning_tree_prim</a></strong></span>(&amp;graph, &amp;tree, &amp;eb);
    <span class="strong"><strong>printf</strong></span>("Minimum spanning tree:\n");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;tree, stdout);

    <span class="emphasis"><em>/* A maximum spanning tree can be computed by first negating the weights. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_scale" title="2.8.2. igraph_vector_scale — Multiplies all elements of a vector by a constant.">igraph_vector_scale</a></strong></span>(&amp;eb, -1);

    <span class="emphasis"><em>/* Compute and output the edges that belong to the maximum weight spanning tree. */</em></span>
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;edges, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree" title="15.1. igraph_minimum_spanning_tree — Calculates one minimum spanning tree of a graph.">igraph_minimum_spanning_tree</a></strong></span>(&amp;graph, &amp;edges, &amp;eb);
    <span class="strong"><strong>printf</strong></span>("\nMaximum spanning tree edges:\n");
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;edges);

    igraph_real_t total_tree_weight = 0;
    igraph_integer_t n = <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;edges);
    <span class="strong"><strong>for</strong></span> (igraph_integer_t i=0; i &lt; n; i++) {
        total_tree_weight += -<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(eb)[ <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(edges)[i] ];
    }
    <span class="strong"><strong>printf</strong></span>("\nTotal maximum spanning tree weight: %g\n", total_tree_weight);

    <span class="emphasis"><em>/* Clean up */</em></span>
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;edges);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;tree);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;eb);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_minimum_spanning_tree_unweighted"></a>15.2. <code class="function">igraph_minimum_spanning_tree_unweighted</code> —  Calculates one minimum spanning tree of an unweighted graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.17.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_minimum_spanning_tree_unweighted(const igraph_t *graph,
        igraph_t *mst);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If the graph has more minimum spanning trees (this is always the
case, except if it is a forest) this implementation returns only
the same one.

</p>
<p>
Directed graphs are considered as undirected for this computation.

</p>
<p>
If the graph is not connected then its minimum spanning forest is
returned. This is the set of the minimum spanning trees of each
component.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mst</code></em>:</span></p></td>
<td><p>
  The minimum spanning tree, another graph object. Do
       <span class="emphasis"><em>not</em></span> initialize this object before passing it to
       this function, but be sure to call <a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object."><code class="function">igraph_destroy()</code></a> on it if
       you don't need it any more.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
        temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|),
|V| is the
number of vertices, |E| the number
of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree_prim" title="15.3. igraph_minimum_spanning_tree_prim — Calculates one minimum spanning tree of a weighted graph."><code class="function">igraph_minimum_spanning_tree_prim()</code></a> for weighted graphs,
    <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree" title="15.1. igraph_minimum_spanning_tree — Calculates one minimum spanning tree of a graph."><code class="function">igraph_minimum_spanning_tree()</code></a> if you need the IDs of the
    edges that constitute the spanning tree.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_minimum_spanning_tree_prim"></a>15.3. <code class="function">igraph_minimum_spanning_tree_prim</code> —  Calculates one minimum spanning tree of a weighted graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.17.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_minimum_spanning_tree_prim(const igraph_t *graph, igraph_t *mst,
                                      const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function uses Prim's method for carrying out the computation,
see Prim, R.C.: Shortest connection networks and some
generalizations, Bell System Technical
Journal, Vol. 36,
1957, 1389--1401.

</p>
<p>
If the graph has more than one minimum spanning tree, the current
implementation returns always the same one.

</p>
<p>
Directed graphs are considered as undirected for this computation.

</p>
<p>
If the graph is not connected then its minimum spanning forest is
returned. This is the set of the minimum spanning trees of each
component.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mst</code></em>:</span></p></td>
<td><p>
  The result of the computation, a graph object containing
       the minimum spanning tree of the graph.
       Do <span class="emphasis"><em>not</em></span> initialize this object before passing it to
       this function, but be sure to call <a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object."><code class="function">igraph_destroy()</code></a> on it if
       you don't need it any more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A vector containing the weights of the edges
       in the same order as the simple edge iterator visits them
       (i.e. in increasing order of edge IDs).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory.
        <code class="constant">IGRAPH_EINVAL</code>, length of weight vector does not
          match number of edges.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E| log |V|),
|V| is the number of vertices,
|E| the number of edges in the
graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree_unweighted" title="15.2. igraph_minimum_spanning_tree_unweighted — Calculates one minimum spanning tree of an unweighted graph."><code class="function">igraph_minimum_spanning_tree_unweighted()</code></a> for unweighted graphs,
    <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree" title="15.1. igraph_minimum_spanning_tree — Calculates one minimum spanning tree of a graph."><code class="function">igraph_minimum_spanning_tree()</code></a> if you need the IDs of the
    edges that constitute the spanning tree.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.17.4.14.1"></a><p class="title"><b>Example 13.27.  File <code class="code">examples/simple/igraph_minimum_spanning_tree.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t graph, tree;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> eb;
    igraph_vector_int_t edges;

    <span class="emphasis"><em>/* Create the Frucht graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_famous" title="1.20. igraph_famous — Create a famous graph by simply providing its name.">igraph_famous</a></strong></span>(&amp;graph, "Frucht");

    <span class="emphasis"><em>/* Compute the edge betweenness. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;eb, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;graph));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_edge_betweenness" title="10.4. igraph_edge_betweenness — Betweenness centrality of the edges.">igraph_edge_betweenness</a></strong></span>(&amp;graph, &amp;eb, IGRAPH_UNDIRECTED, <span class="emphasis"><em>/*weights=*/</em></span> NULL);

    <span class="emphasis"><em>/* Compute and output a minimum weight spanning tree using edge betweenness</em></span>
<span class="emphasis"><em>     * values as weights. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree_prim" title="15.3. igraph_minimum_spanning_tree_prim — Calculates one minimum spanning tree of a weighted graph.">igraph_minimum_spanning_tree_prim</a></strong></span>(&amp;graph, &amp;tree, &amp;eb);
    <span class="strong"><strong>printf</strong></span>("Minimum spanning tree:\n");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;tree, stdout);

    <span class="emphasis"><em>/* A maximum spanning tree can be computed by first negating the weights. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_scale" title="2.8.2. igraph_vector_scale — Multiplies all elements of a vector by a constant.">igraph_vector_scale</a></strong></span>(&amp;eb, -1);

    <span class="emphasis"><em>/* Compute and output the edges that belong to the maximum weight spanning tree. */</em></span>
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;edges, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree" title="15.1. igraph_minimum_spanning_tree — Calculates one minimum spanning tree of a graph.">igraph_minimum_spanning_tree</a></strong></span>(&amp;graph, &amp;edges, &amp;eb);
    <span class="strong"><strong>printf</strong></span>("\nMaximum spanning tree edges:\n");
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;edges);

    igraph_real_t total_tree_weight = 0;
    igraph_integer_t n = <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;edges);
    <span class="strong"><strong>for</strong></span> (igraph_integer_t i=0; i &lt; n; i++) {
        total_tree_weight += -<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(eb)[ <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(edges)[i] ];
    }
    <span class="strong"><strong>printf</strong></span>("\nTotal maximum spanning tree weight: %g\n", total_tree_weight);

    <span class="emphasis"><em>/* Clean up */</em></span>
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;edges);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;tree);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;eb);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_random_spanning_tree"></a>15.4. <code class="function">igraph_random_spanning_tree</code> —  Uniformly samples the spanning trees of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.17.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_random_spanning_tree(const igraph_t *graph, igraph_vector_int_t *res, igraph_integer_t vid);
</pre></div>
<p>
</p>
<p>



Performs a loop-erased random walk on the graph to uniformly sample
its spanning trees. Edge directions are ignored.
</p>
<p>

Multi-graphs are supported, and edge multiplicities will affect the sampling
frequency. For example, consider the 3-cycle graph <code class="literal">1=2-3-1</code>, with two edges
between vertices 1 and 2. Due to these parallel edges, the trees <code class="literal">1-2-3</code>
and <code class="literal">3-1-2</code> will be sampled with multiplicity 2, while the tree
<code class="literal">2-3-1</code> will be sampled with multiplicity 1.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Edge directions are ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the IDs of the edges that constitute
       a spanning tree will be returned here. Use
       <a class="link" href="igraph-Operators.html#igraph_subgraph_edges" title="3.6. igraph_subgraph_edges — Creates a subgraph with the specified edges and their endpoints."><code class="function">igraph_subgraph_edges()</code></a> to extract the spanning tree as
       a separate graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vid</code></em>:</span></p></td>
<td><p>
  This parameter is relevant if the graph is not connected.
       If negative, a random spanning forest of all components will be
       generated. Otherwise, it should be the ID of a vertex. A random
       spanning tree of the component containing the vertex will be
       generated.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree" title="15.1. igraph_minimum_spanning_tree — Calculates one minimum spanning tree of a graph."><code class="function">igraph_minimum_spanning_tree()</code></a>, <a class="link" href="igraph-Visitors.html#igraph_random_walk" title="3.1. igraph_random_walk — Performs a random walk on a graph."><code class="function">igraph_random_walk()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_tree"></a>15.5. <code class="function">igraph_is_tree</code> —  Decides whether the graph is a tree.</h3></div></div></div>
<a class="indexterm" name="id-1.14.17.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_tree(const igraph_t *graph, igraph_bool_t *res, igraph_integer_t *root, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




An undirected graph is a tree if it is connected and has no cycles.

</p>
<p>
In the directed case, a possible additional requirement is that all
edges are oriented away from a root (out-tree or arborescence) or all edges
are oriented towards a root (in-tree or anti-arborescence).
This test can be controlled using the <em class="parameter"><code>mode</code></em> parameter.

</p>
<p>
By convention, the null graph (i.e. the graph with no vertices) is considered not to be a tree.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a logical variable, the result will be stored
       here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>root</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code>, the root node will be stored here. When <em class="parameter"><code>mode</code></em>
       is <code class="constant">IGRAPH_ALL</code> or the graph is undirected, any vertex can be the root
       and <em class="parameter"><code>root</code></em> is set to 0 (the first vertex). When <em class="parameter"><code>mode</code></em> is <code class="constant">IGRAPH_OUT</code>
       or <code class="constant">IGRAPH_IN</code>, the root is set to the vertex with zero in- or out-degree,
       respectively.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For a directed graph this specifies whether to test for an
       out-tree, an in-tree or ignore edge directions. The respective
       possible values are:
       <code class="constant">IGRAPH_OUT</code>, <code class="constant">IGRAPH_IN</code>, <code class="constant">IGRAPH_ALL</code>. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_EINVAL</code>: invalid mode argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: At most O(|V|+|E|), the
number of vertices plus the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_connected" title="8.4. igraph_is_connected — Decides whether the graph is (weakly or strongly) connected."><code class="function">igraph_is_connected()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.17.6.12.1"></a><p class="title"><b>Example 13.28.  File <code class="code">examples/simple/igraph_kary_tree.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    igraph_bool_t res;

    <span class="emphasis"><em>/* Create a directed binary tree on 15 nodes,</em></span>
<span class="emphasis"><em>       with edges pointing towards the root. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_kary_tree" title="1.12. igraph_kary_tree — Creates a k-ary tree in which almost all vertices have k children.">igraph_kary_tree</a></strong></span>(&amp;graph, 15, 2, IGRAPH_TREE_IN);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_tree" title="15.5. igraph_is_tree — Decides whether the graph is a tree.">igraph_is_tree</a></strong></span>(&amp;graph, &amp;res, NULL, IGRAPH_IN);
    <span class="strong"><strong>printf</strong></span>("Is it an in-tree? %s\n", res ? "Yes" : "No");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_tree" title="15.5. igraph_is_tree — Decides whether the graph is a tree.">igraph_is_tree</a></strong></span>(&amp;graph, &amp;res, NULL, IGRAPH_OUT);
    <span class="strong"><strong>printf</strong></span>("Is it an out-tree? %s\n", res ? "Yes" : "No");

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_forest"></a>15.6. <code class="function">igraph_is_forest</code> —  Decides whether the graph is a forest.</h3></div></div></div>
<a class="indexterm" name="id-1.14.17.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_forest(const igraph_t *graph, igraph_bool_t *res,
                                igraph_vector_int_t *roots, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




An undirected graph is a forest if it has no cycles.
</p>
<p>

In the directed case, a possible additional requirement is that edges in each
tree are oriented away from the root (out-trees or arborescences) or all edges
are oriented towards the root (in-trees or anti-arborescences).
This test can be controlled using the <em class="parameter"><code>mode</code></em> parameter.
</p>
<p>

By convention, the null graph (i.e. the graph with no vertices) is considered to be a forest.
</p>
<p>

The <em class="parameter"><code>res</code></em> return value of this function is cached in the graph itself if
<em class="parameter"><code>mode</code></em> is set to <code class="constant">IGRAPH_ALL</code> or if the graph is undirected. Calling the
function multiple times with no modifications to the graph in between
will return a cached value in O(1) time if the roots are not asked for.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a logical variable. If not <code class="constant">NULL</code>, then the result will be stored
       here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>roots</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code>, the root nodes will be stored here. When <em class="parameter"><code>mode</code></em>
       is <code class="constant">IGRAPH_ALL</code> or the graph is undirected, any one vertex from each
       component can be the root. When <em class="parameter"><code>mode</code></em> is <code class="constant">IGRAPH_OUT</code>
       or <code class="constant">IGRAPH_IN</code>, all the vertices with zero in- or out-degree,
       respectively are considered as root nodes.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For a directed graph this specifies whether to test for an
       out-forest, an in-forest or ignore edge directions. The respective
       possible values are:
       <code class="constant">IGRAPH_OUT</code>, <code class="constant">IGRAPH_IN</code>, <code class="constant">IGRAPH_ALL</code>. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_EINVMODE</code>: invalid mode argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: At most O(|V|+|E|), the
number of vertices plus the number of edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_to_prufer"></a>15.7. <code class="function">igraph_to_prufer</code> —  Converts a tree to its Prüfer sequence.</h3></div></div></div>
<a class="indexterm" name="id-1.14.17.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_to_prufer(const igraph_t *graph, igraph_vector_int_t* prufer);
</pre></div>
<p>
</p>
<p>




A Prüfer sequence is a unique sequence of integers associated
with a labelled tree. A tree on n &gt;= 2 vertices can be represented by a
sequence of n-2 integers, each between 0 and n-1 (inclusive).

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized graph object which
          must be a tree on n &gt;= 2 vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>prufer</code></em>:</span></p></td>
<td><p>
  A pointer to the integer vector that should hold the Prüfer sequence;
                 the vector must be initialized and will be resized to n - 2.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
         </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

            there is not enough memory to perform the operation.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

            the graph is not a tree or it is has less than vertices
         
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_from_prufer" title="1.23. igraph_from_prufer — Generates a tree from a Prüfer sequence."><code class="function">igraph_from_prufer()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="transitivity-or-clustering-coefficient"></a>16. Transitivity or clustering coefficient</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_transitivity_undirected">16.1. <code class="function">igraph_transitivity_undirected</code> —  Calculates the transitivity (clustering coefficient) of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_transitivity_local_undirected">16.2. <code class="function">igraph_transitivity_local_undirected</code> —  Calculates the local transitivity (clustering coefficient) of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_transitivity_avglocal_undirected">16.3. <code class="function">igraph_transitivity_avglocal_undirected</code> —  Average local transitivity (clustering coefficient).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_transitivity_barrat">16.4. <code class="function">igraph_transitivity_barrat</code> —  Weighted transitivity, as defined by A. Barrat.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_transitivity_undirected"></a>16.1. <code class="function">igraph_transitivity_undirected</code> —  Calculates the transitivity (clustering coefficient) of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.18.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_transitivity_undirected(const igraph_t *graph,
                                   igraph_real_t *res,
                                   igraph_transitivity_mode_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The transitivity measures the probability that two neighbors of a
vertex are connected. More precisely, this is the ratio of the
triangles and connected triples in the graph, the result is a
single real number. Directed graphs are considered as undirected ones
and multi-edges are ignored.

</p>
<p>
Note that this measure is different from the local transitivity measure
(see <a class="link" href="igraph-Structural.html#igraph_transitivity_local_undirected" title="16.2. igraph_transitivity_local_undirected — Calculates the local transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_local_undirected()</code></a> ) as it calculates a single
value for the whole graph.

</p>
<p>
Clustering coefficient is an alternative name for transitivity.

</p>
<p>
References:

</p>
<p>
S. Wasserman and K. Faust: Social Network Analysis: Methods and
Applications. Cambridge: Cambridge University Press, 1994.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object. Edge directions and multiplicites are ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Defines how to treat graphs with no connected triples.
  <code class="constant">IGRAPH_TRANSITIVITY_NAN</code> returns <code class="constant">NaN</code> in this case,
  <code class="constant">IGRAPH_TRANSITIVITY_ZERO</code> returns zero.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>: not enough memory for
        temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_transitivity_local_undirected" title="16.2. igraph_transitivity_local_undirected — Calculates the local transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_local_undirected()</code></a>,
<a class="link" href="igraph-Structural.html#igraph_transitivity_avglocal_undirected" title="16.3. igraph_transitivity_avglocal_undirected — Average local transitivity (clustering coefficient)."><code class="function">igraph_transitivity_avglocal_undirected()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*d^2), |V| is the number of vertices in
the graph, d is the average node degree.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.18.2.15.1"></a><p class="title"><b>Example 13.29.  File <code class="code">examples/simple/igraph_transitivity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t res;

    <span class="emphasis"><em>/* Trivial cases */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.11. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;g, 100, IGRAPH_UNDIRECTED, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="16.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph.">igraph_transitivity_undirected</a></strong></span>(&amp;g, &amp;res, IGRAPH_TRANSITIVITY_NAN);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (res != 0) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.15. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;g, 20, IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="16.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph.">igraph_transitivity_undirected</a></strong></span>(&amp;g, &amp;res, IGRAPH_TRANSITIVITY_NAN);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (res != 1) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="emphasis"><em>/* Degenerate cases */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED,
                 0,  1,  2,  3,  4,  5, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="16.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph.">igraph_transitivity_undirected</a></strong></span>(&amp;g, &amp;res, IGRAPH_TRANSITIVITY_NAN);
    <span class="emphasis"><em>/* res should be NaN here, any comparison must return false */</em></span>
    <span class="strong"><strong>if</strong></span> (res == 0 || res &gt; 0 || res &lt; 0) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="16.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph.">igraph_transitivity_undirected</a></strong></span>(&amp;g, &amp;res, IGRAPH_TRANSITIVITY_ZERO);
    <span class="emphasis"><em>/* res should be zero here */</em></span>
    <span class="strong"><strong>if</strong></span> (res) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Zachary Karate club */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED,
                 0,  1,  0,  2,  0,  3,  0,  4,  0,  5,
                 0,  6,  0,  7,  0,  8,  0, 10,  0, 11,
                 0, 12,  0, 13,  0, 17,  0, 19,  0, 21,
                 0, 31,  1,  2,  1,  3,  1,  7,  1, 13,
                 1, 17,  1, 19,  1, 21,  1, 30,  2,  3,
                 2,  7,  2,  8,  2,  9,  2, 13,  2, 27,
                 2, 28,  2, 32,  3,  7,  3, 12,  3, 13,
                 4,  6,  4, 10,  5,  6,  5, 10,  5, 16,
                 6, 16,  8, 30,  8, 32,  8, 33,  9, 33,
                 13, 33, 14, 32, 14, 33, 15, 32, 15, 33,
                 18, 32, 18, 33, 19, 33, 20, 32, 20, 33,
                 22, 32, 22, 33, 23, 25, 23, 27, 23, 29,
                 23, 32, 23, 33, 24, 25, 24, 27, 24, 31,
                 25, 31, 26, 29, 26, 33, 27, 33, 28, 31,
                 28, 33, 29, 32, 29, 33, 30, 32, 30, 33,
                 31, 32, 31, 33, 32, 33,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="16.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph.">igraph_transitivity_undirected</a></strong></span>(&amp;g, &amp;res, IGRAPH_TRANSITIVITY_NAN);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (res != 0.2556818181818181767717) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "%f != %f\n", res, 0.2556818181818181767717);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_transitivity_local_undirected"></a>16.2. <code class="function">igraph_transitivity_local_undirected</code> —  Calculates the local transitivity (clustering coefficient) of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.18.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_transitivity_local_undirected(const igraph_t *graph,
        igraph_vector_t *res,
        const igraph_vs_t vids,
        igraph_transitivity_mode_t mode);
</pre></div>
<p>
</p>
<p>



The transitivity measures the probability that two neighbors of a
vertex are connected. In case of the local transitivity, this
probability is calculated separately for each vertex.

</p>
<p>
Note that this measure is different from the global transitivity measure
(see <a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="16.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_undirected()</code></a> ) as it calculates a transitivity
value for each vertex individually.

</p>
<p>
Clustering coefficient is an alternative name for transitivity.

</p>
<p>
References:

</p>
<p>
D. J. Watts and S. Strogatz: Collective dynamics of small-world networks.
Nature 393(6684):440-442 (1998).

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Edge directions and multiplicities are ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result will be
  stored here. It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  Vertex set, the vertices for which the local
  transitivity will be calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Defines how to treat vertices with degree less than two.
   <code class="constant">IGRAPH_TRANSITIVITY_NAN</code> returns <code class="constant">NaN</code> for these vertices,
   <code class="constant">IGRAPH_TRANSITIVITY_ZERO</code> returns zero.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="16.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_undirected()</code></a>, <a class="link" href="igraph-Structural.html#igraph_transitivity_avglocal_undirected" title="16.3. igraph_transitivity_avglocal_undirected — Average local transitivity (clustering coefficient)."><code class="function">igraph_transitivity_avglocal_undirected()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*d^2), n is the number of vertices for which
the transitivity is calculated, d is the average vertex degree.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_transitivity_avglocal_undirected"></a>16.3. <code class="function">igraph_transitivity_avglocal_undirected</code> —  Average local transitivity (clustering coefficient).</h3></div></div></div>
<a class="indexterm" name="id-1.14.18.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_transitivity_avglocal_undirected(const igraph_t *graph,
        igraph_real_t *res,
        igraph_transitivity_mode_t mode);
</pre></div>
<p>
</p>
<p>



The transitivity measures the probability that two neighbors of a
vertex are connected. In case of the average local transitivity,
this probability is calculated for each vertex and then the average
is taken. Vertices with less than two neighbors require special treatment,
they will either be left out from the calculation or they will be considered
as having zero transitivity, depending on the <code class="constant">mode</code> argument.
Edge directions and edge multiplicities are ignored.

</p>
<p>
Note that this measure is different from the global transitivity measure
(see <a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="16.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_undirected()</code></a> ) as it simply takes the
average local transitivity across the whole network.

</p>
<p>
Clustering coefficient is an alternative name for transitivity.

</p>
<p>
References:

</p>
<p>
D. J. Watts and S. Strogatz: Collective dynamics of small-world networks.
Nature 393(6684):440-442 (1998).

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Edge directions and multiplicites are ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Defines how to treat vertices with degree less than two.
   <code class="constant">IGRAPH_TRANSITIVITY_NAN</code> leaves them out from averaging,
   <code class="constant">IGRAPH_TRANSITIVITY_ZERO</code> includes them with zero transitivity.
   The result will be <code class="constant">NaN</code> if the mode is <code class="constant">IGRAPH_TRANSITIVITY_NAN</code>
   and there are no vertices with more than one neighbor.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="16.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_undirected()</code></a>, <a class="link" href="igraph-Structural.html#igraph_transitivity_local_undirected" title="16.2. igraph_transitivity_local_undirected — Calculates the local transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_local_undirected()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*d^2), |V| is the number of vertices in the
graph and d is the average degree.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_transitivity_barrat"></a>16.4. <code class="function">igraph_transitivity_barrat</code> —  Weighted transitivity, as defined by A. Barrat.</h3></div></div></div>
<a class="indexterm" name="id-1.14.18.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_transitivity_barrat(const igraph_t *graph,
                               igraph_vector_t *res,
                               const igraph_vs_t vids,
                               const igraph_vector_t *weights,
                               igraph_transitivity_mode_t mode);
</pre></div>
<p>
</p>
<p>



This is a local transitivity, i.e. a vertex-level index. For a
given vertex <code class="constant">i</code>, from all triangles in which it participates we
consider the weight of the edges incident on <code class="constant">i</code>. The transitivity
is the sum of these weights divided by twice the strength of the
vertex (see <a class="link" href="igraph-Structural.html#igraph_strength" title="10.11. igraph_strength — Strength of the vertices, also called weighted vertex degree."><code class="function">igraph_strength()</code></a>) and the degree of the vertex
minus one. See equation (5) in Alain Barrat, Marc Barthelemy, Romualdo
Pastor-Satorras, Alessandro Vespignani: The architecture of complex
weighted networks, Proc. Natl. Acad. Sci. USA 101, 3747 (2004) at
<a class="ulink" href="https://doi.org/10.1073/pnas.0400087101" target="_top">https://doi.org/10.1073/pnas.0400087101</a> for the exact formula.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Edge directions are ignored for
  directed graphs. Note that the function does <span class="emphasis"><em>not</em></span> work for
  non-simple graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result will be
  stored here. It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Edge weights. If this is a null pointer, then a
  warning is given and <a class="link" href="igraph-Structural.html#igraph_transitivity_local_undirected" title="16.2. igraph_transitivity_local_undirected — Calculates the local transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_local_undirected()</code></a>
  is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Defines how to treat vertices with zero strength.
  <code class="constant">IGRAPH_TRANSITIVITY_NAN</code> says that the transitivity of these
  vertices is <code class="constant">NaN</code>, <code class="constant">IGRAPH_TRANSITIVITY_ZERO</code> says it is zero.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*d^2), |V| is the number of vertices in
the graph, d is the average node degree.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="16.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_undirected()</code></a>, <a class="link" href="igraph-Structural.html#igraph_transitivity_local_undirected" title="16.2. igraph_transitivity_local_undirected — Calculates the local transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_local_undirected()</code></a> and <a class="link" href="igraph-Structural.html#igraph_transitivity_avglocal_undirected" title="16.3. igraph_transitivity_avglocal_undirected — Average local transitivity (clustering coefficient)."><code class="function">igraph_transitivity_avglocal_undirected()</code></a> for other kinds of
(non-weighted) transitivity.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="directedness-conversion"></a>17. Directedness conversion</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_to_directed">17.1. <code class="function">igraph_to_directed</code> —  Convert an undirected graph to a directed one.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_to_undirected">17.2. <code class="function">igraph_to_undirected</code> —  Convert a directed graph to an undirected one.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_to_directed"></a>17.1. <code class="function">igraph_to_directed</code> —  Convert an undirected graph to a directed one.</h3></div></div></div>
<a class="indexterm" name="id-1.14.19.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_to_directed(igraph_t *graph,
                       igraph_to_directed_t mode);
</pre></div>
<p>
</p>
<p>



</p>
<p>
If the supplied graph is directed, this function does nothing.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to convert.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  Constant, specifies the details of how exactly the
       conversion is done. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TO_DIRECTED_ARBITRARY</code></span></p></td>
<td><p>

       The number of edges in the
       graph stays the same, an arbitrarily directed edge is
       created for each undirected edge.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TO_DIRECTED_MUTUAL</code></span></p></td>
<td><p>

       Two directed edges are
       created for each undirected edge, one in each direction.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TO_DIRECTED_RANDOM</code></span></p></td>
<td><p>

       Each undirected edge is converted to a randomly oriented
       directed one.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TO_DIRECTED_ACYCLIC</code></span></p></td>
<td><p>

       Each undirected edge is converted to a directed edge oriented
       from a lower index vertex to a higher index one. If no self-loops
       were present, then the result is a directed acyclic graph.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_to_undirected"></a>17.2. <code class="function">igraph_to_undirected</code> —  Convert a directed graph to an undirected one.</h3></div></div></div>
<a class="indexterm" name="id-1.14.19.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_to_undirected(igraph_t *graph,
                         igraph_to_undirected_t mode,
                         const igraph_attribute_combination_t *edge_comb);
</pre></div>
<p>
</p>
<p>



</p>
<p>
If the supplied graph is undirected, this function does nothing.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to convert.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant, specifies the details of how exactly the
       conversion is done. Possible values: <code class="constant">IGRAPH_TO_UNDIRECTED_EACH</code>: the number of edges remains
       constant, an undirected edge is created for each directed
       one, this version might create graphs with multiple edges;
       <code class="constant">IGRAPH_TO_UNDIRECTED_COLLAPSE</code>: one undirected edge will
       be created for each pair of vertices that are connected
       with at least one directed edge, no multiple edges will be
       created. <code class="constant">IGRAPH_TO_UNDIRECTED_MUTUAL</code> creates an undirected
       edge for each pair of mutual edges in the directed graph.
       Non-mutual edges are lost; loop edges are kept unconditionally.
       This mode might create multiple edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_comb</code></em>:</span></p></td>
<td><p>
  What to do with the edge attributes. See the igraph
       manual section about attributes for details. <code class="constant">NULL</code> means that
       the edge attributes are lost during the conversion, <span class="emphasis"><em>except</em></span>
       when <code class="constant">mode</code> is <code class="constant">IGRAPH_TO_UNDIRECTED_EACH</code>, in which case the
       edge attributes are kept intact.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.19.3.9.1"></a><p class="title"><b>Example 13.30.  File <code class="code">examples/simple/igraph_to_undirected.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_vector_int_t v;
    igraph_t g;

    <span class="strong"><strong>igraph_vector_int_init_int</strong></span>(&amp;v, 2, 5, 5);
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_square_lattice" title="1.10. igraph_square_lattice — Arbitrary dimensional square lattices.">igraph_square_lattice</a></strong></span>(&amp;g, &amp;v, 1, IGRAPH_DIRECTED, 1 <span class="emphasis"><em>/*mutual*/</em></span>, 0 <span class="emphasis"><em>/*periodic*/</em></span>);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_to_undirected" title="17.2. igraph_to_undirected — Convert a directed graph to an undirected one.">igraph_to_undirected</a></strong></span>(&amp;g, IGRAPH_TO_UNDIRECTED_COLLAPSE,
                         <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;g, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;v);

    <span class="strong"><strong>printf</strong></span>("---\n");

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 3,
                 5, 6, 6, 5, 6, 7, 6, 7, 7, 6, 7, 8, 7, 8, 8, 7, 8, 7, 8, 8, 9, 9, 9, 9,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_to_undirected" title="17.2. igraph_to_undirected — Convert a directed graph to an undirected one.">igraph_to_undirected</a></strong></span>(&amp;g, IGRAPH_TO_UNDIRECTED_MUTUAL,
                         <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;g, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="spectral-properties"></a>18. Spectral properties</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_laplacian">18.1. <code class="function">igraph_get_laplacian</code> —  Returns the Laplacian matrix of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_laplacian_sparse">18.2. <code class="function">igraph_get_laplacian_sparse</code> —  Returns the Laplacian of a graph in a sparse matrix format.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_laplacian_normalization_t">18.3. <code class="function">igraph_laplacian_normalization_t</code> —  Normalization methods for a Laplacian matrix.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_laplacian"></a>18.1. <code class="function">igraph_get_laplacian</code> —  Returns the Laplacian matrix of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.20.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_laplacian(
    const igraph_t *graph, igraph_matrix_t *res, igraph_neimode_t mode,
    igraph_laplacian_normalization_t normalization,
    const igraph_vector_t *weights
);
</pre></div>
<p>
</p>
<p>



The Laplacian matrix <code class="constant">L</code> of a graph is defined as
<code class="literal">L_ij = - A_ij</code> when <code class="literal">i != j</code> and
<code class="literal">L_ii = d_i - A_ii</code>. Here <code class="constant">A</code> denotes the (possibly weighted)
adjacency matrix and <code class="literal">d_i</code> is the degree (or strength, if weighted)
of vertex <code class="constant">i</code>. In directed graphs, the <em class="parameter"><code>mode</code></em> parameter controls whether to use
out- or in-degrees. Correspondingly, the rows or columns will sum to zero.
In undirected graphs, <code class="literal">A_ii</code> is taken to be <span class="emphasis"><em>twice</em></span> the number
(or total weight) of self-loops, ensuring that <code class="literal">d_i = \sum_j A_ij</code>.
Thus, the Laplacian of an undirected graph is the same as the Laplacian
of a directed one obtained by replacing each undirected edge with two reciprocal
directed ones.

</p>
<p>
More compactly, <code class="literal">L = D - A</code> where the <code class="constant">D</code> is a diagonal matrix
containing the degrees. The Laplacian matrix can also be normalized, with several
conventional normalization methods. See <a class="link" href="igraph-Structural.html#igraph_laplacian_normalization_t" title="18.3. igraph_laplacian_normalization_t — Normalization methods for a Laplacian matrix."><code class="function">igraph_laplacian_normalization_t</code></a> for
the methods available in igraph.

</p>
<p>
The first version of this function was written by Vincent Matossian.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to the graph to convert.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix object, the result is
       stored here. It will be resized if needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Controls whether to use out- or in-degrees in directed graphs.
       If set to <code class="constant">IGRAPH_ALL</code>, edge directions will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalization</code></em>:</span></p></td>
<td><p>
  The normalization method to use when calculating the
       Laplacian matrix. See <a class="link" href="igraph-Structural.html#igraph_laplacian_normalization_t" title="18.3. igraph_laplacian_normalization_t — Normalization methods for a Laplacian matrix."><code class="function">igraph_laplacian_normalization_t</code></a> for
       possible values.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing non-negative edge weights,
       to calculate the weighted Laplacian matrix. Set it to a null pointer to
       calculate the unweighted Laplacian.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^2), |V| is the number of vertices in the graph.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.20.2.10.1"></a><p class="title"><b>Example 13.31.  File <code class="code">examples/simple/igraph_get_laplacian.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_matrix_t m;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 1, 1);
    <span class="strong"><strong>igraph_vector_init_int</strong></span>(&amp;weights, 5, 1, 2, 3, 4, 5);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.11. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;g, 5, IGRAPH_DIRECTED, 0, 1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_laplacian" title="18.1. igraph_get_laplacian — Returns the Laplacian matrix of a graph.">igraph_get_laplacian</a></strong></span>(&amp;g, &amp;m, IGRAPH_OUT, IGRAPH_LAPLACIAN_SYMMETRIC, &amp;weights);
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;m);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_laplacian_sparse"></a>18.2. <code class="function">igraph_get_laplacian_sparse</code> —  Returns the Laplacian of a graph in a sparse matrix format.</h3></div></div></div>
<a class="indexterm" name="id-1.14.20.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_laplacian_sparse(
    const igraph_t *graph, igraph_sparsemat_t *sparseres, igraph_neimode_t mode,
    igraph_laplacian_normalization_t normalization,
    const igraph_vector_t *weights
);
</pre></div>
<p>
</p>
<p>



See <a class="link" href="igraph-Structural.html#igraph_get_laplacian" title="18.1. igraph_get_laplacian — Returns the Laplacian matrix of a graph."><code class="function">igraph_get_laplacian()</code></a> for the definition of the Laplacian matrix.

</p>
<p>
The first version of this function was written by Vincent Matossian.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to the graph to convert.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sparseres</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized sparse matrix object, the
       result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Controls whether to use out- or in-degrees in directed graphs.
       If set to <code class="constant">IGRAPH_ALL</code>, edge directions will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalization</code></em>:</span></p></td>
<td><p>
  The normalization method to use when calculating the
       Laplacian matrix. See <a class="link" href="igraph-Structural.html#igraph_laplacian_normalization_t" title="18.3. igraph_laplacian_normalization_t — Normalization methods for a Laplacian matrix."><code class="function">igraph_laplacian_normalization_t</code></a> for
       possible values.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing non-negative edge weights,
       to calculate the weighted Laplacian matrix. Set it to a null pointer to
       calculate the unweighted Laplacian.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|), |E| is the number of edges in the graph.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.20.3.9.1"></a><p class="title"><b>Example 13.32.  File <code class="code">examples/simple/igraph_get_laplacian_sparse.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>test_laplacian</strong></span>(<span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *w, igraph_bool_t dir, <a class="link" href="igraph-Structural.html#igraph_laplacian_normalization_t" title="18.3. igraph_laplacian_normalization_t — Normalization methods for a Laplacian matrix.">igraph_laplacian_normalization_t</a> normalization) {
    igraph_t g;
    igraph_matrix_t m;
    igraph_sparsemat_t sm;
    igraph_vector_int_t vec;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *weights = 0;
    igraph_neimode_t mode = IGRAPH_OUT;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="4.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;sm, 0, 0, 0);

    <span class="strong"><strong>if</strong></span> (w) {
        weights = (<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*) <span class="strong"><strong>calloc</strong></span>(1, <span class="strong"><strong>sizeof</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>));
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_copy" title="2.2.3. igraph_vector_init_copy — Initializes a vector from another vector object (constructor).">igraph_vector_init_copy</a></strong></span>(weights, w);
    }

    <span class="emphasis"><em>/* Base graph, no loop or multiple edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.11. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;g, 5, dir, 0, 1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_laplacian_sparse" title="18.2. igraph_get_laplacian_sparse — Returns the Laplacian of a graph in a sparse matrix format.">igraph_get_laplacian_sparse</a></strong></span>(&amp;g, &amp;sm, mode, normalization, weights);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="4.9.3. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;m, &amp;sm);
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong>printf</strong></span>("===\n");

    <span class="emphasis"><em>/* Add some loop edges */</em></span>
    <span class="strong"><strong>igraph_vector_int_init_int</strong></span>(&amp;vec, 4, 1, 1, 2, 2);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_add_edges" title="4.3.2. igraph_add_edges — Adds edges to a graph object.">igraph_add_edges</a></strong></span>(&amp;g, &amp;vec, 0);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;vec);
    <span class="strong"><strong>if</strong></span> (weights) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(weights, 2);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(weights, 2);
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_laplacian_sparse" title="18.2. igraph_get_laplacian_sparse — Returns the Laplacian of a graph in a sparse matrix format.">igraph_get_laplacian_sparse</a></strong></span>(&amp;g, &amp;sm, mode, normalization, weights);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="4.9.3. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;m, &amp;sm);
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong>printf</strong></span>("===\n");

    <span class="emphasis"><em>/* Duplicate some edges */</em></span>
    <span class="strong"><strong>igraph_vector_int_init_int</strong></span>(&amp;vec, 4, 1, 2, 3, 4);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_add_edges" title="4.3.2. igraph_add_edges — Adds edges to a graph object.">igraph_add_edges</a></strong></span>(&amp;g, &amp;vec, 0);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;vec);
    <span class="strong"><strong>if</strong></span> (weights) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(weights, 3);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(weights, 3);
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_laplacian_sparse" title="18.2. igraph_get_laplacian_sparse — Returns the Laplacian of a graph in a sparse matrix format.">igraph_get_laplacian_sparse</a></strong></span>(&amp;g, &amp;sm, mode, normalization, weights);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="4.9.3. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;m, &amp;sm);
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong>printf</strong></span>("===\n");

    <span class="emphasis"><em>/* Add an isolated vertex */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_add_vertices" title="4.3.3. igraph_add_vertices — Adds vertices to a graph.">igraph_add_vertices</a></strong></span>(&amp;g, 1, NULL);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_laplacian_sparse" title="18.2. igraph_get_laplacian_sparse — Returns the Laplacian of a graph in a sparse matrix format.">igraph_get_laplacian_sparse</a></strong></span>(&amp;g, &amp;sm, mode, normalization, weights);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="4.9.3. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;m, &amp;sm);
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (weights) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(weights);
        <span class="strong"><strong>free</strong></span>(weights);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="4.2.6. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;sm);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {
    int res;
    int i;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;

    <span class="strong"><strong>igraph_vector_init_int</strong></span>(&amp;weights, 5, 1, 2, 3, 4, 5);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 8; i++) {
        igraph_bool_t is_normalized = i / 4;
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>* v = ((i &amp; 2) / 2 ? &amp;weights : 0);
        igraph_bool_t dir = (i % 2 ? IGRAPH_DIRECTED : IGRAPH_UNDIRECTED);

        <span class="strong"><strong>printf</strong></span>("=== %sormalized, %sweighted, %sdirected\n",
               (is_normalized ? "N" : "Unn"),
               (v != 0 ? "" : "un"),
               (dir == IGRAPH_DIRECTED ? "" : "un")
              );

        res = <span class="strong"><strong>test_laplacian</strong></span>(v, dir, is_normalized ? IGRAPH_LAPLACIAN_SYMMETRIC : IGRAPH_LAPLACIAN_UNNORMALIZED);

        <span class="strong"><strong>if</strong></span> (res) {
            <span class="strong"><strong>return</strong></span> i + 1;
        }
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_laplacian_normalization_t"></a>18.3. <code class="function">igraph_laplacian_normalization_t</code> —  Normalization methods for a Laplacian matrix.</h3></div></div></div>
<a class="indexterm" name="id-1.14.20.4.2"></a><p>
</p>
<pre class="programlisting">
typedef enum {
    IGRAPH_LAPLACIAN_UNNORMALIZED = 0,
    IGRAPH_LAPLACIAN_SYMMETRIC = 1,
    IGRAPH_LAPLACIAN_LEFT = 2,
    IGRAPH_LAPLACIAN_RIGHT = 3
} igraph_laplacian_normalization_t;
</pre>
<p>
</p>
<p>


Normalization methods for <a class="link" href="igraph-Structural.html#igraph_get_laplacian" title="18.1. igraph_get_laplacian — Returns the Laplacian matrix of a graph."><code class="function">igraph_get_laplacian()</code></a> and
<a class="link" href="igraph-Structural.html#igraph_get_laplacian_sparse" title="18.2. igraph_get_laplacian_sparse — Returns the Laplacian of a graph in a sparse matrix format."><code class="function">igraph_get_laplacian_sparse()</code></a>. In the following, <code class="constant">A</code> refers to the
(possibly weighted) adjacency matrix and <code class="constant">D</code> is a diagonal matrix containing
degrees (unweighted case) or strengths (weighted case). Out-, in- or total degrees
are used according to the <em class="parameter"><code>mode</code></em> parameter.

</p>
<p><b>Values: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LAPLACIAN_UNNORMALIZED</code>:</span></p></td>
<td><p>
  Unnormalized Laplacian, <code class="literal">L = D - A</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LAPLACIAN_SYMMETRIC</code>:</span></p></td>
<td><p>
  Symmetric normalized Laplacian, <code class="literal">L = I - D^(-1/2) A D^(-1/2)</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LAPLACIAN_LEFT</code>:</span></p></td>
<td><p>
  Left-stochastic normalized Laplacian, <code class="literal">L = I - D^-1 A</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LAPLACIAN_RIGHT</code>:</span></p></td>
<td><p>
  Right-stochastic normalized Laplacian, <code class="literal">L = I - A D^-1</code>.</p></td>
</tr>
</tbody>
</table></div>
<p>

 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="non-simple-graphs-multiple-and-loop-edges"></a>19. Non-simple graphs: Multiple and loop edges</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_simple">19.1. <code class="function">igraph_is_simple</code> —  Decides whether the input graph is a simple graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_loop">19.2. <code class="function">igraph_is_loop</code> —  Find the loop edges in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_multiple">19.3. <code class="function">igraph_is_multiple</code> —  Find the multiple edges in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_has_multiple">19.4. <code class="function">igraph_has_multiple</code> —  Check whether the graph has at least one multiple edge.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_count_multiple">19.5. <code class="function">igraph_count_multiple</code> —  Count the number of appearances of the edges in a graph.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_simple"></a>19.1. <code class="function">igraph_is_simple</code> —  Decides whether the input graph is a simple graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.21.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_simple(const igraph_t *graph, igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A graph is a simple graph if it does not contain loop edges and
multiple edges.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean constant, the result
    is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_loop" title="19.2. igraph_is_loop — Find the loop edges in a graph."><code class="function">igraph_is_loop()</code></a> and <a class="link" href="igraph-Structural.html#igraph_is_multiple" title="19.3. igraph_is_multiple — Find the multiple edges in a graph."><code class="function">igraph_is_multiple()</code></a> to
find the loops and multiple edges, <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a> to
get rid of them, or <a class="link" href="igraph-Structural.html#igraph_has_multiple" title="19.4. igraph_has_multiple — Check whether the graph has at least one multiple edge."><code class="function">igraph_has_multiple()</code></a> to decide whether
there is at least one multiple edge.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_loop"></a>19.2. <code class="function">igraph_is_loop</code> —  Find the loop edges in a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.21.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_loop(const igraph_t *graph, igraph_vector_bool_t *res,
                   igraph_es_t es);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A loop edge is an edge from a vertex to itself.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized boolean vector for storing the result,
        it will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>es</code></em>:</span></p></td>
<td><p>
  The edges to check, for all edges supply <a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)."><code class="function">igraph_ess_all()</code></a> here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a> to get rid of loop edges.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(e), the number of edges to check.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.21.3.11.1"></a><p class="title"><b>Example 13.33.  File <code class="code">examples/simple/igraph_is_loop.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_vector</strong></span>(igraph_vector_bool_t *v, FILE *f) {
    igraph_integer_t i;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_bool_size</strong></span>(v); i++) {
        <span class="strong"><strong>fprintf</strong></span>(f, " %i", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i] ? 1 : 0);
    }
    <span class="strong"><strong>fprintf</strong></span>(f, "\n");
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t graph;
    igraph_vector_bool_t v;

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;v, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 1, 0, 1, 1, 0, 3, 4, 11, 10, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_loop" title="19.2. igraph_is_loop — Find the loop edges in a graph.">igraph_is_loop</a></strong></span>(&amp;graph, &amp;v, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_ID));
    <span class="strong"><strong>print_vector</strong></span>(&amp;v, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED,
                 0, 0, 1, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, 2, 2, 0, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_loop" title="19.2. igraph_is_loop — Find the loop edges in a graph.">igraph_is_loop</a></strong></span>(&amp;graph, &amp;v, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_ID));
    <span class="strong"><strong>print_vector</strong></span>(&amp;v, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;v);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_multiple"></a>19.3. <code class="function">igraph_is_multiple</code> —  Find the multiple edges in a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.21.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_multiple(const igraph_t *graph, igraph_vector_bool_t *res,
                       igraph_es_t es);
</pre></div>
<p>
</p>
<p>



</p>
<p>
An edge is a multiple edge if there is another
edge with the same head and tail vertices in the graph.

</p>
<p>
Note that this function returns true only for the second or more
appearances of the multiple edges.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean vector, the result will be stored
       here. It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>es</code></em>:</span></p></td>
<td><p>
  The edges to check. Supply <a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)."><code class="function">igraph_ess_all()</code></a> if you want
       to check all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_count_multiple" title="19.5. igraph_count_multiple — Count the number of appearances of the edges in a graph."><code class="function">igraph_count_multiple()</code></a>, <a class="link" href="igraph-Structural.html#igraph_has_multiple" title="19.4. igraph_has_multiple — Check whether the graph has at least one multiple edge."><code class="function">igraph_has_multiple()</code></a> and <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(e*d), e is the number of edges to check and d is the
average degree (out-degree in directed graphs) of the vertices at the
tail of the edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.21.4.12.1"></a><p class="title"><b>Example 13.34.  File <code class="code">examples/simple/igraph_is_multiple.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_vector</strong></span>(igraph_vector_bool_t *v, FILE *f) {
    igraph_integer_t i;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_bool_size</strong></span>(v); i++) {
        <span class="strong"><strong>fprintf</strong></span>(f, " %i", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i] ? 1 : 0);
    }
    <span class="strong"><strong>fprintf</strong></span>(f, "\n");
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t graph;
    igraph_vector_bool_t v;

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;v, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 1, 0, 1, 1, 0, 3, 4, 11, 10, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_multiple" title="19.3. igraph_is_multiple — Find the multiple edges in a graph.">igraph_is_multiple</a></strong></span>(&amp;graph, &amp;v, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_ID));
    <span class="strong"><strong>print_vector</strong></span>(&amp;v, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED,
                 0, 0, 1, 2, 1, 1, 2, 2, 2, 1, 2, 3, 2, 4,
                 2, 5, 2, 6, 2, 2, 3, 2, 0, 0, 6, 2, 2, 2, 0, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_multiple" title="19.3. igraph_is_multiple — Find the multiple edges in a graph.">igraph_is_multiple</a></strong></span>(&amp;graph, &amp;v, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_ID));
    <span class="strong"><strong>print_vector</strong></span>(&amp;v, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;v);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_has_multiple"></a>19.4. <code class="function">igraph_has_multiple</code> —  Check whether the graph has at least one multiple edge.</h3></div></div></div>
<a class="indexterm" name="id-1.14.21.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_has_multiple(const igraph_t *graph, igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p>
An edge is a multiple edge if there is another
edge with the same head and tail vertices in the graph.

</p>
<p>
The return value of this function is cached in the graph itself; calling
the function multiple times with no modifications to the graph in between
will return a cached value in O(1) time.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean variable, the result will be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_count_multiple" title="19.5. igraph_count_multiple — Count the number of appearances of the edges in a graph."><code class="function">igraph_count_multiple()</code></a>, <a class="link" href="igraph-Structural.html#igraph_is_multiple" title="19.3. igraph_is_multiple — Find the multiple edges in a graph."><code class="function">igraph_is_multiple()</code></a> and <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(e*d), e is the number of edges to check and d is the
average degree (out-degree in directed graphs) of the vertices at the
tail of the edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.21.5.12.1"></a><p class="title"><b>Example 13.35.  File <code class="code">examples/simple/igraph_has_multiple.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t graph;
    igraph_bool_t res;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 1, 0, 1, 1, 0, 3, 4, 11, 10, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="19.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (!res) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED,
                 0, 0, 1, 2, 1, 1, 2, 2, 2, 1, 2, 3, 2, 4,
                 2, 5, 2, 6, 2, 2, 3, 2, 0, 0, 6, 2, 2, 2, 0, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="19.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (!res) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 1, 1, 0, 3, 4, 11, 10, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="19.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (res) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED,
                 0, 0, 1, 2, 1, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, 2, 2, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="19.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (!res) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED,
                 0, 0, 1, 2, 1, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="19.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (res) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED, 0, 1, 0, 1, 1, 2, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="19.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (!res) {
        <span class="strong"><strong>return</strong></span> 6;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED, 0, 0, 0, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="19.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (!res) {
        <span class="strong"><strong>return</strong></span> 7;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_count_multiple"></a>19.5. <code class="function">igraph_count_multiple</code> —  Count the number of appearances of the edges in a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.21.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_count_multiple(const igraph_t *graph, igraph_vector_int_t *res, igraph_es_t es);
</pre></div>
<p>
</p>
<p>



</p>
<p>
If the graph has no multiple edges then the result vector will be
filled with ones.
(An edge is a multiple edge if there is another
edge with the same head and tail vertices in the graph.)

</p>
<p>
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result will be stored
       here. It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>es</code></em>:</span></p></td>
<td><p>
  The edges to check. Supply <a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)."><code class="function">igraph_ess_all()</code></a> if you want
       to check all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_multiple" title="19.3. igraph_is_multiple — Find the multiple edges in a graph."><code class="function">igraph_is_multiple()</code></a> and <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(E d), E is the number of edges to check and d is the
average degree (out-degree in directed graphs) of the vertices at the
tail of the edges.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="mixing-patterns"></a>20. Mixing patterns</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_assortativity_nominal">20.1. <code class="function">igraph_assortativity_nominal</code> —  Assortativity of a graph based on vertex categories.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_assortativity">20.2. <code class="function">igraph_assortativity</code> —  Assortativity based on numeric properties of vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_assortativity_degree">20.3. <code class="function">igraph_assortativity_degree</code> —  Assortativity of a graph based on vertex degree.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_assortativity_nominal"></a>20.1. <code class="function">igraph_assortativity_nominal</code> —  Assortativity of a graph based on vertex categories.</h3></div></div></div>
<a class="indexterm" name="id-1.14.22.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_assortativity_nominal(const igraph_t *graph,
                                            const igraph_vector_int_t *types,
                                            igraph_real_t *res,
                                            igraph_bool_t directed,
                                            igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>



Assuming the vertices of the input graph belong to different
categories, this function calculates the assortativity coefficient of
the graph. The assortativity coefficient is between minus one and one
and it is one if all connections stay within categories, it is
minus one, if the network is perfectly disassortative. For a
randomly connected network it is (asymptotically) zero.

</p>
<p>
The unnormalized version, computed when <em class="parameter"><code>normalized</code></em> is set to false,
is identical to the modularity, and is defined as follows for
directed networks:
</p>
<p>
<code class="literal">1/m sum_ij (A_ij - k^out_i k^in_j / m) d(i,j)</code>,
</p>
<p>
where <code class="constant">m</code> denotes the number of edges, <code class="constant">A_ij</code> is the adjacency matrix,
<code class="literal">k^out</code> and <code class="literal">k^in</code> are the out- and in-degrees,
and <code class="literal">d(i,j)</code> is one if vertices <code class="constant">i</code> and <code class="constant">j</code> are in the same
category and zero otherwise.

</p>
<p>
The normalized assortativity coefficient is obtained by dividing the
previous expression by
</p>
<p>
<code class="literal">1/m sum_ij (m - k^out_i k^in_j d(i,j) / m)</code>.
</p>
<p>
It can take any value within the interval [-1, 1].

</p>
<p>
Undirected graphs are effectively treated as directed ones with all-reciprocal
edges. Thus, self-loops are taken into account twice in undirected graphs.

</p>
<p>
References:

</p>
<p>
M. E. J. Newman: Mixing patterns in networks,
Phys. Rev. E 67, 026126 (2003)
<a class="ulink" href="https://doi.org/10.1103/PhysRevE.67.026126" target="_top">https://doi.org/10.1103/PhysRevE.67.026126</a>.
See section II and equation (2) for the definition of the concept.

</p>
<p>
For an educational overview of assortativity, see
M. E. J. Newman,
Networks: An Introduction, Oxford University Press (2010).
<a class="ulink" href="https://doi.org/10.1093/acprof%3Aoso/9780199206650.001.0001" target="_top">https://doi.org/10.1093/acprof%3Aoso/9780199206650.001.0001</a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Integer vector giving the vertex categories. The types
   are represented by integers starting at zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, it gives whether to consider edge
   directions in a directed graph. It is ignored for undirected
   graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to compute the usual normalized
   assortativity. The unnormalized version is identical to
   modularity. Supply true here to compute the standard assortativity.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|+t), |E| is the number of edges, t is the
number of vertex types.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_assortativity" title="20.2. igraph_assortativity — Assortativity based on numeric properties of vertices."><code class="function">igraph_assortativity()</code></a> for computing the assortativity
based on continuous vertex values instead of discrete categories.
<a class="link" href="igraph-Community.html#igraph_modularity" title="1.1. igraph_modularity — Calculates the modularity of a graph with respect to some clusters or vertex types."><code class="function">igraph_modularity()</code></a> to compute generalized modularity.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.22.2.20.1"></a><p class="title"><b>Example 13.36.  File <code class="code">examples/simple/igraph_assortativity_nominal.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_integer_t nodes = 120, types = 4;

    igraph_matrix_t pref_matrix;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;pref_matrix, types, types);

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Seeds a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);
    <span class="strong"><strong>printf</strong></span>("Randomly generated graph with %" IGRAPH_PRId " nodes and %" IGRAPH_PRId " vertex types\n\n", nodes, types);

    <span class="emphasis"><em>/* Generate preference matrix giving connection probabilities for different vertex types */</em></span>
    <span class="strong"><strong>for</strong></span> (igraph_integer_t i = 0; i &lt; types; i++) {
        <span class="strong"><strong>for</strong></span> (igraph_integer_t j = 0; j &lt; types; j++) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(pref_matrix, i, j) = (i == j ? 0.1: 0.01);
        }
    }
    
    igraph_vector_int_t node_type_vec;
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;node_type_vec, nodes);

    <span class="strong"><strong>for</strong></span> (int i = 0; i &lt; 5; i++) {
        igraph_real_t assortativity;
        igraph_t g;

        <span class="emphasis"><em>/* Generate undirected graph with 1000 nodes and 50 vertex types */</em></span>
        <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_preference_game" title="2.16. igraph_preference_game — Generates a graph with vertex types and connection preferences.">igraph_preference_game</a></strong></span>(&amp;g, nodes, types, <span class="emphasis"><em>/* type_dist= */</em></span> NULL, <span class="emphasis"><em>/* fixed_sizes= */</em></span> 1, &amp;pref_matrix, &amp;node_type_vec, IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS);

        <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="20.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories.">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;node_type_vec, &amp;assortativity, IGRAPH_UNDIRECTED, 1);
        <span class="strong"><strong>printf</strong></span>("Assortativity before rewiring = %g\n", assortativity);

        <span class="emphasis"><em>/* Rewire graph */</em></span>
        <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_rewire" title="2.12. igraph_rewire — Randomly rewires a graph while preserving its degree sequence.">igraph_rewire</a></strong></span>(&amp;g, 10 * <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g), IGRAPH_REWIRING_SIMPLE);

        <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="20.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories.">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;node_type_vec, &amp;assortativity, IGRAPH_UNDIRECTED, 1);
        <span class="strong"><strong>printf</strong></span>("Assortativity after rewiring = %g\n\n", assortativity);

        <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);    
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;node_type_vec);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;pref_matrix);
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_assortativity"></a>20.2. <code class="function">igraph_assortativity</code> —  Assortativity based on numeric properties of vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.22.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_assortativity(const igraph_t *graph,
                         const igraph_vector_t *values,
                         const igraph_vector_t *values_in,
                         igraph_real_t *res,
                         igraph_bool_t directed,
                         igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>



This function calculates the assortativity coefficient of a
graph based on given values <code class="constant">x_i</code> for each vertex <code class="constant">i</code>. This type of
assortativity coefficient equals the Pearson correlation of the values
at the two ends of the edges.

</p>
<p>
The unnormalized covariance of values, computed when <em class="parameter"><code>normalized</code></em> is
set to false, is defined as follows in a directed graph:
</p>
<p>
<code class="literal">cov(x_out, x_in) = 1/m sum_ij (A_ij - k^out_i k^in_j / m) x_i x_j</code>,
</p>
<p>
where <code class="constant">m</code> denotes the number of edges, <code class="constant">A_ij</code> is the adjacency matrix, and
<code class="literal">k^out</code> and <code class="literal">k^in</code> are the out- and in-degrees.
<code class="constant">x_out</code> and <code class="constant">x_in</code> refer to the sets of vertex values at the start and end of
the directed edges.

</p>
<p>
The normalized covariance, i.e. Pearson correlation, is obtained by dividing
the previous expression by
<code class="literal">sqrt(var(x_out)) sqrt(var(x_in))</code>, where
</p>
<p>
<code class="literal">var(x_out) = 1/m sum_i k^out_i x_i^2 - (1/m sum_i k^out_i x_i^2)^2</code>
</p>
<p>
<code class="literal">var(x_in)  = 1/m sum_j k^in_j x_j^2 - (1/m sum_j k^in_j x_j^2)^2</code>

</p>
<p>
Undirected graphs are effectively treated as directed graphs where all edges
are reciprocal. Therefore, self-loops are effectively considered twice in
undirected graphs.

</p>
<p>
References:

</p>
<p>
M. E. J. Newman: Mixing patterns
in networks, Phys. Rev. E 67, 026126 (2003)
<a class="ulink" href="https://doi.org/10.1103/PhysRevE.67.026126" target="_top">https://doi.org/10.1103/PhysRevE.67.026126</a>.
See section III and equation (21) for the definition, and equation (26) for
performing the calculation in directed graphs with the degrees as values.

</p>
<p>
M. E. J. Newman: Assortative mixing in networks,
Phys. Rev. Lett. 89, 208701 (2002)
<a class="ulink" href="http://doi.org/10.1103/PhysRevLett.89.208701" target="_top">http://doi.org/10.1103/PhysRevLett.89.208701</a>.
See equation (4) for performing the calculation in undirected
graphs with the degrees as values.

</p>
<p>
For an educational overview of the concept of assortativity, see
M. E. J. Newman,
Networks: An Introduction, Oxford University Press (2010).
<a class="ulink" href="https://doi.org/10.1093/acprof%3Aoso/9780199206650.001.0001" target="_top">https://doi.org/10.1093/acprof%3Aoso/9780199206650.001.0001</a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>values</code></em>:</span></p></td>
<td><p>
  The vertex values, these can be arbitrary numeric
    values.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>values_in</code></em>:</span></p></td>
<td><p>
  A second value vector to be used for the incoming
    edges when calculating assortativity for a directed graph.
    Supply <code class="constant">NULL</code> here if you want to use the same values
    for outgoing and incoming edges. This argument is ignored
    (with a warning) if it is not a null pointer and the undirected
    assortativity coefficient is being calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider edge directions for
    directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to compute the normalized
    covariance, i.e. Pearson correlation. Supply true here to
    compute the standard assortativity.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|), linear in the number of edges of the
graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="20.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories."><code class="function">igraph_assortativity_nominal()</code></a> if you have discrete vertex
categories instead of numeric labels, and <a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="20.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree."><code class="function">igraph_assortativity_degree()</code></a> for the special case of assortativity
based on vertex degrees.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_assortativity_degree"></a>20.3. <code class="function">igraph_assortativity_degree</code> —  Assortativity of a graph based on vertex degree.</h3></div></div></div>
<a class="indexterm" name="id-1.14.22.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_assortativity_degree(const igraph_t *graph,
                                igraph_real_t *res,
                                igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



Assortativity based on vertex degree, please see the discussion at
the documentation of <a class="link" href="igraph-Structural.html#igraph_assortativity" title="20.2. igraph_assortativity — Assortativity based on numeric properties of vertices."><code class="function">igraph_assortativity()</code></a> for details.
This function simply calls <a class="link" href="igraph-Structural.html#igraph_assortativity" title="20.2. igraph_assortativity — Assortativity based on numeric properties of vertices."><code class="function">igraph_assortativity()</code></a> with
the degrees as the vertex values and normalization enabled.
In the directed case, it uses out-degrees as out-values and
in-degrees as in-values.

</p>
<p>
For regular graphs, i.e. graphs in which all vertices have the
same degree, computing degree correlations is not meaningful,
and this function returns NaN.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider edge directions for
    directed graphs. This argument is ignored for undirected
    graphs. Supply true here to do the natural thing, i.e. use
    directed version of the measure for directed graphs and the
    undirected version for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|+|V|), |E| is the number of edges, |V| is
the number of vertices.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_assortativity" title="20.2. igraph_assortativity — Assortativity based on numeric properties of vertices."><code class="function">igraph_assortativity()</code></a> for the general function
calculating assortativity for any kind of numeric vertex values.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.22.4.11.1"></a><p class="title"><b>Example 13.37.  File <code class="code">examples/simple/igraph_assortativity_degree.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>(){
    igraph_t g;
    igraph_integer_t vcount = 1000;
    igraph_real_t pf = 0.2;
    
    <span class="emphasis"><em>/* Seed random number generator to ensure reproducibility. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Seeds a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);

    <span class="strong"><strong>printf</strong></span>("Forest fire model network with %" IGRAPH_PRId " vertices and %g forward burning probability.\n\n",
           vcount, pf);

    <span class="strong"><strong>for</strong></span> (int i = 0; i &lt; 5; i++) {
        igraph_real_t assortativity;

        <span class="emphasis"><em>/* Generate graph from the forest fire model. */</em></span>
        <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_forest_fire_game" title="2.11. igraph_forest_fire_game — Generates a network according to the “forest fire game”.">igraph_forest_fire_game</a></strong></span>(&amp;g, vcount, pf, 1.0, 1, IGRAPH_UNDIRECTED);

        <span class="emphasis"><em>/* Compute assortativity. */</em></span>
        <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="20.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree.">igraph_assortativity_degree</a></strong></span>(&amp;g, &amp;assortativity, <span class="emphasis"><em>/* ignore edge directions */</em></span> IGRAPH_UNDIRECTED);
        <span class="strong"><strong>printf</strong></span>("Assortativity before rewiring = %g\n", assortativity);
        
        <span class="emphasis"><em>/* Randomize the graph while preserving the degrees. */</em></span>
        <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_rewire" title="2.12. igraph_rewire — Randomly rewires a graph while preserving its degree sequence.">igraph_rewire</a></strong></span>(&amp;g, 20 * <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g), IGRAPH_REWIRING_SIMPLE);
        
        <span class="emphasis"><em>/* Re-compute assortativity. Did it change? */</em></span>
        <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="20.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree.">igraph_assortativity_degree</a></strong></span>(&amp;g, &amp;assortativity, <span class="emphasis"><em>/* ignore edge directions */</em></span> IGRAPH_UNDIRECTED);
        <span class="strong"><strong>printf</strong></span>("Assortativity after rewiring = %g\n\n", assortativity);

        <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    }
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="k-cores"></a>21. K-Cores and K-Trusses</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_coreness">21.1. <code class="function">igraph_coreness</code> —  Finding the coreness of the vertices in a network.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_trussness">21.2. <code class="function">igraph_trussness</code> —  Finding the "trussness" of the edges in a network.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_coreness"></a>21.1. <code class="function">igraph_coreness</code> —  Finding the coreness of the vertices in a network.</h3></div></div></div>
<a class="indexterm" name="id-1.14.23.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_coreness(const igraph_t *graph,
        igraph_vector_int_t *cores, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



The k-core of a graph is a maximal subgraph in which each vertex
has at least degree k. (Degree here means the degree in the
subgraph of course.). The coreness of a vertex is the highest order
of a k-core containing the vertex.

</p>
<p>
This function implements the algorithm presented in Vladimir
Batagelj, Matjaz Zaversnik: An O(m) Algorithm for Cores
Decomposition of Networks.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cores</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result of the
       computation will be stored here. It will be resized as
       needed. For each vertex it contains the highest order of a
       core containing the vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graph it specifies whether to calculate
       in-cores, out-cores or the undirected version. It is ignored
       for undirected graphs. Possible values: <code class="constant">IGRAPH_ALL</code>
       undirected version, <code class="constant">IGRAPH_IN</code> in-cores, <code class="constant">IGRAPH_OUT</code>
       out-cores.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|), the number of edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_trussness"></a>21.2. <code class="function">igraph_trussness</code> —  Finding the "trussness" of the edges in a network.</h3></div></div></div>
<a class="indexterm" name="id-1.14.23.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_trussness(const igraph_t* graph, igraph_vector_int_t* trussness);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A k-truss is a subgraph in which every edge occurs in at least k-2 triangles
in the subgraph. The trussness of an edge indicates the highest k-truss that
the edge occurs in.

</p>
<p>
This function returns the highest k for each edge. If you are interested in
a particular k-truss subgraph, you can subset the graph using to those eids
which are &gt;= k because each k-truss is a subgraph of a (k–1)-truss
(thus to get all 4-trusses, take k &gt;= 4 because the 5-trusses, 6-trusses,
etc need to be included).

</p>
<p>
The current implementation of this function iteratively decrements support
of each edge using O(|E|) space and O(|E|^1.5) time. The implementation does
not support multigraphs; use <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a> to collapse edges before
calling this function.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Loop edges are allowed; multigraphs are not.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>truss</code></em>:</span></p></td>
<td><p>
  Pointer to initialized vector of truss values that will
indicate the highest k-truss each edge occurs in. It will be resized as
needed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: It should be O(|E|^1.5). See Algorithm 2 in:
Wang, Jia, and James Cheng. "Truss decomposition in massive networks."
Proceedings of the VLDB Endowment 5.9 (2012): 812-823.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="topological-sorting-directed-acyclic-graphs"></a>22. Topological sorting, directed acyclic graphs</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_dag">22.1. <code class="function">igraph_is_dag</code> —  Checks whether a graph is a directed acyclic graph (DAG).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_topological_sorting">22.2. <code class="function">igraph_topological_sorting</code> —  Calculate a possible topological sorting of the graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_feedback_arc_set">22.3. <code class="function">igraph_feedback_arc_set</code> —  Feedback arc set of a graph using exact or heuristic methods.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_dag"></a>22.1. <code class="function">igraph_is_dag</code> —  Checks whether a graph is a directed acyclic graph (DAG).</h3></div></div></div>
<a class="indexterm" name="id-1.14.24.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_dag(const igraph_t* graph, igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A directed acyclic graph (DAG) is a directed graph with no cycles.

</p>
<p>
The return value of this function is cached in the graph itself; calling
the function multiple times with no modifications to the graph in between
will return a cached value in O(1) time.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean constant, the result
    is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), where |V| and |E| are the number of
vertices and edges in the original input graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_topological_sorting" title="22.2. igraph_topological_sorting — Calculate a possible topological sorting of the graph."><code class="function">igraph_topological_sorting()</code></a> to get a possible topological
    sorting of a DAG.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_topological_sorting"></a>22.2. <code class="function">igraph_topological_sorting</code> —  Calculate a possible topological sorting of the graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.24.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_topological_sorting(
        const igraph_t* graph, igraph_vector_int_t *res, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A topological sorting of a directed acyclic graph (DAG) is a linear ordering
of its vertices where each vertex comes before all nodes to which it has
edges. Every DAG has at least one topological sort, and may have many.
This function returns one possible topological sort among them. If the
graph contains any cycles that are not self-loops, an error is raised.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result will be stored here.
  It will be resized if needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies how to use the direction of the edges.
  For <code class="constant">IGRAPH_OUT</code>, the sorting order ensures that each vertex comes
  before all vertices to which it has edges, so vertices with no incoming
  edges go first. For <code class="constant">IGRAPH_IN</code>, it is quite the opposite: each
  vertex comes before all vertices from which it receives edges. Vertices
  with no outgoing edges go first.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), where |V| and |E| are the number of
vertices and edges in the original input graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_dag" title="22.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG)."><code class="function">igraph_is_dag()</code></a> if you are only interested in whether a given
    graph is a DAG or not, or <a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods."><code class="function">igraph_feedback_arc_set()</code></a> to find a
    set of edges whose removal makes the graph acyclic.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.24.3.11.1"></a><p class="title"><b>Example 13.38.  File <code class="code">examples/simple/igraph_topological_sorting.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    igraph_vector_int_t res;

    <span class="emphasis"><em>/* Test graph taken from </em></span>http://en.wikipedia.org/wiki/Topological_sorting
<span class="emphasis"><em>     * @ 05.03.2006 */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 8, IGRAPH_DIRECTED,
                 0, 3, 0, 4, 1, 3, 2, 4, 2, 7, 3, 5, 3, 6, 3, 7, 4, 6,
                 -1);

    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* Sort the vertices in "increasing" order. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_topological_sorting" title="22.2. igraph_topological_sorting — Calculate a possible topological sorting of the graph.">igraph_topological_sorting</a></strong></span>(&amp;graph, &amp;res, IGRAPH_OUT);
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;res);
    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="emphasis"><em>/* Sort the vertices in "decreasing" order. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_topological_sorting" title="22.2. igraph_topological_sorting — Calculate a possible topological sorting of the graph.">igraph_topological_sorting</a></strong></span>(&amp;graph, &amp;res, IGRAPH_IN);
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;res);

    <span class="emphasis"><em>/* Destroy data structures when done using them. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_feedback_arc_set"></a>22.3. <code class="function">igraph_feedback_arc_set</code> —  Feedback arc set of a graph using exact or heuristic methods.</h3></div></div></div>
<a class="indexterm" name="id-1.14.24.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_feedback_arc_set(const igraph_t *graph, igraph_vector_int_t *result,
                            const igraph_vector_t *weights, igraph_fas_algorithm_t algo);
</pre></div>
<p>
</p>
<p>




A feedback arc set is a set of edges whose removal makes the graph acyclic.
We are usually interested in <span class="emphasis"><em>minimum</em></span> feedback arc sets, i.e. sets of edges
whose total weight is minimal among all the feedback arc sets.

</p>
<p>
For undirected graphs, the problem is simple: one has to find a maximum weight
spanning tree and then remove all the edges not in the spanning tree. For directed
graphs, this is an NP-hard problem, and various heuristics are usually used to
find an approximate solution to the problem. This function implements a few of
these heuristics.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  An initialized vector, the result will be returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Weight vector or NULL if no weights are specified.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td>
<p>
  The algorithm to use to solve the problem if the graph is directed.
       Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_FAS_EXACT_IP</code></span></p></td>
<td><p>

         Finds a <span class="emphasis"><em>minimum</em></span> feedback arc set using integer programming (IP).
         The complexity of this algorithm is exponential of course.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_FAS_APPROX_EADES</code></span></p></td>
<td><p>

         Finds a feedback arc set using the heuristic of Eades, Lin and
         Smyth (1993). This is guaranteed to be smaller than |E|/2 - |V|/6,
         and it is linear in the number of edges (i.e. O(|E|)).
         For more details, see Eades P, Lin X and Smyth WF: A fast and effective
         heuristic for the feedback arc set problem. In: Proc Inf Process Lett
         319-323, 1993.
       
</p></td>
</tr>
</tbody>
</table></div>
</td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code> if an unknown method was specified or the weight vector
           is invalid.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.24.4.9.1"></a><p class="title"><b>Example 13.39.  File <code class="code">examples/simple/igraph_feedback_arc_set.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;string.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_vector_int_t result;
    igraph_bool_t dag;

    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;result, 0);

    <span class="emphasis"><em>/***********************************************************************/</em></span>
    <span class="emphasis"><em>/* Approximation with Eades' method                                    */</em></span>
    <span class="emphasis"><em>/***********************************************************************/</em></span>

    <span class="emphasis"><em>/* Simple unweighted graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 0, 2, 3, 2, 4, 0, 4, 4, 3, 5, 0, 6, 5, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods.">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, 0, IGRAPH_FAS_APPROX_EADES);
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="4.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="22.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG).">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Simple weighted graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 0, 2, 3, 2, 4, 0, 4, 4, 3, 5, 0, 6, 5, -1);
    <span class="strong"><strong>igraph_vector_init_int_end</strong></span>(&amp;weights, -1, 1, 1, 3, 1, 1, 1, 1, 1, 1, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods.">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, &amp;weights, IGRAPH_FAS_APPROX_EADES);
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="4.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="22.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG).">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Simple unweighted graph with loops */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 0, 2, 3, 2, 4, 0, 4, 4, 3, 5, 0, 6, 5, 1, 1, 4, 4, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods.">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, 0, IGRAPH_FAS_APPROX_EADES);
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="4.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="22.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG).">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Null graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_empty" title="4.1.1. igraph_empty — Creates an empty graph with some vertices and no edges.">igraph_empty</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods.">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, NULL, IGRAPH_FAS_APPROX_EADES);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;result) != 0) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Singleton graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_empty" title="4.1.1. igraph_empty — Creates an empty graph with some vertices and no edges.">igraph_empty</a></strong></span>(&amp;g, 1, IGRAPH_DIRECTED);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods.">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, NULL, IGRAPH_FAS_APPROX_EADES);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;result) != 0) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;result);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.24.4.9.2"></a><p class="title"><b>Example 13.40.  File <code class="code">examples/simple/igraph_feedback_arc_set_ip.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;string.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_vector_int_t result;
    igraph_bool_t dag;
    <a class="link" href="igraph-Error.html#igraph_error_t" title="3.1. igraph_error_t — Return type for functions returning an error code.">igraph_error_t</a> retval;

    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;result, 0);

    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(&amp;<a class="link" href="igraph-Error.html#igraph_error_handler_printignore" title="2.4. igraph_error_handler_printignore — Print and ignore errors.">igraph_error_handler_printignore</a>);

    <span class="emphasis"><em>/***********************************************************************/</em></span>
    <span class="emphasis"><em>/* Exact solution with integer programming                             */</em></span>
    <span class="emphasis"><em>/***********************************************************************/</em></span>

    <span class="emphasis"><em>/* Simple unweighted graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 0, 2, 3, 2, 4, 0, 4, 4, 3, 5, 0, 6, 5, -1);
    retval = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods.">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, 0, IGRAPH_FAS_EXACT_IP);
    <span class="strong"><strong>if</strong></span> (retval == IGRAPH_UNIMPLEMENTED) {
        <span class="strong"><strong>return</strong></span> 77;
    }
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="4.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="22.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG).">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Simple weighted graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 0, 2, 3, 2, 4, 0, 4, 4, 3, 5, 0, 6, 5, -1);
    <span class="strong"><strong>igraph_vector_init_int_end</strong></span>(&amp;weights, -1, 1, 1, 3, 1, 1, 1, 1, 1, 1, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods.">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, &amp;weights, IGRAPH_FAS_EXACT_IP);
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="4.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="22.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG).">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Simple unweighted graph with loops */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 0, 2, 3, 2, 4, 0, 4, 4, 3, 5, 0, 6, 5, 1, 1, 4, 4, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods.">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, 0, IGRAPH_FAS_EXACT_IP);
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="4.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="22.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG).">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Disjoint union of two almost identical graphs */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 1, 2, 2, 0, 2, 3,  2, 4,  0, 4,  4, 3,    5, 0,  6, 5, 1, 1, 4, 4,
                 7, 8, 8, 9, 9, 7, 9, 10, 9, 11, 7, 11, 11, 10, 12, 7, 13, 12,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods.">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, 0, IGRAPH_FAS_EXACT_IP);
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="4.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="22.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG).">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Graph with lots of isolated vertices */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10000, IGRAPH_DIRECTED, 0, 1, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods.">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, 0, IGRAPH_FAS_EXACT_IP);
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="4.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="22.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG).">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Null graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_empty" title="4.1.1. igraph_empty — Creates an empty graph with some vertices and no edges.">igraph_empty</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods.">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, NULL, IGRAPH_FAS_EXACT_IP);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;result) != 0) {
        <span class="strong"><strong>return</strong></span> 6;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Singleton graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_empty" title="4.1.1. igraph_empty — Creates an empty graph with some vertices and no edges.">igraph_empty</a></strong></span>(&amp;g, 1, IGRAPH_DIRECTED);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="22.3. igraph_feedback_arc_set — Feedback arc set of a graph using exact or heuristic methods.">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, NULL, IGRAPH_FAS_EXACT_IP);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;result) != 0) {
        <span class="strong"><strong>return</strong></span> 7;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;result);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p>
Time complexity: depends on <em class="parameter"><code>algo</code></em>, see the time complexities there.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="maximum-cardinality-search-chordal-graphs"></a>23. Maximum cardinality search and chordal graphs</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_maximum_cardinality_search">23.1. <code class="function">igraph_maximum_cardinality_search</code> —  Maximum cardinality search.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_chordal">23.2. <code class="function">igraph_is_chordal</code> —  Decides whether a graph is chordal.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_maximum_cardinality_search"></a>23.1. <code class="function">igraph_maximum_cardinality_search</code> —  Maximum cardinality search.</h3></div></div></div>
<a class="indexterm" name="id-1.14.25.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_maximum_cardinality_search(const igraph_t *graph,
                                      igraph_vector_int_t *alpha,
                                      igraph_vector_int_t *alpham1);
</pre></div>
<p>
</p>
<p>



This function implements the maximum cardinality search algorithm.
It computes a rank <em class="parameter"><code>alpha</code></em> for each vertex, such that visiting
vertices in decreasing rank order corresponds to always choosing
the vertex with the most already visited neighbors as the next one
to visit.

</p>
<p>
Maximum cardinality search is useful in deciding the chordality
of a graph. A graph is chordal if and only if any two neighbors
of a vertex which are higher in rank than it are connected to
each other.

</p>
<p>
References:

</p>
<p>
Robert E Tarjan and Mihalis Yannakakis: Simple linear-time
algorithms to test chordality of graphs, test acyclicity of
hypergraphs, and selectively reduce acyclic hypergraphs.
SIAM Journal of Computation 13, 566--579, 1984.
<a class="ulink" href="https://doi.org/10.1137/0213035" target="_top">https://doi.org/10.1137/0213035</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Edge directions will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>alpha</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is stored here.
  It will be resized, as needed. Upon return it contains
  the rank of the each vertex in the range 0 to <code class="literal">n - 1</code>,
  where <code class="constant">n</code> is the number of vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>alpham1</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a <code class="constant">NULL</code>
  pointer. If not <code class="constant">NULL</code>, then the inverse of <em class="parameter"><code>alpha</code></em> is stored
  here. In other words, the elements of <em class="parameter"><code>alpham1</code></em> are vertex IDs
  in reverse maximum cardinality search order.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in terms of the number of
vertices and edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_chordal" title="23.2. igraph_is_chordal — Decides whether a graph is chordal."><code class="function">igraph_is_chordal()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_chordal"></a>23.2. <code class="function">igraph_is_chordal</code> —  Decides whether a graph is chordal.</h3></div></div></div>
<a class="indexterm" name="id-1.14.25.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_chordal(const igraph_t *graph,
                      const igraph_vector_int_t *alpha,
                      const igraph_vector_int_t *alpham1,
                      igraph_bool_t *chordal,
                      igraph_vector_int_t *fill_in,
                      igraph_t *newgraph);
</pre></div>
<p>
</p>
<p>



A graph is chordal if each of its cycles of four or more nodes
has a chord, i.e. an edge joining two nodes that are not
adjacent in the cycle. An equivalent definition is that any
chordless cycles have at most three nodes.

If either <em class="parameter"><code>alpha</code></em> or <em class="parameter"><code>alpham1</code></em> is given, then the other is
calculated by taking simply the inverse. If neither are given,
then <a class="link" href="igraph-Structural.html#igraph_maximum_cardinality_search" title="23.1. igraph_maximum_cardinality_search — Maximum cardinality search."><code class="function">igraph_maximum_cardinality_search()</code></a> is called to calculate
them.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Edge directions will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>alpha</code></em>:</span></p></td>
<td><p>
  Either an alpha vector coming from
   <a class="link" href="igraph-Structural.html#igraph_maximum_cardinality_search" title="23.1. igraph_maximum_cardinality_search — Maximum cardinality search."><code class="function">igraph_maximum_cardinality_search()</code></a> (on the same graph), or a
   <code class="constant">NULL</code> pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>alpham1</code></em>:</span></p></td>
<td><p>
  Either an inverse alpha vector coming from <a class="link" href="igraph-Structural.html#igraph_maximum_cardinality_search" title="23.1. igraph_maximum_cardinality_search — Maximum cardinality search."><code class="function">igraph_maximum_cardinality_search()</code></a> (on the same graph) or a <code class="constant">NULL</code>
   pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>chordal</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean. If not NULL the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>fill_in</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, or a <code class="constant">NULL</code>
   pointer. If not a <code class="constant">NULL</code> pointer, then the fill-in, also called the
   chordal completion of the graph is stored here.
   The chordal completion is a set of edges that are needed to
   make the graph chordal. The vector is resized as needed.
   Note that the chordal completion returned by this function may not
   be minimal, i.e. some of the returned fill-in edges may not be needed
   to make the graph chordal.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>newgraph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph, or a <code class="constant">NULL</code>
  pointer. If not a null pointer, then a new triangulated graph is
  created here. This essentially means adding the fill-in edges to
  the original graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_maximum_cardinality_search" title="23.1. igraph_maximum_cardinality_search — Maximum cardinality search."><code class="function">igraph_maximum_cardinality_search()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="matchings"></a>24. Matchings</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_matching">24.1. <code class="function">igraph_is_matching</code> — Checks whether the given matching is valid for the given graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_maximal_matching">24.2. <code class="function">igraph_is_maximal_matching</code> — Checks whether a matching in a graph is maximal.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_maximum_bipartite_matching">24.3. <code class="function">igraph_maximum_bipartite_matching</code> — Calculates a maximum matching in a bipartite graph.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_matching"></a>24.1. <code class="function">igraph_is_matching</code> — Checks whether the given matching is valid for the given graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.26.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_matching(const igraph_t *graph,
                       const igraph_vector_bool_t *types, const igraph_vector_int_t *matching,
                       igraph_bool_t *result);
</pre></div>
<p>
</p>
<p>



This function checks a matching vector and verifies whether its length
matches the number of vertices in the given graph, its values are between
-1 (inclusive) and the number of vertices (exclusive), and whether there
exists a corresponding edge in the graph for every matched vertex pair.
For bipartite graphs, it also verifies whether the matched vertices are
in different parts of the graph.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It can be directed but the edge directions
             will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  If the graph is bipartite and you are interested in bipartite
             matchings only, pass the vertex types here. If the graph is
             non-bipartite, simply pass <code class="constant">NULL</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matching</code></em>:</span></p></td>
<td><p>
  The matching itself. It must be a vector where element i
                contains the ID of the vertex that vertex i is matched to,
                or -1 if vertex i is unmatched.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean variable, the result will be returned
              here.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="24.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal."><code class="function">igraph_is_maximal_matching()</code></a> if you are also interested in whether
    the matching is maximal (i.e. non-extendable).
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|) where |V| is the number of vertices and
|E| is the number of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.26.2.8.1"></a><p class="title"><b>Example 13.41.  File <code class="code">examples/simple/igraph_maximum_bipartite_matching.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>test_graph_from_leda_tutorial</strong></span>() {
    <span class="emphasis"><em>/* Test graph from the LEDA tutorial:</em></span>
<span class="emphasis"><em>     * </em></span>http://www.leda-tutorial.org/en/unofficial/ch05s03s05.html
<span class="emphasis"><em>     */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_int_t matching;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_bool_t is_matching;
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0,
                 0, 8, 0, 12, 0, 14,
                 1, 9, 1, 10, 1, 13,
                 2, 8, 2, 9,
                 3, 10, 3, 11, 3, 13,
                 4, 9, 4, 14,
                 5, 14,
                 6, 9, 6, 14,
                 7, 8, 7, 12, 7, 14
                 , -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 15);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 15; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 8);
    }
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;matching, 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="24.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, 0, 0);
    <span class="strong"><strong>if</strong></span> (matching_size != 6) {
        <span class="strong"><strong>printf</strong></span>("matching_size is %" IGRAPH_PRId ", expected: 6\n", matching_size);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (matching_weight != 6) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %" IGRAPH_PRId ", expected: 6\n", (igraph_integer_t) matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="24.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal.">igraph_is_maximal_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching, &amp;is_matching);
    <span class="strong"><strong>if</strong></span> (!is_matching) {
        <span class="strong"><strong>printf</strong></span>("not a matching: ");
        <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;matching);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_from_mit_notes</strong></span>() {
    <span class="emphasis"><em>/* Test graph from the following lecture notes:</em></span>
<span class="emphasis"><em>     * </em></span>http://math.mit.edu/~goemans/18433S07/matching-notes.pdf
<span class="emphasis"><em>     */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_int_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_bool_t is_matching;
    igraph_real_t weight_array[] = { 2, 7, 2, 3,
                                     1, 3, 9, 3, 3,
                                     1, 3, 3, 1, 2,
                                     4, 1, 2,
                                     3
                                   };
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0,
                 0, 6, 0, 7, 0, 8, 0, 9,
                 1, 5, 1, 6, 1, 7, 1, 8, 1, 9,
                 2, 5, 2, 6, 2, 7, 2, 8, 2, 9,
                 3, 5, 3, 7, 3, 9,
                 4, 7, -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 10);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 5);
    }
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;matching, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_array" title="2.2.2. igraph_vector_init_array — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_array</a></strong></span>(&amp;weights, weight_array,
                             <span class="strong"><strong>sizeof</strong></span>(weight_array) / <span class="strong"><strong>sizeof</strong></span>(weight_array[0]));

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="24.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_size != 4) {
        <span class="strong"><strong>printf</strong></span>("matching_size is %" IGRAPH_PRId ", expected: 4\n", matching_size);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (matching_weight != 19) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %" IGRAPH_PRId ", expected: 19\n", (igraph_integer_t) matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="24.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal.">igraph_is_maximal_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching, &amp;is_matching);
    <span class="strong"><strong>if</strong></span> (!is_matching) {
        <span class="strong"><strong>printf</strong></span>("not a matching: ");
        <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;matching);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_generated</strong></span>() {
    <span class="emphasis"><em>/* Several randomly generated small test graphs */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_int_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_real_t weight_array_1[] = { 8, 5, 9, 18, 20, 13 };
    igraph_real_t weight_array_2[] = { 20, 4, 20, 3, 13, 1 };
    int i;

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 10);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 5);
    }
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;matching, 0);

    <span class="emphasis"><em>/* Case 1 */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0, 0, 8, 2, 7, 3, 7, 3, 8, 4, 5, 4, 9, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_array" title="2.2.2. igraph_vector_init_array — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_array</a></strong></span>(&amp;weights, weight_array_1,
                             <span class="strong"><strong>sizeof</strong></span>(weight_array_1) / <span class="strong"><strong>sizeof</strong></span>(weight_array_1[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="24.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_weight != 43) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %" IGRAPH_PRId ", expected: 43\n", (igraph_integer_t)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="emphasis"><em>/* Case 2 */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0, 0, 5, 0, 6, 1, 7, 2, 5, 3, 5, 3, 9, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_array" title="2.2.2. igraph_vector_init_array — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_array</a></strong></span>(&amp;weights, weight_array_2,
                             <span class="strong"><strong>sizeof</strong></span>(weight_array_2) / <span class="strong"><strong>sizeof</strong></span>(weight_array_2[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="24.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_weight != 41) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %" IGRAPH_PRId ", expected: 41\n", (igraph_integer_t)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_graph_from_leda_tutorial</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_weighted_graph_from_mit_notes</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_weighted_graph_generated</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>printf</strong></span>("Finally stack still has %d elements.\n", <span class="strong"><strong>IGRAPH_FINALLY_STACK_SIZE</strong></span>());
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_maximal_matching"></a>24.2. <code class="function">igraph_is_maximal_matching</code> — Checks whether a matching in a graph is maximal.</h3></div></div></div>
<a class="indexterm" name="id-1.14.26.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_maximal_matching(const igraph_t *graph,
                               const igraph_vector_bool_t *types, const igraph_vector_int_t *matching,
                               igraph_bool_t *result);
</pre></div>
<p>
</p>
<p>



A matching is maximal if and only if there exists no unmatched vertex in a
graph such that one of its neighbors is also unmatched.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It can be directed but the edge directions
             will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  If the graph is bipartite and you are interested in bipartite
             matchings only, pass the vertex types here. If the graph is
             non-bipartite, simply pass <code class="constant">NULL</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matching</code></em>:</span></p></td>
<td><p>
  The matching itself. It must be a vector where element i
                contains the ID of the vertex that vertex i is matched to,
                or -1 if vertex i is unmatched.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean variable, the result will be returned
              here.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_matching" title="24.1. igraph_is_matching — Checks whether the given matching is valid for the given graph."><code class="function">igraph_is_matching()</code></a> if you are only interested in whether a
    matching vector is valid for a given graph.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|) where |V| is the number of vertices and
|E| is the number of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.26.3.8.1"></a><p class="title"><b>Example 13.42.  File <code class="code">examples/simple/igraph_maximum_bipartite_matching.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>test_graph_from_leda_tutorial</strong></span>() {
    <span class="emphasis"><em>/* Test graph from the LEDA tutorial:</em></span>
<span class="emphasis"><em>     * </em></span>http://www.leda-tutorial.org/en/unofficial/ch05s03s05.html
<span class="emphasis"><em>     */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_int_t matching;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_bool_t is_matching;
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0,
                 0, 8, 0, 12, 0, 14,
                 1, 9, 1, 10, 1, 13,
                 2, 8, 2, 9,
                 3, 10, 3, 11, 3, 13,
                 4, 9, 4, 14,
                 5, 14,
                 6, 9, 6, 14,
                 7, 8, 7, 12, 7, 14
                 , -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 15);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 15; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 8);
    }
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;matching, 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="24.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, 0, 0);
    <span class="strong"><strong>if</strong></span> (matching_size != 6) {
        <span class="strong"><strong>printf</strong></span>("matching_size is %" IGRAPH_PRId ", expected: 6\n", matching_size);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (matching_weight != 6) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %" IGRAPH_PRId ", expected: 6\n", (igraph_integer_t) matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="24.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal.">igraph_is_maximal_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching, &amp;is_matching);
    <span class="strong"><strong>if</strong></span> (!is_matching) {
        <span class="strong"><strong>printf</strong></span>("not a matching: ");
        <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;matching);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_from_mit_notes</strong></span>() {
    <span class="emphasis"><em>/* Test graph from the following lecture notes:</em></span>
<span class="emphasis"><em>     * </em></span>http://math.mit.edu/~goemans/18433S07/matching-notes.pdf
<span class="emphasis"><em>     */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_int_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_bool_t is_matching;
    igraph_real_t weight_array[] = { 2, 7, 2, 3,
                                     1, 3, 9, 3, 3,
                                     1, 3, 3, 1, 2,
                                     4, 1, 2,
                                     3
                                   };
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0,
                 0, 6, 0, 7, 0, 8, 0, 9,
                 1, 5, 1, 6, 1, 7, 1, 8, 1, 9,
                 2, 5, 2, 6, 2, 7, 2, 8, 2, 9,
                 3, 5, 3, 7, 3, 9,
                 4, 7, -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 10);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 5);
    }
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;matching, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_array" title="2.2.2. igraph_vector_init_array — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_array</a></strong></span>(&amp;weights, weight_array,
                             <span class="strong"><strong>sizeof</strong></span>(weight_array) / <span class="strong"><strong>sizeof</strong></span>(weight_array[0]));

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="24.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_size != 4) {
        <span class="strong"><strong>printf</strong></span>("matching_size is %" IGRAPH_PRId ", expected: 4\n", matching_size);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (matching_weight != 19) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %" IGRAPH_PRId ", expected: 19\n", (igraph_integer_t) matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="24.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal.">igraph_is_maximal_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching, &amp;is_matching);
    <span class="strong"><strong>if</strong></span> (!is_matching) {
        <span class="strong"><strong>printf</strong></span>("not a matching: ");
        <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;matching);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_generated</strong></span>() {
    <span class="emphasis"><em>/* Several randomly generated small test graphs */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_int_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_real_t weight_array_1[] = { 8, 5, 9, 18, 20, 13 };
    igraph_real_t weight_array_2[] = { 20, 4, 20, 3, 13, 1 };
    int i;

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 10);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 5);
    }
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;matching, 0);

    <span class="emphasis"><em>/* Case 1 */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0, 0, 8, 2, 7, 3, 7, 3, 8, 4, 5, 4, 9, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_array" title="2.2.2. igraph_vector_init_array — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_array</a></strong></span>(&amp;weights, weight_array_1,
                             <span class="strong"><strong>sizeof</strong></span>(weight_array_1) / <span class="strong"><strong>sizeof</strong></span>(weight_array_1[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="24.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_weight != 43) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %" IGRAPH_PRId ", expected: 43\n", (igraph_integer_t)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="emphasis"><em>/* Case 2 */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0, 0, 5, 0, 6, 1, 7, 2, 5, 3, 5, 3, 9, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_array" title="2.2.2. igraph_vector_init_array — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_array</a></strong></span>(&amp;weights, weight_array_2,
                             <span class="strong"><strong>sizeof</strong></span>(weight_array_2) / <span class="strong"><strong>sizeof</strong></span>(weight_array_2[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="24.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_weight != 41) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %" IGRAPH_PRId ", expected: 41\n", (igraph_integer_t)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_graph_from_leda_tutorial</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_weighted_graph_from_mit_notes</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_weighted_graph_generated</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>printf</strong></span>("Finally stack still has %d elements.\n", <span class="strong"><strong>IGRAPH_FINALLY_STACK_SIZE</strong></span>());
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_maximum_bipartite_matching"></a>24.3. <code class="function">igraph_maximum_bipartite_matching</code> — Calculates a maximum matching in a bipartite graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.26.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_maximum_bipartite_matching(const igraph_t *graph,
                                      const igraph_vector_bool_t *types, igraph_integer_t *matching_size,
                                      igraph_real_t *matching_weight, igraph_vector_int_t *matching,
                                      const igraph_vector_t *weights, igraph_real_t eps);
</pre></div>
<p>
</p>
<p>



A matching in a bipartite graph is a partial assignment of vertices
of the first kind to vertices of the second kind such that each vertex of
the first kind is matched to at most one vertex of the second kind and
vice versa, and matched vertices must be connected by an edge in the graph.
The size (or cardinality) of a matching is the number of edges.
A matching is a maximum matching if there exists no other matching with
larger cardinality. For weighted graphs, a maximum matching is a matching
whose edges have the largest possible total weight among all possible
matchings.

</p>
<p>
Maximum matchings in bipartite graphs are found by the push-relabel algorithm
with greedy initialization and a global relabeling after every n/2 steps where
n is the number of vertices in the graph.

</p>
<p>
References: Cherkassky BV, Goldberg AV, Martin P, Setubal JC and Stolfi J:
Augment or push: A computational study of bipartite matching and
unit-capacity flow algorithms. ACM Journal of Experimental Algorithmics 3,
1998.

</p>
<p>
Kaya K, Langguth J, Manne F and Ucar B: Experiments on push-relabel-based
maximum cardinality matching algorithms for bipartite graphs. Technical
Report TR/PA/11/33 of the Centre Europeen de Recherche et de Formation
Avancee en Calcul Scientifique, 2011.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It can be directed but the edge directions
             will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Boolean vector giving the vertex types of the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matching_size</code></em>:</span></p></td>
<td><p>
  The size of the matching (i.e. the number of matched
                     vertex pairs will be returned here). It may be <code class="constant">NULL</code>
                     if you don't need this.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matching_weight</code></em>:</span></p></td>
<td><p>
  The weight of the matching if the edges are weighted,
                       or the size of the matching again if the edges are
                       unweighted. It may be <code class="constant">NULL</code> if you don't need this.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matching</code></em>:</span></p></td>
<td><p>
  The matching itself. It must be a vector where element i
                contains the ID of the vertex that vertex i is matched to,
                or -1 if vertex i is unmatched.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A null pointer (=no edge weights), or a vector giving the
               weights of the edges. Note that the algorithm is stable
               only for integer weights.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>eps</code></em>:</span></p></td>
<td><p>
  A small real number used in equality tests in the weighted
           bipartite matching algorithm. Two real numbers are considered
           equal in the algorithm if their difference is smaller than
           <code class="constant">eps</code>. This is required to avoid the accumulation of numerical
           errors. It is advised to pass a value derived from the
           <code class="constant">DBL_EPSILON</code> constant in <code class="constant">float</code>.h here. If you are
           running the algorithm with no <code class="constant">weights</code> vector, this argument
           is ignored.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(sqrt(|V|) |E|) for unweighted graphs (according to the
technical report referenced above), O(|V||E|) for weighted graphs.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.26.4.11.1"></a><p class="title"><b>Example 13.43.  File <code class="code">examples/simple/igraph_maximum_bipartite_matching.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>test_graph_from_leda_tutorial</strong></span>() {
    <span class="emphasis"><em>/* Test graph from the LEDA tutorial:</em></span>
<span class="emphasis"><em>     * </em></span>http://www.leda-tutorial.org/en/unofficial/ch05s03s05.html
<span class="emphasis"><em>     */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_int_t matching;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_bool_t is_matching;
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0,
                 0, 8, 0, 12, 0, 14,
                 1, 9, 1, 10, 1, 13,
                 2, 8, 2, 9,
                 3, 10, 3, 11, 3, 13,
                 4, 9, 4, 14,
                 5, 14,
                 6, 9, 6, 14,
                 7, 8, 7, 12, 7, 14
                 , -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 15);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 15; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 8);
    }
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;matching, 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="24.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, 0, 0);
    <span class="strong"><strong>if</strong></span> (matching_size != 6) {
        <span class="strong"><strong>printf</strong></span>("matching_size is %" IGRAPH_PRId ", expected: 6\n", matching_size);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (matching_weight != 6) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %" IGRAPH_PRId ", expected: 6\n", (igraph_integer_t) matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="24.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal.">igraph_is_maximal_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching, &amp;is_matching);
    <span class="strong"><strong>if</strong></span> (!is_matching) {
        <span class="strong"><strong>printf</strong></span>("not a matching: ");
        <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;matching);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_from_mit_notes</strong></span>() {
    <span class="emphasis"><em>/* Test graph from the following lecture notes:</em></span>
<span class="emphasis"><em>     * </em></span>http://math.mit.edu/~goemans/18433S07/matching-notes.pdf
<span class="emphasis"><em>     */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_int_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_bool_t is_matching;
    igraph_real_t weight_array[] = { 2, 7, 2, 3,
                                     1, 3, 9, 3, 3,
                                     1, 3, 3, 1, 2,
                                     4, 1, 2,
                                     3
                                   };
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0,
                 0, 6, 0, 7, 0, 8, 0, 9,
                 1, 5, 1, 6, 1, 7, 1, 8, 1, 9,
                 2, 5, 2, 6, 2, 7, 2, 8, 2, 9,
                 3, 5, 3, 7, 3, 9,
                 4, 7, -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 10);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 5);
    }
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;matching, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_array" title="2.2.2. igraph_vector_init_array — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_array</a></strong></span>(&amp;weights, weight_array,
                             <span class="strong"><strong>sizeof</strong></span>(weight_array) / <span class="strong"><strong>sizeof</strong></span>(weight_array[0]));

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="24.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_size != 4) {
        <span class="strong"><strong>printf</strong></span>("matching_size is %" IGRAPH_PRId ", expected: 4\n", matching_size);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (matching_weight != 19) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %" IGRAPH_PRId ", expected: 19\n", (igraph_integer_t) matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="24.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal.">igraph_is_maximal_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching, &amp;is_matching);
    <span class="strong"><strong>if</strong></span> (!is_matching) {
        <span class="strong"><strong>printf</strong></span>("not a matching: ");
        <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;matching);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_generated</strong></span>() {
    <span class="emphasis"><em>/* Several randomly generated small test graphs */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_int_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_real_t weight_array_1[] = { 8, 5, 9, 18, 20, 13 };
    igraph_real_t weight_array_2[] = { 20, 4, 20, 3, 13, 1 };
    int i;

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 10);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 5);
    }
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;matching, 0);

    <span class="emphasis"><em>/* Case 1 */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0, 0, 8, 2, 7, 3, 7, 3, 8, 4, 5, 4, 9, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_array" title="2.2.2. igraph_vector_init_array — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_array</a></strong></span>(&amp;weights, weight_array_1,
                             <span class="strong"><strong>sizeof</strong></span>(weight_array_1) / <span class="strong"><strong>sizeof</strong></span>(weight_array_1[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="24.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_weight != 43) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %" IGRAPH_PRId ", expected: 43\n", (igraph_integer_t)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="emphasis"><em>/* Case 2 */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0, 0, 5, 0, 6, 1, 7, 2, 5, 3, 5, 3, 9, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_array" title="2.2.2. igraph_vector_init_array — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_array</a></strong></span>(&amp;weights, weight_array_2,
                             <span class="strong"><strong>sizeof</strong></span>(weight_array_2) / <span class="strong"><strong>sizeof</strong></span>(weight_array_2[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="24.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_weight != 41) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %" IGRAPH_PRId ", expected: 41\n", (igraph_integer_t)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_graph_from_leda_tutorial</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_weighted_graph_from_mit_notes</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_weighted_graph_generated</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>printf</strong></span>("Finally stack still has %d elements.\n", <span class="strong"><strong>IGRAPH_FINALLY_STACK_SIZE</strong></span>());
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="unfolding-a-graph-into-a-tree"></a>25. Unfolding a graph into a tree</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Structural.html#igraph_unfold_tree">25.1. <code class="function">igraph_unfold_tree</code> —  Unfolding a graph into a tree, by possibly multiplicating its vertices.</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_unfold_tree"></a>25.1. <code class="function">igraph_unfold_tree</code> —  Unfolding a graph into a tree, by possibly multiplicating its vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.27.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_unfold_tree(const igraph_t *graph, igraph_t *tree,
                       igraph_neimode_t mode, const igraph_vector_int_t *roots,
                       igraph_vector_int_t *vertex_index);
</pre></div>
<p>
</p>
<p>



A graph is converted into a tree (or forest, if it is unconnected),
by performing a breadth-first search on it, and replicating
vertices that were found a second, third, etc. time.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be either directed or
  undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>tree</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the result is
  stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graphs; whether to follow paths along edge
   directions (<code class="constant">IGRAPH_OUT</code>), or the opposite (<code class="constant">IGRAPH_IN</code>), or
   ignore edge directions completely (<code class="constant">IGRAPH_ALL</code>). It is ignored
   for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>roots</code></em>:</span></p></td>
<td><p>
  A numeric vector giving the root vertex, or vertices
  (if the graph is not connected), to start from.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_index</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, or a null
  pointer. If not a null pointer, then a mapping from the vertices
  in the new graph to the ones in the original is created here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n+m), linear in the number vertices and edges.

 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="other-operations"></a>26. Other operations</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_density">26.1. <code class="function">igraph_density</code> —  Calculate the density of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_reciprocity">26.2. <code class="function">igraph_reciprocity</code> —  Calculates the reciprocity of a directed graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_diversity">26.3. <code class="function">igraph_diversity</code> —  Structural diversity index of the vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_mutual">26.4. <code class="function">igraph_is_mutual</code> —  Check whether some edges of a directed graph are mutual.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_avg_nearest_neighbor_degree">26.5. <code class="function">igraph_avg_nearest_neighbor_degree</code> — Average neighbor degree.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_adjacency">26.6. <code class="function">igraph_get_adjacency</code> —  The adjacency matrix of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_adjacency_sparse">26.7. <code class="function">igraph_get_adjacency_sparse</code> —  Returns the adjacency matrix of a graph in a sparse matrix format.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_stochastic">26.8. <code class="function">igraph_get_stochastic</code> — Stochastic adjacency matrix of a graph</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_stochastic_sparse">26.9. <code class="function">igraph_get_stochastic_sparse</code> —  The stochastic adjacency matrix of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_edgelist">26.10. <code class="function">igraph_get_edgelist</code> —  The list of edges in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_acyclic">26.11. <code class="function">igraph_is_acyclic</code> —  Checks whether a graph is acyclic or not.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_density"></a>26.1. <code class="function">igraph_density</code> —  Calculate the density of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.28.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_density(const igraph_t *graph, igraph_real_t *res,
                   igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>



The density of a graph is simply the ratio of the actual number of its
edges and the largest possible number of edges it could have.
The maximum number of edges depends on interpretation: are vertices
allowed to have a connected to themselves? This is controlled by the
<em class="parameter"><code>loops</code></em> parameter.

</p>
<p>
Note that density is ill-defined for graphs which have multiple edges
between some pairs of vertices. Consider calling <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a>
on such graphs.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the result will be stored
  here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Logical constant, whether to include self-loops in the
  calculation. If this constant is <code class="constant">true</code> then
  loop edges are thought to be possible in the graph (this does not
  necessarily mean that the graph really contains any loops). If
  this is <code class="constant">false</code> then the result is only correct if the graph does not
  contain loops.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_reciprocity"></a>26.2. <code class="function">igraph_reciprocity</code> —  Calculates the reciprocity of a directed graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.28.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_reciprocity(const igraph_t *graph, igraph_real_t *res,
                       igraph_bool_t ignore_loops,
                       igraph_reciprocity_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The measure of reciprocity defines the proportion of mutual
connections, in a directed graph. It is most commonly defined as
the probability that the opposite counterpart of a directed edge is
also included in the graph. In adjacency matrix notation:
<code class="literal">sum(i, j, (A.*A')ij) / sum(i, j, Aij)</code>, where
<code class="literal">A.*A'</code> is the element-wise product of matrix
<code class="literal">A</code> and its transpose. This measure is
calculated if the <em class="parameter"><code>mode</code></em> argument is <code class="constant">IGRAPH_RECIPROCITY_DEFAULT</code>.

</p>
<p>
Prior to igraph version 0.6, another measure was implemented,
defined as the probability of mutual connection between a vertex
pair if we know that there is a (possibly non-mutual) connection
between them. In other words, (unordered) vertex pairs are
classified into three groups: (1) disconnected, (2)
non-reciprocally connected, (3) reciprocally connected.
The result is the size of group (3), divided by the sum of group
sizes (2)+(3). This measure is calculated if <em class="parameter"><code>mode</code></em> is <code class="constant">IGRAPH_RECIPROCITY_RATIO</code>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an <code class="constant">igraph_real_t</code> which will contain the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ignore_loops</code></em>:</span></p></td>
<td><p>
  Whether to ignore loop edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of reciprocity to calculate, possible values are
   <code class="constant">IGRAPH_RECIPROCITY_DEFAULT</code> and <code class="constant">IGRAPH_RECIPROCITY_RATIO</code>,
   please see their description above.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: graph has no edges
        <code class="constant">IGRAPH_ENOMEM</code>: not enough memory for
        temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), |V| is the number of vertices,
|E| is the number of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.28.3.10.1"></a><p class="title"><b>Example 13.44.  File <code class="code">examples/simple/igraph_reciprocity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;math.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t res;

    <span class="emphasis"><em>/* Trivial cases */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.11. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;g, 100, IGRAPH_UNDIRECTED, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_reciprocity" title="26.2. igraph_reciprocity — Calculates the reciprocity of a directed graph.">igraph_reciprocity</a></strong></span>(&amp;g, &amp;res, 0, IGRAPH_RECIPROCITY_DEFAULT);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (res != 1) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="emphasis"><em>/* Small test graph */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0,  1,  0,  2,  0,  3,  1,  0,  2,  3,  3,  2, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_reciprocity" title="26.2. igraph_reciprocity — Calculates the reciprocity of a directed graph.">igraph_reciprocity</a></strong></span>(&amp;g, &amp;res, 0, IGRAPH_RECIPROCITY_RATIO);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (res != 0.5) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "%f != %f\n", res, 0.5);
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 1, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_reciprocity" title="26.2. igraph_reciprocity — Calculates the reciprocity of a directed graph.">igraph_reciprocity</a></strong></span>(&amp;g, &amp;res, 0, IGRAPH_RECIPROCITY_DEFAULT);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(res - 2.0 / 3.0) &gt; 1e-15) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "%f != %f\n", res, 2.0 / 3.0);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_diversity"></a>26.3. <code class="function">igraph_diversity</code> —  Structural diversity index of the vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.28.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_diversity(const igraph_t *graph, const igraph_vector_t *weights,
                     igraph_vector_t *res, const igraph_vs_t vids);
</pre></div>
<p>
</p>
<p>



This measure was defined in Nathan Eagle, Michael Macy and Rob
Claxton: Network Diversity and Economic Development, Science 328,
1029--1031, 2010.

</p>
<p>
It is simply the (normalized) Shannon entropy of the
incident edges' weights. D(i)=H(i)/log(k[i]), and
H(i) = -sum(p[i,j] log(p[i,j]), j=1..k[i]),
where p[i,j]=w[i,j]/sum(w[i,l], l=1..k[i]),  k[i] is the (total)
degree of vertex i, and w[i,j] is the weight of the edge(s) between
vertex i and j. The diversity of isolated vertices will be NaN
(not-a-number), while that of vertices with a single connection
will be zero.

</p>
<p>
The measure works only if the graph is undirected and has no multiple edges.
If the graph has multiple edges, simplify it first using <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a>. If the graph is directed, convert it into an undirected
graph with <a class="link" href="igraph-Structural.html#igraph_to_undirected" title="17.2. igraph_to_undirected — Convert a directed graph to an undirected one."><code class="function">igraph_to_undirected()</code></a> .

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The undirected input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights, in the order of the edge IDs, must
   have appropriate length. Weights must be non-negative.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the results are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  Vertex selector that specifies the vertices which to calculate
   the measure.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear.

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_mutual"></a>26.4. <code class="function">igraph_is_mutual</code> —  Check whether some edges of a directed graph are mutual.</h3></div></div></div>
<a class="indexterm" name="id-1.14.28.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_mutual(const igraph_t *graph, igraph_vector_bool_t *res, igraph_es_t es, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>



An (A,B) non-loop directed edge is mutual if the graph contains
the (B,A) edge too. Whether directed self-loops are considered mutual
is controlled by the <em class="parameter"><code>loops</code></em> parameter.

</p>
<p>
An undirected graph only has mutual edges, by definition.

</p>
<p>
Edge multiplicity is not considered here, e.g. if there are two
(A,B) edges and one (B,A) edge, then all three are considered to be
mutual.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is stored
       here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>es</code></em>:</span></p></td>
<td><p>
  The sequence of edges to check. Supply
       <a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)."><code class="function">igraph_ess_all()</code></a> to check all edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed self-loops
       to be mutual.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n log(d)), n is the number of edges supplied, d
is the maximum in-degree of the vertices that are targets of the
supplied edges. An upper limit of the time complexity is O(n log(|E|)),
|E| is the number of edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_avg_nearest_neighbor_degree"></a>26.5. <code class="function">igraph_avg_nearest_neighbor_degree</code> — Average neighbor degree.</h3></div></div></div>
<a class="indexterm" name="id-1.14.28.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_avg_nearest_neighbor_degree(const igraph_t *graph,
                                       igraph_vs_t vids,
                                       igraph_neimode_t mode,
                                       igraph_neimode_t neighbor_degree_mode,
                                       igraph_vector_t *knn,
                                       igraph_vector_t *knnk,
                                       const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>



Calculates the average degree of the neighbors for each vertex (<em class="parameter"><code>knn</code></em>), and
optionally, the same quantity as a function of the vertex degree (<em class="parameter"><code>knnk</code></em>).

</p>
<p>
For isolated vertices <em class="parameter"><code>knn</code></em> is set to NaN.
The same is done in <em class="parameter"><code>knnk</code></em> for vertex degrees that
don't appear in the graph.

</p>
<p>
The weighted version computes a weighted average of the neighbor degrees as

</p>
<p>
<code class="literal">k_nn_u = 1/s_u sum_v w_uv k_v</code>,

</p>
<p>
where <code class="literal">s_u = sum_v w_uv</code> is the sum of the incident edge weights
of vertex <code class="constant">u</code>, i.e. its strength.
The sum runs over the neighbors <code class="constant">v</code> of vertex <code class="constant">u</code>
as indicated by <em class="parameter"><code>mode</code></em>. <code class="literal">w_uv</code> denotes the weighted adjacency matrix
and <code class="literal">k_v</code> is the neighbors' degree, specified by <em class="parameter"><code>neighbor_degree_mode</code></em>.
This is equation (6) in the reference below.

</p>
<p>
Reference:

</p>
<p>
A. Barrat, M. Barthélemy, R. Pastor-Satorras, and A. Vespignani,
The architecture of complex weighted networks,
Proc. Natl. Acad. Sci. USA 101, 3747 (2004).
<a class="ulink" href="https://dx.doi.org/10.1073/pnas.0400087101" target="_top">https://dx.doi.org/10.1073/pnas.0400087101</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It may be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  The type of neighbors to consider in directed graphs.
  <code class="constant">IGRAPH_OUT</code> considers out-neighbors, <code class="constant">IGRAPH_IN</code> in-neighbors
  and <code class="constant">IGRAPH_ALL</code> ignores edge directions.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>neighbor_degree_mode</code></em>:</span></p></td>
<td><p>
  The type of degree to average in directed graphs.
  <code class="constant">IGRAPH_OUT</code> averages out-degrees, <code class="constant">IGRAPH_IN</code> averages in-degrees
  and <code class="constant">IGRAPH_ALL</code> ignores edge directions for the degree calculation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>knn</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result will be
  stored here. It will be resized as needed. Supply a <code class="constant">NULL</code> pointer
  here, if you only want to calculate <code class="constant">knnk</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>knnk</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the average
  neighbor degree as a function of the vertex degree is stored
  here. The first (zeroth) element is for degree one vertices,
  etc. Supply a <code class="constant">NULL</code> pointer here if you don't want to calculate
  this.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Optional edge weights. Supply a null pointer here
  for the non-weighted version.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.14.28.6.14.1"></a><p class="title"><b>Example 13.45.  File <code class="code">examples/simple/igraph_knn.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> v, v2;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> v_weighted, v2_weighted;
    igraph_integer_t n;
    igraph_neimode_t mode, neighbour_degree_mode;

    mode = IGRAPH_IN;
    neighbour_degree_mode = IGRAPH_OUT;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.11. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;g, 10, <span class="emphasis"><em>/*directed=*/</em></span> 1, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span> 1);
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v, n);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v2, n);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_avg_nearest_neighbor_degree" title="26.5. igraph_avg_nearest_neighbor_degree — Average neighbor degree.">igraph_avg_nearest_neighbor_degree</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                       mode, neighbour_degree_mode,
                                       &amp;v, &amp;v2, <span class="emphasis"><em>/*weights=*/</em></span> 0);

    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_fill" title="2.3.2. igraph_vector_fill — Fill a vector with a constant element.">igraph_vector_fill</a></strong></span>(&amp;weights, 2.0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v_weighted, n);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v2_weighted, n);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_avg_nearest_neighbor_degree" title="26.5. igraph_avg_nearest_neighbor_degree — Average neighbor degree.">igraph_avg_nearest_neighbor_degree</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                       mode, neighbour_degree_mode,
                                       &amp;v_weighted, &amp;v2_weighted, &amp;weights);

    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_all_e" title="2.9.1. igraph_vector_all_e — Are all elements equal?">igraph_vector_all_e</a></strong></span>(&amp;v, &amp;v_weighted)) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v_weighted);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v2_weighted);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v2);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_adjacency"></a>26.6. <code class="function">igraph_get_adjacency</code> —  The adjacency matrix of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.28.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
#define WEIGHT_OF(eid) (weights ? VECTOR(*weights)[eid] : 1)

igraph_error_t igraph_get_adjacency(
    const igraph_t *graph, igraph_matrix_t *res, igraph_get_adjacency_t type,
    const igraph_vector_t *weights, igraph_loops_t loops
);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The result is an adjacency matrix. Entry i, j of the matrix
contains the number of edges connecting vertex i to vertex j in the unweighted
case, or the total weight of edges connecting vertex i to vertex j in the
weighted case.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to the graph to convert
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix object, it will be
       resized if needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type</code></em>:</span></p></td>
<td>
<p>
  Constant specifying the type of the adjacency matrix to
       create for undirected graphs. It is ignored for directed
       graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_GET_ADJACENCY_UPPER</code></span></p></td>
<td><p>

         the upper right triangle of the matrix is used.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_GET_ADJACENCY_LOWER</code></span></p></td>
<td><p>

         the lower left triangle of the matrix is used.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_GET_ADJACENCY_BOTH</code></span></p></td>
<td><p>

         the whole matrix is used, a symmetric matrix is returned
         if the graph is undirected.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing the weight of each edge
       in the graph. Supply a null pointer here to make all edges have
       the same weight of 1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td>
<p>
  Constant specifying how loop edges should be handled.
       Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_NO_LOOPS</code></span></p></td>
<td><p>

         loop edges are ignored and the diagonal of the matrix will contain
         zeros only
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LOOPS_ONCE</code></span></p></td>
<td><p>

         loop edges are counted once, i.e. a vertex with a single unweighted
         loop edge will have 1 in the corresponding diagonal entry
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LOOPS_TWICE</code></span></p></td>
<td><p>

         loop edges are counted twice in <span class="emphasis"><em>undirected</em></span> graphs, i.e. a vertex
         with a single unweighted loop edge in an undirected graph will have
         2 in the corresponding diagonal entry. Loop edges in directed graphs
         are still counted as 1. Essentially, this means that the function is
         counting the incident edge <span class="emphasis"><em>stems</em></span> , which makes more sense when
         using the adjacency matrix in linear algebra.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_EINVAL</code> invalid type argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_adjacency_sparse" title="26.7. igraph_get_adjacency_sparse — Returns the adjacency matrix of a graph in a sparse matrix format."><code class="function">igraph_get_adjacency_sparse()</code></a> if you want a sparse matrix representation
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||V|), |V| is the number of vertices in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_adjacency_sparse"></a>26.7. <code class="function">igraph_get_adjacency_sparse</code> —  Returns the adjacency matrix of a graph in a sparse matrix format.</h3></div></div></div>
<a class="indexterm" name="id-1.14.28.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_adjacency_sparse(
    const igraph_t *graph, igraph_sparsemat_t *res, igraph_get_adjacency_t type,
    const igraph_vector_t *weights, igraph_loops_t loops
);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an <span class="emphasis"><em>initialized</em></span> sparse matrix. The result
   will be stored here. The matrix will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type</code></em>:</span></p></td>
<td>
<p>
  Constant specifying the type of the adjacency matrix to
       create for undirected graphs. It is ignored for directed
       graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_GET_ADJACENCY_UPPER</code></span></p></td>
<td><p>

         the upper right triangle of the matrix is used.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_GET_ADJACENCY_LOWER</code></span></p></td>
<td><p>

         the lower left triangle of the matrix is used.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_GET_ADJACENCY_BOTH</code></span></p></td>
<td><p>

         the whole matrix is used, a symmetric matrix is returned
         if the graph is undirected.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_EINVAL</code> invalid type argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_adjacency" title="26.6. igraph_get_adjacency — The adjacency matrix of a graph."><code class="function">igraph_get_adjacency()</code></a>, the dense version of this function.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_stochastic"></a>26.8. <code class="function">igraph_get_stochastic</code> — Stochastic adjacency matrix of a graph</h3></div></div></div>
<a class="indexterm" name="id-1.14.28.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_stochastic(
    const igraph_t *graph, igraph_matrix_t *res, igraph_bool_t column_wise,
    const igraph_vector_t *weights
);
</pre></div>
<p>
</p>
<p>



Stochastic matrix of a graph. The stochastic matrix of a graph is
its adjacency matrix, normalized row-wise or column-wise, such that
the sum of each row (or column) is one.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix, the result is stored here.
  It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>column_wise</code></em>:</span></p></td>
<td><p>
  Whether to normalize column-wise.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||V|), |V| is the number of vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_stochastic_sparse" title="26.9. igraph_get_stochastic_sparse — The stochastic adjacency matrix of a graph."><code class="function">igraph_get_stochastic_sparse()</code></a>, the sparse version of this
function.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_stochastic_sparse"></a>26.9. <code class="function">igraph_get_stochastic_sparse</code> —  The stochastic adjacency matrix of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.28.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_stochastic_sparse(
    const igraph_t *graph, igraph_sparsemat_t *res, igraph_bool_t column_wise,
    const igraph_vector_t *weights
);
</pre></div>
<p>
</p>
<p>



Stochastic matrix of a graph. The stochastic matrix of a graph is
its adjacency matrix, normalized row-wise or column-wise, such that
the sum of each row (or column) is one.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an <span class="emphasis"><em>initialized</em></span> sparse matrix, the
   result is stored here. The matrix will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>column_wise</code></em>:</span></p></td>
<td><p>
  Whether to normalize column-wise.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_stochastic" title="26.8. igraph_get_stochastic — Stochastic adjacency matrix of a graph"><code class="function">igraph_get_stochastic()</code></a>, the dense version of this function.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_edgelist"></a>26.10. <code class="function">igraph_get_edgelist</code> —  The list of edges in a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.14.28.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_edgelist(const igraph_t *graph, igraph_vector_int_t *res, igraph_bool_t bycol);
</pre></div>
<p>
</p>
<p>




</p>
<p>The order of the edges is given by the edge IDs.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to the graph object
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector object, it will be
       resized.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>bycol</code></em>:</span></p></td>
<td><p>
  Logical, if true, the edges will be returned
       columnwise, e.g. the first edge is
       <code class="literal">res[0]-&gt;res[|E|]</code>, the second is
       <code class="literal">res[1]-&gt;res[|E|+1]</code>, etc.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Basic.html#igraph_edges" title="4.2.5. igraph_edges — Gives the head and tail vertices of a series of edges."><code class="function">igraph_edges()</code></a> to return the result only for some edge IDs.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|), the
number of edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_acyclic"></a>26.11. <code class="function">igraph_is_acyclic</code> —  Checks whether a graph is acyclic or not.</h3></div></div></div>
<a class="indexterm" name="id-1.14.28.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_is_acyclic(const igraph_t *graph, igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>




This function checks whether a graph is acyclic or not.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean constant, the result
        is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), where |V| and |E| are the number of
vertices and edges in the original input graph.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="structural-properties-deprecated"></a>27. Deprecated functions</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_shortest_paths">27.1. <code class="function">igraph_shortest_paths</code> —  Length of the shortest paths between vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_shortest_paths_dijkstra">27.2. <code class="function">igraph_shortest_paths_dijkstra</code> —  Weighted shortest path lengths between vertices (deprecated).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_shortest_paths_bellman_ford">27.3. <code class="function">igraph_shortest_paths_bellman_ford</code> —  Weighted shortest path lengths between vertices, allowing negative weights (deprecated).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_shortest_paths_johnson">27.4. <code class="function">igraph_shortest_paths_johnson</code> —  Weighted shortest path lengths between vertices, using Johnson's algorithm (deprecated).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_stochastic_sparsemat">27.5. <code class="function">igraph_get_stochastic_sparsemat</code> —  Stochastic adjacency matrix of a graph (deprecated).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_sparsemat">27.6. <code class="function">igraph_get_sparsemat</code> —  Converts an igraph graph to a sparse matrix (deprecated).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_laplacian">27.7. <code class="function">igraph_laplacian</code> —  Returns the Laplacian matrix of a graph (deprecated).</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_shortest_paths"></a>27.1. <code class="function">igraph_shortest_paths</code> —  Length of the shortest paths between vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.14.29.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_shortest_paths(const igraph_t *graph,
                                     igraph_matrix_t *res,
                                     const igraph_vs_t from,
                                     const igraph_vs_t to,
                                     igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.10.0. Please do not use this function in new
code; use <a class="link" href="igraph-Structural.html#igraph_distances" title="3.1. igraph_distances — Length of the shortest paths between vertices."><code class="function">igraph_distances()</code></a>
instead.</p>
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_shortest_paths_dijkstra"></a>27.2. <code class="function">igraph_shortest_paths_dijkstra</code> —  Weighted shortest path lengths between vertices (deprecated).</h3></div></div></div>
<a class="indexterm" name="id-1.14.29.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_shortest_paths_dijkstra(const igraph_t *graph,
                                       igraph_matrix_t *res,
                                       const igraph_vs_t from,
                                       const igraph_vs_t to,
                                       const igraph_vector_t *weights,
                                       igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.10.0. Please do not use this function in new
code; use <a class="link" href="igraph-Structural.html#igraph_distances_dijkstra" title="3.2. igraph_distances_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_distances_dijkstra()</code></a>
instead.</p>
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_shortest_paths_bellman_ford"></a>27.3. <code class="function">igraph_shortest_paths_bellman_ford</code> —  Weighted shortest path lengths between vertices, allowing negative weights (deprecated).</h3></div></div></div>
<a class="indexterm" name="id-1.14.29.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_shortest_paths_bellman_ford(const igraph_t *graph,
                                       igraph_matrix_t *res,
                                       const igraph_vs_t from,
                                       const igraph_vs_t to,
                                       const igraph_vector_t *weights,
                                       igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.10.0. Please do not use this function in new
code; use <a class="link" href="igraph-Structural.html#igraph_distances_bellman_ford" title="3.3. igraph_distances_bellman_ford — Weighted shortest path lengths between vertices, allowing negative weights."><code class="function">igraph_distances_bellman_ford()</code></a>
instead.</p>
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_shortest_paths_johnson"></a>27.4. <code class="function">igraph_shortest_paths_johnson</code> —  Weighted shortest path lengths between vertices, using Johnson's algorithm (deprecated).</h3></div></div></div>
<a class="indexterm" name="id-1.14.29.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_shortest_paths_johnson(const igraph_t *graph,
                                  igraph_matrix_t *res,
                                  const igraph_vs_t from,
                                  const igraph_vs_t to,
                                  const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>



</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.10.0. Please do not use this function in new
code; use <a class="link" href="igraph-Structural.html#igraph_distances_johnson" title="3.4. igraph_distances_johnson — Weighted shortest path lengths between vertices, using Johnson's algorithm."><code class="function">igraph_distances_johnson()</code></a>
instead.</p>
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_stochastic_sparsemat"></a>27.5. <code class="function">igraph_get_stochastic_sparsemat</code> —  Stochastic adjacency matrix of a graph (deprecated).</h3></div></div></div>
<a class="indexterm" name="id-1.14.29.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_stochastic_sparsemat(const igraph_t *graph,
                                               igraph_sparsemat_t *res,
                                               igraph_bool_t column_wise);
</pre></div>
<p>
</p>
<p>



This function is deprecated in favour of <a class="link" href="igraph-Structural.html#igraph_get_stochastic_sparse" title="26.9. igraph_get_stochastic_sparse — The stochastic adjacency matrix of a graph."><code class="function">igraph_get_stochastic_sparse()</code></a>,
but does not work in an identical way. This function takes an <span class="emphasis"><em>uninitialized</em></span>
<code class="constant">igraph_sparsemat_t</code> while <a class="link" href="igraph-Structural.html#igraph_get_stochastic_sparse" title="26.9. igraph_get_stochastic_sparse — The stochastic adjacency matrix of a graph."><code class="function">igraph_get_stochastic_sparse()</code></a> takes
an already initialized one.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an <span class="emphasis"><em>uninitialized</em></span> sparse matrix, the
   result is stored here. The matrix will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>column_wise</code></em>:</span></p></td>
<td><p>
  Whether to normalize column-wise. For undirected
   graphs this argument does not have any effect.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.10.0. Please do not use this function in new
code; use <a class="link" href="igraph-Structural.html#igraph_get_stochastic_sparse" title="26.9. igraph_get_stochastic_sparse — The stochastic adjacency matrix of a graph."><code class="function">igraph_get_stochastic_sparse()</code></a>
instead.</p>
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_sparsemat"></a>27.6. <code class="function">igraph_get_sparsemat</code> —  Converts an igraph graph to a sparse matrix (deprecated).</h3></div></div></div>
<a class="indexterm" name="id-1.14.29.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_get_sparsemat(const igraph_t *graph, igraph_sparsemat_t *res);
</pre></div>
<p>
</p>
<p>



If the graph is undirected, then a symmetric matrix is created.

</p>
<p>
This function is deprecated in favour of <a class="link" href="igraph-Structural.html#igraph_get_adjacency_sparse" title="26.7. igraph_get_adjacency_sparse — Returns the adjacency matrix of a graph in a sparse matrix format."><code class="function">igraph_get_adjacency_sparse()</code></a>,
but does not work in an identical way. This function takes an <span class="emphasis"><em>uninitialized</em></span>
<code class="constant">igraph_sparsemat_t</code> while <a class="link" href="igraph-Structural.html#igraph_get_adjacency_sparse" title="26.7. igraph_get_adjacency_sparse — Returns the adjacency matrix of a graph in a sparse matrix format."><code class="function">igraph_get_adjacency_sparse()</code></a> takes
an already initialized one.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an <span class="emphasis"><em>uninitialized</em></span> sparse matrix. The result
   will be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.10.0. Please do not use this function in new
code; use <a class="link" href="igraph-Structural.html#igraph_get_adjacency_sparse" title="26.7. igraph_get_adjacency_sparse — Returns the adjacency matrix of a graph in a sparse matrix format."><code class="function">igraph_get_adjacency_sparse()</code></a>
instead.</p>
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_laplacian"></a>27.7. <code class="function">igraph_laplacian</code> —  Returns the Laplacian matrix of a graph (deprecated).</h3></div></div></div>
<a class="indexterm" name="id-1.14.29.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_laplacian(
    const igraph_t *graph, igraph_matrix_t *res, igraph_sparsemat_t *sparseres,
    igraph_bool_t normalized, const igraph_vector_t *weights
);
</pre></div>
<p>
</p>
<p>



This function produces the Laplacian matrix of a graph in either dense or
sparse format. When <em class="parameter"><code>normalized</code></em> is set to true, the type of normalization
used depends on the directnedness of the graph: symmetric normalization
is used for undirected graphs and left stochastic normalization for
directed graphs.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to the graph to convert.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix object or <code class="constant">NULL</code>. The dense matrix
       result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sparseres</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized sparse matrix object or <code class="constant">NULL</code>.
       The sparse matrix result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Controls whether to use out- or in-degrees in directed graphs.
       If set to <code class="constant">IGRAPH_ALL</code>, edge directions will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to normalize the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing non-negative edge weights,
       to calculate the weighted Laplacian matrix. Set it to a null pointer to
       calculate the unweighted Laplacian.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.10.0. Please do not use this function in new
code; use <a class="link" href="igraph-Structural.html#igraph_get_laplacian" title="18.1. igraph_get_laplacian — Returns the Laplacian matrix of a graph."><code class="function">igraph_get_laplacian()</code></a>
instead.</p>
</div>
<p> 
</p>
</div>
</div>
</div>
<table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Attributes.html"><b>← Chapter 12. Graph, vertex and edge attributes</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Cycles.html"><b>Chapter 14. Graph cycles →</b></a></td>
</tr></table>


      </div>
    </div>
  </div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	  &copy; 2003 &ndash; 2022 The igraph core team.
            &bull; Code licensed under 
            <a href="http://www.gnu.org/licenses/gpl-2.0.html">
            GNU GPL 2</a> or later, documentation under 
            <a href="http://www.gnu.org/copyleft/fdl.html">
              GNU FDL.</a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'c', 'html/');
    </script>





    
  </body>
</html>
