




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>igraph Reference Manual</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/fontawesome.min.css" integrity="sha384-QYIZto+st3yW+o8+5OHfT6S482Zsvz2WfOzpFSXMF9zqeLcFV0/wlZpMtyFcZALm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/solid.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/brands.min.css">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DY4MJME11Z"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-DY4MJME11Z');
	</script>

    <link href="/css/manual.css" rel="stylesheet">
<script async src="https://cse.google.com/cse.js?cx=003494361702844740117:dlnifinshhm"></script>

  </head>

  <body class="cc">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/c">igraph library</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            0.9.0
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="https://r.igraph.org">igraph R package</a>
              <a class="dropdown-item" href="https://python.igraph.org">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa-brands fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa-solid fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa-solid fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa-solid fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa-brands fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">igraph Reference Manual</h1>
        <p class="lead">For using the igraph C library</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container search-box-container">
  <div class="row">
    <div class="col-md-12 d-flex flex-row align-items-middle">
      <div class="search-label">Search the manual:</div>
	  <div style="flex: 1; margin: -1em 0 -1em 0"><div class="gcse-search" data-personalizedAds="false"></div></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="bs-docs-section">
        
<div class="navigation-header mb-4" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-light" href="igraph-Attributes.html"><i class="fa fa-chevron-left"></i>
              Previous
            </a><a accesskey="h" class="btn btn-light" href="index.html"><i class="fa fa-home"></i>
              Home
            </a><a accesskey="n" class="btn btn-light" href="igraph-Cycles.html"><i class="fa fa-chevron-right"></i>
              Next
            </a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Structural"></a>Chapter 13. Structural Properties of Graphs</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#basic-properties">1. Basic Properties</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#shortest-path-related-functions">2. (Shortest) Path Related Functions</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#efficiency-measures">3. Efficiency Measures</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#neighborhood-of-a-vertex">4. Neighborhood of a Vertex</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#local-scan-statistics">5. Local Scan Statistics</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#graph-components">6. Graph Components</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#degree-sequences">7. Degree Sequences</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#centrality-measures">8. Centrality Measures</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#range-limited-centrality-measures">9. Range-limited Centrality Measures</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#centralization">10. Centralization</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#similarity-measures">11. Similarity Measures</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#trees">12. Trees</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#transitivity-or-clustering-coefficient">13. Transitivity or Clustering Coefficient</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#directedness-conversion">14. Directedness Conversion</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#spectral-properties">15. Spectral Properties</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#non-simple-graphs-multiple-and-loop-edges">16. Non-simple Graphs: Multiple and Loop Edges</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#mixing-patterns">17. Mixing Patterns</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#k-cores">18. K-Cores</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#topological-sorting-directed-acyclic-graphs">19. Topological Sorting, Directed Acyclic Graphs</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#maximum-cardinality-search-graph-decomposition-chordal-graphs">20. Maximum Cardinality Search, Graph Decomposition, Chordal Graphs</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#matchings">21. Matchings</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#unfolding-a-graph-into-a-tree">22. Unfolding a Graph Into a Tree</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#other-operations">23. Other Operations</a></span></dt>
</dl></div>
<p>These functions usually calculate some structural property
of a graph, like its diameter, the degree of the nodes, etc.</p>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="basic-properties"></a>1. Basic Properties</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Structural.html#igraph_are_connected">1.1. <code class="function">igraph_are_connected</code> —  Decides whether two vertices are connected</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_are_connected"></a>1.1. <code class="function">igraph_are_connected</code> —  Decides whether two vertices are connected</h3></div></div></div>
<a class="indexterm" name="idp105545204295368"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_are_connected(const igraph_t *graph,
                         igraph_integer_t v1, igraph_integer_t v2,
                         igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v1</code></em>:</span></p></td>
<td><p>
  The first vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v2</code></em>:</span></p></td>
<td><p>
  The second vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Boolean, <code class="constant">TRUE</code> if there is an edge from
        <em class="parameter"><code>v1</code></em> to <em class="parameter"><code>v2</code></em>, <code class="constant">FALSE</code> otherwise.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The error code <code class="constant">IGRAPH_EINVVID</code> is returned if an invalid
        vertex ID is given.
  </p></td>
</tr></tbody>
</table></div>
<p>

The function is of course symmetric for undirected graphs.

</p>
<p>
Time complexity: O( min(log(d1), log(d2)) ),
d1 is the (out-)degree of <em class="parameter"><code>v1</code></em> and d2 is the (in-)degree of <em class="parameter"><code>v2</code></em>.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="shortest-path-related-functions"></a>2. (Shortest) Path Related Functions</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_shortest_paths">2.1. <code class="function">igraph_shortest_paths</code> —  The length of the shortest paths between vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_shortest_paths_dijkstra">2.2. <code class="function">igraph_shortest_paths_dijkstra</code> —  Weighted shortest path lengths between vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_shortest_paths_bellman_ford">2.3. <code class="function">igraph_shortest_paths_bellman_ford</code> —  Weighted shortest path lengths between vertices, allowing negative weights.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_shortest_paths_johnson">2.4. <code class="function">igraph_shortest_paths_johnson</code> —  Weighted shortest path lengths between vertices, using Johnson's algorithm.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_shortest_paths">2.5. <code class="function">igraph_get_shortest_paths</code> —  Shortest paths from a vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_shortest_path">2.6. <code class="function">igraph_get_shortest_path</code> —  Shortest path from one vertex to another one.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra">2.7. <code class="function">igraph_get_shortest_paths_dijkstra</code> —  Weighted shortest paths from a vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_shortest_path_dijkstra">2.8. <code class="function">igraph_get_shortest_path_dijkstra</code> —  Weighted shortest path from one vertex to another one.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_shortest_paths_bellman_ford">2.9. <code class="function">igraph_get_shortest_paths_bellman_ford</code> —  Weighted shortest paths from a vertex, allowing negative weights.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_shortest_path_bellman_ford">2.10. <code class="function">igraph_get_shortest_path_bellman_ford</code> —  Weighted shortest path from one vertex to another one.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_all_shortest_paths">2.11. <code class="function">igraph_get_all_shortest_paths</code> —  All shortest paths (geodesics) from a vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_all_shortest_paths_dijkstra">2.12. <code class="function">igraph_get_all_shortest_paths_dijkstra</code> —  All weighted shortest paths (geodesics) from a vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_all_simple_paths">2.13. <code class="function">igraph_get_all_simple_paths</code> —  List all simple paths from one source.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_average_path_length">2.14. <code class="function">igraph_average_path_length</code> —  Calculates the average unweighted shortest path length between all vertex pairs.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_average_path_length_dijkstra">2.15. <code class="function">igraph_average_path_length_dijkstra</code> —  Calculates the average weighted shortest path length between all vertex pairs.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_path_length_hist">2.16. <code class="function">igraph_path_length_hist</code> — Create a histogram of all shortest path lengths.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_diameter">2.17. <code class="function">igraph_diameter</code> —  Calculates the diameter of a graph (longest geodesic).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_diameter_dijkstra">2.18. <code class="function">igraph_diameter_dijkstra</code> —  Calculates the weighted diameter of a graph using Dijkstra's algorithm.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_girth">2.19. <code class="function">igraph_girth</code> —  The girth of a graph is the length of the shortest cycle in it.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_eccentricity">2.20. <code class="function">igraph_eccentricity</code> —  Eccentricity of some vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_radius">2.21. <code class="function">igraph_radius</code> —  Radius of a graph.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_shortest_paths"></a>2.1. <code class="function">igraph_shortest_paths</code> —  The length of the shortest paths between vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545204383560"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_shortest_paths(const igraph_t *graph, igraph_matrix_t *res,
                          const igraph_vs_t from, const igraph_vs_t to,
                          igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the calculation, a matrix. A pointer to an
       initialized matrix, to be more precise. The matrix will be
       resized if needed. It will have the same
       number of rows as the length of the <code class="constant">from</code>
       argument, and its number of columns is the number of
       vertices in the <code class="constant">to</code> argument. One row of the matrix shows the
       distances from/to a given vertex to the ones in <code class="constant">to</code>.
       For the unreachable vertices IGRAPH_INFINITY is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The source vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The target vertices. It is not allowed to include a
   vertex twice or more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the lengths of the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the lengths of the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for
         the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary
          data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex id passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n(|V|+|E|)),
n is the
number of vertices to calculate, |V| and
|E| are the number of vertices and
edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="2.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a> to get the paths themselves,
<a class="link" href="igraph-Structural.html#igraph_shortest_paths_dijkstra" title="2.2. igraph_shortest_paths_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_shortest_paths_dijkstra()</code></a> for the weighted version.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_shortest_paths_dijkstra"></a>2.2. <code class="function">igraph_shortest_paths_dijkstra</code> —  Weighted shortest path lengths between vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545202948680"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_shortest_paths_dijkstra(const igraph_t *graph,
                                   igraph_matrix_t *res,
                                   const igraph_vs_t from,
                                   const igraph_vs_t to,
                                   const igraph_vector_t *weights,
                                   igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



This function implements Dijkstra's algorithm to find the weighted
shortest path lengths to all vertices from a single source. It is run
independently for the given sources. It uses a binary heap for
efficient implementation.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, can be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result, a matrix. A pointer to an initialized matrix
   should be passed here. The matrix will be resized as needed.
   Each row contains the distances from a single source, to the
   vertices given in the <code class="constant">to</code> argument.
   Unreachable vertices has distance
   <code class="constant">IGRAPH_INFINITY</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The source vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The target vertices. It is not allowed to include a
   vertex twice or more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
   non-negative for Dijkstra's algorithm to work. Additionally, no
   edge weight may be NaN. If either case does not hold, an error
   is returned. If this is a null pointer, then the unweighted
   version, <a class="link" href="igraph-Structural.html#igraph_shortest_paths" title="2.1. igraph_shortest_paths — The length of the shortest paths between vertices."><code class="function">igraph_shortest_paths()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graphs; whether to follow paths along edge
   directions (<code class="constant">IGRAPH_OUT</code>), or the opposite (<code class="constant">IGRAPH_IN</code>), or
   ignore edge directions completely (<code class="constant">IGRAPH_ALL</code>). It is ignored
   for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(s*|E|log|E|+|V|), where |V| is the number of
vertices, |E| the number of edges and s the number of sources.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_shortest_paths" title="2.1. igraph_shortest_paths — The length of the shortest paths between vertices."><code class="function">igraph_shortest_paths()</code></a> for a (slightly) faster unweighted
version or <a class="link" href="igraph-Structural.html#igraph_shortest_paths_bellman_ford" title="2.3. igraph_shortest_paths_bellman_ford — Weighted shortest path lengths between vertices, allowing negative weights."><code class="function">igraph_shortest_paths_bellman_ford()</code></a> for a weighted
variant that works in the presence of negative edge weights (but no
negative loops).
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545202797512"></a><p class="title"><b>Example 13.1.  File <code class="code">examples/simple/dijkstra.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2008-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>print_matrix</strong></span>(<span class="strong"><strong>const</strong></span> igraph_matrix_t *m) {
    long int nrow = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(m);
    long int ncol = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(m);
    long int i, j;
    igraph_real_t val;

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; nrow; i++) {
        <span class="strong"><strong>printf</strong></span>("%li:", i);
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; ncol; j++) {
            val = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j);
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_is_inf</strong></span>(val)) {
                <span class="strong"><strong>if</strong></span> (val &lt; 0) {
                    <span class="strong"><strong>printf</strong></span>("-inf");
                } <span class="strong"><strong>else</strong></span> {
                    <span class="strong"><strong>printf</strong></span>(" inf");
                }
            } <span class="strong"><strong>else</strong></span> {
                <span class="strong"><strong>printf</strong></span>(" %3.0f", val);
            }
        }
        <span class="strong"><strong>printf</strong></span>("\n");
    }
    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_real_t weights_data[] = { 0, 2, 1, 0, 5, 2, 1, 1, 0, 2, 2, 8, 1, 1, 3, 1, 1, 4, 2, 1 };
    igraph_matrix_t res;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED,
                 0, 1, 0, 2, 0, 3,    1, 2, 1, 4, 1, 5,
                 2, 3, 2, 6,         3, 2, 3, 6,
                 4, 5, 4, 7,         5, 6, 5, 8, 5, 9,
                 7, 5, 7, 8,         8, 9,
                 5, 2,
                 2, 1,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights, weights_data,
                       <span class="strong"><strong>sizeof</strong></span>(weights_data) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;res, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_shortest_paths_dijkstra" title="2.2. igraph_shortest_paths_dijkstra — Weighted shortest path lengths between vertices.">igraph_shortest_paths_dijkstra</a></strong></span>(&amp;g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                   &amp;weights, IGRAPH_OUT);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;res);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;res);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_shortest_paths_bellman_ford"></a>2.3. <code class="function">igraph_shortest_paths_bellman_ford</code> —  Weighted shortest path lengths between vertices, allowing negative weights.</h3></div></div></div>
<a class="indexterm" name="idp105545203464520"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_shortest_paths_bellman_ford(const igraph_t *graph,
                                       igraph_matrix_t *res,
                                       const igraph_vs_t from,
                                       const igraph_vs_t to,
                                       const igraph_vector_t *weights,
                                       igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



This function implements the Bellman-Ford algorithm to find the weighted
shortest paths to all vertices from a single source, allowing negative weights.
It is run independently for the given sources. If there are no negative
weights, you are better off with <a class="link" href="igraph-Structural.html#igraph_shortest_paths_dijkstra" title="2.2. igraph_shortest_paths_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_shortest_paths_dijkstra()</code></a> .

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, can be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result, a matrix. A pointer to an initialized matrix
   should be passed here, the matrix will be resized if needed.
   Each row contains the distances from a single source, to all
   vertices in the graph, in the order of vertex ids. For unreachable
   vertices the matrix contains <code class="constant">IGRAPH_INFINITY</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The source vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The target vertices. It is not allowed to include a
   vertex twice or more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. There mustn't be any closed loop in
   the graph that has a negative total weight (since this would allow
   us to decrease the weight of any path containing at least a single
   vertex of this loop infinitely). Additionally, no edge weight may
   be NaN. If either case does not hold, an error is returned. If this
   is a null pointer, then the unweighted version,
   <a class="link" href="igraph-Structural.html#igraph_shortest_paths" title="2.1. igraph_shortest_paths — The length of the shortest paths between vertices."><code class="function">igraph_shortest_paths()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graphs; whether to follow paths along edge
   directions (<code class="constant">IGRAPH_OUT</code>), or the opposite (<code class="constant">IGRAPH_IN</code>), or
   ignore edge directions completely (<code class="constant">IGRAPH_ALL</code>). It is ignored
   for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(s*|E|*|V|), where |V| is the number of
vertices, |E| the number of edges and s the number of sources.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_shortest_paths" title="2.1. igraph_shortest_paths — The length of the shortest paths between vertices."><code class="function">igraph_shortest_paths()</code></a> for a faster unweighted version
or <a class="link" href="igraph-Structural.html#igraph_shortest_paths_dijkstra" title="2.2. igraph_shortest_paths_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_shortest_paths_dijkstra()</code></a> if you do not have negative
edge weights.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545203637320"></a><p class="title"><b>Example 13.2.  File <code class="code">examples/simple/bellman_ford.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2008-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>print_matrix</strong></span>(<span class="strong"><strong>const</strong></span> igraph_matrix_t *m) {
    long int nrow = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(m);
    long int ncol = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(m);
    long int i, j;
    igraph_real_t val;

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; nrow; i++) {
        <span class="strong"><strong>printf</strong></span>("%li:", i);
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; ncol; j++) {
            val = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j);
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_is_inf</strong></span>(val)) {
                <span class="strong"><strong>if</strong></span> (val &lt; 0) {
                    <span class="strong"><strong>printf</strong></span>("-inf");
                } <span class="strong"><strong>else</strong></span> {
                    <span class="strong"><strong>printf</strong></span>(" inf");
                }
            } <span class="strong"><strong>else</strong></span> {
                <span class="strong"><strong>printf</strong></span>(" %3.0f", val);
            }
        }
        <span class="strong"><strong>printf</strong></span>("\n");
    }
    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_real_t weights_data_0[] = { 0, 2, 1, 0, 5, 2, 1, 1, 0, 2, 2, 8, 1, 1, 3, 1, 1, 4, 2, 1 };
    igraph_real_t weights_data_1[] = { 6, 7, 8, -4, -2, -3, 9, 2, 7 };
    igraph_real_t weights_data_2[] = { 6, 7, 2, -4, -2, -3, 9, 2, 7 };
    igraph_matrix_t res;

    <span class="emphasis"><em>/* Graph with only positive weights */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED,
                 0, 1, 0, 2, 0, 3,    1, 2, 1, 4, 1, 5,
                 2, 3, 2, 6,         3, 2, 3, 6,
                 4, 5, 4, 7,         5, 6, 5, 8, 5, 9,
                 7, 5, 7, 8,         8, 9,
                 5, 2,
                 2, 1,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights, weights_data_0,
                       <span class="strong"><strong>sizeof</strong></span>(weights_data_0) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;res, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_shortest_paths_bellman_ford" title="2.3. igraph_shortest_paths_bellman_ford — Weighted shortest path lengths between vertices, allowing negative weights.">igraph_shortest_paths_bellman_ford</a></strong></span>(&amp;g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                       &amp;weights, IGRAPH_OUT);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;res);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;res);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="emphasis"><em>/***************************************/</em></span>

    <span class="emphasis"><em>/* Graph with negative weights */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 5, IGRAPH_DIRECTED,
                 0, 1, 0, 3, 1, 3, 1, 4, 2, 1, 3, 2, 3, 4, 4, 0, 4, 2, -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights, weights_data_1,
                       <span class="strong"><strong>sizeof</strong></span>(weights_data_1) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;res, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_shortest_paths_bellman_ford" title="2.3. igraph_shortest_paths_bellman_ford — Weighted shortest path lengths between vertices, allowing negative weights.">igraph_shortest_paths_bellman_ford</a></strong></span>(&amp;g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                       <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), &amp;weights, IGRAPH_OUT);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;res);

    <span class="emphasis"><em>/***************************************/</em></span>

    <span class="emphasis"><em>/* Same graph with negative loop */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(<a class="link" href="igraph-Error.html#igraph_error_handler_ignore" title="2.3. igraph_error_handler_ignore — Ignore errors.">igraph_error_handler_ignore</a>);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights, weights_data_2,
                       <span class="strong"><strong>sizeof</strong></span>(weights_data_2) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_shortest_paths_bellman_ford" title="2.3. igraph_shortest_paths_bellman_ford — Weighted shortest path lengths between vertices, allowing negative weights.">igraph_shortest_paths_bellman_ford</a></strong></span>(&amp;g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                           <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                           &amp;weights, IGRAPH_OUT) != IGRAPH_ENEGLOOP) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;res);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_shortest_paths_johnson"></a>2.4. <code class="function">igraph_shortest_paths_johnson</code> —  Weighted shortest path lengths between vertices, using Johnson's algorithm.</h3></div></div></div>
<a class="indexterm" name="idp105545206515016"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_shortest_paths_johnson(const igraph_t *graph,
                                  igraph_matrix_t *res,
                                  const igraph_vs_t from,
                                  const igraph_vs_t to,
                                  const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>



See Wikipedia at <a class="ulink" href="http://en.wikipedia.org/wiki/Johnson's_algorithm" target="_top">http://en.wikipedia.org/wiki/Johnson's_algorithm</a>
for Johnson's algorithm. This algorithm works even if the graph
contains negative edge weights, and it is worth using it if we
calculate the shortest paths from many sources.

</p>
<p> If no edge weights are supplied, then the unweighted
version, <a class="link" href="igraph-Structural.html#igraph_shortest_paths" title="2.1. igraph_shortest_paths — The length of the shortest paths between vertices."><code class="function">igraph_shortest_paths()</code></a> is called.

</p>
<p> If all the supplied edge weights are non-negative,
then Dijkstra's algorithm is used by calling
<a class="link" href="igraph-Structural.html#igraph_shortest_paths_dijkstra" title="2.2. igraph_shortest_paths_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_shortest_paths_dijkstra()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, typically it is directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix, the result will be
  stored here, one line for each source vertex, one column for each
  target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The source vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The target vertices. It is not allowed to include a
  vertex twice or more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Optional edge weights. If it is a null-pointer, then
  the unweighted breadth-first search based <a class="link" href="igraph-Structural.html#igraph_shortest_paths" title="2.1. igraph_shortest_paths — The length of the shortest paths between vertices."><code class="function">igraph_shortest_paths()</code></a> will be called.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(s|V|log|V|+|V||E|), |V| and |E| are the number
of vertices and edges, s is the number of source vertices.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_shortest_paths" title="2.1. igraph_shortest_paths — The length of the shortest paths between vertices."><code class="function">igraph_shortest_paths()</code></a> for a faster unweighted version
or <a class="link" href="igraph-Structural.html#igraph_shortest_paths_dijkstra" title="2.2. igraph_shortest_paths_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_shortest_paths_dijkstra()</code></a> if you do not have negative
edge weights, <a class="link" href="igraph-Structural.html#igraph_shortest_paths_bellman_ford" title="2.3. igraph_shortest_paths_bellman_ford — Weighted shortest path lengths between vertices, allowing negative weights."><code class="function">igraph_shortest_paths_bellman_ford()</code></a> if you only
need to calculate shortest paths from a couple of sources.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_shortest_paths"></a>2.5. <code class="function">igraph_get_shortest_paths</code> —  Shortest paths from a vertex.</h3></div></div></div>
<a class="indexterm" name="idp105545206536776"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_shortest_paths(const igraph_t *graph,
                              igraph_vector_ptr_t *vertices,
                              igraph_vector_ptr_t *edges,
                              igraph_integer_t from, const igraph_vs_t to,
                              igraph_neimode_t mode,
                              igraph_vector_long_t *predecessors,
                              igraph_vector_long_t *inbound_edges);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If there is more than one geodesic between two vertices, this
function gives only one of them.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  The result, the ids of the vertices along the paths.
       This is a pointer vector, each element points to a vector
       object. These should be initialized before passing them to
       the function, which will properly clear and/or resize them
       and fill the ids of the vertices along the geodesics from/to
       the vertices. Supply a null pointer here if you don't need
       these vectors.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  The result, the ids of the edges along the paths.
       This is a pointer vector, each element points to a vector
       object. These should be initialized before passing them to
       the function, which will properly clear and/or resize them
       and fill the ids of the vertices along the geodesics from/to
       the vertices. Supply a null pointer here if you don't need
       these vectors.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the vertex from/to which the geodesics are
       calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Vertex sequence with the ids of the vertices to/from which the
       shortest paths will be calculated. A vertex might be given multiple
       times.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>predecessors</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the predecessor of each vertex in
       the single source shortest path tree is returned here. The
       predecessor of vertex i in the tree is the vertex from which vertex i
       was reached. The predecessor of the start vertex (in the <code class="constant">from</code>
       argument) is itself by definition. If the predecessor is -1, it means
       that the given vertex was not reached from the source during the
       search. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>inbound_edges</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the inbound edge of each vertex in
       the single source shortest path tree is returned here. The
       inbound edge of vertex i in the tree is the edge via which vertex i
       was reached. The start vertex and vertices that were not reached
       during the search will have -1 in the corresponding entry of the
       vector. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>from</code></em> is invalid vertex id, or the length of <em class="parameter"><code>to</code></em> is
          not the same as the length of <em class="parameter"><code>res</code></em>.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|),
|V| is the number of vertices,
|E| the number of edges in the
graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_shortest_paths" title="2.1. igraph_shortest_paths — The length of the shortest paths between vertices."><code class="function">igraph_shortest_paths()</code></a> if you only need the path length but
not the paths themselves.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545206566472"></a><p class="title"><b>Example 13.3.  File <code class="code">examples/simple/igraph_get_shortest_paths.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

void <span class="strong"><strong>print_vector</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v) {
    long int i, l = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(v);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; l; i++) {
        <span class="strong"><strong>printf</strong></span>(" %li", (long int) <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i]);
    }
    <span class="strong"><strong>printf</strong></span>("\n");
}

int <span class="strong"><strong>check_evecs</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t *graph, <span class="strong"><strong>const</strong></span> igraph_vector_ptr_t *vecs,
                <span class="strong"><strong>const</strong></span> igraph_vector_ptr_t *evecs, int error_code) {

    igraph_bool_t directed = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="2.2.12. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(graph);
    long int i, n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(vecs);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(evecs) != n) {
        <span class="strong"><strong>exit</strong></span>(error_code + 1);
    }

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *vvec = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vecs)[i];
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *evec = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*evecs)[i];
        long int j, n2 = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(evec);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(vvec) == 0 &amp;&amp; n2 == 0) {
            <span class="strong"><strong>continue</strong></span>;
        }
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(vvec) != n2 + 1) {
            <span class="strong"><strong>exit</strong></span>(error_code + 2);
        }
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; n2; j++) {
            long int edge = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*evec)[j];
            long int from = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vvec)[j];
            long int to = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vvec)[j + 1];
            <span class="strong"><strong>if</strong></span> (directed) {
                <span class="strong"><strong>if</strong></span> (from != <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(graph, edge) ||
                    to   != <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>  (graph, edge)) {
                    <span class="strong"><strong>exit</strong></span>(error_code);
                }
            } <span class="strong"><strong>else</strong></span> {
                long int from2 = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(graph, edge);
                long int to2 = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(graph, edge);
                long int min1 = from &lt; to ? from : to;
                long int max1 = from &lt; to ? to : from;
                long int min2 = from2 &lt; to2 ? from2 : to2;
                long int max2 = from2 &lt; to2 ? to2 : from2;
                <span class="strong"><strong>if</strong></span> (min1 != min2 || max1 != max2) {
                    <span class="strong"><strong>exit</strong></span>(error_code + 3);
                }
            }
        }
    }

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_vector_ptr_t vecs, evecs;
    igraph_vector_long_t pred, inbound;
    long int i;
    igraph_vs_t vs;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED, 0, 1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;vecs, 5);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;evecs, 5);
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;pred, 0);
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;inbound, 0);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;vecs); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vecs)[i] = <span class="strong"><strong>calloc</strong></span>(1, <span class="strong"><strong>sizeof</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>));
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vecs)[i], 0);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(evecs)[i] = <span class="strong"><strong>calloc</strong></span>(1, <span class="strong"><strong>sizeof</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>));
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(evecs)[i], 0);
    }
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_vector_small" title="2.7. igraph_vs_vector_small — Create a vertex set by giving its elements.">igraph_vs_vector_small</a></strong></span>(&amp;vs, 1, 3, 5, 2, 1,  -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="2.5. igraph_get_shortest_paths — Shortest paths from a vertex.">igraph_get_shortest_paths</a></strong></span>(&amp;g, &amp;vecs, &amp;evecs, 0, vs, IGRAPH_OUT, &amp;pred, &amp;inbound);

    <span class="strong"><strong>check_evecs</strong></span>(&amp;g, &amp;vecs, &amp;evecs, 10);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;vecs); i++) {
        <span class="strong"><strong>print_vector</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vecs)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vecs)[i]);
        <span class="strong"><strong>free</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vecs)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(evecs)[i]);
        <span class="strong"><strong>free</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(evecs)[i]);
    }

    <span class="strong"><strong>igraph_vector_long_print</strong></span>(&amp;pred);
    <span class="strong"><strong>igraph_vector_long_print</strong></span>(&amp;inbound);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;vecs);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;evecs);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;pred);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;inbound);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_destroy" title="3.2. igraph_vs_destroy — Destroy a vertex set.">igraph_vs_destroy</a></strong></span>(&amp;vs);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_shortest_path"></a>2.6. <code class="function">igraph_get_shortest_path</code> —  Shortest path from one vertex to another one.</h3></div></div></div>
<a class="indexterm" name="idp105545203096648"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_shortest_path(const igraph_t *graph,
                             igraph_vector_t *vertices,
                             igraph_vector_t *edges,
                             igraph_integer_t from,
                             igraph_integer_t to,
                             igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Calculates and returns a single unweighted shortest path from a
given vertex to another one. If there are more than one shortest
paths between the two vertices, then an arbitrary one is returned.

</p>
<p>This function is a wrapper to <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="2.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a>, for the special case when only one
target vertex is considered.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or
       undirected. Directed paths are considered in directed
       graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
       pointer. If not a null pointer, then the vertex ids along
       the path are stored here, including the source and target
       vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized vector or a null
       pointer. If not a null pointer, then the edge ids along the
       path are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  A constant specifying how edge directions are
       considered in directed graphs. Valid modes are:
       <code class="constant">IGRAPH_OUT</code>, follows edge directions;
       <code class="constant">IGRAPH_IN</code>, follows the opposite directions; and
       <code class="constant">IGRAPH_ALL</code>, ignores edge directions. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="2.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a> for the version with more target
vertices.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_shortest_paths_dijkstra"></a>2.7. <code class="function">igraph_get_shortest_paths_dijkstra</code> —  Weighted shortest paths from a vertex.</h3></div></div></div>
<a class="indexterm" name="idp105545202823112"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_shortest_paths_dijkstra(const igraph_t *graph,
                                       igraph_vector_ptr_t *vertices,
                                       igraph_vector_ptr_t *edges,
                                       igraph_integer_t from,
                                       igraph_vs_t to,
                                       const igraph_vector_t *weights,
                                       igraph_neimode_t mode,
                                       igraph_vector_long_t *predecessors,
                                       igraph_vector_long_t *inbound_edges);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If there is more than one path with the smallest weight between two vertices, this
function gives only one of them.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  The result, the ids of the vertices along the paths.
       This is a pointer vector, each element points to a vector
       object. These should be initialized before passing them to
       the function, which will properly clear and/or resize them
       and fill the ids of the vertices along the geodesics from/to
       the vertices. Supply a null pointer here if you don't need
       these vectors. Normally, either this argument, or the <code class="constant">edges</code> should be non-null, but no error or warning is given
       if they are both null pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  The result, the ids of the edges along the paths.
       This is a pointer vector, each element points to a vector
       object. These should be initialized before passing them to
       the function, which will properly clear and/or resize them
       and fill the ids of the vertices along the geodesics from/to
       the vertices. Supply a null pointer here if you don't need
       these vectors. Normally, either this argument, or the <code class="constant">vertices</code> should be non-null, but no error or warning is given
       if they are both null pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the vertex from/to which the geodesics are
       calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Vertex sequence with the ids of the vertices to/from which the
       shortest paths will be calculated. A vertex might be given multiple
       times.
* </p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
      non-negative for Dijkstra's algorithm to work. Additionally, no
      edge weight may be NaN. If either case does not hold, an error
      is returned. If this is a null pointer, then the unweighted
      version, <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="2.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be use for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>predecessors</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the predecessor of each vertex in
       the single source shortest path tree is returned here. The
       predecessor of vertex i in the tree is the vertex from which vertex i
       was reached. The predecessor of the start vertex (in the <code class="constant">from</code>
       argument) is itself by definition. If the predecessor is -1, it means
       that the given vertex was not reached from the source during the
       search. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>inbound_edges</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the inbound edge of each vertex in
       the single source shortest path tree is returned here. The
       inbound edge of vertex i in the tree is the edge via which vertex i
       was reached. The start vertex and vertices that were not reached
       during the search will have -1 in the corresponding entry of the
       vector. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>from</code></em> is invalid vertex id, or the length of <em class="parameter"><code>to</code></em> is
          not the same as the length of <em class="parameter"><code>res</code></em>.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|log|E|+|V|), where |V| is the number of
vertices and |E| is the number of edges

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_shortest_paths_dijkstra" title="2.2. igraph_shortest_paths_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_shortest_paths_dijkstra()</code></a> if you only need the path length but
not the paths themselves, <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="2.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a> if all edge
weights are equal.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545202840136"></a><p class="title"><b>Example 13.4.  File <code class="code">examples/simple/igraph_get_shortest_paths_dijkstra.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

void <span class="strong"><strong>print_vector</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v) {
    long int i, l = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(v);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; l; i++) {
        <span class="strong"><strong>printf</strong></span>(" %li", (long int) <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i]);
    }
    <span class="strong"><strong>printf</strong></span>("\n");
}

int <span class="strong"><strong>check_evecs</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t *graph, <span class="strong"><strong>const</strong></span> igraph_vector_ptr_t *vecs,
                <span class="strong"><strong>const</strong></span> igraph_vector_ptr_t *evecs, int error_code) {

    igraph_bool_t directed = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="2.2.12. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(graph);
    long int i, n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(vecs);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(evecs) != n) {
        <span class="strong"><strong>exit</strong></span>(error_code + 1);
    }

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *vvec = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vecs)[i];
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *evec = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*evecs)[i];
        long int j, n2 = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(evec);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(vvec) == 0 &amp;&amp; n2 == 0) {
            <span class="strong"><strong>continue</strong></span>;
        }
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(vvec) != n2 + 1) {
            <span class="strong"><strong>exit</strong></span>(error_code + 2);
        }
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; n2; j++) {
            long int edge = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*evec)[j];
            long int from = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vvec)[j];
            long int to = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vvec)[j + 1];
            <span class="strong"><strong>if</strong></span> (directed) {
                <span class="strong"><strong>if</strong></span> (from != <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(graph, edge) ||
                    to   != <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>  (graph, edge)) {
                    <span class="strong"><strong>exit</strong></span>(error_code);
                }
            } <span class="strong"><strong>else</strong></span> {
                long int from2 = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(graph, edge);
                long int to2 = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(graph, edge);
                long int min1 = from &lt; to ? from : to;
                long int max1 = from &lt; to ? to : from;
                long int min2 = from2 &lt; to2 ? from2 : to2;
                long int max2 = from2 &lt; to2 ? to2 : from2;
                <span class="strong"><strong>if</strong></span> (min1 != min2 || max1 != max2) {
                    <span class="strong"><strong>exit</strong></span>(error_code + 3);
                }
            }
        }
    }

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_pred_inbound</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* graph, <span class="strong"><strong>const</strong></span> igraph_vector_long_t* pred,
                       <span class="strong"><strong>const</strong></span> igraph_vector_long_t* inbound, int start, int error_code) {
    long int i, n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(graph);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_vector_long_size</strong></span>(pred) != n ||
        <span class="strong"><strong>igraph_vector_long_size</strong></span>(inbound) != n) {
        <span class="strong"><strong>exit</strong></span>(error_code);
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*pred)[start] != start || <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*inbound)[start] != -1) {
        <span class="strong"><strong>exit</strong></span>(error_code + 1);
    }

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*pred)[i] == -1) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*inbound)[i] != -1) {
                <span class="strong"><strong>exit</strong></span>(error_code + 2);
            }
        } <span class="strong"><strong>else</strong></span> <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*pred)[i] == i) {
            <span class="strong"><strong>if</strong></span> (i != start) {
                <span class="strong"><strong>exit</strong></span>(error_code + 3);
            }
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*inbound)[i] != -1) {
                <span class="strong"><strong>exit</strong></span>(error_code + 4);
            }
        } <span class="strong"><strong>else</strong></span> {
            long int eid = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*inbound)[i];
            long int u = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(graph, eid), v = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(graph, eid);
            <span class="strong"><strong>if</strong></span> (v != i &amp;&amp; !<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="2.2.12. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(graph)) {
                long int dummy = u;
                u = v;
                v = dummy;
            }
            <span class="strong"><strong>if</strong></span> (v != i) {
                <span class="strong"><strong>exit</strong></span>(error_code + 5);
            } <span class="strong"><strong>else</strong></span> <span class="strong"><strong>if</strong></span> (u != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*pred)[i]) {
                <span class="strong"><strong>exit</strong></span>(error_code + 6);
            }
        }
    }

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_vector_ptr_t vecs, evecs;
    igraph_vector_long_t pred, inbound;
    long int i;
    igraph_real_t weights[] = { 1, 2, 3, 4, 5, 1, 1, 1, 1, 1 };
    igraph_real_t weights2[] = { 0, 2, 1, 0, 5, 2, 1, 1, 0, 2, 2, 8, 1, 1, 3, 1, 1, 4, 2, 1 };
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights_vec;
    igraph_vs_t vs;

    <span class="emphasis"><em>/* Simple ring graph without weights */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 10, IGRAPH_UNDIRECTED, 0, 1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;vecs, 6);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;evecs, 6);
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;pred, 0);
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;inbound, 0);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;vecs); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vecs)[i] = <span class="strong"><strong>calloc</strong></span>(1, <span class="strong"><strong>sizeof</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>));
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vecs)[i], 0);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(evecs)[i] = <span class="strong"><strong>calloc</strong></span>(1, <span class="strong"><strong>sizeof</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>));
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(evecs)[i], 0);
    }
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_vector_small" title="2.7. igraph_vs_vector_small — Create a vertex set by giving its elements.">igraph_vs_vector_small</a></strong></span>(&amp;vs, 0, 1, 3, 5, 2, 1,  -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="2.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex.">igraph_get_shortest_paths_dijkstra</a></strong></span>(&amp;g, <span class="emphasis"><em>/*vertices=*/</em></span> &amp;vecs,
                                       <span class="emphasis"><em>/*edges=*/</em></span> &amp;evecs, <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                                       <span class="emphasis"><em>/*weights=*/</em></span> 0, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT,
                                       <span class="emphasis"><em>/*predecessors=*/</em></span> &amp;pred,
                                       <span class="emphasis"><em>/*inbound_edges=*/</em></span> &amp;inbound);

    <span class="strong"><strong>check_evecs</strong></span>(&amp;g, &amp;vecs, &amp;evecs, 10);
    <span class="strong"><strong>check_pred_inbound</strong></span>(&amp;g, &amp;pred, &amp;inbound, <span class="emphasis"><em>/* from= */</em></span> 0, 40);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;vecs); i++) {
        <span class="strong"><strong>print_vector</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vecs)[i]);
    }

    <span class="emphasis"><em>/* Same ring, but with weights */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights_vec, weights, <span class="strong"><strong>sizeof</strong></span>(weights) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="2.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex.">igraph_get_shortest_paths_dijkstra</a></strong></span>(&amp;g, <span class="emphasis"><em>/*vertices=*/</em></span> &amp;vecs,
                                       <span class="emphasis"><em>/*edges=*/</em></span> &amp;evecs, <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                                       &amp;weights_vec, IGRAPH_OUT,
                                       <span class="emphasis"><em>/*predecessors=*/</em></span> &amp;pred,
                                       <span class="emphasis"><em>/*inbound_edges=*/</em></span> &amp;inbound);

    <span class="strong"><strong>check_evecs</strong></span>(&amp;g, &amp;vecs, &amp;evecs, 20);
    <span class="strong"><strong>check_pred_inbound</strong></span>(&amp;g, &amp;pred, &amp;inbound, <span class="emphasis"><em>/* from= */</em></span> 0, 50);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;vecs); i++) {
        <span class="strong"><strong>print_vector</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vecs)[i]);
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* More complicated example */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED,
                 0, 1, 0, 2, 0, 3,    1, 2, 1, 4, 1, 5,
                 2, 3, 2, 6,         3, 2, 3, 6,
                 4, 5, 4, 7,         5, 6, 5, 8, 5, 9,
                 7, 5, 7, 8,         8, 9,
                 5, 2,
                 2, 1,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights_vec, weights2, <span class="strong"><strong>sizeof</strong></span>(weights2) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="2.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex.">igraph_get_shortest_paths_dijkstra</a></strong></span>(&amp;g, <span class="emphasis"><em>/*vertices=*/</em></span> &amp;vecs,
                                       <span class="emphasis"><em>/*edges=*/</em></span> &amp;evecs, <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                                       &amp;weights_vec, IGRAPH_OUT,
                                       <span class="emphasis"><em>/*predecessors=*/</em></span> &amp;pred,
                                       <span class="emphasis"><em>/*inbound_edges=*/</em></span> &amp;inbound);

    <span class="strong"><strong>check_evecs</strong></span>(&amp;g, &amp;vecs, &amp;evecs, 30);
    <span class="strong"><strong>check_pred_inbound</strong></span>(&amp;g, &amp;pred, &amp;inbound, <span class="emphasis"><em>/* from= */</em></span> 0, 60);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;vecs); i++) {
        <span class="strong"><strong>print_vector</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vecs)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vecs)[i]);
        <span class="strong"><strong>free</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vecs)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(evecs)[i]);
        <span class="strong"><strong>free</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(evecs)[i]);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;vecs);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;evecs);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;pred);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;inbound);

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_destroy" title="3.2. igraph_vs_destroy — Destroy a vertex set.">igraph_vs_destroy</a></strong></span>(&amp;vs);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_shortest_path_dijkstra"></a>2.8. <code class="function">igraph_get_shortest_path_dijkstra</code> —  Weighted shortest path from one vertex to another one.</h3></div></div></div>
<a class="indexterm" name="idp105545204428744"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_shortest_path_dijkstra(const igraph_t *graph,
                                      igraph_vector_t *vertices,
                                      igraph_vector_t *edges,
                                      igraph_integer_t from,
                                      igraph_integer_t to,
                                      const igraph_vector_t *weights,
                                      igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Calculates a single (positively) weighted shortest path from
a single vertex to another one, using Dijkstra's algorithm.

</p>
<p>This function is a special case (and a wrapper) to
<a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="2.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex."><code class="function">igraph_get_shortest_paths_dijkstra()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
       pointer. If not a null pointer, then the vertex ids along
       the path are stored here, including the source and target
       vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized vector or a null
       pointer. If not a null pointer, then the edge ids along the
       path are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
      non-negative for Dijkstra's algorithm to work. Additionally, no
      edge weight may be NaN. If either case does not hold, an error
      is returned. If this is a null pointer, then the unweighted
      version, <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths" title="2.5. igraph_get_shortest_paths — Shortest paths from a vertex."><code class="function">igraph_get_shortest_paths()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  A constant specifying how edge directions are
       considered in directed graphs. <code class="constant">IGRAPH_OUT</code> follows edge
       directions, <code class="constant">IGRAPH_IN</code> follows the opposite directions,
       and <code class="constant">IGRAPH_ALL</code> ignores edge directions. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|log|E|+|V|), |V| is the number of vertices,
|E| is the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="2.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex."><code class="function">igraph_get_shortest_paths_dijkstra()</code></a> for the version with
more target vertices.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_shortest_paths_bellman_ford"></a>2.9. <code class="function">igraph_get_shortest_paths_bellman_ford</code> —  Weighted shortest paths from a vertex, allowing negative weights.</h3></div></div></div>
<a class="indexterm" name="idp105545204451528"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_shortest_paths_bellman_ford(const igraph_t *graph,
                                        igraph_vector_ptr_t *vertices,
                                        igraph_vector_ptr_t *edges,
                                        const igraph_integer_t from,
                                        igraph_vs_t to,
                                        const igraph_vector_t *weights,
                                        igraph_neimode_t mode,
                                        igraph_vector_long_t *predecessors,
                                        igraph_vector_long_t *inbound_edges);
</pre></div>
<p>
</p>
<p>




This function calculates weighted shortest paths from or to a single vertex,
and allows negative weights. When there is more than one shortest path between
two vertices, only one of them is returned.

If there are no negative weights, you are better off with 
<a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_dijkstra" title="2.7. igraph_get_shortest_paths_dijkstra — Weighted shortest paths from a vertex."><code class="function">igraph_get_shortest_paths_dijkstra()</code></a> .

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, can be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  The result, the ids of the vertices along the paths.
       This is a pointer vector, each element points to a vector
       object. These should be initialized before passing them to
       the function, which will properly clear and/or resize them
       and fill the ids of the vertices along the geodesics from/to
       the vertices. Supply a null pointer here if you don't need
       these vectors. Normally, either this argument, or the <code class="constant">edges</code> should be non-null, but no error or warning is given
       if they are both null pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  The result, the ids of the edges along the paths.
       This is a pointer vector, each element points to a vector
       object. These should be initialized before passing them to
       the function, which will properly clear and/or resize them
       and fill the ids of the vertices along the geodesics from/to
       the vertices. Supply a null pointer here if you don't need
       these vectors. Normally, either this argument, or the <code class="constant">vertices</code> should be non-null, but no error or warning is given
       if they are both null pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the vertex from/to which the geodesics are
       calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Vertex sequence with the ids of the vertices to/from which the
       shortest paths will be calculated. A vertex might be given multiple
       times.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. There mustn't be any closed loop in
   the graph that has a negative total weight (since this would allow
   us to decrease the weight of any path containing at least a single
   vertex of this loop infinitely). If this is a null pointer, then the
   unweighted version, <a class="link" href="igraph-Structural.html#igraph_shortest_paths" title="2.1. igraph_shortest_paths — The length of the shortest paths between vertices."><code class="function">igraph_shortest_paths()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graphs; whether to follow paths along edge
   directions (<code class="constant">IGRAPH_OUT</code>), or the opposite (<code class="constant">IGRAPH_IN</code>), or
   ignore edge directions completely (<code class="constant">IGRAPH_ALL</code>). It is ignored
   for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>predecessors</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the predecessor of each vertex in
       the single source shortest path tree is returned here. The
       predecessor of vertex i in the tree is the vertex from which vertex i
       was reached. The predecessor of the start vertex (in the <code class="constant">from</code>
       argument) is itself by definition. If the predecessor is -1, it means
       that the given vertex was not reached from the source during the
       search. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>inbound_edges</code></em>:</span></p></td>
<td><p>
  A pointer to an initialized igraph vector or null.
       If not null, a vector containing the inbound edge of each vertex in
       the single source shortest path tree is returned here. The
       inbound edge of vertex i in the tree is the edge via which vertex i
       was reached. The start vertex and vertices that were not reached
       during the search will have -1 in the corresponding entry of the
       vector. Note that the search terminates if all the vertices in
       <code class="constant">to</code> are reached.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          Not enough memory for temporary data.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

          The weight vector doesn't math the number of edges.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>from</code></em> is invalid vertex id, or the length of <em class="parameter"><code>to</code></em> is
          not the same as the length of <em class="parameter"><code>vertices</code></em> or <em class="parameter"><code>edges</code></em>.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENEGLOOP</code></span></p></td>
<td><p>

          Bellman-ford algorithm encounted a negative loop.
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|*|V|), where |V| is the number of
vertices, |E| the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_shortest_paths" title="2.1. igraph_shortest_paths — The length of the shortest paths between vertices."><code class="function">igraph_shortest_paths()</code></a> for a faster unweighted version
or <a class="link" href="igraph-Structural.html#igraph_shortest_paths_dijkstra" title="2.2. igraph_shortest_paths_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_shortest_paths_dijkstra()</code></a> if you do not have negative
edge weights.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_shortest_path_bellman_ford"></a>2.10. <code class="function">igraph_get_shortest_path_bellman_ford</code> —  Weighted shortest path from one vertex to another one.</h3></div></div></div>
<a class="indexterm" name="idp105545204092744"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_shortest_path_bellman_ford(const igraph_t *graph,
                                          igraph_vector_t *vertices,
                                          igraph_vector_t *edges,
                                          igraph_integer_t from,
                                          igraph_integer_t to,
                                          const igraph_vector_t *weights,
                                          igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Calculates a single (positively) weighted shortest path from
a single vertex to another one, using Bellman-Ford algorithm.

</p>
<p>
This function is a special case (and a wrapper) to
<a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_bellman_ford" title="2.9. igraph_get_shortest_paths_bellman_ford — Weighted shortest paths from a vertex, allowing negative weights."><code class="function">igraph_get_shortest_paths_bellman_ford()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertices</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null
       pointer. If not a null pointer, then the vertex ids along
       the path are stored here, including the source and target
       vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized vector or a null
       pointer. If not a null pointer, then the edge ids along the
       path are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. There mustn't be any closed loop in
       the graph that has a negative total weight (since this would allow
       us to decrease the weight of any path containing at least a single
       vertex of this loop infinitely). If this is a null pointer, then the
       unweighted version is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  A constant specifying how edge directions are
       considered in directed graphs. <code class="constant">IGRAPH_OUT</code> follows edge
       directions, <code class="constant">IGRAPH_IN</code> follows the opposite directions,
       and <code class="constant">IGRAPH_ALL</code> ignores edge directions. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|log|E|+|V|), |V| is the number of vertices,
|E| is the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_get_shortest_paths_bellman_ford" title="2.9. igraph_get_shortest_paths_bellman_ford — Weighted shortest paths from a vertex, allowing negative weights."><code class="function">igraph_get_shortest_paths_bellman_ford()</code></a> for the version with
more target vertices.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_all_shortest_paths"></a>2.11. <code class="function">igraph_get_all_shortest_paths</code> —  All shortest paths (geodesics) from a vertex.</h3></div></div></div>
<a class="indexterm" name="idp105545204114632"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_all_shortest_paths(const igraph_t *graph,
                                  igraph_vector_ptr_t *res,
                                  igraph_vector_t *nrgeo,
                                  igraph_integer_t from, const igraph_vs_t to,
                                  igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



When there is more than one shortest path between two vertices,
all of them will be returned.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized pointer vector, the result
  will be stored here in <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_t</code></a> objects. Each vector
  object contains the vertices along a shortest path from <em class="parameter"><code>from</code></em>
  to another vertex. The vectors are ordered according to their
  target vertex: first the shortest paths to vertex 0, then to
  vertex 1, etc. No data is included for unreachable vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nrgeo</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_t</code></a> object or
  <code class="constant">NULL</code>. If not <code class="constant">NULL</code> the number of shortest paths from <em class="parameter"><code>from</code></em> are
  stored here for every vertex in the graph. Note that the values
  will be accurate only for those vertices that are in the target
  vertex sequence (see <em class="parameter"><code>to</code></em>), since the search terminates as soon
  as all the target vertices have been found.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the vertex from/to which the geodesics are
       calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Vertex sequence with the ids of the vertices to/from which the
       shortest paths will be calculated. A vertex might be given multiple
       times.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be use for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the lengths of the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the lengths of the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>from</code></em> is invalid vertex id.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Added in version 0.2.</p>
<p>

Time complexity: O(|V|+|E|) for most graphs, O(|V|^2) in the worst
case.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_all_shortest_paths_dijkstra"></a>2.12. <code class="function">igraph_get_all_shortest_paths_dijkstra</code> —  All weighted shortest paths (geodesics) from a vertex.</h3></div></div></div>
<a class="indexterm" name="idp105545204141512"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_all_shortest_paths_dijkstra(const igraph_t *graph,
        igraph_vector_ptr_t *res,
        igraph_vector_t *nrgeo,
        igraph_integer_t from, igraph_vs_t to,
        const igraph_vector_t *weights,
        igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized pointer vector, the result
  will be stored here in igraph_vector_t objects. Each vector
  object contains the vertices along a shortest path from <em class="parameter"><code>from</code></em>
  to another vertex. The vectors are ordered according to their
  target vertex: first the shortest paths to vertex 0, then to
  vertex 1, etc. No data is included for unreachable vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nrgeo</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized igraph_vector_t object or
  NULL. If not NULL the number of shortest paths from <em class="parameter"><code>from</code></em> are
  stored here for every vertex in the graph. Note that the values
  will be accurate only for those vertices that are in the target
  vertex sequence (see <em class="parameter"><code>to</code></em>), since the search terminates as soon
  as all the target vertices have been found.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The id of the vertex from/to which the geodesics are
       calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Vertex sequence with the ids of the vertices to/from which the
       shortest paths will be calculated. A vertex might be given multiple
       times.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
      non-negative for Dijkstra's algorithm to work. Additionally, no
      edge weight may be NaN. If either case does not hold, an error
      is returned. If this is a null pointer, then the unweighted
      version, <a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths" title="2.11. igraph_get_all_shortest_paths — All shortest paths (geodesics) from a vertex."><code class="function">igraph_get_all_shortest_paths()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be use for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>from</code></em> is invalid vertex id, or the length of <em class="parameter"><code>to</code></em> is
          not the same as the length of <em class="parameter"><code>res</code></em>.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|log|E|+|V|), where |V| is the number of
vertices and |E| is the number of edges

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_shortest_paths_dijkstra" title="2.2. igraph_shortest_paths_dijkstra — Weighted shortest path lengths between vertices."><code class="function">igraph_shortest_paths_dijkstra()</code></a> if you only need the path
length but not the paths themselves, <a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths" title="2.11. igraph_get_all_shortest_paths — All shortest paths (geodesics) from a vertex."><code class="function">igraph_get_all_shortest_paths()</code></a>
if all edge weights are equal.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545204040264"></a><p class="title"><b>Example 13.5.  File <code class="code">examples/simple/igraph_get_all_shortest_paths_dijkstra.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

<span class="emphasis"><em>/* Compares two paths based on their last elements. If they are equal, proceeds</em></span>
<span class="emphasis"><em> * with the ones preceding these elements, until we find a difference. If one</em></span>
<span class="emphasis"><em> * of the vectors is a suffix of the other, the shorter vector gets ordered</em></span>
<span class="emphasis"><em> * first.</em></span>
<span class="emphasis"><em> */</em></span>
int <span class="strong"><strong>vector_tail_cmp</strong></span>(<span class="strong"><strong>const</strong></span> void *path1, <span class="strong"><strong>const</strong></span> void *path2) {
    <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *vec1 = *(<span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>**)path1;
    <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *vec2 = *(<span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>**)path2;
    size_t length1 = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(vec1);
    size_t length2 = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(vec2);
    int diff;

    <span class="strong"><strong>while</strong></span> (length1 &gt; 0 &amp;&amp; length2 &gt; 0) {
        length1--;
        length2--;
        diff = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec1)[length1] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec2)[length2];
        <span class="strong"><strong>if</strong></span> (diff != 0) {
            <span class="strong"><strong>return</strong></span> diff;
        }
    }

    <span class="strong"><strong>if</strong></span> (length1 == 0 &amp;&amp; length2 == 0) {
        <span class="strong"><strong>return</strong></span> 0;
    } <span class="strong"><strong>else</strong></span> <span class="strong"><strong>if</strong></span> (length1 == 0) {
        <span class="strong"><strong>return</strong></span> -1;
    } <span class="strong"><strong>else</strong></span> {
        <span class="strong"><strong>return</strong></span> 1;
    }
}

void <span class="strong"><strong>check_nrgeo</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t *graph, igraph_vs_t vs,
                 <span class="strong"><strong>const</strong></span> igraph_vector_ptr_t *paths,
                 <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *nrgeo) {
    long int i, n;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> nrgeo2, *path;
    igraph_vit_t vit;

    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;nrgeo2, n);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(nrgeo) != n) {
        <span class="strong"><strong>printf</strong></span>("nrgeo vector length must be %ld, was %ld", n, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(nrgeo));
        <span class="strong"><strong>return</strong></span>;
    }

    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(paths);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        path = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*paths)[i];
        <span class="strong"><strong>if</strong></span> (path == 0) {
            <span class="strong"><strong>printf</strong></span>("Null path found in result vector at index %ld\n", i);
            <span class="strong"><strong>return</strong></span>;
        }
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(path) == 0) {
            <span class="strong"><strong>printf</strong></span>("Empty path found in result vector at index %ld\n", i);
            <span class="strong"><strong>return</strong></span>;
        }
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(nrgeo2)[(long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_tail" title="2.4.5. igraph_vector_tail — Returns the last element in a vector.">igraph_vector_tail</a></strong></span>(path)] += 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vit_create" title="5.1. igraph_vit_create — Creates a vertex iterator from a vertex selector.">igraph_vit_create</a></strong></span>(graph, vs, &amp;vit);
    <span class="strong"><strong>for</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_VIT_RESET" title="5.7. IGRAPH_VIT_RESET — Reset a vertex iterator.">IGRAPH_VIT_RESET</a></strong></span>(vit); !<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_VIT_END" title="5.5. IGRAPH_VIT_END — Are we at the end?">IGRAPH_VIT_END</a></strong></span>(vit); <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_VIT_NEXT" title="5.4. IGRAPH_VIT_NEXT — Next vertex.">IGRAPH_VIT_NEXT</a></strong></span>(vit)) {
        long int node = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_VIT_GET" title="5.8. IGRAPH_VIT_GET — Query the current position.">IGRAPH_VIT_GET</a></strong></span>(vit);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*nrgeo)[node] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(nrgeo2)[node]) {
            <span class="strong"><strong>printf</strong></span>("nrgeo[%ld] invalid, observed = %ld, expected = %ld\n",
                   node, (long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*nrgeo)[node], (long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(nrgeo2)[node]);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vit_destroy" title="5.2. igraph_vit_destroy — Destroys a vertex iterator.">igraph_vit_destroy</a></strong></span>(&amp;vit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;nrgeo2);
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_vector_ptr_t res;
    long int i;

    igraph_real_t weights[] = { 1, 2, 3, 4, 5, 1, 1, 1, 1, 1 };
    igraph_real_t weights2[] = { 0, 2, 1, 0, 5, 2, 1, 1, 0, 2, 2, 8, 1, 1, 3, 1, 1, 4, 2, 1 };
    igraph_real_t dim[] = { 4, 4 };

    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights_vec, dim_vec, nrgeo;
    igraph_vs_t vs;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;nrgeo, 0);

    <span class="emphasis"><em>/* Simple ring graph without weights */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 10, IGRAPH_UNDIRECTED, 0, 1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;res, 5);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_vector_small" title="2.7. igraph_vs_vector_small — Create a vertex set by giving its elements.">igraph_vs_vector_small</a></strong></span>(&amp;vs, 1, 3, 4, 5, 2, 1,  -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths_dijkstra" title="2.12. igraph_get_all_shortest_paths_dijkstra — All weighted shortest paths (geodesics) from a vertex.">igraph_get_all_shortest_paths_dijkstra</a></strong></span>(
                &amp;g,
                <span class="emphasis"><em>/*res=*/</em></span> &amp;res, <span class="emphasis"><em>/*nrgeo=*/</em></span> &amp;nrgeo,
                <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                <span class="emphasis"><em>/*weights=*/</em></span> NULL, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);
    <span class="strong"><strong>check_nrgeo</strong></span>(&amp;g, vs, &amp;res, &amp;nrgeo);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;res); i++) {
        <span class="strong"><strong>igraph_vector_print</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i] = 0;
    }

    <span class="emphasis"><em>/* Same ring, but with weights */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights_vec, weights, <span class="strong"><strong>sizeof</strong></span>(weights) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths_dijkstra" title="2.12. igraph_get_all_shortest_paths_dijkstra — All weighted shortest paths (geodesics) from a vertex.">igraph_get_all_shortest_paths_dijkstra</a></strong></span>(
                &amp;g,
                <span class="emphasis"><em>/*res=*/</em></span> &amp;res, <span class="emphasis"><em>/*nrgeo=*/</em></span> &amp;nrgeo,
                <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                <span class="emphasis"><em>/*weights=*/</em></span> &amp;weights_vec, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);
    <span class="strong"><strong>check_nrgeo</strong></span>(&amp;g, vs, &amp;res, &amp;nrgeo);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;res); i++) {
        <span class="strong"><strong>igraph_vector_print</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i] = 0;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* More complicated example */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED,
                 0, 1, 0, 2, 0, 3,   1, 2, 1, 4, 1, 5,
                 2, 3, 2, 6,         3, 2, 3, 6,
                 4, 5, 4, 7,         5, 6, 5, 8, 5, 9,
                 7, 5, 7, 8,         8, 9,
                 5, 2,
                 2, 1,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;weights_vec, weights2, <span class="strong"><strong>sizeof</strong></span>(weights2) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths_dijkstra" title="2.12. igraph_get_all_shortest_paths_dijkstra — All weighted shortest paths (geodesics) from a vertex.">igraph_get_all_shortest_paths_dijkstra</a></strong></span>(
                &amp;g,
                <span class="emphasis"><em>/*res=*/</em></span> &amp;res, <span class="emphasis"><em>/*nrgeo=*/</em></span> &amp;nrgeo,
                <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                <span class="emphasis"><em>/*weights=*/</em></span> &amp;weights_vec, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);

    <span class="strong"><strong>check_nrgeo</strong></span>(&amp;g, vs, &amp;res, &amp;nrgeo);

    <span class="emphasis"><em>/* Sort the paths in a deterministic manner to avoid problems with</em></span>
<span class="emphasis"><em>     * different qsort() implementations on different platforms */</em></span>
    <span class="strong"><strong>igraph_vector_ptr_sort</strong></span>(&amp;res, vector_tail_cmp);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;res); i++) {
        <span class="strong"><strong>igraph_vector_print</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i] = 0;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_destroy" title="3.2. igraph_vs_destroy — Destroy a vertex set.">igraph_vs_destroy</a></strong></span>(&amp;vs);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Regular lattice with some heavyweight edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;dim_vec, dim, <span class="strong"><strong>sizeof</strong></span>(dim) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_lattice" title="1.7. igraph_lattice — Arbitrary dimensional square lattices.">igraph_lattice</a></strong></span>(&amp;g, &amp;dim_vec, 1, 0, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_vector_small" title="2.7. igraph_vs_vector_small — Create a vertex set by giving its elements.">igraph_vs_vector_small</a></strong></span>(&amp;vs, 3, 12, 15, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights_vec, 24);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_fill" title="2.3.2. igraph_vector_fill — Fill a vector with a constant element">igraph_vector_fill</a></strong></span>(&amp;weights_vec, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(weights_vec)[2] = 100;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(weights_vec)[8] = 100; <span class="emphasis"><em>/* 1--&gt;2, 4--&gt;8 */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_all_shortest_paths_dijkstra" title="2.12. igraph_get_all_shortest_paths_dijkstra — All weighted shortest paths (geodesics) from a vertex.">igraph_get_all_shortest_paths_dijkstra</a></strong></span>(
                &amp;g,
                <span class="emphasis"><em>/*res=*/</em></span> 0, <span class="emphasis"><em>/*nrgeo=*/</em></span> &amp;nrgeo,
                <span class="emphasis"><em>/*from=*/</em></span> 0, <span class="emphasis"><em>/*to=*/</em></span> vs,
                <span class="emphasis"><em>/*weights=*/</em></span> &amp;weights_vec, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights_vec);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vs_destroy" title="3.2. igraph_vs_destroy — Destroy a vertex set.">igraph_vs_destroy</a></strong></span>(&amp;vs);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>printf</strong></span>("%ld ", (long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(nrgeo)[3]);
    <span class="strong"><strong>printf</strong></span>("%ld ", (long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(nrgeo)[12]);
    <span class="strong"><strong>printf</strong></span>("%ld\n", (long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(nrgeo)[15]);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;res);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;nrgeo);

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_all_simple_paths"></a>2.13. <code class="function">igraph_get_all_simple_paths</code> —  List all simple paths from one source.</h3></div></div></div>
<a class="indexterm" name="idp105545204155592"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_all_simple_paths(const igraph_t *graph,
                                igraph_vector_int_t *res,
                                igraph_integer_t from,
                                const igraph_vs_t to,
                                igraph_integer_t cutoff,
                                igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



A path is simple if its vertices are unique, i.e. no vertex
is visited more than once.

</p>
<p>
Note that potentially there are exponentially many
paths between two vertices of a graph, and you may
run out of memory when using this function, if your
graph is lattice-like.

</p>
<p>
This function currently ignored multiple and loop edges.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Initialized integer vector, all paths are
       returned here, separated by -1 markers. The paths
       are included in arbitrary order, as they are found.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The start vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The target vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cutoff</code></em>:</span></p></td>
<td><p>
  Maximum length of path that is considered. If
       negative, paths of all lengths are considered.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  The type of the paths to consider, it is ignored
       for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n!) in the worst case, n is the number of
vertices.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_average_path_length"></a>2.14. <code class="function">igraph_average_path_length</code> —  Calculates the average unweighted shortest path length between all vertex pairs.</h3></div></div></div>
<a class="indexterm" name="idp105545204171464"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_average_path_length(const igraph_t *graph,
                               igraph_real_t *res, igraph_real_t *unconn_pairs,
                               igraph_bool_t directed, igraph_bool_t unconn);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If no vertex pairs can be included in the calculation, for example because the graph
has fewer than two vertices, or if the graph has no edges and <code class="constant">unconn</code> is set to <code class="constant">TRUE</code>,
NaN is returned.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, this will contain the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn_pairs</code></em>:</span></p></td>
<td><p>
  Pointer to a real number. If not a null pointer, the number of
   ordered vertex pairs where the second vertex is unreachable from the first one
   will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed
   paths. Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn</code></em>:</span></p></td>
<td><p>
  What to do if the graph is not connected. If
   <code class="constant">TRUE</code>, only those vertex pairs will be included in the calculation
   between which there is a path. If <code class="constant">FALSE</code>, <code class="constant">IGRAPH_INFINITY</code> is returned
   for disconnected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for data structures
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V| |E|), the number of vertices times the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_average_path_length_dijkstra" title="2.15. igraph_average_path_length_dijkstra — Calculates the average weighted shortest path length between all vertex pairs."><code class="function">igraph_average_path_length_dijkstra()</code></a> for the weighted version.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545204189512"></a><p class="title"><b>Example 13.6.  File <code class="code">examples/simple/igraph_average_path_length.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t result;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model.">igraph_barabasi_game</a></strong></span>(&amp;g, 30, <span class="emphasis"><em>/*power=*/</em></span> 1, 30, 0, 0, <span class="emphasis"><em>/*A=*/</em></span> 1,
                         IGRAPH_DIRECTED, IGRAPH_BARABASI_BAG,
                         <span class="emphasis"><em>/*start_from=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_average_path_length" title="2.14. igraph_average_path_length — Calculates the average unweighted shortest path length between all vertex pairs.">igraph_average_path_length</a></strong></span>(&amp;g, &amp;result, NULL, IGRAPH_UNDIRECTED, 1);

    <span class="emphasis"><em>/*   printf("Length of the average shortest paths: %f\n", (float) result); */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_average_path_length_dijkstra"></a>2.15. <code class="function">igraph_average_path_length_dijkstra</code> —  Calculates the average weighted shortest path length between all vertex pairs.</h3></div></div></div>
<a class="indexterm" name="idp105545204205384"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_average_path_length_dijkstra(const igraph_t *graph,
                                        igraph_real_t *res, igraph_real_t *unconn_pairs,
                                        const igraph_vector_t *weights,
                                        igraph_bool_t directed, igraph_bool_t unconn);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If no vertex pairs can be included in the calculation, for example because the graph
has fewer than two vertices, or if the graph has no edges and <code class="constant">unconn</code> is set to <code class="constant">TRUE</code>,
NaN is returned.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
      non-negative for Dijkstra's algorithm to work. Additionally, no
      edge weight may be NaN. If either case does not hold, an error
      is returned. If this is a null pointer, then the unweighted
      version, <a class="link" href="igraph-Structural.html#igraph_average_path_length" title="2.14. igraph_average_path_length — Calculates the average unweighted shortest path length between all vertex pairs."><code class="function">igraph_average_path_length()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, this will contain the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn_pairs</code></em>:</span></p></td>
<td><p>
  Pointer to a real number. If not a null pointer, the number of
   ordered vertex pairs where the second vertex is unreachable from the first one
   will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed paths.
   Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn</code></em>:</span></p></td>
<td><p>
  If <code class="constant">TRUE</code>, only those pairs are considered for the calculation
   between which there is a path. If <code class="constant">FALSE</code>, <code class="constant">IGRAPH_INFINITY</code> is returned
   for disconnected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

             not enough memory for data structures
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

             invalid weight vector
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V| |E| log|E| + |V|), where |V| is the number of
vertices and |E| is the number of edges.

* </p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_average_path_length" title="2.14. igraph_average_path_length — Calculates the average unweighted shortest path length between all vertex pairs."><code class="function">igraph_average_path_length()</code></a> for a slightly faster unweighted version.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_path_length_hist"></a>2.16. <code class="function">igraph_path_length_hist</code> — Create a histogram of all shortest path lengths.</h3></div></div></div>
<a class="indexterm" name="idp105545203835976"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_path_length_hist(const igraph_t *graph, igraph_vector_t *res,
                            igraph_real_t *unconnected, igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



This function calculates a histogram, by calculating the
shortest path length between each pair of vertices. For directed
graphs both directions might be considered and then every pair of vertices
appears twice in the histogram.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is stored
    here. The first (i.e. zeroth) element contains the number of
    shortest paths of length 1, etc. The supplied vector is resized
    as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconnected</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the number of
    pairs for which the second vertex is not reachable from the
    first is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Whether to consider directed paths in a directed
    graph (if not zero). This argument is ignored for undirected
    graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|), the number of vertices times the number
of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_average_path_length" title="2.14. igraph_average_path_length — Calculates the average unweighted shortest path length between all vertex pairs."><code class="function">igraph_average_path_length()</code></a> and <a class="link" href="igraph-Structural.html#igraph_shortest_paths" title="2.1. igraph_shortest_paths — The length of the shortest paths between vertices."><code class="function">igraph_shortest_paths()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_diameter"></a>2.17. <code class="function">igraph_diameter</code> —  Calculates the diameter of a graph (longest geodesic).</h3></div></div></div>
<a class="indexterm" name="idp105545203852232"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_diameter(const igraph_t *graph, igraph_real_t *pres,
                    igraph_integer_t *pfrom, igraph_integer_t *pto,
                    igraph_vector_t *path,
                    igraph_bool_t directed, igraph_bool_t unconn);
</pre></div>
<p>
</p>
<p>




The diameter of a graph is the length of the longest shortest path it has.
This function computes both the diameter, as well as the corresponding path.
The diameter of the null graph is considered be infinity by convention.

If the graph has no vertices, <code class="constant">IGRAPH_NAN</code> is returned.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pres</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, if not <code class="constant">NULL</code> then it will contain
       the diameter (the actual distance).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pfrom</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> it will be set to the
       source vertex of the diameter path. If the graph has no diameter path,
       it will be set to -1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pto</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> it will be set to the
       target vertex of the diameter path. If the graph has no diameter path,
       it will be set to -1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>path</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector. If not <code class="constant">NULL</code> the actual
       longest geodesic path will be stored here. The vector will be
       resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed
       paths. Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn</code></em>:</span></p></td>
<td><p>
  What to do if the graph is not connected. If
       <code class="constant">TRUE</code> the longest geodesic within a component
       will be returned, otherwise <code class="constant">IGRAPH_INFINITY</code> is returned.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
        temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|), the
number of vertices times the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_diameter_dijkstra" title="2.18. igraph_diameter_dijkstra — Calculates the weighted diameter of a graph using Dijkstra's algorithm."><code class="function">igraph_diameter_dijkstra()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545203873608"></a><p class="title"><b>Example 13.7.  File <code class="code">examples/simple/igraph_diameter.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_vector</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v) {
    long int i, n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(v);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>printf</strong></span>(" %li", (long int) <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i]);
    }
    <span class="strong"><strong>printf</strong></span>("\n");
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t result;
    igraph_integer_t from, to;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> path;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model.">igraph_barabasi_game</a></strong></span>(&amp;g, 30, <span class="emphasis"><em>/*power=*/</em></span> 1, 30, 0, 0, <span class="emphasis"><em>/*A=*/</em></span> 1,
                         IGRAPH_DIRECTED, IGRAPH_BARABASI_BAG,
                         <span class="emphasis"><em>/*start_from=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_diameter" title="2.17. igraph_diameter — Calculates the diameter of a graph (longest geodesic).">igraph_diameter</a></strong></span>(&amp;g, &amp;result, 0, 0, 0, IGRAPH_UNDIRECTED, 1);

    <span class="emphasis"><em>/*   printf("Diameter: %li\n", (long int) result); */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;path, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_diameter" title="2.17. igraph_diameter — Calculates the diameter of a graph (longest geodesic).">igraph_diameter</a></strong></span>(&amp;g, &amp;result, &amp;from, &amp;to, &amp;path, IGRAPH_DIRECTED, 1);
    <span class="strong"><strong>printf</strong></span>("diameter: %li, from %li to %li\n", (long int) result,
           (long int) from, (long int) to);
    <span class="strong"><strong>print_vector</strong></span>(&amp;path);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;path);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_diameter_dijkstra"></a>2.18. <code class="function">igraph_diameter_dijkstra</code> —  Calculates the weighted diameter of a graph using Dijkstra's algorithm.</h3></div></div></div>
<a class="indexterm" name="idp105545203767880"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_diameter_dijkstra(const igraph_t *graph,
                             const igraph_vector_t *weights,
                             igraph_real_t *pres,
                             igraph_integer_t *pfrom,
                             igraph_integer_t *pto,
                             igraph_vector_t *path,
                             igraph_bool_t directed,
                             igraph_bool_t unconn);
</pre></div>
<p>
</p>
<p>



This function computes the weighted diameter of a graph.

If the graph has no vertices, <code class="constant">IGRAPH_NAN</code> is returned.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pres</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, if not <code class="constant">NULL</code> then it will contain
       the diameter (the actual distance).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pfrom</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> it will be set to the
       source vertex of the diameter path. If the graph has no diameter path,
       it will be set to -1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pto</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> it will be set to the
       target vertex of the diameter path. If the graph has no diameter path,
       it will be set to -1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>path</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector. If not <code class="constant">NULL</code> the actual
       longest geodesic path will be stored here. The vector will be
       resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed
       paths. Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>unconn</code></em>:</span></p></td>
<td><p>
  What to do if the graph is not connected. If
       <code class="constant">TRUE</code> the longest geodesic within a component
       will be returned, otherwise <code class="constant">IGRAPH_INFINITY</code> is
       returned.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|*log|E|), |V| is the number of vertices,
|E| is the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_diameter" title="2.17. igraph_diameter — Calculates the diameter of a graph (longest geodesic)."><code class="function">igraph_diameter()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_girth"></a>2.19. <code class="function">igraph_girth</code> —  The girth of a graph is the length of the shortest cycle in it.</h3></div></div></div>
<a class="indexterm" name="idp105545203790280"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_girth(const igraph_t *graph, igraph_integer_t *girth,
                 igraph_vector_t *circle);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The current implementation works for undirected graphs only,
directed graphs are treated as undirected graphs. Self-loops and
multiple edges are ignored.

</p>
<p>
For graphs that contain no cycles, and only for such graphs, 
zero is returned. Note that in some applications, it is customary 
to define the girth of acyclic graphs to be infinity. However, infinity
is not representable as an <code class="constant">igraph_integer_t</code>, therefore zero is used
for this case.

</p>
<p>
This implementation is based on Alon Itai and Michael Rodeh:
Finding a minimum circuit in a graph
<span class="emphasis"><em> Proceedings of the ninth annual ACM symposium on Theory of
computing </em></span>, 1-10, 1977. The first implementation of this
function was done by Keith Briggs, thanks Keith.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>girth</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> then the result
    will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>circle</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the vertex ids in
    the shortest circle will be stored here. If <code class="constant">NULL</code> then it is
    ignored.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O((|V|+|E|)^2), |V| is the number of vertices, |E|
is the number of edges in the general case. If the graph has no
cycles at all then the function needs O(|V|+|E|) time to realize
this and then it stops.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545203802312"></a><p class="title"><b>Example 13.8.  File <code class="code">examples/simple/igraph_girth.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2007-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    igraph_integer_t girth;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> v;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> circle;
    igraph_real_t chord[] = { 0, 50 };

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 100, IGRAPH_UNDIRECTED, 0, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;v, chord, <span class="strong"><strong>sizeof</strong></span>(chord) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_add_edges" title="2.3.2. igraph_add_edges — Adds edges to a graph object.">igraph_add_edges</a></strong></span>(&amp;g, &amp;v, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_girth" title="2.19. igraph_girth — The girth of a graph is the length of the shortest cycle in it.">igraph_girth</a></strong></span>(&amp;g, &amp;girth, 0);
    <span class="strong"><strong>if</strong></span> (girth != 51) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Special case: null graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED, 0, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;circle, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(circle)[0] = 2;
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_girth" title="2.19. igraph_girth — The girth of a graph is the length of the shortest cycle in it.">igraph_girth</a></strong></span>(&amp;g, &amp;girth, &amp;circle);
    <span class="strong"><strong>if</strong></span> (girth != 0) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;circle) != 0) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;circle);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_eccentricity"></a>2.20. <code class="function">igraph_eccentricity</code> —  Eccentricity of some vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545203960136"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_eccentricity(const igraph_t *graph,
                        igraph_vector_t *res,
                        igraph_vs_t vids,
                        igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



The eccentricity of a vertex is calculated by measuring the shortest
distance from (or to) the vertex, to (or from) all vertices in the
graph, and taking the maximum.

</p>
<p>
This implementation ignores vertex pairs that are in different
components. Isolated vertices have eccentricity zero.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the eccentricity is calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  What kind of paths to consider for the calculation:
   <code class="constant">IGRAPH_OUT</code>, paths that follow edge directions;
   <code class="constant">IGRAPH_IN</code>, paths that follow the opposite directions; and
   <code class="constant">IGRAPH_ALL</code>, paths that ignore edge directions. This argument
   is ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(v*(|V|+|E|)), where |V| is the number of
vertices, |E| is the number of edges and v is the number of
vertices for which eccentricity is calculated.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_radius" title="2.21. igraph_radius — Radius of a graph."><code class="function">igraph_radius()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545203975752"></a><p class="title"><b>Example 13.9.  File <code class="code">examples/simple/igraph_eccentricity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sts=4 sw=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2011-12  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> ecc;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;ecc, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.6. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_UNDIRECTED, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_eccentricity" title="2.20. igraph_eccentricity — Eccentricity of some vertices.">igraph_eccentricity</a></strong></span>(&amp;g, &amp;ecc, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;ecc);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.6. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_OUT, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_eccentricity" title="2.20. igraph_eccentricity — Eccentricity of some vertices.">igraph_eccentricity</a></strong></span>(&amp;g, &amp;ecc, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;ecc);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.6. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_OUT, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_eccentricity" title="2.20. igraph_eccentricity — Eccentricity of some vertices.">igraph_eccentricity</a></strong></span>(&amp;g, &amp;ecc, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;ecc);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;ecc);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_radius"></a>2.21. <code class="function">igraph_radius</code> —  Radius of a graph.</h3></div></div></div>
<a class="indexterm" name="idp105545204000968"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_radius(const igraph_t *graph, igraph_real_t *radius,
                  igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



The radius of a graph is the defined as the minimum eccentricity of
its vertices, see <a class="link" href="igraph-Structural.html#igraph_eccentricity" title="2.20. igraph_eccentricity — Eccentricity of some vertices."><code class="function">igraph_eccentricity()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>radius</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored
  here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  What kind of paths to consider for the calculation:
   <code class="constant">IGRAPH_OUT</code>, paths that follow edge directions;
   <code class="constant">IGRAPH_IN</code>, paths that follow the opposite directions; and
   <code class="constant">IGRAPH_ALL</code>, paths that ignore edge directions. This argument
   is ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|(|V|+|E|)), where |V| is the number of
vertices and |E| is the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_eccentricity" title="2.20. igraph_eccentricity — Eccentricity of some vertices."><code class="function">igraph_eccentricity()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545204015560"></a><p class="title"><b>Example 13.10.  File <code class="code">examples/simple/igraph_radius.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sts=4 sw=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2011-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t radius;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.6. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_UNDIRECTED, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_radius" title="2.21. igraph_radius — Radius of a graph.">igraph_radius</a></strong></span>(&amp;g, &amp;radius, IGRAPH_OUT);
    <span class="strong"><strong>if</strong></span> (radius != 1) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.6. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_OUT, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_radius" title="2.21. igraph_radius — Radius of a graph.">igraph_radius</a></strong></span>(&amp;g, &amp;radius, IGRAPH_ALL);
    <span class="strong"><strong>if</strong></span> (radius != 1) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.6. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_OUT, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_radius" title="2.21. igraph_radius — Radius of a graph.">igraph_radius</a></strong></span>(&amp;g, &amp;radius, IGRAPH_OUT);
    <span class="strong"><strong>if</strong></span> (radius != 0) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="efficiency-measures"></a>3. Efficiency Measures</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_global_efficiency">3.1. <code class="function">igraph_global_efficiency</code> —  Calculates the global efficiency of a network.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_efficiency">3.2. <code class="function">igraph_local_efficiency</code> —  Calculates the local efficiency around each vertex in a network.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_average_local_efficiency">3.3. <code class="function">igraph_average_local_efficiency</code> —  Calculates the average local efficiency in a network.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_global_efficiency"></a>3.1. <code class="function">igraph_global_efficiency</code> —  Calculates the global efficiency of a network.</h3></div></div></div>
<a class="indexterm" name="idp105545203907656"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_global_efficiency(const igraph_t *graph, igraph_real_t *res,
                             const igraph_vector_t *weights,
                             igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The global efficiency of a network is defined as the average of inverse distances
between all pairs of vertices: <code class="literal"> E_g = 1/(N*(N-1)) sum_{i!=j} 1/d_ij</code> ,
where N is the number of vertices.
The inverse distance between pairs that are not reachable from each other is considered
to be zero. For graphs with fewer than 2 vertices, NaN is returned.

</p>
<p>
Reference:
V. Latora and M. Marchiori,
Efficient Behavior of Small-World Networks,
Phys. Rev. Lett. 87, 198701 (2001).
<a class="ulink" href="https://dx.doi.org/10.1103/PhysRevLett.87.198701" target="_top">https://dx.doi.org/10.1103/PhysRevLett.87.198701</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, this will contain the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
      non-negative for Dijkstra's algorithm to work. Additionally, no
      edge weight may be NaN. If either case does not hold, an error
      is returned. If this is a null pointer, then the unweighted
      version, <a class="link" href="igraph-Structural.html#igraph_average_path_length" title="2.14. igraph_average_path_length — Calculates the average unweighted shortest path length between all vertex pairs."><code class="function">igraph_average_path_length()</code></a> is used in calculating
      the global efficiency.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed paths.
   Ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

             not enough memory for data structures
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

             invalid weight vector
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V| |E| log|E| + |V|) for weighted graphs and
O(|V| |E|) for unweighted ones. |V| denotes the number of
vertices and |E| denotes the number of edges.

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_local_efficiency"></a>3.2. <code class="function">igraph_local_efficiency</code> —  Calculates the local efficiency around each vertex in a network.</h3></div></div></div>
<a class="indexterm" name="idp105545203925192"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_local_efficiency(const igraph_t *graph, igraph_vector_t *res,
                            const igraph_vs_t vids,
                            const igraph_vector_t *weights,
                            igraph_bool_t directed, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The local efficiency of a network around a vertex is defined as follows:
We remove the vertex and compute the distances (shortest path lengths) between
its neighbours through the rest of the network. The local efficiency around the
removed vertex is the average of the inverse of these distances.

</p>
<p>
The inverse distance between two vertices which are not reachable from each other
is considered to be zero. The local efficiency around a vertex with fewer than two
neighbours is taken to be zero by convention.

</p>
<p>
Reference:
I. Vragović, E. Louis, and A. Díaz-Guilera,
Efficiency of informational transfer in regular and complex networks,
Phys. Rev. E 71, 1 (2005).
<a class="ulink" href="http://dx.doi.org/10.1103/PhysRevE.71.036122" target="_top">http://dx.doi.org/10.1103/PhysRevE.71.036122</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, this will contain the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices around which the local efficiency will be calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. All edge weights must be
      non-negative. Additionally, no edge weight may be NaN. If either
      case does not hold, an error is returned. If this is a null
      pointer, then the unweighted version,
      <a class="link" href="igraph-Structural.html#igraph_average_path_length" title="2.14. igraph_average_path_length — Calculates the average unweighted shortest path length between all vertex pairs."><code class="function">igraph_average_path_length()</code></a> is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed paths.
   Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  How to determine the local neighborhood of each vertex
   in directed graphs. Ignored in undirected graphs.
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

             take both in- and out-neighbours;
             this is a reasonable default for high-level interfaces.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

             take only out-neighbours
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

             take only in-neighbours
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

             not enough memory for data structures
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

             invalid weight vector
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|^2 log|E|) for weighted graphs and
O(|E|^2) for unweighted ones. |E| denotes the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_average_local_efficiency" title="3.3. igraph_average_local_efficiency — Calculates the average local efficiency in a network."><code class="function">igraph_average_local_efficiency()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_average_local_efficiency"></a>3.3. <code class="function">igraph_average_local_efficiency</code> —  Calculates the average local efficiency in a network.</h3></div></div></div>
<a class="indexterm" name="idp105545137506376"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_average_local_efficiency(const igraph_t *graph, igraph_real_t *res,
                                    const igraph_vector_t *weights,
                                    igraph_bool_t directed, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




For the null graph, zero is returned by convention.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, this will contain the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights. They must be all non-negative.
   If a null pointer is given, all weights are assumed to be 1.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed paths.
   Ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  How to determine the local neighborhood of each vertex
   in directed graphs. Ignored in undirected graphs.
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

             take both in- and out-neighbours;
             this is a reasonable default for high-level interfaces.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

             take only out-neighbours
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

             take only in-neighbours
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

             not enough memory for data structures
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

             invalid weight vector
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|^2 log|E|) for weighted graphs and
O(|E|^2) for unweighted ones. |E| denotes the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_local_efficiency" title="3.2. igraph_local_efficiency — Calculates the local efficiency around each vertex in a network."><code class="function">igraph_local_efficiency()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="neighborhood-of-a-vertex"></a>4. Neighborhood of a Vertex</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_neighborhood_size">4.1. <code class="function">igraph_neighborhood_size</code> —  Calculates the size of the neighborhood of a given vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_neighborhood">4.2. <code class="function">igraph_neighborhood</code> — Calculate the neighborhood of vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_neighborhood_graphs">4.3. <code class="function">igraph_neighborhood_graphs</code> — Create graphs from the neighborhood(s) of some vertex/vertices.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_neighborhood_size"></a>4.1. <code class="function">igraph_neighborhood_size</code> —  Calculates the size of the neighborhood of a given vertex.</h3></div></div></div>
<a class="indexterm" name="idp105545272788552"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_neighborhood_size(const igraph_t *graph, igraph_vector_t *res,
                             igraph_vs_t vids, igraph_integer_t order,
                             igraph_neimode_t mode,
                             igraph_integer_t mindist);
</pre></div>
<p>
</p>
<p>



The neighborhood of a given order of a vertex includes all vertices
which are closer to the vertex than the order. I.e., order 0 is
always the vertex itself, order 1 is the vertex plus its immediate
neighbors, order 2 is order 1 plus the immediate neighbors of the
vertices in order 1, etc.

</p>
<p> This function calculates the size of the neighborhood
of the given order for the given vertices.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result will be
   stored here. It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>order</code></em>:</span></p></td>
<td><p>
  Integer giving the order of the neighborhood.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies how to use the direction of the edges if a
  directed graph is analyzed. For <code class="constant">IGRAPH_OUT</code> only the outgoing
  edges are followed, so all vertices reachable from the source
  vertex in at most <code class="constant">order</code> steps are counted. For <code class="constant">IGRAPH_IN</code>
  all vertices from which the source vertex is reachable in at most
  <code class="constant">order</code> steps are counted. <code class="constant">IGRAPH_ALL</code> ignores the direction
  of the edges. This argument is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mindist</code></em>:</span></p></td>
<td><p>
  The minimum distance to include a vertex in the counting.
  If this is one, then the starting vertex is not counted. If this is
  two, then its neighbors are not counted, either, etc.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_neighborhood" title="4.2. igraph_neighborhood — Calculate the neighborhood of vertices."><code class="function">igraph_neighborhood()</code></a> for calculating the actual neighborhood,
<a class="link" href="igraph-Structural.html#igraph_neighborhood_graphs" title="4.3. igraph_neighborhood_graphs — Create graphs from the neighborhood(s) of some vertex/vertices."><code class="function">igraph_neighborhood_graphs()</code></a> for creating separate graphs from
the neighborhoods.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*d*o), where n is the number vertices for which
the calculation is performed, d is the average degree, o is the order.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_neighborhood"></a>4.2. <code class="function">igraph_neighborhood</code> — Calculate the neighborhood of vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545272809800"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_neighborhood(const igraph_t *graph, igraph_vector_ptr_t *res,
                        igraph_vs_t vids, igraph_integer_t order,
                        igraph_neimode_t mode, igraph_integer_t mindist);
</pre></div>
<p>
</p>
<p>



The neighborhood of a given order of a vertex includes all vertices
which are closer to the vertex than the order. I.e., order 0 is
always the vertex itself, order 1 is the vertex plus its immediate
neighbors, order 2 is order 1 plus the immediate neighbors of the
vertices in order 1, etc.

</p>
<p> This function calculates the vertices within the
neighborhood of the specified vertices.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized pointer vector. Note that the objects
   (pointers) in the vector will <span class="emphasis"><em>not</em></span> be freed, but the pointer
   vector will be resized as needed. The result of the calculation
   will be stored here in <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_t</code></a> objects.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>order</code></em>:</span></p></td>
<td><p>
  Integer giving the order of the neighborhood.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies how to use the direction of the edges if a
  directed graph is analyzed. For <code class="constant">IGRAPH_OUT</code> only the outgoing
  edges are followed, so all vertices reachable from the source
  vertex in at most <em class="parameter"><code>order</code></em> steps are included. For <code class="constant">IGRAPH_IN</code>
  all vertices from which the source vertex is reachable in at most
  <em class="parameter"><code>order</code></em> steps are included. <code class="constant">IGRAPH_ALL</code> ignores the direction
  of the edges. This argument is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mindist</code></em>:</span></p></td>
<td><p>
  The minimum distance to include a vertex in the counting.
  If this is one, then the starting vertex is not counted. If this is
  two, then its neighbors are not counted, either, etc.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_neighborhood_size" title="4.1. igraph_neighborhood_size — Calculates the size of the neighborhood of a given vertex."><code class="function">igraph_neighborhood_size()</code></a> to calculate the size of the
neighborhood, <a class="link" href="igraph-Structural.html#igraph_neighborhood_graphs" title="4.3. igraph_neighborhood_graphs — Create graphs from the neighborhood(s) of some vertex/vertices."><code class="function">igraph_neighborhood_graphs()</code></a> for creating
graphs from the neighborhoods.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*d*o), n is the number of vertices for which
the calculation is performed, d is the average degree, o is the
order.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_neighborhood_graphs"></a>4.3. <code class="function">igraph_neighborhood_graphs</code> — Create graphs from the neighborhood(s) of some vertex/vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545272701512"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_neighborhood_graphs(const igraph_t *graph, igraph_vector_ptr_t *res,
                               igraph_vs_t vids, igraph_integer_t order,
                               igraph_neimode_t mode,
                               igraph_integer_t mindist);
</pre></div>
<p>
</p>
<p>



The neighborhood of a given order of a vertex includes all vertices
which are closer to the vertex than the order. Ie. order 0 is
always the vertex itself, order 1 is the vertex plus its immediate
neighbors, order 2 is order 1 plus the immediate neighbors of the
vertices in order 1, etc.

</p>
<p> This function finds every vertex in the neighborhood
of a given parameter vertex and creates a graph from these
vertices.

</p>
<p> The first version of this function was written by
Vincent Matossian, thanks Vincent.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer vector, the result will be stored
  here, ie. <em class="parameter"><code>res</code></em> will contain pointers to <code class="constant">igraph_t</code>
  objects. It will be resized if needed but note that the
  objects in the pointer vector will not be freed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>order</code></em>:</span></p></td>
<td><p>
  Integer giving the order of the neighborhood.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies how to use the direction of the edges if a
  directed graph is analyzed. For <code class="constant">IGRAPH_OUT</code> only the outgoing
  edges are followed, so all vertices reachable from the source
  vertex in at most <em class="parameter"><code>order</code></em> steps are counted. For <code class="constant">IGRAPH_IN</code>
  all vertices from which the source vertex is reachable in at most
  <em class="parameter"><code>order</code></em> steps are counted. <code class="constant">IGRAPH_ALL</code> ignores the direction
  of the edges. This argument is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mindist</code></em>:</span></p></td>
<td><p>
  The minimum distance to include a vertex in the counting.
  If this is one, then the starting vertex is not counted. If this is
  two, then its neighbors are not counted, either, etc.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_neighborhood_size" title="4.1. igraph_neighborhood_size — Calculates the size of the neighborhood of a given vertex."><code class="function">igraph_neighborhood_size()</code></a> for calculating the neighborhood
sizes only, <a class="link" href="igraph-Structural.html#igraph_neighborhood" title="4.2. igraph_neighborhood — Calculate the neighborhood of vertices."><code class="function">igraph_neighborhood()</code></a> for calculating the
neighborhoods (but not creating graphs).
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*(|V|+|E|)), where n is the number vertices for
which the calculation is performed, |V| and |E| are the number of
vertices and edges in the original input graph.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="local-scan-statistics"></a>5. Local Scan Statistics</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#us-statistics">5.1. "Us" statistics</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#them-statistics">5.2. "Them" statistics</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#pre-calculated-neighborhoods">5.3. Pre-calculated neighborhoods</a></span></dt>
</dl></div>
<p>
The scan statistic is a summary of the locality statistics that is computed
from the local neighborhood of each vertex. For details, see
Priebe, C. E., Conroy, J. M., Marchette, D. J., Park, Y. (2005).
Scan Statistics on Enron Graphs. Computational and Mathematical Organization Theory.
</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="us-statistics"></a>5.1. "Us" statistics</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_0">5.1.1. <code class="function">igraph_local_scan_0</code> — Local scan-statistics, k=0</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_1_ecount">5.1.2. <code class="function">igraph_local_scan_1_ecount</code> — Local scan-statistics, k=1, edge count and sum of weights</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_k_ecount">5.1.3. <code class="function">igraph_local_scan_k_ecount</code> — Local scan-statistics, general function, edge count and sum of weights</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_0"></a>5.1.1. <code class="function">igraph_local_scan_0</code> — Local scan-statistics, k=0</h4></div></div></div>
<a class="indexterm" name="idp105545272726088"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_local_scan_0(const igraph_t *graph, igraph_vector_t *res,
                        const igraph_vector_t *weights,
                        igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



K=0 scan-statistics is arbitrarily defined as the vertex degree for
unweighted, and the vertex strength for weighted graphs. See <a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a> and <a class="link" href="igraph-Structural.html#igraph_strength" title="8.11. igraph_strength — Strength of the vertices, weighted vertex degree in other words."><code class="function">igraph_strength()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the results are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of the neighborhood, <code class="constant">IGRAPH_OUT</code> means outgoing,
       <code class="constant">IGRAPH_IN</code> means incoming and <code class="constant">IGRAPH_ALL</code> means all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_1_ecount"></a>5.1.2. <code class="function">igraph_local_scan_1_ecount</code> — Local scan-statistics, k=1, edge count and sum of weights</h4></div></div></div>
<a class="indexterm" name="idp105545272741320"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_local_scan_1_ecount(const igraph_t *graph, igraph_vector_t *res,
                               const igraph_vector_t *weights,
                               igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Count the number of edges or the sum the edge weights in the
1-neighborhood of vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the results are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of the neighborhood, <code class="constant">IGRAPH_OUT</code> means outgoing,
       <code class="constant">IGRAPH_IN</code> means incoming and <code class="constant">IGRAPH_ALL</code> means all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_k_ecount"></a>5.1.3. <code class="function">igraph_local_scan_k_ecount</code> — Local scan-statistics, general function, edge count and sum of weights</h4></div></div></div>
<a class="indexterm" name="idp105545272755016"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_local_scan_k_ecount(const igraph_t *graph, int k,
                               igraph_vector_t *res,
                               const igraph_vector_t *weights,
                               igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Count the number of edges or the sum the edge weights in the
k-neighborhood of vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>k</code></em>:</span></p></td>
<td><p>
  The size of the neighborhood, non-negative integer.
       The k=0 case is special, see <a class="link" href="igraph-Structural.html#igraph_local_scan_0" title="5.1.1. igraph_local_scan_0 — Local scan-statistics, k=0"><code class="function">igraph_local_scan_0()</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the results are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of the neighborhood, <code class="constant">IGRAPH_OUT</code> means outgoing,
       <code class="constant">IGRAPH_IN</code> means incoming and <code class="constant">IGRAPH_ALL</code> means all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="them-statistics"></a>5.2. "Them" statistics</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_0_them">5.2.1. <code class="function">igraph_local_scan_0_them</code> — Local THEM scan-statistics, k=0</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_1_ecount_them">5.2.2. <code class="function">igraph_local_scan_1_ecount_them</code> — Local THEM scan-statistics, k=1, edge count and sum of weights</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_k_ecount_them">5.2.3. <code class="function">igraph_local_scan_k_ecount_them</code> — Local THEM scan-statistics, general function, edge count and sum of weights</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_0_them"></a>5.2.1. <code class="function">igraph_local_scan_0_them</code> — Local THEM scan-statistics, k=0</h4></div></div></div>
<a class="indexterm" name="idp105545272902728"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_local_scan_0_them(const igraph_t *us, const igraph_t *them,
                             igraph_vector_t *res,
                             const igraph_vector_t *weights_them,
                             igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



K=0 scan-statistics is arbitrarily defined as the vertex degree for
unweighted, and the vertex strength for weighted graphs. See <a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a> and <a class="link" href="igraph-Structural.html#igraph_strength" title="8.11. igraph_strength — Strength of the vertices, weighted vertex degree in other words."><code class="function">igraph_strength()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>us</code></em>:</span></p></td>
<td><p>
  The input graph, to use to extract the neighborhoods.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>them</code></em>:</span></p></td>
<td><p>
  The input graph to use for the actually counting.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the results are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights_them</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of the neighborhood, <code class="constant">IGRAPH_OUT</code> means outgoing,
       <code class="constant">IGRAPH_IN</code> means incoming and <code class="constant">IGRAPH_ALL</code> means all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_1_ecount_them"></a>5.2.2. <code class="function">igraph_local_scan_1_ecount_them</code> — Local THEM scan-statistics, k=1, edge count and sum of weights</h4></div></div></div>
<a class="indexterm" name="idp105545272919368"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_local_scan_1_ecount_them(const igraph_t *us, const igraph_t *them,
                                    igraph_vector_t *res,
                                    const igraph_vector_t *weights_them,
                                    igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Count the number of edges or the sum the edge weights in the
1-neighborhood of vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>us</code></em>:</span></p></td>
<td><p>
  The input graph to extract the neighborhoods.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>them</code></em>:</span></p></td>
<td><p>
  The input graph to perform the counting.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights_them</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of the neighborhood, <code class="constant">IGRAPH_OUT</code> means outgoing,
       <code class="constant">IGRAPH_IN</code> means incoming and <code class="constant">IGRAPH_ALL</code> means all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_local_scan_1_ecount" title="5.1.2. igraph_local_scan_1_ecount — Local scan-statistics, k=1, edge count and sum of weights"><code class="function">igraph_local_scan_1_ecount()</code></a> for the US statistics.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_k_ecount_them"></a>5.2.3. <code class="function">igraph_local_scan_k_ecount_them</code> — Local THEM scan-statistics, general function, edge count and sum of weights</h4></div></div></div>
<a class="indexterm" name="idp105545272936008"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_local_scan_k_ecount_them(const igraph_t *us, const igraph_t *them,
                                    int k, igraph_vector_t *res,
                                    const igraph_vector_t *weights_them,
                                    igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



Count the number of edges or the sum the edge weights in the
k-neighborhood of vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>us</code></em>:</span></p></td>
<td><p>
  The input graph to extract the neighborhoods.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>them</code></em>:</span></p></td>
<td><p>
  The input graph to perform the counting.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>k</code></em>:</span></p></td>
<td><p>
  The size of the neighborhood, non-negative integer.
       The k=0 case is special, see <a class="link" href="igraph-Structural.html#igraph_local_scan_0_them" title="5.2.1. igraph_local_scan_0_them — Local THEM scan-statistics, k=0"><code class="function">igraph_local_scan_0_them()</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights_them</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of the neighborhood, <code class="constant">IGRAPH_OUT</code> means outgoing,
       <code class="constant">IGRAPH_IN</code> means incoming and <code class="constant">IGRAPH_ALL</code> means all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_local_scan_1_ecount" title="5.1.2. igraph_local_scan_1_ecount — Local scan-statistics, k=1, edge count and sum of weights"><code class="function">igraph_local_scan_1_ecount()</code></a> for the US statistics.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="pre-calculated-neighborhoods"></a>5.3. Pre-calculated neighborhoods</h3></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Structural.html#igraph_local_scan_neighborhood_ecount">5.3.1. <code class="function">igraph_local_scan_neighborhood_ecount</code> — Local scan-statistics with pre-calculated neighborhoods</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_local_scan_neighborhood_ecount"></a>5.3.1. <code class="function">igraph_local_scan_neighborhood_ecount</code> — Local scan-statistics with pre-calculated neighborhoods</h4></div></div></div>
<a class="indexterm" name="idp105545272955592"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_local_scan_neighborhood_ecount(const igraph_t *graph,
        igraph_vector_t *res,
        const igraph_vector_t *weights,
        const igraph_vector_ptr_t *neighborhoods);
</pre></div>
<p>
</p>
<p>



Count the number of edges, or sum the edge weigths in
neighborhoods given as a parameter.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph to perform the counting/summing in.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Initialized vector, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Weight vector for weighted graphs, null pointer for
       unweighted graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>neighborhoods</code></em>:</span></p></td>
<td><p>
  List of <code class="literal"> igraph_vector_int_t</code> 
       objects, the neighborhoods, one for each vertex in the
       graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="graph-components"></a>6. Graph Components</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_subcomponent">6.1. <code class="function">igraph_subcomponent</code> —  The vertices in the same component as a given vertex.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_clusters">6.2. <code class="function">igraph_clusters</code> —  Calculates the (weakly or strongly) connected components in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_connected">6.3. <code class="function">igraph_is_connected</code> —  Decides whether the graph is (weakly or strongly) connected.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_decompose">6.4. <code class="function">igraph_decompose</code> —  Decompose a graph into connected components.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_decompose_destroy">6.5. <code class="function">igraph_decompose_destroy</code> —  Free the memory allocated by <code class="function">igraph_decompose()</code>.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_biconnected_components">6.6. <code class="function">igraph_biconnected_components</code> — Calculate biconnected components</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_articulation_points">6.7. <code class="function">igraph_articulation_points</code> — Find the articulation points in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_bridges">6.8. <code class="function">igraph_bridges</code> — Find all bridges in a graph.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subcomponent"></a>6.1. <code class="function">igraph_subcomponent</code> —  The vertices in the same component as a given vertex.</h3></div></div></div>
<a class="indexterm" name="idp105545272838472"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_subcomponent(const igraph_t *graph, igraph_vector_t *res, igraph_real_t vertex,
                        igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result, vector with the ids of the vertices in the
       same component.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex</code></em>:</span></p></td>
<td><p>
  The id of the vertex of which the component is
       searched.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  Type of the component for directed graphs, possible
       values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the set of vertices reachable <span class="emphasis"><em>from</em></span> the
         <em class="parameter"><code>vertex</code></em>,
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the set of vertices from which the
         <em class="parameter"><code>vertex</code></em> is reachable.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the graph is considered as an
         undirected graph. Note that this is <span class="emphasis"><em>not</em></span> the same
         as the union of the previous two.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

         not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          <em class="parameter"><code>vertex</code></em> is an invalid vertex id
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument passed.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|),
|V| and
|E| are the number of vertices and
edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Operators.html#igraph_induced_subgraph" title="3.3. igraph_induced_subgraph — Creates a subgraph induced by the specified vertices."><code class="function">igraph_induced_subgraph()</code></a> if you want a graph object consisting only
a given set of vertices and the edges between them.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_clusters"></a>6.2. <code class="function">igraph_clusters</code> —  Calculates the (weakly or strongly) connected components in a graph.</h3></div></div></div>
<a class="indexterm" name="idp105545272863176"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_clusters(const igraph_t *graph, igraph_vector_t *membership,
                    igraph_vector_t *csize, igraph_integer_t *no,
                    igraph_connectedness_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>membership</code></em>:</span></p></td>
<td><p>
  First half of the result will be stored here. For
       every vertex the id of its component is given. The vector
       has to be preinitialized and will be resized. Alternatively
       this argument can be <code class="constant">NULL</code>, in which case it is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>csize</code></em>:</span></p></td>
<td><p>
  The second half of the result. For every component it
       gives its size, the order is defined by the component ids.
       The vector has to be preinitialized and will be resized.
       Alternatively this argument can be <code class="constant">NULL</code>, in which
       case it is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, if not <code class="constant">NULL</code> then the number of
       clusters will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graph this specifies whether to calculate
       weakly or strongly connected components. Possible values:
       <code class="constant">IGRAPH_WEAK</code>,
       <code class="constant">IGRAPH_STRONG</code>. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid mode argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|),
|V| and
|E| are the number of vertices and
edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_connected"></a>6.3. <code class="function">igraph_is_connected</code> —  Decides whether the graph is (weakly or strongly) connected.</h3></div></div></div>
<a class="indexterm" name="idp105545272879432"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_connected(const igraph_t *graph, igraph_bool_t *res,
                        igraph_connectedness_t mode);
</pre></div>
<p>
</p>
<p>




A graph with zero vertices (i.e. the null graph) is <span class="emphasis"><em>not</em></span> connected by
definition. This behaviour changed in igraph 0.9; earlier versions assumed
that the null graph is connected. See the following issue on Github for the
argument that led us to change the definition:
<a class="ulink" href="https://github.com/igraph/igraph/issues/1538" target="_top">https://github.com/igraph/igraph/issues/1538</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a logical variable, the result will be stored
       here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For a directed graph this specifies whether to calculate
       weak or strong connectedness. Possible values:
       <code class="constant">IGRAPH_WEAK</code>,
       <code class="constant">IGRAPH_STRONG</code>. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_EINVAL</code>: invalid mode argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the
number of vertices
plus the number of edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_decompose"></a>6.4. <code class="function">igraph_decompose</code> —  Decompose a graph into connected components.</h3></div></div></div>
<a class="indexterm" name="idp105545272892872"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_decompose(const igraph_t *graph, igraph_vector_ptr_t *components,
                     igraph_connectedness_t mode,
                     long int maxcompno, long int minelements);
</pre></div>
<p>
</p>
<p>



Create separate graph for each component of a graph. Note that the
vertex ids in the new graphs will be different than in the original
graph. (Except if there is only one component in the original graph.)

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The original graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>components</code></em>:</span></p></td>
<td><p>
  This pointer vector will contain pointers to the
  subcomponent graphs. It should be initialized before calling this
  function and will be resized to hold the graphs. Don't forget to
  call <a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object."><code class="function">igraph_destroy()</code></a> and <a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions"><code class="function">igraph_free()</code></a> on the elements of
  this pointer vector to free unneeded memory. Alternatively, you can
  simply call <a class="link" href="igraph-Structural.html#igraph_decompose_destroy" title="6.5. igraph_decompose_destroy — Free the memory allocated by igraph_decompose()."><code class="function">igraph_decompose_destroy()</code></a> that does this for you.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Either <code class="constant">IGRAPH_WEAK</code> or <code class="constant">IGRAPH_STRONG</code> for weakly
   and strongly connected components respectively.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maxcompno</code></em>:</span></p></td>
<td><p>
  The maximum number of components to return. The
   first <em class="parameter"><code>maxcompno</code></em> components will be returned (which hold at
   least <em class="parameter"><code>minelements</code></em> vertices, see the next parameter), the
   others will be ignored. Supply -1 here if you don't want to limit
   the number of components.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>minelements</code></em>:</span></p></td>
<td><p>
  The minimum number of vertices a component
   should contain in order to place it in the <em class="parameter"><code>components</code></em>
   vector. Eg. supply 2 here to ignore isolated vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, <code class="constant">IGRAPH_ENOMEM</code> if there is not enough memory
  to perform the operation.
  </p></td>
</tr></tbody>
</table></div>
<p>

Added in version 0.2.</p>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545272517448"></a><p class="title"><b>Example 13.11.  File <code class="code">examples/simple/igraph_decompose.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

void <span class="strong"><strong>free_complist</strong></span>(igraph_vector_ptr_t *complist) {
    long int i;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(complist); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*complist)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*complist)[i]);
    }
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t ring, g;
    igraph_vector_ptr_t complist;
    long int i;
    igraph_real_t edges[] = { 0, 1, 1, 2, 2, 0,
                              3, 4, 4, 5, 5, 6,
                              8, 9, 9, 10
                            };
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> v;

    <span class="emphasis"><em>/* A ring, a single component */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring, 10, IGRAPH_UNDIRECTED, 0, 1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;complist, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_decompose" title="6.4. igraph_decompose — Decompose a graph into connected components.">igraph_decompose</a></strong></span>(&amp;ring, &amp;complist, IGRAPH_WEAK, -1, 0);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(complist)[0], stdout);
    <span class="strong"><strong>free_complist</strong></span>(&amp;complist);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring);

    <span class="emphasis"><em>/* random graph with a giant component */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game" title="2.3. igraph_erdos_renyi_game — Generates a random (Erdős-Rényi) graph.">igraph_erdos_renyi_game</a></strong></span>(&amp;g, IGRAPH_ERDOS_RENYI_GNP, 100, 4.0 / 100,
                            IGRAPH_UNDIRECTED, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_decompose" title="6.4. igraph_decompose — Decompose a graph into connected components.">igraph_decompose</a></strong></span>(&amp;g, &amp;complist, IGRAPH_WEAK, -1, 20);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;complist) != 1) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>free_complist</strong></span>(&amp;complist);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* a toy graph, three components maximum, with at least 2 vertices each */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_create" title="1.1. igraph_create — Creates a graph with the specified edges.">igraph_create</a></strong></span>(&amp;g,
                  <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;v, edges, <span class="strong"><strong>sizeof</strong></span>(edges) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t)),
                  0, IGRAPH_DIRECTED);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_decompose" title="6.4. igraph_decompose — Decompose a graph into connected components.">igraph_decompose</a></strong></span>(&amp;g, &amp;complist, IGRAPH_WEAK, 3, 2);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;complist); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(complist)[i], stdout);
    }
    <span class="strong"><strong>free_complist</strong></span>(&amp;complist);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* The same graph, this time with vertex attributes */</em></span>
    <span class="emphasis"><em>/*   igraph_vector_init_seq(&amp;idvect, 0, igraph_vcount(&amp;g)-1); */</em></span>
    <span class="emphasis"><em>/*   igraph_add_vertex_attribute(&amp;g, "id", IGRAPH_ATTRIBUTE_NUM); */</em></span>
    <span class="emphasis"><em>/*   igraph_set_vertex_attributes(&amp;g, "id", IGRAPH_VS_ALL(&amp;g), &amp;idvect); */</em></span>
    <span class="emphasis"><em>/*   igraph_vector_destroy(&amp;idvect); */</em></span>

    <span class="emphasis"><em>/*   igraph_decompose(&amp;g, &amp;complist, IGRAPH_WEAK, 3, 2); */</em></span>
    <span class="emphasis"><em>/*   for (i=0; i&lt;igraph_vector_ptr_size(&amp;complist); i++) { */</em></span>
    <span class="emphasis"><em>/*     igraph_t *comp=VECTOR(complist)[i]; */</em></span>
    <span class="emphasis"><em>/*     igraph_es_t es; */</em></span>
    <span class="emphasis"><em>/*     igraph_es_all(comp, &amp;es); */</em></span>
    <span class="emphasis"><em>/*     while (!igraph_es_end(comp, &amp;es)) { */</em></span>
    <span class="emphasis"><em>/*       igraph_real_t *from, *to;  */</em></span>
    <span class="emphasis"><em>/*       igraph_get_vertex_attribute(comp, "id", igraph_es_from(comp, &amp;es), */</em></span>
    <span class="emphasis"><em>/*                (void**) &amp;from, 0); */</em></span>
    <span class="emphasis"><em>/*       igraph_get_vertex_attribute(comp, "id", igraph_es_to(comp, &amp;es), */</em></span>
    <span class="emphasis"><em>/*                (void**) &amp;to, 0); */</em></span>
    <span class="emphasis"><em>/*       printf("%li %li\n", (long int) *from, (long int) *to); */</em></span>
    <span class="emphasis"><em>/*       igraph_es_next(comp, &amp;es); */</em></span>
    <span class="emphasis"><em>/*     } */</em></span>
    <span class="emphasis"><em>/*   } */</em></span>

    <span class="emphasis"><em>/*   free_complist(&amp;complist); */</em></span>
    <span class="emphasis"><em>/*   igraph_destroy(&amp;g);   */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;complist);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_decompose_destroy"></a>6.5. <code class="function">igraph_decompose_destroy</code> —  Free the memory allocated by <a class="link" href="igraph-Structural.html#igraph_decompose" title="6.4. igraph_decompose — Decompose a graph into connected components."><code class="function">igraph_decompose()</code></a>.</h3></div></div></div>
<a class="indexterm" name="idp105545272563656"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_decompose_destroy(igraph_vector_ptr_t *complist);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>complist</code></em>:</span></p></td>
<td><p>
  The list of graph components, as returned by
       <a class="link" href="igraph-Structural.html#igraph_decompose" title="6.4. igraph_decompose — Decompose a graph into connected components."><code class="function">igraph_decompose()</code></a>.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(c), c is the number of components.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_biconnected_components"></a>6.6. <code class="function">igraph_biconnected_components</code> — Calculate biconnected components</h3></div></div></div>
<a class="indexterm" name="idp105545272439496"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_biconnected_components(const igraph_t *graph,
                                  igraph_integer_t *no,
                                  igraph_vector_ptr_t *tree_edges,
                                  igraph_vector_ptr_t *component_edges,
                                  igraph_vector_ptr_t *components,
                                  igraph_vector_t *articulation_points);
</pre></div>
<p>
</p>
<p>



A graph is biconnected if the removal of any single vertex (and
its incident edges) does not disconnect it.

</p>
<p>
A biconnected component of a graph is a maximal biconnected
subgraph of it. The biconnected components of a graph can be given
by the partition of its edges: every edge is a member of exactly
one biconnected component. Note that this is not true for
vertices: the same vertex can be part of many biconnected
components.

</p>
<p>
Somewhat arbitrarily, igraph does not consider components containing
a single vertex only as being biconnected. Isolated vertices will
not be part of any of the biconnected components.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no</code></em>:</span></p></td>
<td><p>
  The number of biconnected components will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>tree_edges</code></em>:</span></p></td>
<td><p>
  If not a NULL pointer, then the found components
    are stored here, in a list of vectors. Every vector in the list
    is a biconnected component, represented by its edges. More precisely,
    a spanning tree of the biconnected component is returned.
    Note you'll have to
    destroy each vector first by calling <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a>
    and then <a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions"><code class="function">igraph_free()</code></a> on it, plus you need to call
    <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector."><code class="function">igraph_vector_ptr_destroy()</code></a> on the list to regain all
    allocated memory.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>component_edges</code></em>:</span></p></td>
<td><p>
  If not a NULL pointer, then the edges of the
    biconnected components are stored here, in the same form as for
    <code class="constant">tree_edges</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>components</code></em>:</span></p></td>
<td><p>
  If not a NULL pointer, then the vertices of the
    biconnected components are stored here, in the same format as
    for the previous two arguments.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>articulation_points</code></em>:</span></p></td>
<td><p>
  If not a NULL pointer, then the
    articulation points of the graph are stored in this vector.
    A vertex is an articulation point if its removal increases the
    number of (weakly) connected components in the graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges, but only if you do not calculate <code class="constant">components</code> and
<code class="constant">component_edges</code>. If you calculate <code class="constant">components</code>, then it is
quadratic in the number of vertices. If you calculate <code class="constant">component_edges</code> as well, then it is cubic in the number of
vertices.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_articulation_points" title="6.7. igraph_articulation_points — Find the articulation points in a graph."><code class="function">igraph_articulation_points()</code></a>, <a class="link" href="igraph-Structural.html#igraph_clusters" title="6.2. igraph_clusters — Calculates the (weakly or strongly) connected components in a graph."><code class="function">igraph_clusters()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545272462152"></a><p class="title"><b>Example 13.12.  File <code class="code">examples/simple/igraph_biconnected_components.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

void <span class="strong"><strong>sort_and_print_vector</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v) {
    long int i, n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(v);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_sort" title="2.14.1. igraph_vector_sort — Sorts the elements of the vector into ascending order.">igraph_vector_sort</a></strong></span>(v);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>printf</strong></span>(" %li", (long int) <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i]);
    }
    <span class="strong"><strong>printf</strong></span>("\n");
}

void <span class="strong"><strong>warning_handler_ignore</strong></span>(<span class="strong"><strong>const</strong></span> char* reason, <span class="strong"><strong>const</strong></span> char* file, int line, int e) {
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_vector_ptr_t result;
    igraph_integer_t no;
    long int i;

    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_warning_handler" title="4.2. igraph_set_warning_handler — Installs a warning handler.">igraph_set_warning_handler</a></strong></span>(warning_handler_ignore);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;result, 0);
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 7, 0, 0, 1, 1, 2, 2, 3, 3, 0, 2, 4, 4, 5, 2, 5, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_biconnected_components" title="6.6. igraph_biconnected_components — Calculate biconnected components">igraph_biconnected_components</a></strong></span>(&amp;g, &amp;no, 0, 0, &amp;result, 0);
    <span class="strong"><strong>if</strong></span> (no != 2 || no != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;result)) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; no; i++) {
        <span class="strong"><strong>sort_and_print_vector</strong></span>((<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(result)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>((<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(result)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>((<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(result)[i]);
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_biconnected_components" title="6.6. igraph_biconnected_components — Calculate biconnected components">igraph_biconnected_components</a></strong></span>(&amp;g, &amp;no, 0, &amp;result, 0, 0);
    <span class="strong"><strong>if</strong></span> (no != 2 || no != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;result)) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; no; i++) {
        <span class="strong"><strong>sort_and_print_vector</strong></span>((<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(result)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>((<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(result)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>((<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(result)[i]);
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_biconnected_components" title="6.6. igraph_biconnected_components — Calculate biconnected components">igraph_biconnected_components</a></strong></span>(&amp;g, &amp;no, &amp;result, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (no != 2 || no != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;result)) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; no; i++) {
        <span class="strong"><strong>sort_and_print_vector</strong></span>((<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(result)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>((<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(result)[i]);
        <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>((<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(result)[i]);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_articulation_points"></a>6.7. <code class="function">igraph_articulation_points</code> — Find the articulation points in a graph.</h3></div></div></div>
<a class="indexterm" name="idp105545272642888"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_articulation_points(const igraph_t *graph,
                               igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>



A vertex is an articulation point if its removal increases
the number of connected components in the graph.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the
   articulation points will be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_biconnected_components" title="6.6. igraph_biconnected_components — Calculate biconnected components"><code class="function">igraph_biconnected_components()</code></a>, <a class="link" href="igraph-Structural.html#igraph_clusters" title="6.2. igraph_clusters — Calculates the (weakly or strongly) connected components in a graph."><code class="function">igraph_clusters()</code></a>, <a class="link" href="igraph-Structural.html#igraph_bridges" title="6.8. igraph_bridges — Find all bridges in a graph."><code class="function">igraph_bridges()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bridges"></a>6.8. <code class="function">igraph_bridges</code> — Find all bridges in a graph.</h3></div></div></div>
<a class="indexterm" name="idp105545272657224"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_bridges(const igraph_t *graph, igraph_vector_t *bridges);
</pre></div>
<p>
</p>
<p>



An edge is a bridge if its removal increases the number of (weakly)
connected components in the graph.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the
   bridges will be stored here as edge indices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_articulation_points" title="6.7. igraph_articulation_points — Find the articulation points in a graph."><code class="function">igraph_articulation_points()</code></a>, <a class="link" href="igraph-Structural.html#igraph_biconnected_components" title="6.6. igraph_biconnected_components — Calculate biconnected components"><code class="function">igraph_biconnected_components()</code></a>, <a class="link" href="igraph-Structural.html#igraph_clusters" title="6.2. igraph_clusters — Calculates the (weakly or strongly) connected components in a graph."><code class="function">igraph_clusters()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="degree-sequences"></a>7. Degree Sequences</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_graphical">7.1. <code class="function">igraph_is_graphical</code> —  Is there a graph with the given degree sequence?</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_bigraphical">7.2. <code class="function">igraph_is_bigraphical</code> —  Is there a bipartite graph with the given bi-degree-sequence?</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_degree_sequence">7.3. <code class="function">igraph_is_degree_sequence</code> —  Determines whether a degree sequence is valid.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_graphical_degree_sequence">7.4. <code class="function">igraph_is_graphical_degree_sequence</code> —  Determines whether a sequence of integers can be the degree sequence of some simple graph.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_graphical"></a>7.1. <code class="function">igraph_is_graphical</code> —  Is there a graph with the given degree sequence?</h3></div></div></div>
<a class="indexterm" name="idp105545272672200"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_graphical(const igraph_vector_t *out_degrees,
                        const igraph_vector_t *in_degrees,
                        const igraph_edge_type_sw_t allowed_edge_types,
                        igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>



Determines whether a sequence of integers can be the degree sequence of some graph.
The classical concept of graphicality assumes simple graphs. This function can perform
the check also when either self-loops, multi-edge, or both are allowed in the graph.

</p>
<p>
For simple undirected graphs, the Erdős-Gallai conditions are checked using the linear-time
algorithm of Cloteaux. If both self-loops and multi-edges are allowed,
it is sufficient to chek that that sum of degrees is even. If only multi-edges are allowed, but
not self-loops, there is an additional condition that the sum of degrees be no smaller than twice
the maximum degree. If at most one self-loop is allowed per vertex, but no multi-edges, a modified
version of the Erdős-Gallai conditions are used (see Cairns &amp; Mendan).

</p>
<p>
For simple directed graphs, the Fulkerson-Chen-Anstee theorem is used with the relaxation by Berger.
If both self-loops and multi-edges are allowed, then it is sufficient to check that the sum of
in- and out-degrees is the same. If only multi-edges are allowed, but not self loops, there is an
additional condition that the sum of out-degrees (or equivalently, in-degrees) is no smaller than
the maximum total degree. If single self-loops are allowed, but not multi-edges, the problem is equivalent
to realizability as a simple bipartite graph, thus the Gale-Ryser theorem can be used; see
<a class="link" href="igraph-Structural.html#igraph_is_bigraphical" title="7.2. igraph_is_bigraphical — Is there a bipartite graph with the given bi-degree-sequence?"><code class="function">igraph_is_bigraphical()</code></a> for more information.

</p>
<p>
References:

</p>
<p>
P. Erdős and T. Gallai, Gráfok előírt fokú pontokkal, Matematikai Lapok 11, pp. 264–274 (1960).
<a class="ulink" href="https://users.renyi.hu/~p_erdos/1961-05.pdf" target="_top">https://users.renyi.hu/~p_erdos/1961-05.pdf</a>

</p>
<p>
Z Király, Recognizing graphic degree sequences and generating all realizations.
TR-2011-11, Egerváry Research Group, H-1117, Budapest, Hungary. ISSN 1587-4451 (2012).
<a class="ulink" href="http://bolyai.cs.elte.hu/egres/tr/egres-11-11.pdf" target="_top">http://bolyai.cs.elte.hu/egres/tr/egres-11-11.pdf</a>

</p>
<p>
B. Cloteaux, Is This for Real? Fast Graphicality Testing, Comput. Sci. Eng. 17, 91 (2015).
<a class="ulink" href="https://dx.doi.org/10.1109/MCSE.2015.125" target="_top">https://dx.doi.org/10.1109/MCSE.2015.125</a>

</p>
<p>
A. Berger, A note on the characterization of digraphic sequences, Discrete Math. 314, 38 (2014).
<a class="ulink" href="https://dx.doi.org/10.1016/j.disc.2013.09.010" target="_top">https://dx.doi.org/10.1016/j.disc.2013.09.010</a>

</p>
<p>
G. Cairns and S. Mendan, Degree Sequence for Graphs with Loops (2013).
<a class="ulink" href="https://arxiv.org/abs/1303.2145v1" target="_top">https://arxiv.org/abs/1303.2145v1</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>out_degrees</code></em>:</span></p></td>
<td><p>
  A vector of integers specifying the degree sequence for
    undirected graphs or the out-degree sequence for directed graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>in_degrees</code></em>:</span></p></td>
<td><p>
  A vector of integers specifying the in-degree sequence for
    directed graphs. For undirected graphs, it must be <code class="constant">NULL</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>allowed_edge_types</code></em>:</span></p></td>
<td>
<p>
  The types of edges to allow in the graph:
    </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_SIMPLE_SW</code></span></p></td>
<td><p>

      simple graphs (i.e. no self-loops or multi-edges allowed).
    
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LOOPS_SW</code></span></p></td>
<td><p>

      single self-loops are allowed, but not multi-edges.
    
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_MULTI_SW</code></span></p></td>
<td><p>

      multi-edges are allowed, but not self-loops.
    
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LOOPS_SW | IGRAPH_MULTI_SW</code></span></p></td>
<td><p>

      both self-loops and multi-edges are allowed.
    
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a Boolean. The result will be stored here.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_bigraphical" title="7.2. igraph_is_bigraphical — Is there a bipartite graph with the given bi-degree-sequence?"><code class="function">igraph_is_bigraphical()</code></a> to check if a bi-degree-sequence can be realized as a bipartite graph;
<a class="link" href="igraph-Generators.html#igraph_realize_degree_sequence" title="1.12. igraph_realize_degree_sequence — Generates a graph with the given degree sequence."><code class="function">igraph_realize_degree_sequence()</code></a> to construct a graph with a given degree sequence.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n^2) for simple directed graphs, O(n log n) for graphs with self-loops,
and O(n) for all other cases, where n is the length of the degree sequence(s).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_bigraphical"></a>7.2. <code class="function">igraph_is_bigraphical</code> —  Is there a bipartite graph with the given bi-degree-sequence?</h3></div></div></div>
<a class="indexterm" name="idp105545272698824"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_bigraphical(const igraph_vector_t *degrees1,
                          const igraph_vector_t *degrees2,
                          const igraph_edge_type_sw_t allowed_edge_types,
                          igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>



Determines whether two sequences of integers can be the degree sequences of
a bipartite graph. Such a pair of degree sequence is called <span class="emphasis"><em>bigraphical.</em></span>

</p>
<p>
When multi-edges are allowed, it is sufficient to check that the sum of degrees is the
same in the two partitions. For simple graphs, the Gale-Ryser theorem is used
with Berger's relaxation.

</p>
<p>
References:

</p>
<p>
H. J. Ryser, Combinatorial Properties of Matrices of Zeros and Ones, Can. J. Math. 9, 371 (1957).
<a class="ulink" href="https://dx.doi.org/10.4153/cjm-1957-044-3" target="_top">https://dx.doi.org/10.4153/cjm-1957-044-3</a>

</p>
<p>
D. Gale, A theorem on flows in networks, Pacific J. Math. 7, 1073 (1957).
<a class="ulink" href="https://dx.doi.org/10.2140/pjm.1957.7.1073" target="_top">https://dx.doi.org/10.2140/pjm.1957.7.1073</a>

</p>
<p>
A. Berger, A note on the characterization of digraphic sequences, Discrete Math. 314, 38 (2014).
<a class="ulink" href="https://dx.doi.org/10.1016/j.disc.2013.09.010" target="_top">https://dx.doi.org/10.1016/j.disc.2013.09.010</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>degrees1</code></em>:</span></p></td>
<td><p>
  A vector of integers specifying the degrees in the first partition
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>degrees2</code></em>:</span></p></td>
<td><p>
  A vector of integers specifying the degrees in the second partition
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>allowed_edge_types</code></em>:</span></p></td>
<td>
<p>
  The types of edges to allow in the graph:
    </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_SIMPLE_SW</code></span></p></td>
<td><p>

      simple graphs (i.e. no multi-edges allowed).
    
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_MULTI_SW</code></span></p></td>
<td><p>

      multi-edges are allowed.
    
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a Boolean. The result will be stored here.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_graphical" title="7.1. igraph_is_graphical — Is there a graph with the given degree sequence?"><code class="function">igraph_is_graphical()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n log n) for simple graphs, O(n) for multigraphs,
where n is the length of the larger degree sequence.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_degree_sequence"></a>7.3. <code class="function">igraph_is_degree_sequence</code> —  Determines whether a degree sequence is valid.</h3></div></div></div>
<a class="indexterm" name="idp105545272589000"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_degree_sequence(const igraph_vector_t *out_degrees,
                              const igraph_vector_t *in_degrees, igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.9. Please do not use this function in new
code; use <a class="link" href="igraph-Structural.html#igraph_is_graphical" title="7.1. igraph_is_graphical — Is there a graph with the given degree sequence?"><code class="function">igraph_is_graphical()</code></a>
instead.</p>
</div>
<p>
</p>
<p>
A sequence of n integers is a valid degree sequence if there exists some
graph where the degree of the i-th vertex is equal to the i-th element of the
sequence. Note that the graph may contain multiple or loop edges; if you are
interested in whether the degrees of some <span class="emphasis"><em>simple</em></span> graph may realize the
given sequence, use <a class="link" href="igraph-Structural.html#igraph_is_graphical_degree_sequence" title="7.4. igraph_is_graphical_degree_sequence — Determines whether a sequence of integers can be the degree sequence of some simple graph."><code class="function">igraph_is_graphical_degree_sequence</code></a>.

</p>
<p>
In particular, the function checks whether all the degrees are non-negative.
For undirected graphs, it also checks whether the sum of degrees is even.
For directed graphs, the function checks whether the lengths of the two
degree vectors are equal and whether their sums are also equal. These are
known sufficient and necessary conditions for a degree sequence to be
valid.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>out_degrees</code></em>:</span></p></td>
<td><p>
  an integer vector specifying the degree sequence for
    undirected graphs or the out-degree sequence for directed graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>in_degrees</code></em>:</span></p></td>
<td><p>
  an integer vector specifying the in-degrees of the
    vertices for directed graphs. For undirected graphs, this must be null.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  pointer to a boolean variable, the result will be stored here
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), where n is the length of the degree sequence.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_graphical_degree_sequence"></a>7.4. <code class="function">igraph_is_graphical_degree_sequence</code> —  Determines whether a sequence of integers can be the degree sequence of some simple graph.</h3></div></div></div>
<a class="indexterm" name="idp105545272603848"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_graphical_degree_sequence(const igraph_vector_t *out_degrees,
                                        const igraph_vector_t *in_degrees, igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.9. Please do not use this function in new
code; use <a class="link" href="igraph-Structural.html#igraph_is_graphical" title="7.1. igraph_is_graphical — Is there a graph with the given degree sequence?"><code class="function">igraph_is_graphical()</code></a>
instead.</p>
</div>
<p>
</p>
<p>
References:

</p>
<p>
Hakimi SL: On the realizability of a set of integers as degrees of the
vertices of a simple graph. J SIAM Appl Math 10:496-506, 1962.

</p>
<p>
PL Erdős, I Miklós and Z Toroczkai: A simple Havel-Hakimi type algorithm
to realize graphical degree sequences of directed graphs.
The Electronic Journal of Combinatorics 17(1):R66, 2010.
<a class="ulink" href="https://dx.doi.org/10.1017/S0963548317000499" target="_top">https://dx.doi.org/10.1017/S0963548317000499</a>

</p>
<p>
Z Kiraly: Recognizing graphic degree sequences and generating all
realizations. TR-2011-11, Egervary Research Group, H-1117, Budapest,
Hungary. ISSN 1587-4451, 2012.
<a class="ulink" href="https://www.cs.elte.hu/egres/tr/egres-11-11.pdf" target="_top">https://www.cs.elte.hu/egres/tr/egres-11-11.pdf</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>out_degrees</code></em>:</span></p></td>
<td><p>
  an integer vector specifying the degree sequence for
    undirected graphs or the out-degree sequence for directed graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>in_degrees</code></em>:</span></p></td>
<td><p>
  an integer vector specifying the in-degrees of the
    vertices for directed graphs. For undirected graphs, this must be null.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  pointer to a boolean variable, the result will be stored here
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n log n) for undirected graphs, O(n^2) for directed
                 graphs, where n is the length of the degree sequence.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="centrality-measures"></a>8. Centrality Measures</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_closeness">8.1. <code class="function">igraph_closeness</code> —  Closeness centrality calculations for some vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_harmonic_centrality">8.2. <code class="function">igraph_harmonic_centrality</code> —  Harmonic centrality for some vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_betweenness">8.3. <code class="function">igraph_betweenness</code> —  Betweenness centrality of some vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_edge_betweenness">8.4. <code class="function">igraph_edge_betweenness</code> —  Betweenness centrality of the edges.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_pagerank_algo_t">8.5. <code class="function">igraph_pagerank_algo_t</code> —  PageRank algorithm implementation</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_pagerank">8.6. <code class="function">igraph_pagerank</code> —  Calculates the Google PageRank for the specified vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_personalized_pagerank">8.7. <code class="function">igraph_personalized_pagerank</code> —  Calculates the personalized Google PageRank for the specified vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_personalized_pagerank_vs">8.8. <code class="function">igraph_personalized_pagerank_vs</code> —  Calculates the personalized Google PageRank for the specified vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_constraint">8.9. <code class="function">igraph_constraint</code> —  Burt's constraint scores.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_maxdegree">8.10. <code class="function">igraph_maxdegree</code> —  The maximum degree in a graph (or set of vertices).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_strength">8.11. <code class="function">igraph_strength</code> — Strength of the vertices, weighted vertex degree in other words.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_eigenvector_centrality">8.12. <code class="function">igraph_eigenvector_centrality</code> — Eigenvector centrality of the vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_hub_score">8.13. <code class="function">igraph_hub_score</code> — Kleinberg's hub scores</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_authority_score">8.14. <code class="function">igraph_authority_score</code> — Kleinerg's authority scores</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_closeness"></a>8.1. <code class="function">igraph_closeness</code> —  Closeness centrality calculations for some vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545272619848"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_closeness(const igraph_t *graph, igraph_vector_t *res,
                     igraph_vector_t *reachable_count, igraph_bool_t *all_reachable,
                     const igraph_vs_t vids, igraph_neimode_t mode,
                     const igraph_vector_t *weights,
                     igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The closeness centrality of a vertex measures how easily other
vertices can be reached from it (or the other way: how easily it
can be reached from the other vertices). It is defined as
the inverse of the mean distance to (or from) all other vertices.

</p>
<p>
Closeness centrality is meaningful only for connected graphs.
If the graph is not connected, igraph computes the inverse of the
mean distance to (or from) all <span class="emphasis"><em>reachable</em></span> vertices. In undirected
graphs, this is equivalent to computing the closeness separately in
each connected component. The optional <em class="parameter"><code>all_reachable</code></em> output
parameter is provided to help detect when the graph is disconnected.

</p>
<p>
While there is no universally adopted definition of closeness centrality
for disconnected graphs, there have been some attempts for generalizing
the concept to the disconnected case. One type of approach considers the mean distance
only to reachable vertices, then re-scales the obtained certrality score
by a factor that depends on the number of reachable vertices
(i.e. the size of the component in the undirected case).
To facilitate computing these generalizations of closeness centrality,
the number of reachable vertices (not including the starting vertex)
is returned in <em class="parameter"><code>reachable_count</code></em>.

</p>
<p>
In disconnected graphs, consider using the harmonic centrality,
computable using <a class="link" href="igraph-Structural.html#igraph_harmonic_centrality" title="8.2. igraph_harmonic_centrality — Harmonic centrality for some vertices."><code class="function">igraph_harmonic_centrality()</code></a>.

</p>
<p>
For isolated vertices, i.e. those having no associated paths, NaN is returned.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
       closeness centrality scores for the given vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>reachable_count</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code>, this vector will contain the number of
       vertices reachable from each vertex for which the closeness is calculated
       (not including that vertex).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>all_reachable</code></em>:</span></p></td>
<td><p>
  Pointer to a Boolean. If not <code class="constant">NULL</code>, it indicates if all
       vertices of the graph were reachable from each vertex in <em class="parameter"><code>vids</code></em>.
       If false, the graph is non-connected If true, and the graph is undirected,
       or if the graph is directed and <em class="parameter"><code>vids</code></em> contains all vertices, then the
       graph is connected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the closeness centrality will be computed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the lengths of the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the lengths of the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       weighted closeness. No edge weight may be NaN. Supply a null
       pointer here for traditional, unweighted closeness.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  If true, the inverse of the mean distance to reachable
       vetices is returned. If false, the inverse of the sum of distances
       is returned.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex id passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n|E|),
n is the number
of vertices for which the calculation is done and
|E| is the number
of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Other centrality types: <a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a>, <a class="link" href="igraph-Structural.html#igraph_betweenness" title="8.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a>,
  <a class="link" href="igraph-Structural.html#igraph_harmonic_centrality" title="8.2. igraph_harmonic_centrality — Harmonic centrality for some vertices."><code class="function">igraph_harmonic_centrality()</code></a>.
  See <a class="link" href="igraph-Structural.html#igraph_closeness_cutoff" title="9.1. igraph_closeness_cutoff — Range limited closeness centrality."><code class="function">igraph_closeness_cutoff()</code></a> for the range-limited closeness centrality.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_harmonic_centrality"></a>8.2. <code class="function">igraph_harmonic_centrality</code> —  Harmonic centrality for some vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545272262600"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_harmonic_centrality(const igraph_t *graph, igraph_vector_t *res,
                               const igraph_vs_t vids, igraph_neimode_t mode,
                               const igraph_vector_t *weights,
                               igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The harmonic centrality of a vertex is the mean inverse distance to
all other vertices. The inverse distance to an unreachable vertex
is considered to be zero.

</p>
<p>
References:

</p>
<p>
M. Marchiori and V. Latora, Harmony in the small-world, Physica A 285, pp. 539-546 (2000).
<a class="ulink" href="https://doi.org/10.1016/S0378-4371%2800%2900311-3" target="_top">https://doi.org/10.1016/S0378-4371%2800%2900311-3</a>

</p>
<p>
Y. Rochat, Closeness Centrality Extended to Unconnected Graphs: the Harmonic Centrality Index, ASNA 2009.
<a class="ulink" href="https://infoscience.epfl.ch/record/200525" target="_top">https://infoscience.epfl.ch/record/200525</a>

</p>
<p>
S. Vigna and P. Boldi, Axioms for Centrality, Internet Mathematics 10, (2014).
<a class="ulink" href="https://doi.org/10.1080/15427951.2013.865686" target="_top">https://doi.org/10.1080/15427951.2013.865686</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
       harmonic centrality scores for the given vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the harmonic centrality will be computed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the lengths of the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the lengths of the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       weighted harmonic centrality. No edge weight may be NaN.
       If <code class="constant">NULL</code>, all weights are considered to be one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to normalize the result. If true,
       the result is the mean inverse path length to other vertices,
       i.e. it is normalized by the number of vertices minus one.
       If false, the result is the sum of inverse path lengths to other
       vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex id passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n|E|), where
n is the numberof vertices for which the calculation is done and
|E| is the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Other centrality types: <a class="link" href="igraph-Structural.html#igraph_closeness" title="8.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a>, <a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a>, <a class="link" href="igraph-Structural.html#igraph_betweenness" title="8.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_betweenness"></a>8.3. <code class="function">igraph_betweenness</code> —  Betweenness centrality of some vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545272292936"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_betweenness(const igraph_t *graph, igraph_vector_t *res,
                       const igraph_vs_t vids, igraph_bool_t directed,
                       const igraph_vector_t* weights);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The betweenness centrality of a vertex is the number of geodesics
going through it. If there are more than one geodesic between two
vertices, the value of these geodesics are weighted by one over the
number of geodesics.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
       betweenness scores for the specified vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices of which the betweenness centrality scores
       will be calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, if true directed paths will be considered
       for directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       calculating weighted betweenness. No edge weight may be NaN.
       Supply a null pointer here for unweighted betweenness.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
       temporary data.
       <code class="constant">IGRAPH_EINVVID</code>, invalid vertex id passed in
       <em class="parameter"><code>vids</code></em>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|),
|V| and
|E| are the number of vertices and
edges in the graph.
Note that the time complexity is independent of the number of
vertices for which the score is calculated.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Other centrality types: <a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a>, <a class="link" href="igraph-Structural.html#igraph_closeness" title="8.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a>.
    See <a class="link" href="igraph-Structural.html#igraph_edge_betweenness" title="8.4. igraph_edge_betweenness — Betweenness centrality of the edges."><code class="function">igraph_edge_betweenness()</code></a> for calculating the betweenness score
    of the edges in a graph. See <a class="link" href="igraph-Structural.html#igraph_betweenness_cutoff" title="9.3. igraph_betweenness_cutoff — Range-limited betweenness centrality."><code class="function">igraph_betweenness_cutoff()</code></a> to
    calculate the range-limited betweenness of the vertices in a graph.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_edge_betweenness"></a>8.4. <code class="function">igraph_edge_betweenness</code> —  Betweenness centrality of the edges.</h3></div></div></div>
<a class="indexterm" name="idp105545272182856"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_edge_betweenness(const igraph_t *graph, igraph_vector_t *result,
                            igraph_bool_t directed,
                            const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The betweenness centrality of an edge is the number of geodesics
going through it. If there are more than one geodesics between two
vertices, the value of these geodesics are weighted by one over the
number of geodesics.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  The result of the computation, vector containing the
       betweenness scores for the edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, if true directed paths will be considered
       for directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional weight vector for weighted edge
       betweenness. No edge weight may be NaN. Supply a null
       pointer here for the unweighted version.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
       temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|),
|V| and
|E| are the number of vertices and
edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Other centrality types: <a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a>, <a class="link" href="igraph-Structural.html#igraph_closeness" title="8.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a>.
    See <a class="link" href="igraph-Structural.html#igraph_edge_betweenness" title="8.4. igraph_edge_betweenness — Betweenness centrality of the edges."><code class="function">igraph_edge_betweenness()</code></a> for calculating the betweenness score
    of the edges in a graph. See <a class="link" href="igraph-Structural.html#igraph_edge_betweenness_cutoff" title="9.4. igraph_edge_betweenness_cutoff — Range-limited betweenness centrality of the edges."><code class="function">igraph_edge_betweenness_cutoff()</code></a> to
    compute the range-limited betweenness score of the edges in a graph.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_pagerank_algo_t"></a>8.5. <code class="function">igraph_pagerank_algo_t</code> —  PageRank algorithm implementation</h3></div></div></div>
<a class="indexterm" name="idp105545272201288"></a><p>
</p>
<pre class="programlisting">
typedef enum {
    IGRAPH_PAGERANK_ALGO_ARPACK = 1,
    IGRAPH_PAGERANK_ALGO_PRPACK = 2
} igraph_pagerank_algo_t;
</pre>
<p>
</p>
<p>


Algorithms to calculate PageRank.
</p>
<p><b>Values: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_PAGERANK_ALGO_ARPACK</code>:</span></p></td>
<td><p>
  Use the ARPACK library, this
  was the PageRank implementation in igraph from version 0.5, until
  version 0.7.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_PAGERANK_ALGO_PRPACK</code>:</span></p></td>
<td><p>
  Use the PRPACK
  library. Currently this implementation is recommended.</p></td>
</tr>
</tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_pagerank"></a>8.6. <code class="function">igraph_pagerank</code> —  Calculates the Google PageRank for the specified vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545272208712"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_pagerank(const igraph_t *graph, igraph_pagerank_algo_t algo,
                    igraph_vector_t *vector,
                    igraph_real_t *value, const igraph_vs_t vids,
                    igraph_bool_t directed, igraph_real_t damping,
                    const igraph_vector_t *weights, igraph_arpack_options_t *options);
</pre></div>
<p>
</p>
<p>



The PageRank centrality of a vertex is the fraction of time a
random walker traversing the graph would spend on that vertex.
The walker follows the out-edges with probabilities proportional
to their weights. Additionally, in each step, it restarts the walk
from a random vertex with probability <code class="literal"> 1 - damping</code> .
If the random walker gets stuck in a sink vertex, it will also restart
from a random vertex.

</p>
<p>
The PageRank centrality is mainly useful for directed graphs. In undirected
graphs it converges to trivial values proportional to degrees as the damping
factor approaches 1.

</p>
<p>
Starting from version 0.9, igraph has two PageRank implementations,
and the user can choose between them. The first implementation is
<code class="constant">IGRAPH_PAGERANK_ALGO_ARPACK</code>, based on the ARPACK library. This
was the default before igraph version 0.7. The second and recommended
implementation is <code class="constant">IGRAPH_PAGERANK_ALGO_PRPACK</code>. This is using the
PRPACK package, see <a class="ulink" href="https://github.com/dgleich/prpack" target="_top">https://github.com/dgleich/prpack</a> .

</p>
<p>
Note that the PageRank of a given vertex depends on the PageRank
of all other vertices, so even if you want to calculate the PageRank for
only some of the vertices, all of them must be calculated. Requesting
the PageRank for only some of the vertices does not result in any
performance increase at all.

</p>
<p>
References:

</p>
<p>
Sergey Brin and Larry Page: The Anatomy of a Large-Scale Hypertextual
Web Search Engine. Proceedings of the 7th World-Wide Web Conference,
Brisbane, Australia, April 1998.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td><p>
  The PageRank implementation to use. Possible values:
   <code class="constant">IGRAPH_PAGERANK_ALGO_ARPACK</code>, <code class="constant">IGRAPH_PAGERANK_ALGO_PRPACK</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is
   stored here. It is resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the eigenvalue
   corresponding to the PageRank vector is stored here. It should
   be always exactly one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex ids for which the PageRank is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider the directedness of
   the edges. This is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>damping</code></em>:</span></p></td>
<td><p>
  The damping factor ("d" in the original paper).
   Must be a probability in the range [0, 1]. A commonly used value is 0.85.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Optional edge weights. May be a <code class="constant">NULL</code> pointer,
   meaning unweighted edges, or a vector of non-negative values
   of the same length as the number of edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options for the ARPACK method. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Note that the function overwrites the <code class="literal"> n</code>  (number
   of vertices), <code class="literal"> nev</code>  (1), <code class="literal"> ncv</code>  (3) and <code class="literal"> which</code> 
   (LM) parameters and it always starts the calculation from a non-random vector
   calculated based on the degree of the vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for temporary data.
        <code class="constant">IGRAPH_EINVVID</code>, invalid vertex id in <em class="parameter"><code>vids</code></em>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the input graph, usually it is O(|E|),
the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_personalized_pagerank" title="8.7. igraph_personalized_pagerank — Calculates the personalized Google PageRank for the specified vertices."><code class="function">igraph_personalized_pagerank()</code></a> and <a class="link" href="igraph-Structural.html#igraph_personalized_pagerank_vs" title="8.8. igraph_personalized_pagerank_vs — Calculates the personalized Google PageRank for the specified vertices."><code class="function">igraph_personalized_pagerank_vs()</code></a>
for the personalized PageRank measure. See <a class="link" href="igraph-Arpack.html#igraph_arpack_rssolve" title="3.2.1. igraph_arpack_rssolve — ARPACK solver for symmetric matrices"><code class="function">igraph_arpack_rssolve()</code></a> and
<a class="link" href="igraph-Arpack.html#igraph_arpack_rnsolve" title="3.2.2. igraph_arpack_rnsolve — ARPACK solver for non-symmetric matrices"><code class="function">igraph_arpack_rnsolve()</code></a> for the underlying machinery used by
<code class="constant">IGRAPH_PAGERANK_ALGO_ARPACK</code>.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545272372168"></a><p class="title"><b>Example 13.13.  File <code class="code">examples/simple/igraph_pagerank.c</code></b></p>
<div class="example-contents">
<pre class="programlisting">
<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;float.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pagerank;
    igraph_real_t value;

    <span class="emphasis"><em>/* Create a directed graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_kautz" title="1.19. igraph_kautz — Generate a Kautz graph.">igraph_kautz</a></strong></span>(&amp;graph, 2, 3);

    <span class="emphasis"><em>/* Initialize the vector where the results will be stored */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pagerank, 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_pagerank" title="8.6. igraph_pagerank — Calculates the Google PageRank for the specified vertices.">igraph_pagerank</a></strong></span>(&amp;graph, IGRAPH_PAGERANK_ALGO_PRPACK,
                    &amp;pagerank, &amp;value,
                    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_DIRECTED,
                    <span class="emphasis"><em>/* damping */</em></span> 0.85, <span class="emphasis"><em>/* weights */</em></span> NULL,
                    NULL <span class="emphasis"><em>/* not needed with PRPACK method */</em></span>);

    <span class="emphasis"><em>/* Check that the eigenvalue is 1, as expected. */</em></span>
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(value - 1.0) &gt; 32*DBL_EPSILON) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "PageRank failed to converge.\n");
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="emphasis"><em>/* Output the result */</em></span>
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;pagerank);

    <span class="emphasis"><em>/* Destroy data structure when no longer needed */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pagerank);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_personalized_pagerank"></a>8.7. <code class="function">igraph_personalized_pagerank</code> —  Calculates the personalized Google PageRank for the specified vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545272388680"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_personalized_pagerank(const igraph_t *graph,
                                 igraph_pagerank_algo_t algo, igraph_vector_t *vector,
                                 igraph_real_t *value, const igraph_vs_t vids,
                                 igraph_bool_t directed, igraph_real_t damping,
                                 const igraph_vector_t *reset,
                                 const igraph_vector_t *weights,
                                 igraph_arpack_options_t *options);
</pre></div>
<p>
</p>
<p>



The personalized PageRank is similar to the original PageRank measure, but
when the random walk is restarted, a new starting vertex is chosen non-uniformly,
according to the distribution specified in <em class="parameter"><code>reset</code></em>
(instead of the uniform distribution in the original PageRank measure).
The <em class="parameter"><code>reset</code></em> distribution is used both when restarting randomly with probability
<code class="literal"> 1 - damping</code> , and when the walker is forced to restart due to being
stuck in a sink vertex (a vertex with no outgoing edges).

</p>
<p>
Note that the personalized PageRank of a given vertex depends on the
personalized PageRank of all other vertices, so even if you want to calculate
the personalized PageRank for only some of the vertices, all of them must be
calculated. Requesting the personalized PageRank for only some of the vertices
does not result in any performance increase at all.
</p>
<p>
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td><p>
  The PageRank implementation to use. Possible values:
   <code class="constant">IGRAPH_PAGERANK_ALGO_ARPACK</code>, <code class="constant">IGRAPH_PAGERANK_ALGO_PRPACK</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is
   stored here. It is resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the eigenvalue
   corresponding to the PageRank vector is stored here. It should
   be always exactly one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex ids for which the PageRank is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider the directedness of
   the edges. This is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>damping</code></em>:</span></p></td>
<td><p>
  The damping factor ("d" in the original paper).
   Must be a probability in the range [0, 1]. A commonly used value is 0.85.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>reset</code></em>:</span></p></td>
<td><p>
  The probability distribution over the vertices used when
   resetting the random walk. It is either a <code class="constant">NULL</code> pointer (denoting
   a uniform choice that results in the original PageRank measure)
   or a vector of the same length as the number of vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Optional edge weights. May be a <code class="constant">NULL</code> pointer,
   meaning unweighted edges, or a vector of non-negative values
   of the same length as the number of edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options for the ARPACK method. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Note that the function overwrites the <code class="literal"> n</code>  (number
   of vertices), <code class="literal"> nev</code>  (1), <code class="literal"> ncv</code>  (3) and <code class="literal"> which</code> 
   (LM) parameters and it always starts the calculation from a non-random vector
   calculated based on the degree of the vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
        temporary data.
        <code class="constant">IGRAPH_EINVVID</code>, invalid vertex id in
        <em class="parameter"><code>vids</code></em> or an invalid reset vector in <em class="parameter"><code>reset</code></em>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the input graph, usually it is O(|E|),
the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_pagerank" title="8.6. igraph_pagerank — Calculates the Google PageRank for the specified vertices."><code class="function">igraph_pagerank()</code></a> for the non-personalized implementation,
<a class="link" href="igraph-Structural.html#igraph_personalized_pagerank_vs" title="8.8. igraph_personalized_pagerank_vs — Calculates the personalized Google PageRank for the specified vertices."><code class="function">igraph_personalized_pagerank_vs()</code></a> for a personalized implementation
with resetting to specific vertices.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_personalized_pagerank_vs"></a>8.8. <code class="function">igraph_personalized_pagerank_vs</code> —  Calculates the personalized Google PageRank for the specified vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545272421960"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_personalized_pagerank_vs(const igraph_t *graph,
                                    igraph_pagerank_algo_t algo, igraph_vector_t *vector,
                                    igraph_real_t *value, const igraph_vs_t vids,
                                    igraph_bool_t directed, igraph_real_t damping,
                                    igraph_vs_t reset_vids,
                                    const igraph_vector_t *weights,
                                    igraph_arpack_options_t *options);
</pre></div>
<p>
</p>
<p>



The personalized PageRank is similar to the original PageRank measure, but
when the random walk is restarted, a new starting vertex is chosen according to
a specified distribution.
This distribution is used both when restarting randomly with probability
<code class="literal"> 1 - damping</code> , and when the walker is forced to restart due to being
stuck in a sink vertex (a vertex with no outgoing edges).

</p>
<p>
This simplified interface takes a vertex sequence and resets the random walk to
one of the vertices in the specified vertex sequence, chosen uniformly. A typical
application of personalized PageRank is when the random walk is reset to the same
vertex every time - this can easily be achieved using <a class="link" href="igraph-Iterators.html#igraph_vss_1" title="4.3. igraph_vss_1 — Vertex set with a single vertex (immediate version)."><code class="function">igraph_vss_1()</code></a> which
generates a vertex sequence containing only a single vertex.

</p>
<p>
Note that the personalized PageRank of a given vertex depends on the
personalized PageRank of all other vertices, so even if you want to calculate
the personalized PageRank for only some of the vertices, all of them must be
calculated. Requesting the personalized PageRank for only some of the vertices
does not result in any performance increase at all.
</p>
<p>
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td><p>
  The PageRank implementation to use. Possible values:
   <code class="constant">IGRAPH_PAGERANK_ALGO_ARPACK</code>, <code class="constant">IGRAPH_PAGERANK_ALGO_PRPACK</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is
   stored here. It is resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the eigenvalue
   corresponding to the PageRank vector is stored here. It should
   be always exactly one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex ids for which the PageRank is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider the directedness of
   the edges. This is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>damping</code></em>:</span></p></td>
<td><p>
  The damping factor ("d" in the original paper).
   Must be a probability in the range [0, 1]. A commonly used value is 0.85.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>reset_vids</code></em>:</span></p></td>
<td><p>
  IDs of the vertices used when resetting the random walk.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Optional edge weights, it is either a null pointer,
   then the edges are not weighted, or a vector of the same length
   as the number of edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options for the ARPACK method. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Note that the function overwrites the <code class="literal"> n</code>  (number
   of vertices), <code class="literal"> nev</code>  (1), <code class="literal"> ncv</code>  (3) and <code class="literal"> which</code> 
   (LM) parameters and it always starts the calculation from a non-random vector
   calculated based on the degree of the vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
        temporary data.
        <code class="constant">IGRAPH_EINVVID</code>, invalid vertex id in
        <em class="parameter"><code>vids</code></em> or an empty reset vertex sequence in
        <em class="parameter"><code>vids_reset</code></em>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the input graph, usually it is O(|E|),
the number of edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_pagerank" title="8.6. igraph_pagerank — Calculates the Google PageRank for the specified vertices."><code class="function">igraph_pagerank()</code></a> for the non-personalized implementation.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_constraint"></a>8.9. <code class="function">igraph_constraint</code> —  Burt's constraint scores.</h3></div></div></div>
<a class="indexterm" name="idp105545272322504"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_constraint(const igraph_t *graph, igraph_vector_t *res,
                      igraph_vs_t vids, const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function calculates Burt's constraint scores for the given
vertices, also known as structural holes.

</p>
<p>
Burt's constraint is higher if ego has less, or mutually stronger
related (i.e. more redundant) contacts. Burt's measure of
constraint, C[i], of vertex i's ego network V[i], is defined for
directed and valued graphs,
</p>
<div class="blockquote"><blockquote class="blockquote"><p>
C[i] = sum( sum( (p[i,q] p[q,j])^2, q in V[i], q != i,j ), j in
V[], j != i)
</p></blockquote></div>
<p>
for a graph of order (i.e. number of vertices) N, where proportional
tie strengths are defined as
</p>
<div class="blockquote"><blockquote class="blockquote"><p>
p[i,j]=(a[i,j]+a[j,i]) / sum(a[i,k]+a[k,i], k in V[i], k != i),
</p></blockquote></div>
<p>
a[i,j] are elements of A and
the latter being the graph adjacency matrix. For isolated vertices,
constraint is undefined.

</p>
<p>
Burt, R.S. (2004). Structural holes and good ideas. American
Journal of Sociology 110, 349-399.

</p>
<p>
The first R version of this function was contributed by Jeroen
Bruggeman.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  A graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result will be
       stored here. The vector will be resized to have the
       appropriate size for holding the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  Vertex selector containing the vertices for which the
       constraint should be calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Vector giving the weights of the edges. If it is
       <code class="constant">NULL</code> then each edge is supposed to have the same weight.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+E|+n*d^2), n is the number of vertices for
which the constraint is calculated and d is the average degree, |V|
is the number of vertices, |E| the number of edges in the
graph. If the weights argument is <code class="constant">NULL</code> then the time complexity
is O(|V|+n*d^2).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_maxdegree"></a>8.10. <code class="function">igraph_maxdegree</code> —  The maximum degree in a graph (or set of vertices).</h3></div></div></div>
<a class="indexterm" name="idp105545272337992"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_maxdegree(const igraph_t *graph, igraph_integer_t *res,
                     igraph_vs_t vids, igraph_neimode_t mode,
                     igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The largest in-, out- or total degree of the specified vertices is
calculated. If the graph has no vertices, or <em class="parameter"><code>vids</code></em> is empty,
0 is returned, as this is the smallest possible value for degrees.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an integer (<code class="constant">igraph_integer_t</code>), the result
       will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  Vector giving the vertex IDs for which the maximum degree will
       be calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Defines the type of the degree.
       <code class="constant">IGRAPH_OUT</code>, out-degree,
       <code class="constant">IGRAPH_IN</code>, in-degree,
       <code class="constant">IGRAPH_ALL</code>, total degree (sum of the
       in- and out-degree).
       This parameter is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Boolean, gives whether the self-loops should be
       counted.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVVID</code>: invalid vertex id.
        <code class="constant">IGRAPH_EINVMODE</code>: invalid mode argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(v) if loops is TRUE, and O(v*d) otherwise. v is the number
of vertices for which the degree will be calculated, and d is their
(average) degree.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strength"></a>8.11. <code class="function">igraph_strength</code> — Strength of the vertices, weighted vertex degree in other words.</h3></div></div></div>
<a class="indexterm" name="idp105545272355144"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_strength(const igraph_t *graph, igraph_vector_t *res,
                    const igraph_vs_t vids, igraph_neimode_t mode,
                    igraph_bool_t loops, const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>



In a weighted network the strength of a vertex is the sum of the
weights of all incident edges. In a non-weighted network this is
exactly the vertex degree.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is stored
  here. It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Gives whether to count only outgoing (<code class="constant">IGRAPH_OUT</code>),
  incoming (<code class="constant">IGRAPH_IN</code>) edges or both (<code class="constant">IGRAPH_ALL</code>).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  A logical scalar, whether to count loop edges as well.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A vector giving the edge weights. If this is a NULL
  pointer, then <a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a> is called to perform the
  calculation.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number vertices and
edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a> for the traditional, non-weighted version.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_eigenvector_centrality"></a>8.12. <code class="function">igraph_eigenvector_centrality</code> — Eigenvector centrality of the vertices</h3></div></div></div>
<a class="indexterm" name="idp105545271982152"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_eigenvector_centrality(const igraph_t *graph,
                                  igraph_vector_t *vector,
                                  igraph_real_t *value,
                                  igraph_bool_t directed, igraph_bool_t scale,
                                  const igraph_vector_t *weights,
                                  igraph_arpack_options_t *options);
</pre></div>
<p>
</p>
<p>



Eigenvector centrality is a measure of the importance of a node in a
network. It assigns relative scores to all nodes in the network based
on the principle that connections from high-scoring nodes contribute
more to the score of the node in question than equal connections from
low-scoring nodes. Specifically, the eigenvector centrality of each
vertex is proportional to the sum of eigenvector centralities of its
neighbors. In practice, the centralities are determined by calculating the
eigenvector corresponding to the largest positive eigenvalue of the
adjacency matrix. In the undirected case, this function considers
the diagonal entries of the adjacency matrix to be <span class="emphasis"><em>twice</em></span> the number of
self-loops on the corresponding vertex.

</p>
<p>
The centrality scores returned by igraph can be normalized
(using the <em class="parameter"><code>scale</code></em> parameter) such that the largest eigenvector centrality
score is 1 (with one exception, see below).

</p>
<p>
In the directed case, the left eigenvector of the adjacency matrix is
calculated. In other words, the centrality of a vertex is proportional
to the sum of centralities of vertices pointing to it.

</p>
<p>
Eigenvector centrality is meaningful only for connected graphs.
Graphs that are not connected should be decomposed into connected
components, and the eigenvector centrality calculated for each separately.
This function does not verify that the graph is connected. If it is not,
in the undirected case the scores of all but one component will be zeros.

</p>
<p>
Also note that the adjacency matrix of a directed acyclic graph or the
adjacency matrix of an empty graph does not possess positive eigenvalues,
therefore the eigenvector centrality is not defined for these graphs.
igraph will return an eigenvalue of zero in such cases. The eigenvector
centralities will all be equal for an empty graph and will all be zeros
for a directed acyclic graph. Such pathological cases can be detected
by asking igraph to calculate the eigenvalue as well (using the <em class="parameter"><code>value</code></em>
parameter, see below) and checking whether the eigenvalue is very close
to zero.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It may be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, it will be resized
    as needed. The result of the computation is stored here. It can
    be a null pointer, then it is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then the eigenvalue
    corresponding to the found eigenvector is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean scalar, whether to consider edge directions
    in a directed graph. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scale</code></em>:</span></p></td>
<td><p>
  If not zero then the result will be scaled such that
    the absolute value of the maximum centrality is one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A null pointer (=no edge weights), or a vector
    giving the weights of the edges. The algorithm might result
    complex numbers is some weights are negative. In this case only
    the real part is reported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options to ARPACK. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Note that the function overwrites the
   <code class="literal"> n</code>  (number of vertices) parameter and
   it always starts the calculation from a non-random vector
   calculated based on the degree of the vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the input graph, usually it is O(|V|+|E|).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_pagerank" title="8.6. igraph_pagerank — Calculates the Google PageRank for the specified vertices."><code class="function">igraph_pagerank</code></a> and <a class="link" href="igraph-Structural.html#igraph_personalized_pagerank" title="8.7. igraph_personalized_pagerank — Calculates the personalized Google PageRank for the specified vertices."><code class="function">igraph_personalized_pagerank</code></a> for
  modifications of eigenvector centrality.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545272005192"></a><p class="title"><b>Example 13.14.  File <code class="code">examples/simple/eigenvector_centrality.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2007-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> "igraph.h"

<span class="strong"><strong>#include</strong></span> &lt;math.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> v, weights;
    long int i;
    igraph_real_t value;
    <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK">igraph_arpack_options_t</a> options;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.6. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 100, IGRAPH_STAR_UNDIRECTED, 0);

    <span class="strong"><strong><a class="link" href="igraph-Arpack.html#igraph_arpack_options_init" title="3.1.4. igraph_arpack_options_init — Initialize ARPACK options">igraph_arpack_options_init</a></strong></span>(&amp;options);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="8.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices">igraph_eigenvector_centrality</a></strong></span>(&amp;g, &amp;v, &amp;value, <span class="emphasis"><em>/*directed=*/</em></span> 0,
                                  <span class="emphasis"><em>/*scale=*/</em></span>1, <span class="emphasis"><em>/*weights=*/</em></span>0,
                                  &amp;options);

    <span class="strong"><strong>if</strong></span> (options.info != 0) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;v); i++) {
        <span class="strong"><strong>printf</strong></span>(" %.4f", <span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[i]));
    }
    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Special cases: check for empty graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_empty" title="2.1.1. igraph_empty — Creates an empty graph with some vertices and no edges.">igraph_empty</a></strong></span>(&amp;g, 10, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="8.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices">igraph_eigenvector_centrality</a></strong></span>(&amp;g, &amp;v, &amp;value, 0, 0, 0, &amp;options);
    <span class="strong"><strong>if</strong></span> (value != 0.0) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;v); i++) {
        <span class="strong"><strong>printf</strong></span>(" %.2f", <span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[i]));
    }
    <span class="strong"><strong>printf</strong></span>("\n");
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Special cases: check for full graph, zero weights */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.10. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;g, 10, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, 45);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_fill" title="2.3.2. igraph_vector_fill — Fill a vector with a constant element">igraph_vector_fill</a></strong></span>(&amp;weights, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="8.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices">igraph_eigenvector_centrality</a></strong></span>(&amp;g, &amp;v, &amp;value, 0, 0, &amp;weights, &amp;options);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>if</strong></span> (value != 0.0) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;v); i++) {
        <span class="strong"><strong>printf</strong></span>(" %.2f", <span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[i]));
    }
    <span class="strong"><strong>printf</strong></span>("\n");
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_hub_score"></a>8.13. <code class="function">igraph_hub_score</code> — Kleinberg's hub scores</h3></div></div></div>
<a class="indexterm" name="idp105545271914952"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_hub_score(const igraph_t *graph, igraph_vector_t *vector,
                     igraph_real_t *value, igraph_bool_t scale,
                     const igraph_vector_t *weights,
                     igraph_arpack_options_t *options);
</pre></div>
<p>
</p>
<p>



The hub scores of the vertices are defined as the principal
eigenvector of <code class="literal"> A*A^T</code> , where <code class="literal"> A</code>  is the adjacency
matrix of the graph, <code class="literal"> A^T</code>  is its transposed.
</p>
<p>
See the following reference on the meaning of this score:
J. Kleinberg. Authoritative sources in a hyperlinked
environment. <span class="emphasis"><em> Proc. 9th ACM-SIAM Symposium on Discrete
Algorithms, </em></span> 1998. Extended version in <span class="emphasis"><em> Journal of the
ACM </em></span> 46(1999). Also appears as IBM Research Report RJ 10076, May
1997.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Can be directed and undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is
   stored here. If a null pointer then it is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  If not a null pointer then the eigenvalue
   corresponding to the calculated eigenvector is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scale</code></em>:</span></p></td>
<td><p>
  If not zero then the result will be scaled such that
    the absolute value of the maximum centrality is one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A null pointer (=no edge weights), or a vector
    giving the weights of the edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options to ARPACK. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Note that the function overwrites the
   <code class="literal"> n</code>  (number of vertices) parameter and
   it always starts the calculation from a non-random vector
   calculated based on the degree of the vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the input graph, usually it is O(|V|),
the number of vertices.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_authority_score" title="8.14. igraph_authority_score — Kleinerg's authority scores"><code class="function">igraph_authority_score()</code></a> for the companion measure,
<a class="link" href="igraph-Structural.html#igraph_pagerank" title="8.6. igraph_pagerank — Calculates the Google PageRank for the specified vertices."><code class="function">igraph_pagerank()</code></a>, <a class="link" href="igraph-Structural.html#igraph_personalized_pagerank" title="8.7. igraph_personalized_pagerank — Calculates the personalized Google PageRank for the specified vertices."><code class="function">igraph_personalized_pagerank()</code></a>,
<a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="8.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices"><code class="function">igraph_eigenvector_centrality()</code></a> for similar measures.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_authority_score"></a>8.14. <code class="function">igraph_authority_score</code> — Kleinerg's authority scores</h3></div></div></div>
<a class="indexterm" name="idp105545271939656"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_authority_score(const igraph_t *graph, igraph_vector_t *vector,
                           igraph_real_t *value, igraph_bool_t scale,
                           const igraph_vector_t *weights,
                           igraph_arpack_options_t *options);
</pre></div>
<p>
</p>
<p>



The authority scores of the vertices are defined as the principal
eigenvector of <code class="literal"> A^T*A</code> , where <code class="literal"> A</code>  is the adjacency
matrix of the graph, <code class="literal"> A^T</code>  is its transposed.
</p>
<p>
See the following reference on the meaning of this score:
J. Kleinberg. Authoritative sources in a hyperlinked
environment. <span class="emphasis"><em> Proc. 9th ACM-SIAM Symposium on Discrete
Algorithms, </em></span> 1998. Extended version in <span class="emphasis"><em> Journal of the
ACM </em></span> 46(1999). Also appears as IBM Research Report RJ 10076, May
1997.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Can be directed and undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is
   stored here. If a null pointer then it is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  If not a null pointer then the eigenvalue
   corresponding to the calculated eigenvector is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scale</code></em>:</span></p></td>
<td><p>
  If not zero then the result will be scaled such that
    the absolute value of the maximum centrality is one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A null pointer (=no edge weights), or a vector
    giving the weights of the edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options to ARPACK. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Note that the function overwrites the
   <code class="literal"> n</code>  (number of vertices) parameter and
   it always starts the calculation from a non-random vector
   calculated based on the degree of the vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: depends on the input graph, usually it is O(|V|),
the number of vertices.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_hub_score" title="8.13. igraph_hub_score — Kleinberg's hub scores"><code class="function">igraph_hub_score()</code></a> for the companion measure,
<a class="link" href="igraph-Structural.html#igraph_pagerank" title="8.6. igraph_pagerank — Calculates the Google PageRank for the specified vertices."><code class="function">igraph_pagerank()</code></a>, <a class="link" href="igraph-Structural.html#igraph_personalized_pagerank" title="8.7. igraph_personalized_pagerank — Calculates the personalized Google PageRank for the specified vertices."><code class="function">igraph_personalized_pagerank()</code></a>,
<a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="8.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices"><code class="function">igraph_eigenvector_centrality()</code></a> for similar measures.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="range-limited-centrality-measures"></a>9. Range-limited Centrality Measures</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_closeness_cutoff">9.1. <code class="function">igraph_closeness_cutoff</code> —  Range limited closeness centrality.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_harmonic_centrality_cutoff">9.2. <code class="function">igraph_harmonic_centrality_cutoff</code> —  Range limited harmonic centrality.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_betweenness_cutoff">9.3. <code class="function">igraph_betweenness_cutoff</code> —  Range-limited betweenness centrality.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_edge_betweenness_cutoff">9.4. <code class="function">igraph_edge_betweenness_cutoff</code> —  Range-limited betweenness centrality of the edges.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_closeness_cutoff"></a>9.1. <code class="function">igraph_closeness_cutoff</code> —  Range limited closeness centrality.</h3></div></div></div>
<a class="indexterm" name="idp105545271965128"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_closeness_cutoff(const igraph_t *graph, igraph_vector_t *res,
                            igraph_vector_t *reachable_count, igraph_bool_t *all_reachable,
                            const igraph_vs_t vids, igraph_neimode_t mode,
                            const igraph_vector_t *weights,
                            igraph_bool_t normalized,
                            igraph_real_t cutoff);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function computes a range-limited version of closeness centrality
by considering only those shortest paths whose length is no greater
then the given cutoff value.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
       range-limited closeness centrality scores for the given vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>reachable_count</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code>, this vector will contain the number of
       vertices reachable within the cutoff distance from each vertex for which
       the range-limited closeness is calculated (not including that vertex).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>all_reachable</code></em>:</span></p></td>
<td><p>
  Pointer to a Boolean. If not <code class="constant">NULL</code>, it indicates if all
       vertices of the graph were reachable from each vertex in <em class="parameter"><code>vids</code></em> within
       the given cutoff distance.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the range limited closeness centrality
            will be computed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the lengths of the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the lengths of the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       weighted closeness. No edge weight may be NaN. Supply a null
       pointer here for traditional, unweighted closeness.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  If true, the inverse of the mean distance to vertices
       reachable within the cutoff is returned. If false, the inverse
       of the sum of distances is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cutoff</code></em>:</span></p></td>
<td><p>
  The maximal length of paths that will be considered.
       If negative, the exact closeness will be calculated (no upper
       limit on path lengths).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex id passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n|E|),
n is the number
of vertices for which the calculation is done and
|E| is the number
of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_closeness" title="8.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a> to calculate the exact closeness centrality.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_harmonic_centrality_cutoff"></a>9.2. <code class="function">igraph_harmonic_centrality_cutoff</code> —  Range limited harmonic centrality.</h3></div></div></div>
<a class="indexterm" name="idp105545272127304"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_harmonic_centrality_cutoff(const igraph_t *graph, igraph_vector_t *res,
                                      const igraph_vs_t vids, igraph_neimode_t mode,
                                      const igraph_vector_t *weights,
                                      igraph_bool_t normalized,
                                      igraph_real_t cutoff);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function computes the range limited version of harmonic centrality:
only those shortest paths are considered whose length is not above the given cutoff.
The inverse distance to vertices not reachable within the cutoff is considered
to be zero.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
       range limited harmonic centrality scores for the given vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the harmonic centrality will be computed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of shortest paths to be used for the
       calculation in directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the lengths of the outgoing paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the lengths of the incoming paths are calculated.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an
         undirected one for the computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       weighted harmonic centrality. No edge weight may be NaN.
       If <code class="constant">NULL</code>, all weights are considered to be one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to normalize the result. If true,
       the result is the mean inverse path length to other vertices.
       i.e. it is normalized by the number of vertices minus one.
       If false, the result is the sum of inverse path lengths to other
       vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cutoff</code></em>:</span></p></td>
<td><p>
  The maximal length of paths that will be considered.
       The inverse distance to vertices that are not reachable within
       the cutoff path length is considered to be zero.
       Supply a negative value to compute the exact harmonic centrality,
       without any upper limit on the length of paths.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex id passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n|E|), where
n is the number of vertices for which the calculation is done and
|E| is the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Other centrality types: <a class="link" href="igraph-Structural.html#igraph_closeness" title="8.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a>, <a class="link" href="igraph-Structural.html#igraph_betweenness" title="8.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_betweenness_cutoff"></a>9.3. <code class="function">igraph_betweenness_cutoff</code> —  Range-limited betweenness centrality.</h3></div></div></div>
<a class="indexterm" name="idp105545272155592"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_betweenness_cutoff(const igraph_t *graph, igraph_vector_t *res,
                              const igraph_vs_t vids, igraph_bool_t directed,
                              const igraph_vector_t *weights, igraph_real_t cutoff);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function computes a range-limited version of betweenness centrality
by considering only those shortest paths whose length is no greater
then the given cutoff value.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result of the computation, a vector containing the
       range-limited betweenness scores for the specified vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the range-limited betweenness centrality
       scores will be computed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, if true directed paths will be considered
       for directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights for
       calculating weighted betweenness. No edge weight may be NaN.
       Supply a null pointer here for unweighted betweenness.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cutoff</code></em>:</span></p></td>
<td><p>
  The maximal length of paths that will be considered.
       If negative, the exact betweenness will be calculated, and
       there will be no upper limit on path lengths.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
       temporary data.
       <code class="constant">IGRAPH_EINVVID</code>, invalid vertex id passed in
       <em class="parameter"><code>vids</code></em>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|),
|V| and
|E| are the number of vertices and
edges in the graph.
Note that the time complexity is independent of the number of
vertices for which the score is calculated.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_betweenness" title="8.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a> to calculate the exact betweenness and
<a class="link" href="igraph-Structural.html#igraph_edge_betweenness_cutoff" title="9.4. igraph_edge_betweenness_cutoff — Range-limited betweenness centrality of the edges."><code class="function">igraph_edge_betweenness_cutoff()</code></a> to calculate the range-limited
edge betweenness.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_edge_betweenness_cutoff"></a>9.4. <code class="function">igraph_edge_betweenness_cutoff</code> —  Range-limited betweenness centrality of the edges.</h3></div></div></div>
<a class="indexterm" name="idp105545272045384"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_edge_betweenness_cutoff(const igraph_t *graph, igraph_vector_t *result,
                                   igraph_bool_t directed,
                                   const igraph_vector_t *weights, igraph_real_t cutoff);
</pre></div>
<p>
</p>
<p>




</p>
<p>
</p>
<p>
This function computes a range-limited version of edge betweenness centrality
by considering only those shortest paths whose length is no greater
then the given cutoff value.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  The result of the computation, vector containing the
       betweenness scores for the edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, if true directed paths will be considered
       for directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional weight vector for weighted
       betweenness. No edge weight may be NaN. Supply a null
       pointer here for unweighted betweenness.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cutoff</code></em>:</span></p></td>
<td><p>
  The maximal length of paths that will be considered.
       If negative, the exact betweenness will be calculated (no
       upper limit on path lengths).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
       temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||E|),
|V| and
|E| are the number of vertices and
edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_edge_betweenness" title="8.4. igraph_edge_betweenness — Betweenness centrality of the edges."><code class="function">igraph_edge_betweenness()</code></a> to compute the exact edge betweenness and
<a class="link" href="igraph-Structural.html#igraph_betweenness_cutoff" title="9.3. igraph_betweenness_cutoff — Range-limited betweenness centrality."><code class="function">igraph_betweenness_cutoff()</code></a> to compute the range-limited vertex betweenness.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="centralization"></a>10. Centralization</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization">10.1. <code class="function">igraph_centralization</code> — Calculate the centralization score from the node level scores</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_degree">10.2. <code class="function">igraph_centralization_degree</code> — Calculate vertex degree and graph centralization</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_betweenness">10.3. <code class="function">igraph_centralization_betweenness</code> — Calculate vertex betweenness and graph centralization</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_closeness">10.4. <code class="function">igraph_centralization_closeness</code> — Calculate vertex closeness and graph centralization</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_eigenvector_centrality">10.5. <code class="function">igraph_centralization_eigenvector_centrality</code> — Calculate eigenvector centrality scores and graph centralization</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_degree_tmax">10.6. <code class="function">igraph_centralization_degree_tmax</code> — Theoretical maximum for graph centralization based on degree</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_betweenness_tmax">10.7. <code class="function">igraph_centralization_betweenness_tmax</code> — Theoretical maximum for graph centralization based on betweenness</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_closeness_tmax">10.8. <code class="function">igraph_centralization_closeness_tmax</code> — Theoretical maximum for graph centralization based on closeness</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_centralization_eigenvector_centrality_tmax">10.9. <code class="function">igraph_centralization_eigenvector_centrality_tmax</code> — Theoretical maximum centralization for eigenvector centrality</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization"></a>10.1. <code class="function">igraph_centralization</code> — Calculate the centralization score from the node level scores</h3></div></div></div>
<a class="indexterm" name="idp105545272064840"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_centralization(const igraph_vector_t *scores,
                                    igraph_real_t theoretical_max,
                                    igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>



For a centrality score defined on the vertices of a graph, it is
possible to define a graph level centralization index, by
calculating the sum of the deviation from the maximum centrality
score. Consequently, the higher the centralization index of the
graph, the more centralized the structure is.

</p>
<p>In order to make graphs of different sizes comparable,
the centralization index is usually normalized to a number between
zero and one, by dividing the (unnormalized) centralization score
of the most centralized structure with the same number of vertices.

</p>
<p>For most centrality indices the most centralized
structure is the star graph, a single center connected to all other
nodes in the network. There are some variation depending on whether
the graph is directed or not, whether loop edges are allowed, etc.

</p>
<p>
This function simply calculates the graph level index, if the node
level scores and the theoretical maximum are given. It is called by
all the measure-specific centralization functions.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>scores</code></em>:</span></p></td>
<td><p>
  A vector containing the node-level centrality
    scores.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>theoretical_max</code></em>:</span></p></td>
<td><p>
  The graph level centrality score of the most
    centralized graph with the same number of vertices. Only used
    if <code class="constant">normalized</code> set to true.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to normalize the centralization
    by dividing the supplied theoretical maximum.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The graph level index.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization_degree" title="10.2. igraph_centralization_degree — Calculate vertex degree and graph centralization"><code class="function">igraph_centralization_degree()</code></a>, <a class="link" href="igraph-Structural.html#igraph_centralization_betweenness" title="10.3. igraph_centralization_betweenness — Calculate vertex betweenness and graph centralization"><code class="function">igraph_centralization_betweenness()</code></a>, <a class="link" href="igraph-Structural.html#igraph_centralization_closeness" title="10.4. igraph_centralization_closeness — Calculate vertex closeness and graph centralization"><code class="function">igraph_centralization_closeness()</code></a>, and <a class="link" href="igraph-Structural.html#igraph_centralization_eigenvector_centrality" title="10.5. igraph_centralization_eigenvector_centrality — Calculate eigenvector centrality scores and graph centralization"><code class="function">igraph_centralization_eigenvector_centrality()</code></a> for specific
centralization functions.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the length of the score vector.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545272081096"></a><p class="title"><b>Example 13.15.  File <code class="code">examples/simple/centralization.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2009-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;math.h&gt;

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>ALMOST_EQUALS</strong></span>(a, b) (<span class="strong"><strong>fabs</strong></span>((a)-(b)) &lt; 1e-8)

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t cent;
    <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK">igraph_arpack_options_t</a> arpack_options;

    <span class="emphasis"><em>/****************************/</em></span>
    <span class="emphasis"><em>/* in-star */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.6. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_IN, <span class="emphasis"><em>/*center=*/</em></span> 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_degree" title="10.2. igraph_centralization_degree — Calculate vertex degree and graph centralization">igraph_centralization_degree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> 0,
                                 <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_IN, IGRAPH_NO_LOOPS,
                                 &amp;cent, <span class="emphasis"><em>/*theoretical_max=*/</em></span> 0,
                                 <span class="emphasis"><em>/*normalized=*/</em></span> 1);
    <span class="strong"><strong>if</strong></span> (cent != 1.0) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "in-star, degree: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_betweenness" title="10.3. igraph_centralization_betweenness — Calculate vertex betweenness and graph centralization">igraph_centralization_betweenness</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> 0,
                                      IGRAPH_UNDIRECTED, &amp;cent,
                                      <span class="emphasis"><em>/*theoretical_max=*/</em></span> 0,
                                      <span class="emphasis"><em>/*normalized=*/</em></span> 1);
    <span class="strong"><strong>if</strong></span> (cent != 1.0) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "in-star, betweenness: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="emphasis"><em>/* Skip closeness, as it is not well-defined for disconnected graphs such as an in-star. */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/****************************/</em></span>
    <span class="emphasis"><em>/* out-star */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.6. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_OUT, <span class="emphasis"><em>/*center=*/</em></span> 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_degree" title="10.2. igraph_centralization_degree — Calculate vertex degree and graph centralization">igraph_centralization_degree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> 0,
                                 <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT, IGRAPH_NO_LOOPS,
                                 &amp;cent, <span class="emphasis"><em>/*theoretical_max=*/</em></span> 0,
                                 <span class="emphasis"><em>/*normalized=*/</em></span> 1);
    <span class="strong"><strong>if</strong></span> (cent != 1.0) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "out-star, degree: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 11;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_betweenness" title="10.3. igraph_centralization_betweenness — Calculate vertex betweenness and graph centralization">igraph_centralization_betweenness</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> 0,
                                      IGRAPH_UNDIRECTED, &amp;cent,
                                      <span class="emphasis"><em>/*theoretical_max=*/</em></span> 0,
                                      <span class="emphasis"><em>/*normalized=*/</em></span> 1);
    <span class="strong"><strong>if</strong></span> (cent != 1.0) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "out-star, betweenness: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 12;
    }

    <span class="emphasis"><em>/* Skip closeness, as it is not well-defined for disconnected graphs such as an out-star. */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/****************************/</em></span>
    <span class="emphasis"><em>/* undirected star */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.6. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;g, 10, IGRAPH_STAR_UNDIRECTED, <span class="emphasis"><em>/*center=*/</em></span> 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_degree" title="10.2. igraph_centralization_degree — Calculate vertex degree and graph centralization">igraph_centralization_degree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> 0,
                                 <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_ALL, IGRAPH_NO_LOOPS,
                                 &amp;cent, <span class="emphasis"><em>/*theoretical_max=*/</em></span> 0,
                                 <span class="emphasis"><em>/*normalized=*/</em></span> 1);
    <span class="strong"><strong>if</strong></span> (cent != 1.0) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "undirected star, degree: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 21;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_betweenness" title="10.3. igraph_centralization_betweenness — Calculate vertex betweenness and graph centralization">igraph_centralization_betweenness</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> 0,
                                      IGRAPH_UNDIRECTED, &amp;cent,
                                      <span class="emphasis"><em>/*theoretical_max=*/</em></span> 0,
                                      <span class="emphasis"><em>/*normalized=*/</em></span> 1);
    <span class="strong"><strong>if</strong></span> (cent != 1.0) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "undirected star, betweenness: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 22;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_closeness" title="10.4. igraph_centralization_closeness — Calculate vertex closeness and graph centralization">igraph_centralization_closeness</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> 0,
                                    IGRAPH_ALL, &amp;cent,
                                    <span class="emphasis"><em>/*theoretical_max=*/</em></span> 0,
                                    <span class="emphasis"><em>/*normalization=*/</em></span> 1);

    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>ALMOST_EQUALS</strong></span>(cent, 1.0)) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "undirected star, closeness: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 23;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/****************************/</em></span>
    <span class="emphasis"><em>/* single dyad */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, <span class="emphasis"><em>/*n=*/</em></span> 10, <span class="emphasis"><em>/*directed=*/</em></span> 0,
                 0, 1, -1);

    <span class="strong"><strong><a class="link" href="igraph-Arpack.html#igraph_arpack_options_init" title="3.1.4. igraph_arpack_options_init — Initialize ARPACK options">igraph_arpack_options_init</a></strong></span>(&amp;arpack_options);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_eigenvector_centrality" title="10.5. igraph_centralization_eigenvector_centrality — Calculate eigenvector centrality scores and graph centralization">igraph_centralization_eigenvector_centrality</a></strong></span>(&amp;g, <span class="emphasis"><em>/*vector=*/</em></span> 0,
            <span class="emphasis"><em>/*value=*/</em></span> 0,
            <span class="emphasis"><em>/*directed=*/</em></span> 1,
            <span class="emphasis"><em>/*scale=*/</em></span> 1,
            &amp;arpack_options, &amp;cent,
            <span class="emphasis"><em>/*theoretical_max=*/</em></span> 0,
            <span class="emphasis"><em>/*normalization=*/</em></span> 1);

    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>ALMOST_EQUALS</strong></span>(cent, 1.0)) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "dyad, eigenvector centrality: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 24;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_centralization_eigenvector_centrality" title="10.5. igraph_centralization_eigenvector_centrality — Calculate eigenvector centrality scores and graph centralization">igraph_centralization_eigenvector_centrality</a></strong></span>(&amp;g, <span class="emphasis"><em>/*vector=*/</em></span> 0,
            <span class="emphasis"><em>/*value=*/</em></span> 0,
            <span class="emphasis"><em>/*directed=*/</em></span> 1,
            <span class="emphasis"><em>/*scale=*/</em></span> 0,
            &amp;arpack_options, &amp;cent,
            <span class="emphasis"><em>/*theoretical_max=*/</em></span> 0,
            <span class="emphasis"><em>/*normalization=*/</em></span> 1);

    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>ALMOST_EQUALS</strong></span>(cent, 1.0)) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "dyad, eigenvector centrality, not scaled: %g\n", cent);
        <span class="strong"><strong>return</strong></span> 25;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_degree"></a>10.2. <code class="function">igraph_centralization_degree</code> — Calculate vertex degree and graph centralization</h3></div></div></div>
<a class="indexterm" name="idp105545273848392"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_centralization_degree(const igraph_t *graph, igraph_vector_t *res,
                                 igraph_neimode_t mode, igraph_bool_t loops,
                                 igraph_real_t *centralization,
                                 igraph_real_t *theoretical_max,
                                 igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>



This function calculates the degree of the vertices by passing its
arguments to <a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a>; and it calculates the graph
level centralization index based on the results by calling <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  A vector if you need the node-level degree scores, or a
    null pointer otherwise.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant the specifies the type of degree for directed
    graphs. Possible values: <code class="constant">IGRAPH_IN</code>, <code class="constant">IGRAPH_OUT</code> and <code class="constant">IGRAPH_ALL</code>. This argument is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider loop edges when
    calculating the degree (and the centralization).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>centralization</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the centralization
    score is placed here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>theoretical_max</code></em>:</span></p></td>
<td><p>
  Pointer to real number or a null pointer. If
    not a null pointer, then the theoretical maximum graph
    centrality score for a graph with the same number vertices is
    stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to calculate a normalized
    centralization score. See <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a> for how
    the normalization is done.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a>, <a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: the complexity of <a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph."><code class="function">igraph_degree()</code></a> plus O(n),
the number of vertices queried, for calculating the centralization
score.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_betweenness"></a>10.3. <code class="function">igraph_centralization_betweenness</code> — Calculate vertex betweenness and graph centralization</h3></div></div></div>
<a class="indexterm" name="idp105545273873096"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_centralization_betweenness(const igraph_t *graph,
                                      igraph_vector_t *res,
                                      igraph_bool_t directed,
                                      igraph_real_t *centralization,
                                      igraph_real_t *theoretical_max,
                                      igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>



This function calculates the betweenness centrality of the vertices
by passing its arguments to <a class="link" href="igraph-Structural.html#igraph_betweenness" title="8.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a>; and it
calculates the graph level centralization index based on the
results by calling <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  A vector if you need the node-level betweenness scores, or a
    null pointer otherwise.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider directed paths when
    calculating betweenness.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>centralization</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the centralization
    score is placed here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>theoretical_max</code></em>:</span></p></td>
<td><p>
  Pointer to real number or a null pointer. If
    not a null pointer, then the theoretical maximum graph
    centrality score for a graph with the same number vertices is
    stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to calculate a normalized
    centralization score. See <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a> for how
    the normalization is done.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a>, <a class="link" href="igraph-Structural.html#igraph_betweenness" title="8.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: the complexity of <a class="link" href="igraph-Structural.html#igraph_betweenness" title="8.3. igraph_betweenness — Betweenness centrality of some vertices."><code class="function">igraph_betweenness()</code></a> plus
O(n), the number of vertices queried, for calculating the
centralization score.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_closeness"></a>10.4. <code class="function">igraph_centralization_closeness</code> — Calculate vertex closeness and graph centralization</h3></div></div></div>
<a class="indexterm" name="idp105545273764168"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_centralization_closeness(const igraph_t *graph,
                                    igraph_vector_t *res,
                                    igraph_neimode_t mode,
                                    igraph_real_t *centralization,
                                    igraph_real_t *theoretical_max,
                                    igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>



This function calculates the closeness centrality of the vertices
by passing its arguments to <a class="link" href="igraph-Structural.html#igraph_closeness" title="8.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a>; and it
calculates the graph level centralization index based on the
results by calling <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  A vector if you need the node-level closeness scores, or a
    null pointer otherwise.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant the specifies the type of closeness for directed
    graphs. Possible values: <code class="constant">IGRAPH_IN</code>, <code class="constant">IGRAPH_OUT</code> and <code class="constant">IGRAPH_ALL</code>. This argument is ignored for undirected graphs. See
    <a class="link" href="igraph-Structural.html#igraph_closeness" title="8.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a> argument with the same name for more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>centralization</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the centralization
    score is placed here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>theoretical_max</code></em>:</span></p></td>
<td><p>
  Pointer to real number or a null pointer. If
    not a null pointer, then the theoretical maximum graph
    centrality score for a graph with the same number vertices is
    stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to calculate a normalized
    centralization score. See <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a> for how
    the normalization is done.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a>, <a class="link" href="igraph-Structural.html#igraph_closeness" title="8.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: the complexity of <a class="link" href="igraph-Structural.html#igraph_closeness" title="8.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a> plus
O(n), the number of vertices queried, for calculating the
centralization score.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_eigenvector_centrality"></a>10.5. <code class="function">igraph_centralization_eigenvector_centrality</code> — Calculate eigenvector centrality scores and graph centralization</h3></div></div></div>
<a class="indexterm" name="idp105545273788232"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_centralization_eigenvector_centrality(
    const igraph_t *graph,
    igraph_vector_t *vector,
    igraph_real_t *value,
    igraph_bool_t directed,
    igraph_bool_t scale,
    igraph_arpack_options_t *options,
    igraph_real_t *centralization,
    igraph_real_t *theoretical_max,
    igraph_bool_t normalized);
</pre></div>
<p>
</p>
<p>



This function calculates the eigenvector centrality of the vertices
by passing its arguments to <a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="8.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices"><code class="function">igraph_eigenvector_centrality</code></a>);
and it calculates the graph level centralization index based on the
results by calling <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  A vector if you need the node-level eigenvector
     centrality scores, or a null pointer otherwise.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then the leading eigenvalue is
     stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scale</code></em>:</span></p></td>
<td><p>
  If not zero then the result will be scaled, such that
    the absolute value of the maximum centrality is one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  Options to ARPACK. See <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details. Note that the function overwrites the
   <code class="literal"> n</code>  (number of vertices) parameter and
   it always starts the calculation from a non-random vector
   calculated based on the degree of the vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>centralization</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the centralization
    score is placed here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>theoretical_max</code></em>:</span></p></td>
<td><p>
  Pointer to real number or a null pointer. If
    not a null pointer, then the theoretical maximum graph
    centrality score for a graph with the same number vertices is
    stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Boolean, whether to calculate a normalized
    centralization score. See <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a> for how
    the normalization is done.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a>, <a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="8.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices"><code class="function">igraph_eigenvector_centrality()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: the complexity of <a class="link" href="igraph-Structural.html#igraph_eigenvector_centrality" title="8.12. igraph_eigenvector_centrality — Eigenvector centrality of the vertices"><code class="function">igraph_eigenvector_centrality()</code></a> plus O(|V|), the number of vertices
for the calculating the centralization.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_degree_tmax"></a>10.6. <code class="function">igraph_centralization_degree_tmax</code> — Theoretical maximum for graph centralization based on degree</h3></div></div></div>
<a class="indexterm" name="idp105545273945672"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_centralization_degree_tmax(const igraph_t *graph,
                                      igraph_integer_t nodes,
                                      igraph_neimode_t mode,
                                      igraph_bool_t loops,
                                      igraph_real_t *res);
</pre></div>
<p>
</p>
<p>



This function returns the theoretical maximum graph centrality
based on vertex degree.

</p>
<p>
There are two ways to call this function, the first is to supply a
graph as the <code class="literal"> graph</code>  argument, and then the number of
vertices is taken from this object, and its directedness is
considered as well. The <code class="literal"> nodes</code>  argument is ignored in
this case. The <code class="literal"> mode</code>  argument is also ignored if the
supplied graph is undirected.

</p>
<p>
The other way is to supply a null pointer as the <code class="literal"> graph</code> 
argument. In this case the <code class="literal"> nodes</code>  and <code class="literal"> mode</code> 
arguments are considered.

</p>
<p>
The most centralized structure is the star. More specifically, for
undirected graphs it is the star, for directed graphs it is the
in-star or the out-star.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  A graph object or a null pointer, see the description
    above.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of nodes. This is ignored if the
    <code class="literal"> graph</code>  argument is not a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant, whether the calculation is based on in-degree
    (<code class="literal"> IGRAPH_IN</code> ), out-degree (<code class="literal"> IGRAPH_OUT</code> )
    or total degree (<code class="literal"> IGRAPH_ALL</code> ). This is ignored if
    the <code class="literal"> graph</code>  argument is not a null pointer and the
    given graph is undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Boolean scalar, whether to consider loop edges in the
    calculation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization_degree" title="10.2. igraph_centralization_degree — Calculate vertex degree and graph centralization"><code class="function">igraph_centralization_degree()</code></a> and <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_betweenness_tmax"></a>10.7. <code class="function">igraph_centralization_betweenness_tmax</code> — Theoretical maximum for graph centralization based on betweenness</h3></div></div></div>
<a class="indexterm" name="idp105545273969864"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_centralization_betweenness_tmax(const igraph_t *graph,
        igraph_integer_t nodes,
        igraph_bool_t directed,
        igraph_real_t *res);
</pre></div>
<p>
</p>
<p>



This function returns the theoretical maximum graph centrality
based on vertex betweenness.

</p>
<p>
There are two ways to call this function, the first is to supply a
graph as the <code class="literal"> graph</code>  argument, and then the number of
vertices is taken from this object, and its directedness is
considered as well. The <code class="literal"> nodes</code>  argument is ignored in
this case. The <code class="literal"> directed</code>  argument is also ignored if the
supplied graph is undirected.

</p>
<p>
The other way is to supply a null pointer as the <code class="literal"> graph</code> 
argument. In this case the <code class="literal"> nodes</code>  and <code class="literal"> directed</code> 
arguments are considered.

</p>
<p>
The most centralized structure is the star.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  A graph object or a null pointer, see the description
    above.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of nodes. This is ignored if the
    <code class="literal"> graph</code>  argument is not a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean scalar, whether to use directed paths in
    the betweenness calculation. This argument is ignored if
    <code class="literal"> graph</code>  is not a null pointer and it is undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization_betweenness" title="10.3. igraph_centralization_betweenness — Calculate vertex betweenness and graph centralization"><code class="function">igraph_centralization_betweenness()</code></a> and <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_closeness_tmax"></a>10.8. <code class="function">igraph_centralization_closeness_tmax</code> — Theoretical maximum for graph centralization based on closeness</h3></div></div></div>
<a class="indexterm" name="idp105545273991240"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_centralization_closeness_tmax(const igraph_t *graph,
        igraph_integer_t nodes,
        igraph_neimode_t mode,
        igraph_real_t *res);
</pre></div>
<p>
</p>
<p>



This function returns the theoretical maximum graph centrality
based on vertex closeness.

</p>
<p>
There are two ways to call this function, the first is to supply a
graph as the <code class="literal"> graph</code>  argument, and then the number of
vertices is taken from this object, and its directedness is
considered as well. The <code class="literal"> nodes</code>  argument is ignored in
this case. The <code class="literal"> mode</code>  argument is also ignored if the
supplied graph is undirected.

</p>
<p>
The other way is to supply a null pointer as the <code class="literal"> graph</code> 
argument. In this case the <code class="literal"> nodes</code>  and <code class="literal"> mode</code> 
arguments are considered.

</p>
<p>
The most centralized structure is the star.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  A graph object or a null pointer, see the description
    above.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of nodes. This is ignored if the
    <code class="literal"> graph</code>  argument is not a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant, specifies what kinf of distances to consider
    to calculate closeness. See the <code class="literal"> mode</code>  argument of
    <a class="link" href="igraph-Structural.html#igraph_closeness" title="8.1. igraph_closeness — Closeness centrality calculations for some vertices."><code class="function">igraph_closeness()</code></a> for details. This argument is ignored
    if <code class="literal"> graph</code>  is not a null pointer and it is
    undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization_closeness" title="10.4. igraph_centralization_closeness — Calculate vertex closeness and graph centralization"><code class="function">igraph_centralization_closeness()</code></a> and <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_centralization_eigenvector_centrality_tmax"></a>10.9. <code class="function">igraph_centralization_eigenvector_centrality_tmax</code> — Theoretical maximum centralization for eigenvector centrality</h3></div></div></div>
<a class="indexterm" name="idp105545273882696"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_centralization_eigenvector_centrality_tmax(
    const igraph_t *graph,
    igraph_integer_t nodes,
    igraph_bool_t directed,
    igraph_bool_t scale,
    igraph_real_t *res);
</pre></div>
<p>
</p>
<p>



This function returns the theoretical maximum graph centrality
based on vertex eigenvector centrality.

</p>
<p>
There are two ways to call this function, the first is to supply a
graph as the <code class="literal"> graph</code>  argument, and then the number of
vertices is taken from this object, and its directedness is
considered as well. The <code class="literal"> nodes</code>  argument is ignored in
this case. The <code class="literal"> directed</code>  argument is also ignored if the
supplied graph is undirected.

</p>
<p>
The other way is to supply a null pointer as the <code class="literal"> graph</code> 
argument. In this case the <code class="literal"> nodes</code>  and <code class="literal"> directed</code> 
arguments are considered.

</p>
<p>
The most centralized directed structure is the in-star. The most
centralized undirected structure is the graph with a single edge.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  A graph object or a null pointer, see the description
    above.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of nodes. This is ignored if the
    <code class="literal"> graph</code>  argument is not a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean scalar, whether to consider edge
    directions. This argument is ignored if
    <code class="literal"> graph</code>  is not a null pointer and it is undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scale</code></em>:</span></p></td>
<td><p>
  Whether to rescale the node-level centrality scores to
    have a maximum of one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_centralization_closeness" title="10.4. igraph_centralization_closeness — Calculate vertex closeness and graph centralization"><code class="function">igraph_centralization_closeness()</code></a> and <a class="link" href="igraph-Structural.html#igraph_centralization" title="10.1. igraph_centralization — Calculate the centralization score from the node level scores"><code class="function">igraph_centralization()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="similarity-measures"></a>11. Similarity Measures</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_bibcoupling">11.1. <code class="function">igraph_bibcoupling</code> —  Bibliographic coupling.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_cocitation">11.2. <code class="function">igraph_cocitation</code> —  Cocitation coupling.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_jaccard">11.3. <code class="function">igraph_similarity_jaccard</code> —  Jaccard similarity coefficient for the given vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_jaccard_pairs">11.4. <code class="function">igraph_similarity_jaccard_pairs</code> —  Jaccard similarity coefficient for given vertex pairs.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_jaccard_es">11.5. <code class="function">igraph_similarity_jaccard_es</code> —  Jaccard similarity coefficient for a given edge selector.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_dice">11.6. <code class="function">igraph_similarity_dice</code> —  Dice similarity coefficient.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_dice_pairs">11.7. <code class="function">igraph_similarity_dice_pairs</code> —  Dice similarity coefficient for given vertex pairs.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_dice_es">11.8. <code class="function">igraph_similarity_dice_es</code> —  Dice similarity coefficient for a given edge selector.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_similarity_inverse_log_weighted">11.9. <code class="function">igraph_similarity_inverse_log_weighted</code> —  Vertex similarity based on the inverse logarithm of vertex degrees.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bibcoupling"></a>11.1. <code class="function">igraph_bibcoupling</code> —  Bibliographic coupling.</h3></div></div></div>
<a class="indexterm" name="idp105545273906120"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_bibcoupling(const igraph_t *graph, igraph_matrix_t *res,
                       const igraph_vs_t vids);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The bibliographic coupling of two vertices is the number
of other vertices they both cite, <a class="link" href="igraph-Structural.html#igraph_bibcoupling" title="11.1. igraph_bibcoupling — Bibliographic coupling."><code class="function">igraph_bibcoupling()</code></a> calculates
this.
The bibliographic coupling  score for each given vertex and all
other vertices in the graph will be calculated.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a matrix, the result of the calculation will
       be stored here. The number of its rows is the same as the
       number of vertex ids in <em class="parameter"><code>vids</code></em>, the number of
       columns is the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex ids of the vertices for which the
       calculation will be done.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVVID</code>: invalid vertex id.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|d^2),
|V| is the number of vertices in
the graph, d is the (maximum)
degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_cocitation" title="11.2. igraph_cocitation — Cocitation coupling."><code class="function">igraph_cocitation()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545273920840"></a><p class="title"><b>Example 13.16.  File <code class="code">examples/simple/igraph_cocitation.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2020  The igraph development team </em></span>&lt;igraph@igraph.org&gt;

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program.  If not, see </em></span>&lt;https://www.gnu.org/licenses/&gt;<span class="emphasis"><em>.</em></span>
<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    igraph_matrix_t matrix;

    <span class="emphasis"><em>/* Create a small test graph. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="emphasis"><em>/* As usual with igraph functions, the data structure in which the result</em></span>
<span class="emphasis"><em>       will be returned must be initialized in advance. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;matrix, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_bibcoupling" title="11.1. igraph_bibcoupling — Bibliographic coupling.">igraph_bibcoupling</a></strong></span>(&amp;graph, &amp;matrix, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>());
    <span class="strong"><strong>printf</strong></span>("Bibliographic coupling matrix:\n");
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;matrix);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_cocitation" title="11.2. igraph_cocitation — Cocitation coupling.">igraph_cocitation</a></strong></span>(&amp;graph, &amp;matrix, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>());
    <span class="strong"><strong>printf</strong></span>("\nCocitation matrix:\n");
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;matrix);

    <span class="emphasis"><em>/* Destroy data structures when we are done with them. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;matrix);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_cocitation"></a>11.2. <code class="function">igraph_cocitation</code> —  Cocitation coupling.</h3></div></div></div>
<a class="indexterm" name="idp105545273942344"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_cocitation(const igraph_t *graph, igraph_matrix_t *res,
                      const igraph_vs_t vids);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Two vertices are cocited if there is another vertex citing both of
them. <a class="link" href="igraph-Structural.html#igraph_cocitation" title="11.2. igraph_cocitation — Cocitation coupling."><code class="function">igraph_cocitation()</code></a> simply counts how many times two vertices are
cocited.
The cocitation score for each given vertex and all other vertices
in the graph will be calculated.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a matrix, the result of the calculation will
       be stored here. The number of its rows is the same as the
       number of vertex ids in <em class="parameter"><code>vids</code></em>, the number of
       columns is the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex ids of the vertices for which the
       calculation will be done.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVVID</code>: invalid vertex id.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|d^2), |V| is
the number of vertices in the graph,
d is the (maximum) degree of
the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_bibcoupling" title="11.1. igraph_bibcoupling — Bibliographic coupling."><code class="function">igraph_bibcoupling()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545273563848"></a><p class="title"><b>Example 13.17.  File <code class="code">examples/simple/igraph_cocitation.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2020  The igraph development team </em></span>&lt;igraph@igraph.org&gt;

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program.  If not, see </em></span>&lt;https://www.gnu.org/licenses/&gt;<span class="emphasis"><em>.</em></span>
<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    igraph_matrix_t matrix;

    <span class="emphasis"><em>/* Create a small test graph. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="emphasis"><em>/* As usual with igraph functions, the data structure in which the result</em></span>
<span class="emphasis"><em>       will be returned must be initialized in advance. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;matrix, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_bibcoupling" title="11.1. igraph_bibcoupling — Bibliographic coupling.">igraph_bibcoupling</a></strong></span>(&amp;graph, &amp;matrix, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>());
    <span class="strong"><strong>printf</strong></span>("Bibliographic coupling matrix:\n");
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;matrix);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_cocitation" title="11.2. igraph_cocitation — Cocitation coupling.">igraph_cocitation</a></strong></span>(&amp;graph, &amp;matrix, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>());
    <span class="strong"><strong>printf</strong></span>("\nCocitation matrix:\n");
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;matrix);

    <span class="emphasis"><em>/* Destroy data structures when we are done with them. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;matrix);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_jaccard"></a>11.3. <code class="function">igraph_similarity_jaccard</code> —  Jaccard similarity coefficient for the given vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545273585352"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_similarity_jaccard(const igraph_t *graph, igraph_matrix_t *res,
                              const igraph_vs_t vids, igraph_neimode_t mode, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The Jaccard similarity coefficient of two vertices is the number of common
neighbors divided by the number of vertices that are neighbors of at
least one of the two vertices being considered. This function calculates
the pairwise Jaccard similarities for some (or all) of the vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a matrix, the result of the calculation will
       be stored here. The number of its rows and columns is the same
       as the number of vertex ids in <em class="parameter"><code>vids</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex ids of the vertices for which the
       calculation will be done.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to include the vertices themselves in the neighbor
       sets.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex id passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^2 d),
|V| is the number of vertices in the vertex iterator given, d is the
(maximum) degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="11.6. igraph_similarity_dice — Dice similarity coefficient."><code class="function">igraph_similarity_dice()</code></a>, a measure very similar to the Jaccard
  coefficient
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545273608520"></a><p class="title"><b>Example 13.18.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_matrix</strong></span>(igraph_matrix_t *m, FILE *f) {
    long int i, j;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(m); i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(m); j++) {
            <span class="strong"><strong>fprintf</strong></span>(f, " %.2f", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
        }
        <span class="strong"><strong>fprintf</strong></span>(f, "\n");
    }
    <span class="strong"><strong>fprintf</strong></span>(f, "==========\n");
}

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="11.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="11.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="11.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="11.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="11.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_seq" title="4.5. igraph_vss_seq — An interval of vertices (immediate version).">igraph_vss_seq</a></strong></span>(1, 2), IGRAPH_ALL, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_jaccard_pairs"></a>11.4. <code class="function">igraph_similarity_jaccard_pairs</code> —  Jaccard similarity coefficient for given vertex pairs.</h3></div></div></div>
<a class="indexterm" name="idp105545273712584"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_similarity_jaccard_pairs(const igraph_t *graph, igraph_vector_t *res,
                                    const igraph_vector_t *pairs, igraph_neimode_t mode, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The Jaccard similarity coefficient of two vertices is the number of common
neighbors divided by the number of vertices that are neighbors of at
least one of the two vertices being considered. This function calculates
the pairwise Jaccard similarities for a list of vertex pairs.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result of the calculation will
       be stored here. The number of elements is the same as the number
       of pairs in <em class="parameter"><code>pairs</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pairs</code></em>:</span></p></td>
<td><p>
  A vector that contains the pairs for which the similarity
       will be calculated. Each pair is defined by two consecutive elements,
       i.e. the first and second element of the vector specifies the first
       pair, the third and fourth element specifies the second pair and so on.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to include the vertices themselves in the neighbor
       sets.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex id passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nd), n is the number of pairs in the given vector, d is
the (maximum) degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices."><code class="function">igraph_similarity_jaccard()</code></a> to calculate the Jaccard similarity
  between all pairs of a vertex set, or <a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="11.6. igraph_similarity_dice — Dice similarity coefficient."><code class="function">igraph_similarity_dice()</code></a> and
  <a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="11.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs."><code class="function">igraph_similarity_dice_pairs()</code></a> for a measure very similar to the
  Jaccard coefficient
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545273737288"></a><p class="title"><b>Example 13.19.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_matrix</strong></span>(igraph_matrix_t *m, FILE *f) {
    long int i, j;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(m); i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(m); j++) {
            <span class="strong"><strong>fprintf</strong></span>(f, " %.2f", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
        }
        <span class="strong"><strong>fprintf</strong></span>(f, "\n");
    }
    <span class="strong"><strong>fprintf</strong></span>(f, "==========\n");
}

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="11.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="11.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="11.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="11.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="11.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_seq" title="4.5. igraph_vss_seq — An interval of vertices (immediate version).">igraph_vss_seq</a></strong></span>(1, 2), IGRAPH_ALL, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_jaccard_es"></a>11.5. <code class="function">igraph_similarity_jaccard_es</code> —  Jaccard similarity coefficient for a given edge selector.</h3></div></div></div>
<a class="indexterm" name="idp105545273317064"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_similarity_jaccard_es(const igraph_t *graph, igraph_vector_t *res,
                                 const igraph_es_t es, igraph_neimode_t mode, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The Jaccard similarity coefficient of two vertices is the number of common
neighbors divided by the number of vertices that are neighbors of at
least one of the two vertices being considered. This function calculates
the pairwise Jaccard similarities for the endpoints of edges in a given edge
selector.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result of the calculation will
       be stored here. The number of elements is the same as the number
       of edges in <em class="parameter"><code>es</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>es</code></em>:</span></p></td>
<td><p>
  An edge selector that specifies the edges to be included in the
       result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to include the vertices themselves in the neighbor
       sets.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex id passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nd), n is the number of edges in the edge selector, d is
the (maximum) degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices."><code class="function">igraph_similarity_jaccard()</code></a> and <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="11.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs."><code class="function">igraph_similarity_jaccard_pairs()</code></a>
  to calculate the Jaccard similarity between all pairs of a vertex set or
  some selected vertex pairs, or <a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="11.6. igraph_similarity_dice — Dice similarity coefficient."><code class="function">igraph_similarity_dice()</code></a>,
  <a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="11.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs."><code class="function">igraph_similarity_dice_pairs()</code></a> and <a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="11.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector."><code class="function">igraph_similarity_dice_es()</code></a> for a
  measure very similar to the Jaccard coefficient
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545273343304"></a><p class="title"><b>Example 13.20.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_matrix</strong></span>(igraph_matrix_t *m, FILE *f) {
    long int i, j;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(m); i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(m); j++) {
            <span class="strong"><strong>fprintf</strong></span>(f, " %.2f", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
        }
        <span class="strong"><strong>fprintf</strong></span>(f, "\n");
    }
    <span class="strong"><strong>fprintf</strong></span>(f, "==========\n");
}

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="11.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="11.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="11.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="11.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="11.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_seq" title="4.5. igraph_vss_seq — An interval of vertices (immediate version).">igraph_vss_seq</a></strong></span>(1, 2), IGRAPH_ALL, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_dice"></a>11.6. <code class="function">igraph_similarity_dice</code> —  Dice similarity coefficient.</h3></div></div></div>
<a class="indexterm" name="idp105545273447368"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_similarity_dice(const igraph_t *graph, igraph_matrix_t *res,
                           const igraph_vs_t vids, igraph_neimode_t mode, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The Dice similarity coefficient of two vertices is twice the number of common
neighbors divided by the sum of the degrees of the vertices. This function
calculates the pairwise Dice similarities for some (or all) of the vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a matrix, the result of the calculation will
       be stored here. The number of its rows and columns is the same
       as the number of vertex ids in <em class="parameter"><code>vids</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex ids of the vertices for which the
       calculation will be done.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to include the vertices themselves as their own
       neighbors.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex id passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^2 d),
|V| is the number of vertices in the vertex iterator given, d is the
(maximum) degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices."><code class="function">igraph_similarity_jaccard()</code></a>, a measure very similar to the Dice
  coefficient
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545273470536"></a><p class="title"><b>Example 13.21.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_matrix</strong></span>(igraph_matrix_t *m, FILE *f) {
    long int i, j;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(m); i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(m); j++) {
            <span class="strong"><strong>fprintf</strong></span>(f, " %.2f", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
        }
        <span class="strong"><strong>fprintf</strong></span>(f, "\n");
    }
    <span class="strong"><strong>fprintf</strong></span>(f, "==========\n");
}

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="11.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="11.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="11.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="11.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="11.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_seq" title="4.5. igraph_vss_seq — An interval of vertices (immediate version).">igraph_vss_seq</a></strong></span>(1, 2), IGRAPH_ALL, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_dice_pairs"></a>11.7. <code class="function">igraph_similarity_dice_pairs</code> —  Dice similarity coefficient for given vertex pairs.</h3></div></div></div>
<a class="indexterm" name="idp105545273050312"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_similarity_dice_pairs(const igraph_t *graph, igraph_vector_t *res,
                                 const igraph_vector_t *pairs, igraph_neimode_t mode, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The Dice similarity coefficient of two vertices is twice the number of common
neighbors divided by the sum of the degrees of the vertices. This function
calculates the pairwise Dice similarities for a list of vertex pairs.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result of the calculation will
       be stored here. The number of elements is the same as the number
       of pairs in <em class="parameter"><code>pairs</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pairs</code></em>:</span></p></td>
<td><p>
  A vector that contains the pairs for which the similarity
       will be calculated. Each pair is defined by two consecutive elements,
       i.e. the first and second element of the vector specifies the first
       pair, the third and fourth element specifies the second pair and so on.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to include the vertices themselves as their own
       neighbors.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex id passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nd), n is the number of pairs in the given vector, d is
the (maximum) degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="11.6. igraph_similarity_dice — Dice similarity coefficient."><code class="function">igraph_similarity_dice()</code></a> to calculate the Dice similarity
  between all pairs of a vertex set, or <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices."><code class="function">igraph_similarity_jaccard()</code></a>,
  <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="11.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs."><code class="function">igraph_similarity_jaccard_pairs()</code></a> and <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="11.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector."><code class="function">igraph_similarity_jaccard_es()</code></a>
  for a measure very similar to the Dice coefficient
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545273075784"></a><p class="title"><b>Example 13.22.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_matrix</strong></span>(igraph_matrix_t *m, FILE *f) {
    long int i, j;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(m); i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(m); j++) {
            <span class="strong"><strong>fprintf</strong></span>(f, " %.2f", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
        }
        <span class="strong"><strong>fprintf</strong></span>(f, "\n");
    }
    <span class="strong"><strong>fprintf</strong></span>(f, "==========\n");
}

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="11.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="11.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="11.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="11.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="11.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_seq" title="4.5. igraph_vss_seq — An interval of vertices (immediate version).">igraph_vss_seq</a></strong></span>(1, 2), IGRAPH_ALL, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_dice_es"></a>11.8. <code class="function">igraph_similarity_dice_es</code> —  Dice similarity coefficient for a given edge selector.</h3></div></div></div>
<a class="indexterm" name="idp105545273179848"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_similarity_dice_es(const igraph_t *graph, igraph_vector_t *res,
                              const igraph_es_t es, igraph_neimode_t mode, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The Dice similarity coefficient of two vertices is twice the number of common
neighbors divided by the sum of the degrees of the vertices. This function
calculates the pairwise Dice similarities for the endpoints of edges in a given
edge selector.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result of the calculation will
       be stored here. The number of elements is the same as the number
       of edges in <em class="parameter"><code>es</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>es</code></em>:</span></p></td>
<td><p>
  An edge selector that specifies the edges to be included in the
       result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to include the vertices themselves as their own
       neighbors.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          not enough memory for temporary data.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid vertex id passed.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nd), n is the number of pairs in the given vector, d is
the (maximum) degree of the vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="11.6. igraph_similarity_dice — Dice similarity coefficient."><code class="function">igraph_similarity_dice()</code></a> and <a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="11.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs."><code class="function">igraph_similarity_dice_pairs()</code></a>
  to calculate the Dice similarity between all pairs of a vertex set or
  some selected vertex pairs, or <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices."><code class="function">igraph_similarity_jaccard()</code></a>,
  <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="11.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs."><code class="function">igraph_similarity_jaccard_pairs()</code></a> and <a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="11.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector."><code class="function">igraph_similarity_jaccard_es()</code></a>
  for a measure very similar to the Dice coefficient
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545273206088"></a><p class="title"><b>Example 13.23.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_matrix</strong></span>(igraph_matrix_t *m, FILE *f) {
    long int i, j;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(m); i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(m); j++) {
            <span class="strong"><strong>fprintf</strong></span>(f, " %.2f", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
        }
        <span class="strong"><strong>fprintf</strong></span>(f, "\n");
    }
    <span class="strong"><strong>fprintf</strong></span>(f, "==========\n");
}

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="11.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="11.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="11.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="11.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="11.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_seq" title="4.5. igraph_vss_seq — An interval of vertices (immediate version).">igraph_vss_seq</a></strong></span>(1, 2), IGRAPH_ALL, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_similarity_inverse_log_weighted"></a>11.9. <code class="function">igraph_similarity_inverse_log_weighted</code> —  Vertex similarity based on the inverse logarithm of vertex degrees.</h3></div></div></div>
<a class="indexterm" name="idp105545270688712"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_similarity_inverse_log_weighted(const igraph_t *graph,
        igraph_matrix_t *res, const igraph_vs_t vids, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The inverse log-weighted similarity of two vertices is the number of
their common neighbors, weighted by the inverse logarithm of their degrees.
It is based on the assumption that two vertices should be considered
more similar if they share a low-degree common neighbor, since high-degree
common neighbors are more likely to appear even by pure chance.

</p>
<p>
Isolated vertices will have zero similarity to any other vertex.
Self-similarities are not calculated.

</p>
<p>
See the following paper for more details: Lada A. Adamic and Eytan Adar:
Friends and neighbors on the Web. Social Networks, 25(3):211-230, 2003.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a matrix, the result of the calculation will
       be stored here. The number of its rows is the same as the
       number of vertex ids in <em class="parameter"><code>vids</code></em>, the number of
       columns is the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertex ids of the vertices for which the
       calculation will be done.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The type of neighbors to be used for the calculation in
       directed graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         the outgoing edges will be considered for each node. Nodes
         will be weighted according to their in-degree.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         the incoming edges will be considered for each node. Nodes
         will be weighted according to their out-degree.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         the directed graph is considered as an undirected one for the
         computation. Every node is weighted according to its undirected
         degree.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVVID</code>: invalid vertex id.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|d^2),
|V| is the number of vertices in
the graph, d is the (maximum)
degree of the vertices in the graph.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545270704968"></a><p class="title"><b>Example 13.24.  File <code class="code">examples/simple/igraph_similarity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_matrix</strong></span>(igraph_matrix_t *m, FILE *f) {
    long int i, j;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(m); i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(m); j++) {
            <span class="strong"><strong>fprintf</strong></span>(f, " %.2f", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
        }
        <span class="strong"><strong>fprintf</strong></span>(f, "\n");
    }
    <span class="strong"><strong>fprintf</strong></span>(f, "==========\n");
}

int <span class="strong"><strong>check_jaccard_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                      igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_pairs" title="11.4. igraph_similarity_jaccard_pairs — Jaccard similarity coefficient for given vertex pairs.">igraph_similarity_jaccard_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard_es" title="11.5. igraph_similarity_jaccard_es — Jaccard similarity coefficient for a given edge selector.">igraph_similarity_jaccard_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Jaccard similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>check_dice_all</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t* g, igraph_matrix_t* m,
                   igraph_neimode_t mode, igraph_bool_t loops) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> pairs, res;
    long int i, j, k, n;
    igraph_eit_t eit;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* First, query the similarities for all the vertices to a matrix */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice" title="11.6. igraph_similarity_dice — Dice similarity coefficient.">igraph_similarity_dice</a></strong></span>(g, m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), mode, loops);

    <span class="emphasis"><em>/* Second, query the similarities for all pairs using a pair vector */</em></span>
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;pairs, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, i);
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(&amp;pairs, j);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_pairs" title="11.7. igraph_similarity_dice_pairs — Dice similarity coefficient for given vertex pairs.">igraph_similarity_dice_pairs</a></strong></span>(g, &amp;res, &amp;pairs, mode, loops);
    <span class="strong"><strong>for</strong></span> (i = 0, k = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = n - 1; j &gt;= 0; j--, k++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
                <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for vertex pair %ld-%ld "
                        "does not match the value in the full matrix (%.6f vs %.6f)\n",
                        i, j, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
                <span class="strong"><strong>return</strong></span> 1;
            }
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;pairs);

    <span class="emphasis"><em>/* Third, query the similarities for all edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_dice_es" title="11.8. igraph_similarity_dice_es — Dice similarity coefficient for a given edge selector.">igraph_similarity_dice_es</a></strong></span>(g, &amp;res, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), mode, loops);
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_FROM), &amp;eit);
    k = 0;
    <span class="strong"><strong>while</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit)) {
        long int eid = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        i = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="2.2.4. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(g, eid);
        j = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="2.2.5. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(g, eid);
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j)) &gt; 1e-6) {
            <span class="strong"><strong>fprintf</strong></span>(stderr, "Dice similarity calculation for edge %ld-%ld (ID=%ld) "
                    "does not match the value in the full matrix (%.6f vs %.6f)\n",
                    i, j, eid, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[k], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*m, i, j));
            <span class="strong"><strong>return</strong></span> 1;
        }
        <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit);
        k++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t m;
    int ret;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 0, 3, 0,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 0, 0);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_jaccard" title="11.3. igraph_similarity_jaccard — Jaccard similarity coefficient for the given vertices.">igraph_similarity_jaccard</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_seq" title="4.5. igraph_vss_seq — An interval of vertices (immediate version).">igraph_vss_seq</a></strong></span>(1, 2), IGRAPH_ALL, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    ret = <span class="strong"><strong>check_jaccard_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_ALL, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_OUT, 1);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    ret = <span class="strong"><strong>check_dice_all</strong></span>(&amp;g, &amp;m, IGRAPH_IN, 0);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);
    <span class="strong"><strong>if</strong></span> (ret) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_similarity_inverse_log_weighted" title="11.9. igraph_similarity_inverse_log_weighted — Vertex similarity based on the inverse logarithm of vertex degrees.">igraph_similarity_inverse_log_weighted</a></strong></span>(&amp;g, &amp;m, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN);
    <span class="strong"><strong>print_matrix</strong></span>(&amp;m, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="trees"></a>12. Trees</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_minimum_spanning_tree">12.1. <code class="function">igraph_minimum_spanning_tree</code> —  Calculates one minimum spanning tree of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_minimum_spanning_tree_unweighted">12.2. <code class="function">igraph_minimum_spanning_tree_unweighted</code> —  Calculates one minimum spanning tree of an unweighted graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_minimum_spanning_tree_prim">12.3. <code class="function">igraph_minimum_spanning_tree_prim</code> —  Calculates one minimum spanning tree of a weighted graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_random_spanning_tree">12.4. <code class="function">igraph_random_spanning_tree</code> —  Uniformly sample the spanning trees of a graph</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_tree">12.5. <code class="function">igraph_is_tree</code> —  Decides whether the graph is a tree.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_to_prufer">12.6. <code class="function">igraph_to_prufer</code> —  Converts a tree to its Prüfer sequence</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_minimum_spanning_tree"></a>12.1. <code class="function">igraph_minimum_spanning_tree</code> —  Calculates one minimum spanning tree of a graph.</h3></div></div></div>
<a class="indexterm" name="idp105545270809800"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_minimum_spanning_tree(const igraph_t* graph,
                                 igraph_vector_t* res, const igraph_vector_t* weights);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If the graph has more minimum spanning trees (this is always the
case, except if it is a forest) this implementation returns only
the same one.

</p>
<p>
Directed graphs are considered as undirected for this computation.

</p>
<p>
If the graph is not connected then its minimum spanning forest is
returned. This is the set of the minimum spanning trees of each
component.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the IDs of the edges that constitute
       a spanning tree will be returned here. Use
       <a class="link" href="igraph-Operators.html#igraph_subgraph_edges" title="3.6. igraph_subgraph_edges — Creates a subgraph with the specified edges and their endpoints."><code class="function">igraph_subgraph_edges()</code></a> to extract the spanning tree as
       a separate graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A vector containing the weights of the edges
       in the same order as the simple edge iterator visits them
       (i.e. in increasing order of edge IDs).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
        temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|) for the unweighted case, O(|E| log |V|)
for the weighted case. |V| is the number of vertices, |E| the
number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree_unweighted" title="12.2. igraph_minimum_spanning_tree_unweighted — Calculates one minimum spanning tree of an unweighted graph."><code class="function">igraph_minimum_spanning_tree_unweighted()</code></a> and
    <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree_prim" title="12.3. igraph_minimum_spanning_tree_prim — Calculates one minimum spanning tree of a weighted graph."><code class="function">igraph_minimum_spanning_tree_prim()</code></a> if you only need the
    tree as a separate graph object.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545270825288"></a><p class="title"><b>Example 13.25.  File <code class="code">examples/simple/igraph_minimum_spanning_tree.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g, tree;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> eb, edges;
    long int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED,
                 0,  1,  0,  2,  0,  3,  0,  4,  0,  5,
                 0,  6,  0,  7,  0,  8,  0, 10,  0, 11,
                 0, 12,  0, 13,  0, 17,  0, 19,  0, 21,
                 0, 31,  1,  2,  1,  3,  1,  7,  1, 13,
                 1, 17,  1, 19,  1, 21,  1, 30,  2,  3,
                 2,  7,  2,  8,  2,  9,  2, 13,  2, 27,
                 2, 28,  2, 32,  3,  7,  3, 12,  3, 13,
                 4,  6,  4, 10,  5,  6,  5, 10,  5, 16,
                 6, 16,  8, 30,  8, 32,  8, 33,  9, 33,
                 13, 33, 14, 32, 14, 33, 15, 32, 15, 33,
                 18, 32, 18, 33, 19, 33, 20, 32, 20, 33,
                 22, 32, 22, 33, 23, 25, 23, 27, 23, 29,
                 23, 32, 23, 33, 24, 25, 24, 27, 24, 31,
                 25, 31, 26, 29, 26, 33, 27, 33, 28, 31,
                 28, 33, 29, 32, 29, 33, 30, 32, 30, 33,
                 31, 32, 31, 33, 32, 33,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;eb, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_edge_betweenness" title="8.4. igraph_edge_betweenness — Betweenness centrality of the edges.">igraph_edge_betweenness</a></strong></span>(&amp;g, &amp;eb, IGRAPH_UNDIRECTED, <span class="emphasis"><em>/*weights=*/</em></span> 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;eb); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(eb)[i] = -<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(eb)[i];
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree_prim" title="12.3. igraph_minimum_spanning_tree_prim — Calculates one minimum spanning tree of a weighted graph.">igraph_minimum_spanning_tree_prim</a></strong></span>(&amp;g, &amp;tree, &amp;eb);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;tree, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;edges, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree" title="12.1. igraph_minimum_spanning_tree — Calculates one minimum spanning tree of a graph.">igraph_minimum_spanning_tree</a></strong></span>(&amp;g, &amp;edges, &amp;eb);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;edges);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;edges);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;tree);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;eb);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_minimum_spanning_tree_unweighted"></a>12.2. <code class="function">igraph_minimum_spanning_tree_unweighted</code> —  Calculates one minimum spanning tree of an unweighted graph.</h3></div></div></div>
<a class="indexterm" name="idp105545270850760"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_minimum_spanning_tree_unweighted(const igraph_t *graph,
        igraph_t *mst);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If the graph has more minimum spanning trees (this is always the
case, except if it is a forest) this implementation returns only
the same one.

</p>
<p>
Directed graphs are considered as undirected for this computation.

</p>
<p>
If the graph is not connected then its minimum spanning forest is
returned. This is the set of the minimum spanning trees of each
component.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mst</code></em>:</span></p></td>
<td><p>
  The minimum spanning tree, another graph object. Do
       <span class="emphasis"><em>not</em></span> initialize this object before passing it to
       this function, but be sure to call <a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object."><code class="function">igraph_destroy()</code></a> on it if
       you don't need it any more.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory for
        temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|),
|V| is the
number of vertices, |E| the number
of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree_prim" title="12.3. igraph_minimum_spanning_tree_prim — Calculates one minimum spanning tree of a weighted graph."><code class="function">igraph_minimum_spanning_tree_prim()</code></a> for weighted graphs,
    <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree" title="12.1. igraph_minimum_spanning_tree — Calculates one minimum spanning tree of a graph."><code class="function">igraph_minimum_spanning_tree()</code></a> if you need the IDs of the
    edges that constitute the spanning tree.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_minimum_spanning_tree_prim"></a>12.3. <code class="function">igraph_minimum_spanning_tree_prim</code> —  Calculates one minimum spanning tree of a weighted graph.</h3></div></div></div>
<a class="indexterm" name="idp105545270735432"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_minimum_spanning_tree_prim(const igraph_t *graph, igraph_t *mst,
                                      const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function uses Prim's method for carrying out the computation,
see Prim, R.C.: Shortest connection networks and some
generalizations, Bell System Technical
Journal, Vol. 36,
1957, 1389--1401.

</p>
<p>
If the graph has more than one minimum spanning tree, the current
implementation returns always the same one.

</p>
<p>
Directed graphs are considered as undirected for this computation.

</p>
<p>
If the graph is not connected then its minimum spanning forest is
returned. This is the set of the minimum spanning trees of each
component.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mst</code></em>:</span></p></td>
<td><p>
  The result of the computation, a graph object containing
       the minimum spanning tree of the graph.
       Do <span class="emphasis"><em>not</em></span> initialize this object before passing it to
       this function, but be sure to call <a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object."><code class="function">igraph_destroy()</code></a> on it if
       you don't need it any more.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A vector containing the weights of the edges
       in the same order as the simple edge iterator visits them
       (i.e. in increasing order of edge IDs).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>, not enough memory.
        <code class="constant">IGRAPH_EINVAL</code>, length of weight vector does not
          match number of edges.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E| log |V|),
|V| is the number of vertices,
|E| the number of edges in the
graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree_unweighted" title="12.2. igraph_minimum_spanning_tree_unweighted — Calculates one minimum spanning tree of an unweighted graph."><code class="function">igraph_minimum_spanning_tree_unweighted()</code></a> for unweighted graphs,
    <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree" title="12.1. igraph_minimum_spanning_tree — Calculates one minimum spanning tree of a graph."><code class="function">igraph_minimum_spanning_tree()</code></a> if you need the IDs of the
    edges that constitute the spanning tree.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545270752072"></a><p class="title"><b>Example 13.26.  File <code class="code">examples/simple/igraph_minimum_spanning_tree.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g, tree;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> eb, edges;
    long int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED,
                 0,  1,  0,  2,  0,  3,  0,  4,  0,  5,
                 0,  6,  0,  7,  0,  8,  0, 10,  0, 11,
                 0, 12,  0, 13,  0, 17,  0, 19,  0, 21,
                 0, 31,  1,  2,  1,  3,  1,  7,  1, 13,
                 1, 17,  1, 19,  1, 21,  1, 30,  2,  3,
                 2,  7,  2,  8,  2,  9,  2, 13,  2, 27,
                 2, 28,  2, 32,  3,  7,  3, 12,  3, 13,
                 4,  6,  4, 10,  5,  6,  5, 10,  5, 16,
                 6, 16,  8, 30,  8, 32,  8, 33,  9, 33,
                 13, 33, 14, 32, 14, 33, 15, 32, 15, 33,
                 18, 32, 18, 33, 19, 33, 20, 32, 20, 33,
                 22, 32, 22, 33, 23, 25, 23, 27, 23, 29,
                 23, 32, 23, 33, 24, 25, 24, 27, 24, 31,
                 25, 31, 26, 29, 26, 33, 27, 33, 28, 31,
                 28, 33, 29, 32, 29, 33, 30, 32, 30, 33,
                 31, 32, 31, 33, 32, 33,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;eb, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_edge_betweenness" title="8.4. igraph_edge_betweenness — Betweenness centrality of the edges.">igraph_edge_betweenness</a></strong></span>(&amp;g, &amp;eb, IGRAPH_UNDIRECTED, <span class="emphasis"><em>/*weights=*/</em></span> 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;eb); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(eb)[i] = -<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(eb)[i];
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree_prim" title="12.3. igraph_minimum_spanning_tree_prim — Calculates one minimum spanning tree of a weighted graph.">igraph_minimum_spanning_tree_prim</a></strong></span>(&amp;g, &amp;tree, &amp;eb);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;tree, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;edges, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree" title="12.1. igraph_minimum_spanning_tree — Calculates one minimum spanning tree of a graph.">igraph_minimum_spanning_tree</a></strong></span>(&amp;g, &amp;edges, &amp;eb);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;edges);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;edges);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;tree);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;eb);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_random_spanning_tree"></a>12.4. <code class="function">igraph_random_spanning_tree</code> —  Uniformly sample the spanning trees of a graph</h3></div></div></div>
<a class="indexterm" name="idp105545270777544"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_random_spanning_tree(const igraph_t *graph, igraph_vector_t *res, igraph_integer_t vid);
</pre></div>
<p>
</p>
<p>



Performs a loop-erased random walk on the graph to uniformly sample
its spanning trees. Edge directions are ignored.
</p>
<p>

Multi-graphs are supported, and edge multiplicities will affect the sampling
frequency. For example, consider the 3-cycle graph <code class="literal"> 1=2-3-1</code> , with two edges
between vertices 1 and 2. Due to these parallel edges, the trees <code class="literal"> 1-2-3</code> 
and <code class="literal"> 3-1-2</code>  will be sampled with multiplicity 2, while the tree
<code class="literal"> 2-3-1</code>  will be sampled with multiplicity 1.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Edge directions are ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the IDs of the edges that constitute
       a spanning tree will be returned here. Use
       <a class="link" href="igraph-Operators.html#igraph_subgraph_edges" title="3.6. igraph_subgraph_edges — Creates a subgraph with the specified edges and their endpoints."><code class="function">igraph_subgraph_edges()</code></a> to extract the spanning tree as
       a separate graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vid</code></em>:</span></p></td>
<td><p>
  This parameter is relevant if the graph is not connected.
       If negative, a random spanning forest of all components will be
       generated. Otherwise, it should be the ID of a vertex. A random
       spanning tree of the component containing the vertex will be
       generated.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_minimum_spanning_tree" title="12.1. igraph_minimum_spanning_tree — Calculates one minimum spanning tree of a graph."><code class="function">igraph_minimum_spanning_tree()</code></a>, <a class="link" href="igraph-Visitors.html#igraph_random_walk" title="3.1. igraph_random_walk — Perform a random walk on a graph"><code class="function">igraph_random_walk()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_tree"></a>12.5. <code class="function">igraph_is_tree</code> —  Decides whether the graph is a tree.</h3></div></div></div>
<a class="indexterm" name="idp105545270795720"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_tree(const igraph_t *graph, igraph_bool_t *res, igraph_integer_t *root, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>




An undirected graph is a tree if it is connected and has no cycles.
</p>
<p>

In the directed case, a possible additional requirement is that all
edges are oriented away from a root (out-tree or arborescence) or all edges
are oriented towards a root (in-tree or anti-arborescence).
This test can be controlled using the <em class="parameter"><code>mode</code></em> parameter.
</p>
<p>

By convention, the null graph (i.e. the graph with no vertices) is considered not to be a tree.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to analyze.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a logical variable, the result will be stored
       here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>root</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code>, the root node will be stored here. When <em class="parameter"><code>mode</code></em>
       is <code class="constant">IGRAPH_ALL</code> or the graph is undirected, any vertex can be the root
       and <em class="parameter"><code>root</code></em> is set to 0 (the first vertex). When <em class="parameter"><code>mode</code></em> is <code class="constant">IGRAPH_OUT</code>
       or <code class="constant">IGRAPH_IN</code>, the root is set to the vertex with zero in- or out-degree,
       respectively.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For a directed graph this specifies whether to test for an
       out-tree, an in-tree or ignore edge directions. The respective
       possible values are:
       <code class="constant">IGRAPH_OUT</code>, <code class="constant">IGRAPH_IN</code>, <code class="constant">IGRAPH_ALL</code>. This argument is
       ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_EINVAL</code>: invalid mode argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: At most O(|V|+|E|), the
number of vertices plus the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  igraph_is_weakly_connected()
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545270421448"></a><p class="title"><b>Example 13.27.  File <code class="code">examples/simple/igraph_tree.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    igraph_bool_t res;

    <span class="emphasis"><em>/* Create a directed binary tree on 15 nodes,</em></span>
<span class="emphasis"><em>       with edges pointing towards the root. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_tree" title="1.9. igraph_tree — Creates a tree in which almost all vertices have the same number of children.">igraph_tree</a></strong></span>(&amp;graph, 15, 2, IGRAPH_TREE_IN);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_tree" title="12.5. igraph_is_tree — Decides whether the graph is a tree.">igraph_is_tree</a></strong></span>(&amp;graph, &amp;res, NULL, IGRAPH_IN);
    <span class="strong"><strong>printf</strong></span>("Is it an in-tree? %s\n", res ? "Yes" : "No");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_tree" title="12.5. igraph_is_tree — Decides whether the graph is a tree.">igraph_is_tree</a></strong></span>(&amp;graph, &amp;res, NULL, IGRAPH_OUT);
    <span class="strong"><strong>printf</strong></span>("Is it an out-tree? %s\n", res ? "Yes" : "No");

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_to_prufer"></a>12.6. <code class="function">igraph_to_prufer</code> —  Converts a tree to its Prüfer sequence</h3></div></div></div>
<a class="indexterm" name="idp105545270438344"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_to_prufer(const igraph_t *graph, igraph_vector_int_t* prufer);
</pre></div>
<p>
</p>
<p>




A Prüfer sequence is a unique sequence of integers associated
with a labelled tree. A tree on n &gt;= 2 vertices can be represented by a
sequence of n-2 integers, each between 0 and n-1 (inclusive).

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized graph object which
          must be a tree on n &gt;= 2 vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>prufer</code></em>:</span></p></td>
<td><p>
  A pointer to the integer vector that should hold the Prüfer sequence;
                 the vector must be initialized and will be resized to n - 2.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
         </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

            there is not enough memory to perform the operation.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

            the graph is not a tree or it is has less than vertices
         
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_from_prufer" title="1.16. igraph_from_prufer — Generates a tree from a Prüfer sequence."><code class="function">igraph_from_prufer()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="transitivity-or-clustering-coefficient"></a>13. Transitivity or Clustering Coefficient</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_transitivity_undirected">13.1. <code class="function">igraph_transitivity_undirected</code> —  Calculates the transitivity (clustering coefficient) of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_transitivity_local_undirected">13.2. <code class="function">igraph_transitivity_local_undirected</code> —  Calculates the local transitivity (clustering coefficient) of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_transitivity_avglocal_undirected">13.3. <code class="function">igraph_transitivity_avglocal_undirected</code> —  Average local transitivity (clustering coefficient).</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_transitivity_barrat">13.4. <code class="function">igraph_transitivity_barrat</code> — Weighted transitivity, as defined by A. Barrat.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_transitivity_undirected"></a>13.1. <code class="function">igraph_transitivity_undirected</code> —  Calculates the transitivity (clustering coefficient) of a graph.</h3></div></div></div>
<a class="indexterm" name="idp105545270454216"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_transitivity_undirected(const igraph_t *graph,
                                   igraph_real_t *res,
                                   igraph_transitivity_mode_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The transitivity measures the probability that two neighbors of a
vertex are connected. More precisely, this is the ratio of the
triangles and connected triples in the graph, the result is a
single real number. Directed graphs are considered as undirected ones.

</p>
<p>
Note that this measure is different from the local transitivity measure
(see <a class="link" href="igraph-Structural.html#igraph_transitivity_local_undirected" title="13.2. igraph_transitivity_local_undirected — Calculates the local transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_local_undirected()</code></a> ) as it calculates a single
value for the whole graph. See the following reference for more details:

</p>
<p>
S. Wasserman and K. Faust: Social Network Analysis: Methods and
Applications. Cambridge: Cambridge University Press, 1994.

</p>
<p>
Clustering coefficient is an alternative name for transitivity.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Defines how to treat graphs with no connected triples.
  <code class="constant">IGRAPH_TRANSITIVITY_NAN</code> returns <code class="constant">NaN</code> in this case,
  <code class="constant">IGRAPH_TRANSITIVITY_ZERO</code> returns zero.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>: not enough memory for
        temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_transitivity_local_undirected" title="13.2. igraph_transitivity_local_undirected — Calculates the local transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_local_undirected()</code></a>,
<a class="link" href="igraph-Structural.html#igraph_transitivity_avglocal_undirected" title="13.3. igraph_transitivity_avglocal_undirected — Average local transitivity (clustering coefficient)."><code class="function">igraph_transitivity_avglocal_undirected()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*d^2), |V| is the number of vertices in
the graph, d is the average node degree.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545270340040"></a><p class="title"><b>Example 13.28.  File <code class="code">examples/simple/igraph_transitivity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t res;

    <span class="emphasis"><em>/* Trivial cases */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 100, IGRAPH_UNDIRECTED, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="13.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph.">igraph_transitivity_undirected</a></strong></span>(&amp;g, &amp;res, IGRAPH_TRANSITIVITY_NAN);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (res != 0) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.10. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;g, 20, IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="13.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph.">igraph_transitivity_undirected</a></strong></span>(&amp;g, &amp;res, IGRAPH_TRANSITIVITY_NAN);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (res != 1) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="emphasis"><em>/* Degenerate cases */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED,
                 0,  1,  2,  3,  4,  5, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="13.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph.">igraph_transitivity_undirected</a></strong></span>(&amp;g, &amp;res, IGRAPH_TRANSITIVITY_NAN);
    <span class="emphasis"><em>/* res should be NaN here, any comparison must return false */</em></span>
    <span class="strong"><strong>if</strong></span> (res == 0 || res &gt; 0 || res &lt; 0) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="13.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph.">igraph_transitivity_undirected</a></strong></span>(&amp;g, &amp;res, IGRAPH_TRANSITIVITY_ZERO);
    <span class="emphasis"><em>/* res should be zero here */</em></span>
    <span class="strong"><strong>if</strong></span> (res) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Zachary Karate club */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED,
                 0,  1,  0,  2,  0,  3,  0,  4,  0,  5,
                 0,  6,  0,  7,  0,  8,  0, 10,  0, 11,
                 0, 12,  0, 13,  0, 17,  0, 19,  0, 21,
                 0, 31,  1,  2,  1,  3,  1,  7,  1, 13,
                 1, 17,  1, 19,  1, 21,  1, 30,  2,  3,
                 2,  7,  2,  8,  2,  9,  2, 13,  2, 27,
                 2, 28,  2, 32,  3,  7,  3, 12,  3, 13,
                 4,  6,  4, 10,  5,  6,  5, 10,  5, 16,
                 6, 16,  8, 30,  8, 32,  8, 33,  9, 33,
                 13, 33, 14, 32, 14, 33, 15, 32, 15, 33,
                 18, 32, 18, 33, 19, 33, 20, 32, 20, 33,
                 22, 32, 22, 33, 23, 25, 23, 27, 23, 29,
                 23, 32, 23, 33, 24, 25, 24, 27, 24, 31,
                 25, 31, 26, 29, 26, 33, 27, 33, 28, 31,
                 28, 33, 29, 32, 29, 33, 30, 32, 30, 33,
                 31, 32, 31, 33, 32, 33,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="13.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph.">igraph_transitivity_undirected</a></strong></span>(&amp;g, &amp;res, IGRAPH_TRANSITIVITY_NAN);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (res != 0.2556818181818181767717) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "%f != %f\n", res, 0.2556818181818181767717);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_transitivity_local_undirected"></a>13.2. <code class="function">igraph_transitivity_local_undirected</code> —  Calculates the local transitivity (clustering coefficient) of a graph.</h3></div></div></div>
<a class="indexterm" name="idp105545270369608"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_transitivity_local_undirected(const igraph_t *graph,
        igraph_vector_t *res,
        const igraph_vs_t vids,
        igraph_transitivity_mode_t mode);
</pre></div>
<p>
</p>
<p>



The transitivity measures the probability that two neighbors of a
vertex are connected. In case of the local transitivity, this
probability is calculated separately for each vertex.

</p>
<p>
Note that this measure is different from the global transitivity measure
(see <a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="13.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_undirected()</code></a> ) as it calculates a transitivity
value for each vertex individually. See the following reference for more
details:

</p>
<p>
D. J. Watts and S. Strogatz: Collective dynamics of small-world networks.
Nature 393(6684):440-442 (1998).

</p>
<p>
Clustering coefficient is an alternative name for transitivity.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, which should be undirected and simple.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result will be
  stored here. It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  Vertex set, the vertices for which the local
  transitivity will be calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Defines how to treat vertices with degree less than two.
   <code class="constant">IGRAPH_TRANSITIVITY_NAN</code> returns <code class="constant">NaN</code> for these vertices,
   <code class="constant">IGRAPH_TRANSITIVITY_ZERO</code> returns zero.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="13.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_undirected()</code></a>, <a class="link" href="igraph-Structural.html#igraph_transitivity_avglocal_undirected" title="13.3. igraph_transitivity_avglocal_undirected — Average local transitivity (clustering coefficient)."><code class="function">igraph_transitivity_avglocal_undirected()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*d^2), n is the number of vertices for which
the transitivity is calculated, d is the average vertex degree.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_transitivity_avglocal_undirected"></a>13.3. <code class="function">igraph_transitivity_avglocal_undirected</code> —  Average local transitivity (clustering coefficient).</h3></div></div></div>
<a class="indexterm" name="idp105545270388680"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_transitivity_avglocal_undirected(const igraph_t *graph,
        igraph_real_t *res,
        igraph_transitivity_mode_t mode);
</pre></div>
<p>
</p>
<p>



The transitivity measures the probability that two neighbors of a
vertex are connected. In case of the average local transitivity,
this probability is calculated for each vertex and then the average
is taken. Vertices with less than two neighbors require special treatment,
they will either be left out from the calculation or they will be considered
as having zero transitivity, depending on the <code class="constant">mode</code> argument.

</p>
<p>
Note that this measure is different from the global transitivity measure
(see <a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="13.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_undirected()</code></a> ) as it simply takes the
average local transitivity across the whole network. See the following
reference for more details:

</p>
<p>
D. J. Watts and S. Strogatz: Collective dynamics of small-world networks.
Nature 393(6684):440-442 (1998).

</p>
<p>
Clustering coefficient is an alternative name for transitivity.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, directed graphs are considered as
   undirected ones.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Defines how to treat vertices with degree less than two.
   <code class="constant">IGRAPH_TRANSITIVITY_NAN</code> leaves them out from averaging,
   <code class="constant">IGRAPH_TRANSITIVITY_ZERO</code> includes them with zero transitivity.
   The result will be <code class="constant">NaN</code> if the mode is <code class="constant">IGRAPH_TRANSITIVITY_NAN</code>
   and there are no vertices with more than one neighbor.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="13.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_undirected()</code></a>, <a class="link" href="igraph-Structural.html#igraph_transitivity_local_undirected" title="13.2. igraph_transitivity_local_undirected — Calculates the local transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_local_undirected()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*d^2), |V| is the number of vertices in the
graph and d is the average degree.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_transitivity_barrat"></a>13.4. <code class="function">igraph_transitivity_barrat</code> — Weighted transitivity, as defined by A. Barrat.</h3></div></div></div>
<a class="indexterm" name="idp105545270538184"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_transitivity_barrat(const igraph_t *graph,
                               igraph_vector_t *res,
                               const igraph_vs_t vids,
                               const igraph_vector_t *weights,
                               igraph_transitivity_mode_t mode);
</pre></div>
<p>
</p>
<p>



This is a local transitivity, i.e. a vertex-level index. For a
given vertex <code class="constant">i</code>, from all triangles in which it participates we
consider the weight of the edges incident on <code class="constant">i</code>. The transitivity
is the sum of these weights divided by twice the strength of the
vertex (see <a class="link" href="igraph-Structural.html#igraph_strength" title="8.11. igraph_strength — Strength of the vertices, weighted vertex degree in other words."><code class="function">igraph_strength()</code></a>) and the degree of the vertex
minus one. See   Alain Barrat, Marc Barthelemy, Romualdo
Pastor-Satorras, Alessandro Vespignani: The architecture of complex
weighted networks, Proc. Natl. Acad. Sci. USA 101, 3747 (2004) at
<a class="ulink" href="http://arxiv.org/abs/cond-mat/0311416" target="_top">http://arxiv.org/abs/cond-mat/0311416</a> for the exact formula.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, edge directions are ignored for
  directed graphs. Note that the function does NOT work for
  non-simple graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result will be
  stored here. It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Edge weights. If this is a null pointer, then a
  warning is given and <a class="link" href="igraph-Structural.html#igraph_transitivity_local_undirected" title="13.2. igraph_transitivity_local_undirected — Calculates the local transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_local_undirected()</code></a>
  is called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Defines how to treat vertices with zero strength.
  <code class="constant">IGRAPH_TRANSITIVITY_NAN</code> says that the transitivity of these
  vertices is <code class="constant">NaN</code>, <code class="constant">IGRAPH_TRANSITIVITY_ZERO</code> says it is zero.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*d^2), |V| is the number of vertices in
the graph, d is the average node degree.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_transitivity_undirected" title="13.1. igraph_transitivity_undirected — Calculates the transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_undirected()</code></a>, <a class="link" href="igraph-Structural.html#igraph_transitivity_local_undirected" title="13.2. igraph_transitivity_local_undirected — Calculates the local transitivity (clustering coefficient) of a graph."><code class="function">igraph_transitivity_local_undirected()</code></a> and <a class="link" href="igraph-Structural.html#igraph_transitivity_avglocal_undirected" title="13.3. igraph_transitivity_avglocal_undirected — Average local transitivity (clustering coefficient)."><code class="function">igraph_transitivity_avglocal_undirected()</code></a> for other kinds of
(non-weighted) transitivity.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="directedness-conversion"></a>14. Directedness Conversion</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_to_directed">14.1. <code class="function">igraph_to_directed</code> —  Convert an undirected graph to a directed one</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_to_undirected">14.2. <code class="function">igraph_to_undirected</code> —  Convert a directed graph to an undirected one.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_to_directed"></a>14.1. <code class="function">igraph_to_directed</code> —  Convert an undirected graph to a directed one</h3></div></div></div>
<a class="indexterm" name="idp105545270561352"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_to_directed(igraph_t *graph,
                       igraph_to_directed_t mode);
</pre></div>
<p>
</p>
<p>



</p>
<p>
If the supplied graph is directed, this function does nothing.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to convert.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  Constant, specifies the details of how exactly the
       conversion is done. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TO_DIRECTED_ARBITRARY</code></span></p></td>
<td><p>

       The number of edges in the
       graph stays the same, an arbitrarily directed edge is
       created for each undirected edge.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TO_DIRECTED_MUTUAL</code></span></p></td>
<td><p>

       Two directed edges are
       created for each undirected edge, one in each direction.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TO_DIRECTED_RANDOM</code></span></p></td>
<td><p>

       Each undirected edge is converted to a randomly oriented
       directed one.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TO_DIRECTED_ACYCLIC</code></span></p></td>
<td><p>

       Each undirected edge is converted to a directed edge oriented
       from a lower index vertex to a higher index one. If no self-loops
       were present, then the result is a directed acyclic graph.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_to_undirected"></a>14.2. <code class="function">igraph_to_undirected</code> —  Convert a directed graph to an undirected one.</h3></div></div></div>
<a class="indexterm" name="idp105545270575816"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_to_undirected(igraph_t *graph,
                         igraph_to_undirected_t mode,
                         const igraph_attribute_combination_t *edge_comb);
</pre></div>
<p>
</p>
<p>



</p>
<p>
If the supplied graph is undirected, this function does nothing.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to convert.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant, specifies the details of how exactly the
       conversion is done. Possible values: <code class="constant">IGRAPH_TO_UNDIRECTED_EACH</code>: the number of edges remains
       constant, an undirected edge is created for each directed
       one, this version might create graphs with multiple edges;
       <code class="constant">IGRAPH_TO_UNDIRECTED_COLLAPSE</code>: one undirected edge will
       be created for each pair of vertices which are connected
       with at least one directed edge, no multiple edges will be
       created. <code class="constant">IGRAPH_TO_UNDIRECTED_MUTUAL</code> creates an undirected
       edge for each pair of mutual edges in the directed graph.
       Non-mutual edges are lost. This mode might create multiple
       edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_comb</code></em>:</span></p></td>
<td><p>
  What to do with the edge attributes. See the igraph
       manual section about attributes for details.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545270586952"></a><p class="title"><b>Example 13.29.  File <code class="code">examples/simple/igraph_to_undirected.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> v;
    igraph_t g;

    <span class="strong"><strong>igraph_vector_init_int</strong></span>(&amp;v, 2, 5, 5);
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_lattice" title="1.7. igraph_lattice — Arbitrary dimensional square lattices.">igraph_lattice</a></strong></span>(&amp;g, &amp;v, 1, IGRAPH_DIRECTED, 1 <span class="emphasis"><em>/*mutual*/</em></span>, 0 <span class="emphasis"><em>/*circular*/</em></span>);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_to_undirected" title="14.2. igraph_to_undirected — Convert a directed graph to an undirected one.">igraph_to_undirected</a></strong></span>(&amp;g, IGRAPH_TO_UNDIRECTED_COLLAPSE,
                         <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;g, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v);

    <span class="strong"><strong>printf</strong></span>("---\n");

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED,
                 0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 3,
                 5, 6, 6, 5, 6, 7, 6, 7, 7, 6, 7, 8, 7, 8, 8, 7, 8, 7, 8, 8, 9, 9, 9, 9,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_to_undirected" title="14.2. igraph_to_undirected — Convert a directed graph to an undirected one.">igraph_to_undirected</a></strong></span>(&amp;g, IGRAPH_TO_UNDIRECTED_MUTUAL,
                         <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;g, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="spectral-properties"></a>15. Spectral Properties</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Structural.html#igraph_laplacian">15.1. <code class="function">igraph_laplacian</code> —  Returns the Laplacian matrix of a graph</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_laplacian"></a>15.1. <code class="function">igraph_laplacian</code> —  Returns the Laplacian matrix of a graph</h3></div></div></div>
<a class="indexterm" name="idp105545270478664"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_laplacian(const igraph_t *graph, igraph_matrix_t *res,
                     igraph_sparsemat_t *sparseres,
                     igraph_bool_t normalized,
                     const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The graph Laplacian matrix is similar to an adjacency matrix but
contains -1's instead of 1's and the vertex degrees are included in
the diagonal. So the result for edge i--j is -1 if i!=j and is equal
to the degree of vertex i if i==j. igraph_laplacian will work on a
directed graph; in this case, the diagonal will contain the out-degrees.
Loop edges will be ignored.

</p>
<p>
The normalized version of the Laplacian matrix has 1 in the diagonal and
-1/sqrt(d[i]d[j]) if there is an edge from i to j.

</p>
<p>
The first version of this function was written by Vincent Matossian.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to the graph to convert.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix object, the result is
       stored here. It will be resized if needed.
       If it is a null pointer, then it is ignored.
       At least one of <em class="parameter"><code>res</code></em> and <em class="parameter"><code>sparseres</code></em> must be a non-null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sparseres</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized sparse matrix object, the
       result is stored here, if it is not a null pointer.
       At least one of <em class="parameter"><code>res</code></em> and <em class="parameter"><code>sparseres</code></em> must be a non-null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>normalized</code></em>:</span></p></td>
<td><p>
  Whether to create a normalized Laplacian matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  An optional vector containing edge weights, to calculate
       the weighted Laplacian matrix. Set it to a null pointer to
       calculate the unweighted Laplacian.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||V|),
|V| is the
number of vertices in the graph.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545270494152"></a><p class="title"><b>Example 13.30.  File <code class="code">examples/simple/igraph_laplacian.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

igraph_bool_t <span class="strong"><strong>check_laplacian</strong></span>(igraph_t* graph, <span class="strong"><strong>const</strong></span> igraph_matrix_t* matrix, <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>* w) {
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> vec, res;
    long int i, j;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;vec, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(graph));

    <span class="strong"><strong>if</strong></span> (w) {
        <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_strength" title="8.11. igraph_strength — Strength of the vertices, weighted vertex degree in other words.">igraph_strength</a></strong></span>(graph, &amp;vec, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT, IGRAPH_NO_LOOPS, w);
    } <span class="strong"><strong>else</strong></span> {
        <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(graph, &amp;vec, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT, IGRAPH_NO_LOOPS);
    }

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(graph); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vec)[i] = <span class="strong"><strong>sqrt</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vec)[i]);
    }

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(graph); i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(graph); j++) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[i] += <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*matrix, i, j) * <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vec)[j];
        }
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_min" title="2.10.1. igraph_vector_min — Smallest element of a vector.">igraph_vector_min</a></strong></span>(&amp;res) &gt; 1e-7) {
        <span class="strong"><strong>printf</strong></span>("Invalid Laplacian matrix:\n");
        <span class="strong"><strong>igraph_matrix_print</strong></span>(matrix);
        <span class="strong"><strong>return</strong></span> 0;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;vec);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 1;
}

int <span class="strong"><strong>test_unnormalized_laplacian</strong></span>(<span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>* w, igraph_bool_t dir) {
    igraph_t g;
    igraph_matrix_t m, m2;
    igraph_sparsemat_t sm;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> vec, *weights = NULL;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 1, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;sm, 0, 0, 0);

    <span class="strong"><strong>if</strong></span> (w) {
        weights = (<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*)<span class="strong"><strong>calloc</strong></span>(1, <span class="strong"><strong>sizeof</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>));
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_copy" title="2.2.4. igraph_vector_copy — Initializes a vector from another vector object (constructor).">igraph_vector_copy</a></strong></span>(weights, w);
    }

    <span class="emphasis"><em>/* No loop or multiple edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 5, dir, 0, 1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_laplacian" title="15.1. igraph_laplacian — Returns the Laplacian matrix of a graph">igraph_laplacian</a></strong></span>(&amp;g, &amp;m, &amp;sm, 0, weights);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.8.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;m2, &amp;sm);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>igraph_matrix_all_e_tol</strong></span>(&amp;m, &amp;m2, 0)) {
        <span class="strong"><strong>return</strong></span> 41;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m2);
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;m);
    <span class="strong"><strong>printf</strong></span>("===\n");

    <span class="emphasis"><em>/* Add some loop edges */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;vec, 4, 1.0, 1.0, 2.0, 2.0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_add_edges" title="2.3.2. igraph_add_edges — Adds edges to a graph object.">igraph_add_edges</a></strong></span>(&amp;g, &amp;vec, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;vec);
    <span class="strong"><strong>if</strong></span> (weights) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(weights, 2);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(weights, 2);
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_laplacian" title="15.1. igraph_laplacian — Returns the Laplacian matrix of a graph">igraph_laplacian</a></strong></span>(&amp;g, &amp;m, &amp;sm, 0, weights);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.8.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;m2, &amp;sm);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>igraph_matrix_all_e_tol</strong></span>(&amp;m, &amp;m2, 0)) {
        <span class="strong"><strong>return</strong></span> 42;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m2);
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;m);
    <span class="strong"><strong>printf</strong></span>("===\n");

    <span class="emphasis"><em>/* Duplicate some edges */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;vec, 4, 1.0, 2.0, 3.0, 4.0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_add_edges" title="2.3.2. igraph_add_edges — Adds edges to a graph object.">igraph_add_edges</a></strong></span>(&amp;g, &amp;vec, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;vec);
    <span class="strong"><strong>if</strong></span> (weights) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(weights, 3);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(weights, 3);
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_laplacian" title="15.1. igraph_laplacian — Returns the Laplacian matrix of a graph">igraph_laplacian</a></strong></span>(&amp;g, &amp;m, &amp;sm, 0, weights);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.8.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;m2, &amp;sm);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>igraph_matrix_all_e_tol</strong></span>(&amp;m, &amp;m2, 0)) {
        <span class="strong"><strong>return</strong></span> 43;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m2);
    <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;m);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong>if</strong></span> (weights) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(weights);
        <span class="strong"><strong>free</strong></span>(weights);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;sm);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_normalized_laplacian</strong></span>(<span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *w, igraph_bool_t dir) {
    igraph_t g;
    igraph_matrix_t m, m2;
    igraph_sparsemat_t sm;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> vec, *weights = 0;
    igraph_bool_t ok = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m, 1, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;sm, 0, 0, 0);

    <span class="strong"><strong>if</strong></span> (w) {
        weights = (<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>*) <span class="strong"><strong>calloc</strong></span>(1, <span class="strong"><strong>sizeof</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>));
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_copy" title="2.2.4. igraph_vector_copy — Initializes a vector from another vector object (constructor).">igraph_vector_copy</a></strong></span>(weights, w);
    }

    <span class="emphasis"><em>/* Undirected graph, no loop or multiple edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 5, dir, 0, 1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_laplacian" title="15.1. igraph_laplacian — Returns the Laplacian matrix of a graph">igraph_laplacian</a></strong></span>(&amp;g, &amp;m, &amp;sm, 1, weights);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.8.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;m2, &amp;sm);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>igraph_matrix_all_e_tol</strong></span>(&amp;m, &amp;m2, 0)) {
        <span class="strong"><strong>return</strong></span> 44;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m2);
    ok = ok &amp;&amp; <span class="strong"><strong>check_laplacian</strong></span>(&amp;g, &amp;m, weights);

    <span class="emphasis"><em>/* Add some loop edges */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;vec, 4, 1.0, 1.0, 2.0, 2.0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_add_edges" title="2.3.2. igraph_add_edges — Adds edges to a graph object.">igraph_add_edges</a></strong></span>(&amp;g, &amp;vec, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;vec);
    <span class="strong"><strong>if</strong></span> (weights) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(weights, 2);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(weights, 2);
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_laplacian" title="15.1. igraph_laplacian — Returns the Laplacian matrix of a graph">igraph_laplacian</a></strong></span>(&amp;g, &amp;m, &amp;sm, 1, weights);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.8.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;m2, &amp;sm);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>igraph_matrix_all_e_tol</strong></span>(&amp;m, &amp;m2, 0)) {
        <span class="strong"><strong>return</strong></span> 45;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m2);
    ok = ok &amp;&amp; <span class="strong"><strong>check_laplacian</strong></span>(&amp;g, &amp;m, weights);

    <span class="emphasis"><em>/* Duplicate some edges */</em></span>
    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;vec, 4, 1.0, 2.0, 3.0, 4.0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_add_edges" title="2.3.2. igraph_add_edges — Adds edges to a graph object.">igraph_add_edges</a></strong></span>(&amp;g, &amp;vec, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;vec);
    <span class="strong"><strong>if</strong></span> (weights) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(weights, 3);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(weights, 3);
    }

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_laplacian" title="15.1. igraph_laplacian — Returns the Laplacian matrix of a graph">igraph_laplacian</a></strong></span>(&amp;g, &amp;m, &amp;sm, 1, weights);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;m2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.8.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;m2, &amp;sm);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>igraph_matrix_all_e_tol</strong></span>(&amp;m, &amp;m2, 0)) {
        <span class="strong"><strong>return</strong></span> 46;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m2);
    ok = ok &amp;&amp; <span class="strong"><strong>check_laplacian</strong></span>(&amp;g, &amp;m, weights);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;m);
    <span class="strong"><strong>if</strong></span> (weights) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(weights);
        <span class="strong"><strong>free</strong></span>(weights);
    }

    <span class="strong"><strong>if</strong></span> (ok) {
        <span class="strong"><strong>printf</strong></span>("OK\n");
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;sm);

    <span class="strong"><strong>return</strong></span> !ok;
}

int <span class="strong"><strong>main</strong></span>() {
    int res;
    int i;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;

    <span class="strong"><strong>igraph_vector_init_real</strong></span>(&amp;weights, 5, 1.0, 2.0, 3.0, 4.0, 5.0);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 8; i++) {
        igraph_bool_t is_normalized = i / 4;
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>* v = ((i &amp; 2) / 2 ? &amp;weights : 0);
        igraph_bool_t dir = (i % 2 ? IGRAPH_DIRECTED : IGRAPH_UNDIRECTED);

        <span class="strong"><strong>printf</strong></span>("=== %sormalized, %sweighted, %sdirected\n",
               (is_normalized ? "N" : "Unn"),
               (v != 0 ? "" : "un"),
               (dir == IGRAPH_DIRECTED ? "" : "un")
              );

        <span class="strong"><strong>if</strong></span> (is_normalized) {
            res = <span class="strong"><strong>test_normalized_laplacian</strong></span>(v, dir);
        } <span class="strong"><strong>else</strong></span> {
            res = <span class="strong"><strong>test_unnormalized_laplacian</strong></span>(v, dir);
        }

        <span class="strong"><strong>if</strong></span> (res) {
            <span class="strong"><strong>return</strong></span> i + 1;
        }
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="non-simple-graphs-multiple-and-loop-edges"></a>16. Non-simple Graphs: Multiple and Loop Edges</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_simple">16.1. <code class="function">igraph_is_simple</code> —  Decides whether the input graph is a simple graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_loop">16.2. <code class="function">igraph_is_loop</code> —  Find the loop edges in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_multiple">16.3. <code class="function">igraph_is_multiple</code> —  Find the multiple edges in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_has_multiple">16.4. <code class="function">igraph_has_multiple</code> —  Check whether the graph has at least one multiple edge.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_count_multiple">16.5. <code class="function">igraph_count_multiple</code> —  Count the number of appearances of the edges in a graph.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_simple"></a>16.1. <code class="function">igraph_is_simple</code> —  Decides whether the input graph is a simple graph.</h3></div></div></div>
<a class="indexterm" name="idp105545270087240"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_simple(const igraph_t *graph, igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A graph is a simple graph if it does not contain loop edges and
multiple edges.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean constant, the result
    is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_loop" title="16.2. igraph_is_loop — Find the loop edges in a graph."><code class="function">igraph_is_loop()</code></a> and <a class="link" href="igraph-Structural.html#igraph_is_multiple" title="16.3. igraph_is_multiple — Find the multiple edges in a graph."><code class="function">igraph_is_multiple()</code></a> to
find the loops and multiple edges, <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a> to
get rid of them, or <a class="link" href="igraph-Structural.html#igraph_has_multiple" title="16.4. igraph_has_multiple — Check whether the graph has at least one multiple edge."><code class="function">igraph_has_multiple()</code></a> to decide whether
there is at least one multiple edge.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_loop"></a>16.2. <code class="function">igraph_is_loop</code> —  Find the loop edges in a graph.</h3></div></div></div>
<a class="indexterm" name="idp105545270102472"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_loop(const igraph_t *graph, igraph_vector_bool_t *res,
                   igraph_es_t es);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A loop edge is an edge from a vertex to itself.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized boolean vector for storing the result,
        it will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>es</code></em>:</span></p></td>
<td><p>
  The edges to check, for all edges supply <a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)"><code class="function">igraph_ess_all()</code></a> here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a> to get rid of loop edges.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(e), the number of edges to check.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545270116168"></a><p class="title"><b>Example 13.31.  File <code class="code">examples/simple/igraph_is_loop.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2007-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_vector</strong></span>(igraph_vector_bool_t *v, FILE *f) {
    long int i;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_bool_size</strong></span>(v); i++) {
        <span class="strong"><strong>fprintf</strong></span>(f, " %i", (int) <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i]);
    }
    <span class="strong"><strong>fprintf</strong></span>(f, "\n");
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t graph;
    igraph_vector_bool_t v;

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;v, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 1, 0, 1, 1, 0, 3, 4, 11, 10, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_loop" title="16.2. igraph_is_loop — Find the loop edges in a graph.">igraph_is_loop</a></strong></span>(&amp;graph, &amp;v, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_ID));
    <span class="strong"><strong>print_vector</strong></span>(&amp;v, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED,
                 0, 0, 1, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, 2, 2, 0, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_loop" title="16.2. igraph_is_loop — Find the loop edges in a graph.">igraph_is_loop</a></strong></span>(&amp;graph, &amp;v, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_ID));
    <span class="strong"><strong>print_vector</strong></span>(&amp;v, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;v);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_multiple"></a>16.3. <code class="function">igraph_is_multiple</code> —  Find the multiple edges in a graph.</h3></div></div></div>
<a class="indexterm" name="idp105545270139720"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_multiple(const igraph_t *graph, igraph_vector_bool_t *res,
                       igraph_es_t es);
</pre></div>
<p>
</p>
<p>



</p>
<p>
An edge is a multiple edge if there is another
edge with the same head and tail vertices in the graph.

</p>
<p>
Note that this function returns true only for the second or more
appearances of the multiple edges.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean vector, the result will be stored
       here. It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>es</code></em>:</span></p></td>
<td><p>
  The edges to check. Supply <a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)"><code class="function">igraph_ess_all()</code></a> if you want
       to check all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_count_multiple" title="16.5. igraph_count_multiple — Count the number of appearances of the edges in a graph."><code class="function">igraph_count_multiple()</code></a>, <a class="link" href="igraph-Structural.html#igraph_has_multiple" title="16.4. igraph_has_multiple — Check whether the graph has at least one multiple edge."><code class="function">igraph_has_multiple()</code></a> and <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(e*d), e is the number of edges to check and d is the
average degree (out-degree in directed graphs) of the vertices at the
tail of the edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545270286408"></a><p class="title"><b>Example 13.32.  File <code class="code">examples/simple/igraph_is_multiple.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2007-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_vector</strong></span>(igraph_vector_bool_t *v, FILE *f) {
    long int i;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_bool_size</strong></span>(v); i++) {
        <span class="strong"><strong>fprintf</strong></span>(f, " %i", (int) <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i]);
    }
    <span class="strong"><strong>fprintf</strong></span>(f, "\n");
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t graph;
    igraph_vector_bool_t v;

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;v, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 1, 0, 1, 1, 0, 3, 4, 11, 10, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_multiple" title="16.3. igraph_is_multiple — Find the multiple edges in a graph.">igraph_is_multiple</a></strong></span>(&amp;graph, &amp;v, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_ID));
    <span class="strong"><strong>print_vector</strong></span>(&amp;v, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED,
                 0, 0, 1, 2, 1, 1, 2, 2, 2, 1, 2, 3, 2, 4,
                 2, 5, 2, 6, 2, 2, 3, 2, 0, 0, 6, 2, 2, 2, 0, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_multiple" title="16.3. igraph_is_multiple — Find the multiple edges in a graph.">igraph_is_multiple</a></strong></span>(&amp;graph, &amp;v, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_ID));
    <span class="strong"><strong>print_vector</strong></span>(&amp;v, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;v);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_has_multiple"></a>16.4. <code class="function">igraph_has_multiple</code> —  Check whether the graph has at least one multiple edge.</h3></div></div></div>
<a class="indexterm" name="idp105545270309960"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_has_multiple(const igraph_t *graph, igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p>
An edge is a multiple edge if there is another
edge with the same head and tail vertices in the graph.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean variable, the result will be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_count_multiple" title="16.5. igraph_count_multiple — Count the number of appearances of the edges in a graph."><code class="function">igraph_count_multiple()</code></a>, <a class="link" href="igraph-Structural.html#igraph_is_multiple" title="16.3. igraph_is_multiple — Find the multiple edges in a graph."><code class="function">igraph_is_multiple()</code></a> and <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(e*d), e is the number of edges to check and d is the
average degree (out-degree in directed graphs) of the vertices at the
tail of the edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545270323016"></a><p class="title"><b>Example 13.33.  File <code class="code">examples/simple/igraph_has_multiple.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2007-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>print_vector</strong></span>(igraph_vector_bool_t *v, FILE *f) {
    long int i;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_bool_size</strong></span>(v); i++) {
        <span class="strong"><strong>fprintf</strong></span>(f, " %i", (int) <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*v)[i]);
    }
    <span class="strong"><strong>fprintf</strong></span>(f, "\n");
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t graph;
    igraph_bool_t res;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 1, 0, 1, 1, 0, 3, 4, 11, 10, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="16.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (!res) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED,
                 0, 0, 1, 2, 1, 1, 2, 2, 2, 1, 2, 3, 2, 4,
                 2, 5, 2, 6, 2, 2, 3, 2, 0, 0, 6, 2, 2, 2, 0, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="16.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (!res) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 1, 1, 0, 3, 4, 11, 10, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="16.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (res) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED,
                 0, 0, 1, 2, 1, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, 2, 2, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="16.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (!res) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED,
                 0, 0, 1, 2, 1, 1, 2, 2, 2, 3, 2, 4, 2, 5, 2, 6, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="16.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (res) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED, 0, 1, 0, 1, 1, 2, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="16.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (!res) {
        <span class="strong"><strong>return</strong></span> 6;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, IGRAPH_UNDIRECTED, 0, 0, 0, 0, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_has_multiple" title="16.4. igraph_has_multiple — Check whether the graph has at least one multiple edge.">igraph_has_multiple</a></strong></span>(&amp;graph, &amp;res);
    <span class="strong"><strong>if</strong></span> (!res) {
        <span class="strong"><strong>return</strong></span> 7;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_count_multiple"></a>16.5. <code class="function">igraph_count_multiple</code> —  Count the number of appearances of the edges in a graph.</h3></div></div></div>
<a class="indexterm" name="idp105545270230600"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_count_multiple(const igraph_t *graph, igraph_vector_t *res, igraph_es_t es);
</pre></div>
<p>
</p>
<p>



</p>
<p>
If the graph has no multiple edges then the result vector will be
filled with ones.
(An edge is a multiple edge if there is another
edge with the same head and tail vertices in the graph.)

</p>
<p>
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result will be stored
       here. It will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>es</code></em>:</span></p></td>
<td><p>
  The edges to check. Supply <a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)"><code class="function">igraph_ess_all()</code></a> if you want
       to check all edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_multiple" title="16.3. igraph_is_multiple — Find the multiple edges in a graph."><code class="function">igraph_is_multiple()</code></a> and <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(E d), E is the number of edges to check and d is the
average degree (out-degree in directed graphs) of the vertices at the
tail of the edges.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="mixing-patterns"></a>17. Mixing Patterns</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_assortativity_nominal">17.1. <code class="function">igraph_assortativity_nominal</code> — Assortativity of a graph based on vertex categories</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_assortativity">17.2. <code class="function">igraph_assortativity</code> — Assortativity based on numeric properties of vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_assortativity_degree">17.3. <code class="function">igraph_assortativity_degree</code> — Assortativity of a graph based on vertex degree</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_assortativity_nominal"></a>17.1. <code class="function">igraph_assortativity_nominal</code> — Assortativity of a graph based on vertex categories</h3></div></div></div>
<a class="indexterm" name="idp105545270247496"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_assortativity_nominal(const igraph_t *graph,
                                 const igraph_vector_t *types,
                                 igraph_real_t *res,
                                 igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



Assuming the vertices of the input graph belong to different
categories, this function calculates the assortativity coefficient of
the graph. The assortativity coefficient is between minus one and one
and it is one if all connections stay within categories, it is
minus one, if the network is perfectly disassortative. For a
randomly connected network it is (asymptotically) zero.

</p>
<p>See equation (2) in M. E. J. Newman: Mixing patterns
in networks, Phys. Rev. E 67, 026126 (2003)
(<a class="ulink" href="http://arxiv.org/abs/cond-mat/0209450" target="_top">http://arxiv.org/abs/cond-mat/0209450</a>) for the proper
definition.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Vector giving the vertex types. They are assumed to be
   integer numbers, starting with zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, it gives whether to consider edge
   directions in a directed graph. It is ignored for undirected
   graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|+t), |E| is the number of edges, t is the
number of vertex types.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices"><code class="function">igraph_assortativity</code></a> if the vertex types are defines by
numeric values (e.g. vertex degree), instead of categories.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545270262472"></a><p class="title"><b>Example 13.34.  File <code class="code">examples/simple/assortativity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2009-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    FILE *karate, *neural;
    igraph_real_t res;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> types;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> degree, outdegree, indegree;

    igraph_real_t football_types[] = {
        7, 0, 2, 3, 7, 3, 2, 8, 8, 7, 3, 10, 6, 2, 6, 2, 7, 9, 6, 1, 9, 8, 8, 7, 10, 0, 6, 9,
        11, 1, 1, 6, 2, 0, 6, 1, 5, 0, 6, 2, 3, 7, 5, 6, 4, 0, 11, 2, 4, 11, 10, 8, 3, 11, 6,
        1, 9, 4, 11, 10, 2, 6, 9, 10, 2, 9, 4, 11, 8, 10, 9, 6, 3, 11, 3, 4, 9, 8, 8, 1, 5, 3,
        5, 11, 3, 6, 4, 9, 11, 0, 5, 4, 4, 7, 1, 9, 9, 10, 3, 6, 2, 1, 3, 0, 7, 0, 2, 3, 8, 0,
        4, 8, 4, 9, 11
    };

    karate = <span class="strong"><strong>fopen</strong></span>("karate.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, karate);
    <span class="strong"><strong>fclose</strong></span>(karate);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;types, 0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;types, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, <span class="emphasis"><em>/*loops=*/</em></span> 1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;types, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    neural = <span class="strong"><strong>fopen</strong></span>("celegansneural.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, neural);
    <span class="strong"><strong>fclose</strong></span>(neural);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;types, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, <span class="emphasis"><em>/*loops=*/</em></span> 1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;types, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;types, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;types);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    karate = <span class="strong"><strong>fopen</strong></span>("karate.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, karate);
    <span class="strong"><strong>fclose</strong></span>(karate);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;degree, 0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;degree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, <span class="emphasis"><em>/*loops=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_add_constant" title="2.8.1. igraph_vector_add_constant — Add a constant to the vector.">igraph_vector_add_constant</a></strong></span>(&amp;degree, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices">igraph_assortativity</a></strong></span>(&amp;g, &amp;degree, 0, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    neural = <span class="strong"><strong>fopen</strong></span>("celegansneural.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, neural);
    <span class="strong"><strong>fclose</strong></span>(neural);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;degree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, <span class="emphasis"><em>/*loops=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_add_constant" title="2.8.1. igraph_vector_add_constant — Add a constant to the vector.">igraph_vector_add_constant</a></strong></span>(&amp;degree, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices">igraph_assortativity</a></strong></span>(&amp;g, &amp;degree, 0, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices">igraph_assortativity</a></strong></span>(&amp;g, &amp;degree, 0, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;degree);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;indegree, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;outdegree, 0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;indegree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN, <span class="emphasis"><em>/*loops=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;outdegree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT, <span class="emphasis"><em>/*loops=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_add_constant" title="2.8.1. igraph_vector_add_constant — Add a constant to the vector.">igraph_vector_add_constant</a></strong></span>(&amp;indegree, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_add_constant" title="2.8.1. igraph_vector_add_constant — Add a constant to the vector.">igraph_vector_add_constant</a></strong></span>(&amp;outdegree, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices">igraph_assortativity</a></strong></span>(&amp;g, &amp;outdegree, &amp;indegree, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;indegree);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;outdegree);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="17.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree">igraph_assortativity_degree</a></strong></span>(&amp;g, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    karate = <span class="strong"><strong>fopen</strong></span>("karate.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, karate);
    <span class="strong"><strong>fclose</strong></span>(karate);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="17.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree">igraph_assortativity_degree</a></strong></span>(&amp;g, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, <span class="strong"><strong>sizeof</strong></span>(football_types) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t),
                 IGRAPH_UNDIRECTED,
                 0, 1, 2, 3, 0, 4, 4, 5, 3, 5, 2, 6, 6, 7, 7, 8, 8, 9, 0, 9, 4, 9, 5, 10, 10, 11, 5, 11,
                 3, 11, 12, 13, 2, 13, 2, 14, 12, 14, 14, 15, 13, 15, 2, 15, 4, 16, 9, 16, 0, 16,
                 16, 17, 12, 17, 12, 18, 18, 19, 17, 20, 20, 21, 8, 21, 7, 21, 9, 22, 7, 22, 21,
                 22, 8, 22, 22, 23, 9, 23, 4, 23, 16, 23, 0, 23, 11, 24, 24, 25, 1, 25, 3, 26, 12,
                 26, 14, 26, 26, 27, 17, 27, 1, 27, 17, 27, 4, 28, 11, 28, 24, 28, 19, 29, 29,
                 30, 19, 30, 18, 31, 31, 32, 21, 32, 15, 32, 13, 32, 6, 32, 0, 33, 1, 33, 25, 33,
                 19, 33, 31, 34, 26, 34, 12, 34, 18, 34, 34, 35, 0, 35, 29, 35, 19, 35, 30, 35,
                 18, 36, 12, 36, 20, 36, 19, 36, 36, 37, 1, 37, 25, 37, 33, 37, 18, 38, 16, 38,
                 28, 38, 26, 38, 14, 38, 12, 38, 38, 39, 6, 39, 32, 39, 13, 39, 15, 39, 7, 40, 3,
                 40, 40, 41, 8, 41, 4, 41, 23, 41, 9, 41, 0, 41, 16, 41, 34, 42, 29, 42, 18, 42,
                 26, 42, 42, 43, 36, 43, 26, 43, 31, 43, 38, 43, 12, 43, 14, 43, 19, 44, 35, 44,
                 30, 44, 44, 45, 13, 45, 33, 45, 1, 45, 37, 45, 25, 45, 21, 46, 46, 47, 22, 47,
                 6, 47, 15, 47, 2, 47, 39, 47, 32, 47, 44, 48, 48, 49, 32, 49, 46, 49, 30, 50,
                 24, 50, 11, 50, 28, 50, 50, 51, 40, 51, 8, 51, 22, 51, 21, 51, 3, 52, 40, 52, 5,
                 52, 52, 53, 25, 53, 48, 53, 49, 53, 46, 53, 39, 54, 31, 54, 38, 54, 14, 54, 34,
                 54, 18, 54, 54, 55, 31, 55, 6, 55, 35, 55, 29, 55, 19, 55, 30, 55, 27, 56, 56,
                 57, 1, 57, 42, 57, 44, 57, 48, 57, 3, 58, 6, 58, 17, 58, 36, 58, 36, 59, 58, 59,
                 59, 60, 10, 60, 39, 60, 6, 60, 47, 60, 13, 60, 15, 60, 2, 60, 43, 61, 47, 61,
                 54, 61, 18, 61, 26, 61, 31, 61, 34, 61, 61, 62, 20, 62, 45, 62, 17, 62, 27, 62,
                 56, 62, 27, 63, 58, 63, 59, 63, 42, 63, 63, 64, 9, 64, 32, 64, 60, 64, 2, 64, 6,
                 64, 47, 64, 13, 64, 0, 65, 27, 65, 17, 65, 63, 65, 56, 65, 20, 65, 65, 66, 59,
                 66, 24, 66, 44, 66, 48, 66, 16, 67, 41, 67, 46, 67, 53, 67, 49, 67, 67, 68, 15,
                 68, 50, 68, 21, 68, 51, 68, 7, 68, 22, 68, 8, 68, 4, 69, 24, 69, 28, 69, 50, 69,
                 11, 69, 69, 70, 43, 70, 65, 70, 20, 70, 56, 70, 62, 70, 27, 70, 60, 71, 18, 71,
                 14, 71, 34, 71, 54, 71, 38, 71, 61, 71, 31, 71, 71, 72, 2, 72, 10, 72, 3, 72,
                 40, 72, 52, 72, 7, 73, 49, 73, 53, 73, 67, 73, 46, 73, 73, 74, 2, 74, 72, 74, 5,
                 74, 10, 74, 52, 74, 3, 74, 40, 74, 20, 75, 66, 75, 48, 75, 57, 75, 44, 75, 75,
                 76, 27, 76, 59, 76, 20, 76, 70, 76, 66, 76, 56, 76, 62, 76, 73, 77, 22, 77, 7,
                 77, 51, 77, 21, 77, 8, 77, 77, 78, 23, 78, 50, 78, 28, 78, 22, 78, 8, 78, 68,
                 78, 7, 78, 51, 78, 31, 79, 43, 79, 30, 79, 19, 79, 29, 79, 35, 79, 55, 79, 79,
                 80, 37, 80, 29, 80, 16, 81, 5, 81, 40, 81, 10, 81, 72, 81, 3, 81, 81, 82, 74,
                 82, 39, 82, 77, 82, 80, 82, 30, 82, 29, 82, 7, 82, 53, 83, 81, 83, 69, 83, 73,
                 83, 46, 83, 67, 83, 49, 83, 83, 84, 24, 84, 49, 84, 52, 84, 3, 84, 74, 84, 10,
                 84, 81, 84, 5, 84, 3, 84, 6, 85, 14, 85, 38, 85, 43, 85, 80, 85, 12, 85, 26, 85,
                 31, 85, 44, 86, 53, 86, 75, 86, 57, 86, 48, 86, 80, 86, 66, 86, 86, 87, 17, 87,
                 62, 87, 56, 87, 24, 87, 20, 87, 65, 87, 49, 88, 58, 88, 83, 88, 69, 88, 46, 88,
                 53, 88, 73, 88, 67, 88, 88, 89, 1, 89, 37, 89, 25, 89, 33, 89, 55, 89, 45, 89,
                 5, 90, 8, 90, 23, 90, 0, 90, 11, 90, 50, 90, 24, 90, 69, 90, 28, 90, 29, 91, 48,
                 91, 66, 91, 69, 91, 44, 91, 86, 91, 57, 91, 80, 91, 91, 92, 35, 92, 15, 92, 86,
                 92, 48, 92, 57, 92, 61, 92, 66, 92, 75, 92, 0, 93, 23, 93, 80, 93, 16, 93, 4,
                 93, 82, 93, 91, 93, 41, 93, 9, 93, 34, 94, 19, 94, 55, 94, 79, 94, 80, 94, 29,
                 94, 30, 94, 82, 94, 35, 94, 70, 95, 69, 95, 76, 95, 62, 95, 56, 95, 27, 95, 17,
                 95, 87, 95, 37, 95, 48, 96, 17, 96, 76, 96, 27, 96, 56, 96, 65, 96, 20, 96, 87,
                 96, 5, 97, 86, 97, 58, 97, 11, 97, 59, 97, 63, 97, 97, 98, 77, 98, 48, 98, 84,
                 98, 40, 98, 10, 98, 5, 98, 52, 98, 81, 98, 89, 99, 34, 99, 14, 99, 85, 99, 54,
                 99, 18, 99, 31, 99, 61, 99, 71, 99, 14, 99, 99, 100, 82, 100, 13, 100, 2, 100,
                 15, 100, 32, 100, 64, 100, 47, 100, 39, 100, 6, 100, 51, 101, 30, 101, 94,
                 101, 1, 101, 79, 101, 58, 101, 19, 101, 55, 101, 35, 101, 29, 101, 100, 102,
                 74, 102, 52, 102, 98, 102, 72, 102, 40, 102, 10, 102, 3, 102, 102, 103, 33,
                 103, 45, 103, 25, 103, 89, 103, 37, 103, 1, 103, 70, 103, 72, 104, 11, 104,
                 0, 104, 93, 104, 67, 104, 41, 104, 16, 104, 87, 104, 23, 104, 4, 104, 9, 104,
                 89, 105, 103, 105, 33, 105, 62, 105, 37, 105, 45, 105, 1, 105, 80, 105, 25,
                 105, 25, 106, 56, 106, 92, 106, 2, 106, 13, 106, 32, 106, 60, 106, 6, 106,
                 64, 106, 15, 106, 39, 106, 88, 107, 75, 107, 98, 107, 102, 107, 72, 107, 40,
                 107, 81, 107, 5, 107, 10, 107, 84, 107, 4, 108, 9, 108, 7, 108, 51, 108, 77,
                 108, 21, 108, 78, 108, 22, 108, 68, 108, 79, 109, 30, 109, 63, 109, 1, 109,
                 33, 109, 103, 109, 105, 109, 45, 109, 25, 109, 89, 109, 37, 109, 67, 110,
                 13, 110, 24, 110, 80, 110, 88, 110, 49, 110, 73, 110, 46, 110, 83, 110, 53,
                 110, 23, 111, 64, 111, 46, 111, 78, 111, 8, 111, 21, 111, 51, 111, 7, 111,
                 108, 111, 68, 111, 77, 111, 52, 112, 96, 112, 97, 112, 57, 112, 66, 112, 63,
                 112, 44, 112, 92, 112, 75, 112, 91, 112, 28, 113, 20, 113, 95, 113, 59, 113,
                 70, 113, 17, 113, 87, 113, 76, 113, 65, 113, 96, 113, 83, 114, 88, 114, 110,
                 114, 53, 114, 49, 114, 73, 114, 46, 114, 67, 114, 58, 114, 15, 114, 104, 114,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph.">igraph_simplify</a></strong></span>(&amp;g, <span class="emphasis"><em>/*multiple=*/</em></span> 1, <span class="emphasis"><em>/*loops=*/</em></span> 1, <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;types, football_types,
                       <span class="strong"><strong>sizeof</strong></span>(football_types) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;types, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}

</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_assortativity"></a>17.2. <code class="function">igraph_assortativity</code> — Assortativity based on numeric properties of vertices</h3></div></div></div>
<a class="indexterm" name="idp105545269941960"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_assortativity(const igraph_t *graph,
                         const igraph_vector_t *types1,
                         const igraph_vector_t *types2,
                         igraph_real_t *res,
                         igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



This function calculates the assortativity coefficient of the input
graph. This coefficient is basically the correlation between the
actual connectivity patterns of the vertices and the pattern
expected from the distribution of the vertex types.

</p>
<p>See equation (21) in M. E. J. Newman: Mixing patterns
in networks, Phys. Rev. E 67, 026126 (2003)
(<a class="ulink" href="http://arxiv.org/abs/cond-mat/0209450" target="_top">http://arxiv.org/abs/cond-mat/0209450</a>) for the proper
definition. The actual calculation is performed using equation (26)
in the same paper for directed graphs, and equation (4) in
M. E. J. Newman: Assortative mixing in networks,
Phys. Rev. Lett. 89, 208701 (2002)
(<a class="ulink" href="http://arxiv.org/abs/cond-mat/0205405/" target="_top">http://arxiv.org/abs/cond-mat/0205405/</a>) for undirected graphs.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types1</code></em>:</span></p></td>
<td><p>
  The vertex values, these can be arbitrary numeric
    values.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types2</code></em>:</span></p></td>
<td><p>
  A second value vector to be using for the incoming
    edges when calculating assortativity for a directed graph.
    Supply a null pointer here if you want to use the same values
    for outgoing and incoming edges. This argument is ignored
    (with a warning) if it is not a null pointer and undirected
    assortativity coefficient is being calculated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider edge directions for
    directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|), linear in the number of edges of the
graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories"><code class="function">igraph_assortativity_nominal()</code></a> if you have discrete vertex
categories instead of numeric labels, and <a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="17.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree"><code class="function">igraph_assortativity_degree()</code></a> for the special case of assortativity
based on vertex degree.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545269828424"></a><p class="title"><b>Example 13.35.  File <code class="code">examples/simple/assortativity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2009-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    FILE *karate, *neural;
    igraph_real_t res;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> types;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> degree, outdegree, indegree;

    igraph_real_t football_types[] = {
        7, 0, 2, 3, 7, 3, 2, 8, 8, 7, 3, 10, 6, 2, 6, 2, 7, 9, 6, 1, 9, 8, 8, 7, 10, 0, 6, 9,
        11, 1, 1, 6, 2, 0, 6, 1, 5, 0, 6, 2, 3, 7, 5, 6, 4, 0, 11, 2, 4, 11, 10, 8, 3, 11, 6,
        1, 9, 4, 11, 10, 2, 6, 9, 10, 2, 9, 4, 11, 8, 10, 9, 6, 3, 11, 3, 4, 9, 8, 8, 1, 5, 3,
        5, 11, 3, 6, 4, 9, 11, 0, 5, 4, 4, 7, 1, 9, 9, 10, 3, 6, 2, 1, 3, 0, 7, 0, 2, 3, 8, 0,
        4, 8, 4, 9, 11
    };

    karate = <span class="strong"><strong>fopen</strong></span>("karate.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, karate);
    <span class="strong"><strong>fclose</strong></span>(karate);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;types, 0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;types, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, <span class="emphasis"><em>/*loops=*/</em></span> 1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;types, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    neural = <span class="strong"><strong>fopen</strong></span>("celegansneural.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, neural);
    <span class="strong"><strong>fclose</strong></span>(neural);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;types, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, <span class="emphasis"><em>/*loops=*/</em></span> 1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;types, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;types, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;types);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    karate = <span class="strong"><strong>fopen</strong></span>("karate.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, karate);
    <span class="strong"><strong>fclose</strong></span>(karate);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;degree, 0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;degree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, <span class="emphasis"><em>/*loops=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_add_constant" title="2.8.1. igraph_vector_add_constant — Add a constant to the vector.">igraph_vector_add_constant</a></strong></span>(&amp;degree, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices">igraph_assortativity</a></strong></span>(&amp;g, &amp;degree, 0, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    neural = <span class="strong"><strong>fopen</strong></span>("celegansneural.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, neural);
    <span class="strong"><strong>fclose</strong></span>(neural);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;degree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, <span class="emphasis"><em>/*loops=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_add_constant" title="2.8.1. igraph_vector_add_constant — Add a constant to the vector.">igraph_vector_add_constant</a></strong></span>(&amp;degree, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices">igraph_assortativity</a></strong></span>(&amp;g, &amp;degree, 0, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices">igraph_assortativity</a></strong></span>(&amp;g, &amp;degree, 0, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;degree);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;indegree, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;outdegree, 0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;indegree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN, <span class="emphasis"><em>/*loops=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;outdegree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT, <span class="emphasis"><em>/*loops=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_add_constant" title="2.8.1. igraph_vector_add_constant — Add a constant to the vector.">igraph_vector_add_constant</a></strong></span>(&amp;indegree, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_add_constant" title="2.8.1. igraph_vector_add_constant — Add a constant to the vector.">igraph_vector_add_constant</a></strong></span>(&amp;outdegree, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices">igraph_assortativity</a></strong></span>(&amp;g, &amp;outdegree, &amp;indegree, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;indegree);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;outdegree);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="17.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree">igraph_assortativity_degree</a></strong></span>(&amp;g, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    karate = <span class="strong"><strong>fopen</strong></span>("karate.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, karate);
    <span class="strong"><strong>fclose</strong></span>(karate);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="17.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree">igraph_assortativity_degree</a></strong></span>(&amp;g, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, <span class="strong"><strong>sizeof</strong></span>(football_types) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t),
                 IGRAPH_UNDIRECTED,
                 0, 1, 2, 3, 0, 4, 4, 5, 3, 5, 2, 6, 6, 7, 7, 8, 8, 9, 0, 9, 4, 9, 5, 10, 10, 11, 5, 11,
                 3, 11, 12, 13, 2, 13, 2, 14, 12, 14, 14, 15, 13, 15, 2, 15, 4, 16, 9, 16, 0, 16,
                 16, 17, 12, 17, 12, 18, 18, 19, 17, 20, 20, 21, 8, 21, 7, 21, 9, 22, 7, 22, 21,
                 22, 8, 22, 22, 23, 9, 23, 4, 23, 16, 23, 0, 23, 11, 24, 24, 25, 1, 25, 3, 26, 12,
                 26, 14, 26, 26, 27, 17, 27, 1, 27, 17, 27, 4, 28, 11, 28, 24, 28, 19, 29, 29,
                 30, 19, 30, 18, 31, 31, 32, 21, 32, 15, 32, 13, 32, 6, 32, 0, 33, 1, 33, 25, 33,
                 19, 33, 31, 34, 26, 34, 12, 34, 18, 34, 34, 35, 0, 35, 29, 35, 19, 35, 30, 35,
                 18, 36, 12, 36, 20, 36, 19, 36, 36, 37, 1, 37, 25, 37, 33, 37, 18, 38, 16, 38,
                 28, 38, 26, 38, 14, 38, 12, 38, 38, 39, 6, 39, 32, 39, 13, 39, 15, 39, 7, 40, 3,
                 40, 40, 41, 8, 41, 4, 41, 23, 41, 9, 41, 0, 41, 16, 41, 34, 42, 29, 42, 18, 42,
                 26, 42, 42, 43, 36, 43, 26, 43, 31, 43, 38, 43, 12, 43, 14, 43, 19, 44, 35, 44,
                 30, 44, 44, 45, 13, 45, 33, 45, 1, 45, 37, 45, 25, 45, 21, 46, 46, 47, 22, 47,
                 6, 47, 15, 47, 2, 47, 39, 47, 32, 47, 44, 48, 48, 49, 32, 49, 46, 49, 30, 50,
                 24, 50, 11, 50, 28, 50, 50, 51, 40, 51, 8, 51, 22, 51, 21, 51, 3, 52, 40, 52, 5,
                 52, 52, 53, 25, 53, 48, 53, 49, 53, 46, 53, 39, 54, 31, 54, 38, 54, 14, 54, 34,
                 54, 18, 54, 54, 55, 31, 55, 6, 55, 35, 55, 29, 55, 19, 55, 30, 55, 27, 56, 56,
                 57, 1, 57, 42, 57, 44, 57, 48, 57, 3, 58, 6, 58, 17, 58, 36, 58, 36, 59, 58, 59,
                 59, 60, 10, 60, 39, 60, 6, 60, 47, 60, 13, 60, 15, 60, 2, 60, 43, 61, 47, 61,
                 54, 61, 18, 61, 26, 61, 31, 61, 34, 61, 61, 62, 20, 62, 45, 62, 17, 62, 27, 62,
                 56, 62, 27, 63, 58, 63, 59, 63, 42, 63, 63, 64, 9, 64, 32, 64, 60, 64, 2, 64, 6,
                 64, 47, 64, 13, 64, 0, 65, 27, 65, 17, 65, 63, 65, 56, 65, 20, 65, 65, 66, 59,
                 66, 24, 66, 44, 66, 48, 66, 16, 67, 41, 67, 46, 67, 53, 67, 49, 67, 67, 68, 15,
                 68, 50, 68, 21, 68, 51, 68, 7, 68, 22, 68, 8, 68, 4, 69, 24, 69, 28, 69, 50, 69,
                 11, 69, 69, 70, 43, 70, 65, 70, 20, 70, 56, 70, 62, 70, 27, 70, 60, 71, 18, 71,
                 14, 71, 34, 71, 54, 71, 38, 71, 61, 71, 31, 71, 71, 72, 2, 72, 10, 72, 3, 72,
                 40, 72, 52, 72, 7, 73, 49, 73, 53, 73, 67, 73, 46, 73, 73, 74, 2, 74, 72, 74, 5,
                 74, 10, 74, 52, 74, 3, 74, 40, 74, 20, 75, 66, 75, 48, 75, 57, 75, 44, 75, 75,
                 76, 27, 76, 59, 76, 20, 76, 70, 76, 66, 76, 56, 76, 62, 76, 73, 77, 22, 77, 7,
                 77, 51, 77, 21, 77, 8, 77, 77, 78, 23, 78, 50, 78, 28, 78, 22, 78, 8, 78, 68,
                 78, 7, 78, 51, 78, 31, 79, 43, 79, 30, 79, 19, 79, 29, 79, 35, 79, 55, 79, 79,
                 80, 37, 80, 29, 80, 16, 81, 5, 81, 40, 81, 10, 81, 72, 81, 3, 81, 81, 82, 74,
                 82, 39, 82, 77, 82, 80, 82, 30, 82, 29, 82, 7, 82, 53, 83, 81, 83, 69, 83, 73,
                 83, 46, 83, 67, 83, 49, 83, 83, 84, 24, 84, 49, 84, 52, 84, 3, 84, 74, 84, 10,
                 84, 81, 84, 5, 84, 3, 84, 6, 85, 14, 85, 38, 85, 43, 85, 80, 85, 12, 85, 26, 85,
                 31, 85, 44, 86, 53, 86, 75, 86, 57, 86, 48, 86, 80, 86, 66, 86, 86, 87, 17, 87,
                 62, 87, 56, 87, 24, 87, 20, 87, 65, 87, 49, 88, 58, 88, 83, 88, 69, 88, 46, 88,
                 53, 88, 73, 88, 67, 88, 88, 89, 1, 89, 37, 89, 25, 89, 33, 89, 55, 89, 45, 89,
                 5, 90, 8, 90, 23, 90, 0, 90, 11, 90, 50, 90, 24, 90, 69, 90, 28, 90, 29, 91, 48,
                 91, 66, 91, 69, 91, 44, 91, 86, 91, 57, 91, 80, 91, 91, 92, 35, 92, 15, 92, 86,
                 92, 48, 92, 57, 92, 61, 92, 66, 92, 75, 92, 0, 93, 23, 93, 80, 93, 16, 93, 4,
                 93, 82, 93, 91, 93, 41, 93, 9, 93, 34, 94, 19, 94, 55, 94, 79, 94, 80, 94, 29,
                 94, 30, 94, 82, 94, 35, 94, 70, 95, 69, 95, 76, 95, 62, 95, 56, 95, 27, 95, 17,
                 95, 87, 95, 37, 95, 48, 96, 17, 96, 76, 96, 27, 96, 56, 96, 65, 96, 20, 96, 87,
                 96, 5, 97, 86, 97, 58, 97, 11, 97, 59, 97, 63, 97, 97, 98, 77, 98, 48, 98, 84,
                 98, 40, 98, 10, 98, 5, 98, 52, 98, 81, 98, 89, 99, 34, 99, 14, 99, 85, 99, 54,
                 99, 18, 99, 31, 99, 61, 99, 71, 99, 14, 99, 99, 100, 82, 100, 13, 100, 2, 100,
                 15, 100, 32, 100, 64, 100, 47, 100, 39, 100, 6, 100, 51, 101, 30, 101, 94,
                 101, 1, 101, 79, 101, 58, 101, 19, 101, 55, 101, 35, 101, 29, 101, 100, 102,
                 74, 102, 52, 102, 98, 102, 72, 102, 40, 102, 10, 102, 3, 102, 102, 103, 33,
                 103, 45, 103, 25, 103, 89, 103, 37, 103, 1, 103, 70, 103, 72, 104, 11, 104,
                 0, 104, 93, 104, 67, 104, 41, 104, 16, 104, 87, 104, 23, 104, 4, 104, 9, 104,
                 89, 105, 103, 105, 33, 105, 62, 105, 37, 105, 45, 105, 1, 105, 80, 105, 25,
                 105, 25, 106, 56, 106, 92, 106, 2, 106, 13, 106, 32, 106, 60, 106, 6, 106,
                 64, 106, 15, 106, 39, 106, 88, 107, 75, 107, 98, 107, 102, 107, 72, 107, 40,
                 107, 81, 107, 5, 107, 10, 107, 84, 107, 4, 108, 9, 108, 7, 108, 51, 108, 77,
                 108, 21, 108, 78, 108, 22, 108, 68, 108, 79, 109, 30, 109, 63, 109, 1, 109,
                 33, 109, 103, 109, 105, 109, 45, 109, 25, 109, 89, 109, 37, 109, 67, 110,
                 13, 110, 24, 110, 80, 110, 88, 110, 49, 110, 73, 110, 46, 110, 83, 110, 53,
                 110, 23, 111, 64, 111, 46, 111, 78, 111, 8, 111, 21, 111, 51, 111, 7, 111,
                 108, 111, 68, 111, 77, 111, 52, 112, 96, 112, 97, 112, 57, 112, 66, 112, 63,
                 112, 44, 112, 92, 112, 75, 112, 91, 112, 28, 113, 20, 113, 95, 113, 59, 113,
                 70, 113, 17, 113, 87, 113, 76, 113, 65, 113, 96, 113, 83, 114, 88, 114, 110,
                 114, 53, 114, 49, 114, 73, 114, 46, 114, 67, 114, 58, 114, 15, 114, 104, 114,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph.">igraph_simplify</a></strong></span>(&amp;g, <span class="emphasis"><em>/*multiple=*/</em></span> 1, <span class="emphasis"><em>/*loops=*/</em></span> 1, <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;types, football_types,
                       <span class="strong"><strong>sizeof</strong></span>(football_types) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;types, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}

</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_assortativity_degree"></a>17.3. <code class="function">igraph_assortativity_degree</code> — Assortativity of a graph based on vertex degree</h3></div></div></div>
<a class="indexterm" name="idp105545270032200"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_assortativity_degree(const igraph_t *graph,
                                igraph_real_t *res,
                                igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



Assortativity based on vertex degree, please see the discussion at
the documentation of <a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices"><code class="function">igraph_assortativity()</code></a> for details.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to consider edge directions for
    directed graphs. This argument is ignored for undirected
    graphs. Supply 1 (=TRUE) here to do the natural thing, i.e. use
    directed version of the measure for directed graphs and the
    undirected version for undirected graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|+|V|), |E| is the number of edges, |V| is
the number of vertices.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices"><code class="function">igraph_assortativity()</code></a> for the general function
calculating assortativity for any kind of numeric vertex values.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545270045640"></a><p class="title"><b>Example 13.36.  File <code class="code">examples/simple/assortativity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2009-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    FILE *karate, *neural;
    igraph_real_t res;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> types;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> degree, outdegree, indegree;

    igraph_real_t football_types[] = {
        7, 0, 2, 3, 7, 3, 2, 8, 8, 7, 3, 10, 6, 2, 6, 2, 7, 9, 6, 1, 9, 8, 8, 7, 10, 0, 6, 9,
        11, 1, 1, 6, 2, 0, 6, 1, 5, 0, 6, 2, 3, 7, 5, 6, 4, 0, 11, 2, 4, 11, 10, 8, 3, 11, 6,
        1, 9, 4, 11, 10, 2, 6, 9, 10, 2, 9, 4, 11, 8, 10, 9, 6, 3, 11, 3, 4, 9, 8, 8, 1, 5, 3,
        5, 11, 3, 6, 4, 9, 11, 0, 5, 4, 4, 7, 1, 9, 9, 10, 3, 6, 2, 1, 3, 0, 7, 0, 2, 3, 8, 0,
        4, 8, 4, 9, 11
    };

    karate = <span class="strong"><strong>fopen</strong></span>("karate.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, karate);
    <span class="strong"><strong>fclose</strong></span>(karate);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;types, 0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;types, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, <span class="emphasis"><em>/*loops=*/</em></span> 1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;types, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    neural = <span class="strong"><strong>fopen</strong></span>("celegansneural.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, neural);
    <span class="strong"><strong>fclose</strong></span>(neural);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;types, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, <span class="emphasis"><em>/*loops=*/</em></span> 1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;types, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;types, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;types);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    karate = <span class="strong"><strong>fopen</strong></span>("karate.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, karate);
    <span class="strong"><strong>fclose</strong></span>(karate);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;degree, 0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;degree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, <span class="emphasis"><em>/*loops=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_add_constant" title="2.8.1. igraph_vector_add_constant — Add a constant to the vector.">igraph_vector_add_constant</a></strong></span>(&amp;degree, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices">igraph_assortativity</a></strong></span>(&amp;g, &amp;degree, 0, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    neural = <span class="strong"><strong>fopen</strong></span>("celegansneural.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, neural);
    <span class="strong"><strong>fclose</strong></span>(neural);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;degree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, <span class="emphasis"><em>/*loops=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_add_constant" title="2.8.1. igraph_vector_add_constant — Add a constant to the vector.">igraph_vector_add_constant</a></strong></span>(&amp;degree, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices">igraph_assortativity</a></strong></span>(&amp;g, &amp;degree, 0, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices">igraph_assortativity</a></strong></span>(&amp;g, &amp;degree, 0, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;degree);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;indegree, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;outdegree, 0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;indegree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN, <span class="emphasis"><em>/*loops=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="2.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;outdegree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT, <span class="emphasis"><em>/*loops=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_add_constant" title="2.8.1. igraph_vector_add_constant — Add a constant to the vector.">igraph_vector_add_constant</a></strong></span>(&amp;indegree, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_add_constant" title="2.8.1. igraph_vector_add_constant — Add a constant to the vector.">igraph_vector_add_constant</a></strong></span>(&amp;outdegree, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity" title="17.2. igraph_assortativity — Assortativity based on numeric properties of vertices">igraph_assortativity</a></strong></span>(&amp;g, &amp;outdegree, &amp;indegree, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;indegree);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;outdegree);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="17.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree">igraph_assortativity_degree</a></strong></span>(&amp;g, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    karate = <span class="strong"><strong>fopen</strong></span>("karate.gml", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_gml" title="4.1. igraph_read_graph_gml — Read a graph in GML format.">igraph_read_graph_gml</a></strong></span>(&amp;g, karate);
    <span class="strong"><strong>fclose</strong></span>(karate);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="17.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree">igraph_assortativity_degree</a></strong></span>(&amp;g, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 1);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/*---------------------*/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, <span class="strong"><strong>sizeof</strong></span>(football_types) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t),
                 IGRAPH_UNDIRECTED,
                 0, 1, 2, 3, 0, 4, 4, 5, 3, 5, 2, 6, 6, 7, 7, 8, 8, 9, 0, 9, 4, 9, 5, 10, 10, 11, 5, 11,
                 3, 11, 12, 13, 2, 13, 2, 14, 12, 14, 14, 15, 13, 15, 2, 15, 4, 16, 9, 16, 0, 16,
                 16, 17, 12, 17, 12, 18, 18, 19, 17, 20, 20, 21, 8, 21, 7, 21, 9, 22, 7, 22, 21,
                 22, 8, 22, 22, 23, 9, 23, 4, 23, 16, 23, 0, 23, 11, 24, 24, 25, 1, 25, 3, 26, 12,
                 26, 14, 26, 26, 27, 17, 27, 1, 27, 17, 27, 4, 28, 11, 28, 24, 28, 19, 29, 29,
                 30, 19, 30, 18, 31, 31, 32, 21, 32, 15, 32, 13, 32, 6, 32, 0, 33, 1, 33, 25, 33,
                 19, 33, 31, 34, 26, 34, 12, 34, 18, 34, 34, 35, 0, 35, 29, 35, 19, 35, 30, 35,
                 18, 36, 12, 36, 20, 36, 19, 36, 36, 37, 1, 37, 25, 37, 33, 37, 18, 38, 16, 38,
                 28, 38, 26, 38, 14, 38, 12, 38, 38, 39, 6, 39, 32, 39, 13, 39, 15, 39, 7, 40, 3,
                 40, 40, 41, 8, 41, 4, 41, 23, 41, 9, 41, 0, 41, 16, 41, 34, 42, 29, 42, 18, 42,
                 26, 42, 42, 43, 36, 43, 26, 43, 31, 43, 38, 43, 12, 43, 14, 43, 19, 44, 35, 44,
                 30, 44, 44, 45, 13, 45, 33, 45, 1, 45, 37, 45, 25, 45, 21, 46, 46, 47, 22, 47,
                 6, 47, 15, 47, 2, 47, 39, 47, 32, 47, 44, 48, 48, 49, 32, 49, 46, 49, 30, 50,
                 24, 50, 11, 50, 28, 50, 50, 51, 40, 51, 8, 51, 22, 51, 21, 51, 3, 52, 40, 52, 5,
                 52, 52, 53, 25, 53, 48, 53, 49, 53, 46, 53, 39, 54, 31, 54, 38, 54, 14, 54, 34,
                 54, 18, 54, 54, 55, 31, 55, 6, 55, 35, 55, 29, 55, 19, 55, 30, 55, 27, 56, 56,
                 57, 1, 57, 42, 57, 44, 57, 48, 57, 3, 58, 6, 58, 17, 58, 36, 58, 36, 59, 58, 59,
                 59, 60, 10, 60, 39, 60, 6, 60, 47, 60, 13, 60, 15, 60, 2, 60, 43, 61, 47, 61,
                 54, 61, 18, 61, 26, 61, 31, 61, 34, 61, 61, 62, 20, 62, 45, 62, 17, 62, 27, 62,
                 56, 62, 27, 63, 58, 63, 59, 63, 42, 63, 63, 64, 9, 64, 32, 64, 60, 64, 2, 64, 6,
                 64, 47, 64, 13, 64, 0, 65, 27, 65, 17, 65, 63, 65, 56, 65, 20, 65, 65, 66, 59,
                 66, 24, 66, 44, 66, 48, 66, 16, 67, 41, 67, 46, 67, 53, 67, 49, 67, 67, 68, 15,
                 68, 50, 68, 21, 68, 51, 68, 7, 68, 22, 68, 8, 68, 4, 69, 24, 69, 28, 69, 50, 69,
                 11, 69, 69, 70, 43, 70, 65, 70, 20, 70, 56, 70, 62, 70, 27, 70, 60, 71, 18, 71,
                 14, 71, 34, 71, 54, 71, 38, 71, 61, 71, 31, 71, 71, 72, 2, 72, 10, 72, 3, 72,
                 40, 72, 52, 72, 7, 73, 49, 73, 53, 73, 67, 73, 46, 73, 73, 74, 2, 74, 72, 74, 5,
                 74, 10, 74, 52, 74, 3, 74, 40, 74, 20, 75, 66, 75, 48, 75, 57, 75, 44, 75, 75,
                 76, 27, 76, 59, 76, 20, 76, 70, 76, 66, 76, 56, 76, 62, 76, 73, 77, 22, 77, 7,
                 77, 51, 77, 21, 77, 8, 77, 77, 78, 23, 78, 50, 78, 28, 78, 22, 78, 8, 78, 68,
                 78, 7, 78, 51, 78, 31, 79, 43, 79, 30, 79, 19, 79, 29, 79, 35, 79, 55, 79, 79,
                 80, 37, 80, 29, 80, 16, 81, 5, 81, 40, 81, 10, 81, 72, 81, 3, 81, 81, 82, 74,
                 82, 39, 82, 77, 82, 80, 82, 30, 82, 29, 82, 7, 82, 53, 83, 81, 83, 69, 83, 73,
                 83, 46, 83, 67, 83, 49, 83, 83, 84, 24, 84, 49, 84, 52, 84, 3, 84, 74, 84, 10,
                 84, 81, 84, 5, 84, 3, 84, 6, 85, 14, 85, 38, 85, 43, 85, 80, 85, 12, 85, 26, 85,
                 31, 85, 44, 86, 53, 86, 75, 86, 57, 86, 48, 86, 80, 86, 66, 86, 86, 87, 17, 87,
                 62, 87, 56, 87, 24, 87, 20, 87, 65, 87, 49, 88, 58, 88, 83, 88, 69, 88, 46, 88,
                 53, 88, 73, 88, 67, 88, 88, 89, 1, 89, 37, 89, 25, 89, 33, 89, 55, 89, 45, 89,
                 5, 90, 8, 90, 23, 90, 0, 90, 11, 90, 50, 90, 24, 90, 69, 90, 28, 90, 29, 91, 48,
                 91, 66, 91, 69, 91, 44, 91, 86, 91, 57, 91, 80, 91, 91, 92, 35, 92, 15, 92, 86,
                 92, 48, 92, 57, 92, 61, 92, 66, 92, 75, 92, 0, 93, 23, 93, 80, 93, 16, 93, 4,
                 93, 82, 93, 91, 93, 41, 93, 9, 93, 34, 94, 19, 94, 55, 94, 79, 94, 80, 94, 29,
                 94, 30, 94, 82, 94, 35, 94, 70, 95, 69, 95, 76, 95, 62, 95, 56, 95, 27, 95, 17,
                 95, 87, 95, 37, 95, 48, 96, 17, 96, 76, 96, 27, 96, 56, 96, 65, 96, 20, 96, 87,
                 96, 5, 97, 86, 97, 58, 97, 11, 97, 59, 97, 63, 97, 97, 98, 77, 98, 48, 98, 84,
                 98, 40, 98, 10, 98, 5, 98, 52, 98, 81, 98, 89, 99, 34, 99, 14, 99, 85, 99, 54,
                 99, 18, 99, 31, 99, 61, 99, 71, 99, 14, 99, 99, 100, 82, 100, 13, 100, 2, 100,
                 15, 100, 32, 100, 64, 100, 47, 100, 39, 100, 6, 100, 51, 101, 30, 101, 94,
                 101, 1, 101, 79, 101, 58, 101, 19, 101, 55, 101, 35, 101, 29, 101, 100, 102,
                 74, 102, 52, 102, 98, 102, 72, 102, 40, 102, 10, 102, 3, 102, 102, 103, 33,
                 103, 45, 103, 25, 103, 89, 103, 37, 103, 1, 103, 70, 103, 72, 104, 11, 104,
                 0, 104, 93, 104, 67, 104, 41, 104, 16, 104, 87, 104, 23, 104, 4, 104, 9, 104,
                 89, 105, 103, 105, 33, 105, 62, 105, 37, 105, 45, 105, 1, 105, 80, 105, 25,
                 105, 25, 106, 56, 106, 92, 106, 2, 106, 13, 106, 32, 106, 60, 106, 6, 106,
                 64, 106, 15, 106, 39, 106, 88, 107, 75, 107, 98, 107, 102, 107, 72, 107, 40,
                 107, 81, 107, 5, 107, 10, 107, 84, 107, 4, 108, 9, 108, 7, 108, 51, 108, 77,
                 108, 21, 108, 78, 108, 22, 108, 68, 108, 79, 109, 30, 109, 63, 109, 1, 109,
                 33, 109, 103, 109, 105, 109, 45, 109, 25, 109, 89, 109, 37, 109, 67, 110,
                 13, 110, 24, 110, 80, 110, 88, 110, 49, 110, 73, 110, 46, 110, 83, 110, 53,
                 110, 23, 111, 64, 111, 46, 111, 78, 111, 8, 111, 21, 111, 51, 111, 7, 111,
                 108, 111, 68, 111, 77, 111, 52, 112, 96, 112, 97, 112, 57, 112, 66, 112, 63,
                 112, 44, 112, 92, 112, 75, 112, 91, 112, 28, 113, 20, 113, 95, 113, 59, 113,
                 70, 113, 17, 113, 87, 113, 76, 113, 65, 113, 96, 113, 83, 114, 88, 114, 110,
                 114, 53, 114, 49, 114, 73, 114, 46, 114, 67, 114, 58, 114, 15, 114, 104, 114,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph.">igraph_simplify</a></strong></span>(&amp;g, <span class="emphasis"><em>/*multiple=*/</em></span> 1, <span class="emphasis"><em>/*loops=*/</em></span> 1, <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t.">igraph_vector_view</a></strong></span>(&amp;types, football_types,
                       <span class="strong"><strong>sizeof</strong></span>(football_types) / <span class="strong"><strong>sizeof</strong></span>(igraph_real_t));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_nominal" title="17.1. igraph_assortativity_nominal — Assortativity of a graph based on vertex categories">igraph_assortativity_nominal</a></strong></span>(&amp;g, &amp;types, &amp;res, <span class="emphasis"><em>/*directed=*/</em></span> 0);
    <span class="strong"><strong>printf</strong></span>("%.5f\n", res);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}

</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="k-cores"></a>18. K-Cores</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Structural.html#igraph_coreness">18.1. <code class="function">igraph_coreness</code> —  Finding the coreness of the vertices in a network.</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_coreness"></a>18.1. <code class="function">igraph_coreness</code> —  Finding the coreness of the vertices in a network.</h3></div></div></div>
<a class="indexterm" name="idp105545269988040"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_coreness(const igraph_t *graph, igraph_vector_t *cores,
                    igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



The k-core of a graph is a maximal subgraph in which each vertex
has at least degree k. (Degree here means the degree in the
subgraph of course.). The coreness of a vertex is the highest order
of a k-core containing the vertex.

</p>
<p>
This function implements the algorithm presented in Vladimir
Batagelj, Matjaz Zaversnik: An O(m) Algorithm for Cores
Decomposition of Networks.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cores</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result of the
       computation will be stored here. It will be resized as
       needed. For each vertex it contains the highest order of a
       core containing the vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graph it specifies whether to calculate
       in-cores, out-cores or the undirected version. It is ignored
       for undirected graphs. Possible values: <code class="constant">IGRAPH_ALL</code>
       undirected version, <code class="constant">IGRAPH_IN</code> in-cores, <code class="constant">IGRAPH_OUT</code>
       out-cores.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|), the number of edges.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="topological-sorting-directed-acyclic-graphs"></a>19. Topological Sorting, Directed Acyclic Graphs</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_dag">19.1. <code class="function">igraph_is_dag</code> — Checks whether a graph is a directed acyclic graph (DAG) or not.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_topological_sorting">19.2. <code class="function">igraph_topological_sorting</code> —  Calculate a possible topological sorting of the graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_feedback_arc_set">19.3. <code class="function">igraph_feedback_arc_set</code> —  Calculates a feedback arc set of the graph using different</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_dag"></a>19.1. <code class="function">igraph_is_dag</code> — Checks whether a graph is a directed acyclic graph (DAG) or not.</h3></div></div></div>
<a class="indexterm" name="idp105545270001480"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_dag(const igraph_t* graph, igraph_bool_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A directed acyclic graph (DAG) is a directed graph with no cycles.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean constant, the result
    is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), where |V| and |E| are the number of
vertices and edges in the original input graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_topological_sorting" title="19.2. igraph_topological_sorting — Calculate a possible topological sorting of the graph."><code class="function">igraph_topological_sorting()</code></a> to get a possible topological
    sorting of a DAG.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_topological_sorting"></a>19.2. <code class="function">igraph_topological_sorting</code> —  Calculate a possible topological sorting of the graph.</h3></div></div></div>
<a class="indexterm" name="idp105545271718472"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_topological_sorting(const igraph_t* graph, igraph_vector_t *res,
                               igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



</p>
<p>
A topological sorting of a directed acyclic graph (DAG) is a linear ordering
of its vertices where each vertex comes before all nodes to which it has
edges. Every DAG has at least one topological sort, and may have many.
This function returns one possible topological sort among them. If the
graph is not acyclic (it has at least one cycle), an error is raised.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result will be stored here.
  It will be resized if needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Specifies how to use the direction of the edges.
  For <code class="constant">IGRAPH_OUT</code>, the sorting order ensures that each vertex comes
  before all vertices to which it has edges, so vertices with no incoming
  edges go first. For <code class="constant">IGRAPH_IN</code>, it is quite the opposite: each
  vertex comes before all vertices from which it receives edges. Vertices
  with no outgoing edges go first.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), where |V| and |E| are the number of
vertices and edges in the original input graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_dag" title="19.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG) or not."><code class="function">igraph_is_dag()</code></a> if you are only interested in whether a given
    graph is a DAG or not, or <a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="19.3. igraph_feedback_arc_set — Calculates a feedback arc set of the graph using different"><code class="function">igraph_feedback_arc_set()</code></a> to find a
    set of edges whose removal makes the graph acyclic.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545271733064"></a><p class="title"><b>Example 13.37.  File <code class="code">examples/simple/igraph_topological_sorting.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2020  The igraph development team </em></span>&lt;igraph@igraph.org&gt;

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program.  If not, see </em></span>&lt;https://www.gnu.org/licenses/&gt;<span class="emphasis"><em>.</em></span>
<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;

    <span class="emphasis"><em>/* Test graph taken from </em></span>http://en.wikipedia.org/wiki/Topological_sorting
<span class="emphasis"><em>     * @ 05.03.2006 */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 8, IGRAPH_DIRECTED,
                 0, 3, 0, 4, 1, 3, 2, 4, 2, 7, 3, 5, 3, 6, 3, 7, 4, 6,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;res, 0);

    <span class="emphasis"><em>/* Sort the vertices in "increasing" order. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_topological_sorting" title="19.2. igraph_topological_sorting — Calculate a possible topological sorting of the graph.">igraph_topological_sorting</a></strong></span>(&amp;graph, &amp;res, IGRAPH_OUT);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;res);
    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="emphasis"><em>/* Sort the vertices in "decreasing" order. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_topological_sorting" title="19.2. igraph_topological_sorting — Calculate a possible topological sorting of the graph.">igraph_topological_sorting</a></strong></span>(&amp;graph, &amp;res, IGRAPH_IN);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;res);

    <span class="emphasis"><em>/* Destroy data structures when done using them. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_feedback_arc_set"></a>19.3. <code class="function">igraph_feedback_arc_set</code> —  Calculates a feedback arc set of the graph using different</h3></div></div></div>
<a class="indexterm" name="idp105545271753544"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_feedback_arc_set(const igraph_t *graph, igraph_vector_t *result,
                            const igraph_vector_t *weights, igraph_fas_algorithm_t algo);
</pre></div>
<p>
</p>
<p>



       algorithms.

</p>
<p>
A feedback arc set is a set of edges whose removal makes the graph acyclic.
We are usually interested in <span class="emphasis"><em>minimum</em></span> feedback arc sets, i.e. sets of edges
whose total weight is minimal among all the feedback arc sets.

</p>
<p>
For undirected graphs, the problem is simple: one has to find a maximum weight
spanning tree and then remove all the edges not in the spanning tree. For directed
graphs, this is an NP-hard problem, and various heuristics are usually used to
find an approximate solution to the problem. This function implements a few of
these heuristics.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  An initialized vector, the result will be returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Weight vector or NULL if no weights are specified.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td>
<p>
  The algorithm to use to solve the problem if the graph is directed.
       Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_FAS_EXACT_IP</code></span></p></td>
<td><p>

         Finds a <span class="emphasis"><em>minimum</em></span> feedback arc set using integer programming (IP).
         The complexity of this algorithm is exponential of course.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_FAS_APPROX_EADES</code></span></p></td>
<td><p>

         Finds a feedback arc set using the heuristic of Eades, Lin and
         Smyth (1993). This is guaranteed to be smaller than |E|/2 - |V|/6,
         and it is linear in the number of edges (i.e. O(|E|)).
         For more details, see Eades P, Lin X and Smyth WF: A fast and effective
         heuristic for the feedback arc set problem. In: Proc Inf Process Lett
         319-323, 1993.
       
</p></td>
</tr>
</tbody>
</table></div>
</td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code> if an unknown method was specified or the weight vector
           is invalid.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545271768776"></a><p class="title"><b>Example 13.38.  File <code class="code">examples/simple/igraph_feedback_arc_set.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2011-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;string.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights, result;
    igraph_bool_t dag;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;result, 0);

    <span class="emphasis"><em>/***********************************************************************/</em></span>
    <span class="emphasis"><em>/* Approximation with Eades' method                                    */</em></span>
    <span class="emphasis"><em>/***********************************************************************/</em></span>

    <span class="emphasis"><em>/* Simple unweighted graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 0, 2, 3, 2, 4, 0, 4, 4, 3, 5, 0, 6, 5, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="19.3. igraph_feedback_arc_set — Calculates a feedback arc set of the graph using different">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, 0, IGRAPH_FAS_APPROX_EADES);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="2.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="19.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG) or not.">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Simple weighted graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 0, 2, 3, 2, 4, 0, 4, 4, 3, 5, 0, 6, 5, -1);
    <span class="strong"><strong>igraph_vector_init_int_end</strong></span>(&amp;weights, -1, 1, 1, 3, 1, 1, 1, 1, 1, 1, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="19.3. igraph_feedback_arc_set — Calculates a feedback arc set of the graph using different">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, &amp;weights, IGRAPH_FAS_APPROX_EADES);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="2.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="19.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG) or not.">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Simple unweighted graph with loops */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 0, 2, 3, 2, 4, 0, 4, 4, 3, 5, 0, 6, 5, 1, 1, 4, 4, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="19.3. igraph_feedback_arc_set — Calculates a feedback arc set of the graph using different">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, 0, IGRAPH_FAS_APPROX_EADES);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="2.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="19.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG) or not.">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;result);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545271673160"></a><p class="title"><b>Example 13.39.  File <code class="code">examples/simple/igraph_feedback_arc_set_ip.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2011-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;string.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights, result;
    igraph_bool_t dag;
    int retval;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;result, 0);

    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(&amp;<a class="link" href="igraph-Error.html#igraph_error_handler_printignore" title="2.4. igraph_error_handler_printignore — Print and ignore errors.">igraph_error_handler_printignore</a>);

    <span class="emphasis"><em>/***********************************************************************/</em></span>
    <span class="emphasis"><em>/* Exact solution with integer programming                             */</em></span>
    <span class="emphasis"><em>/***********************************************************************/</em></span>

    <span class="emphasis"><em>/* Simple unweighted graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 0, 2, 3, 2, 4, 0, 4, 4, 3, 5, 0, 6, 5, -1);
    retval = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="19.3. igraph_feedback_arc_set — Calculates a feedback arc set of the graph using different">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, 0, IGRAPH_FAS_EXACT_IP);
    <span class="strong"><strong>if</strong></span> (retval == IGRAPH_UNIMPLEMENTED) {
        <span class="strong"><strong>return</strong></span> 77;
    }
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="2.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="19.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG) or not.">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Simple weighted graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 0, 2, 3, 2, 4, 0, 4, 4, 3, 5, 0, 6, 5, -1);
    <span class="strong"><strong>igraph_vector_init_int_end</strong></span>(&amp;weights, -1, 1, 1, 3, 1, 1, 1, 1, 1, 1, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="19.3. igraph_feedback_arc_set — Calculates a feedback arc set of the graph using different">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, &amp;weights, IGRAPH_FAS_EXACT_IP);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="2.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="19.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG) or not.">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Simple unweighted graph with loops */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 0, 2, 3, 2, 4, 0, 4, 4, 3, 5, 0, 6, 5, 1, 1, 4, 4, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="19.3. igraph_feedback_arc_set — Calculates a feedback arc set of the graph using different">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, 0, IGRAPH_FAS_EXACT_IP);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="2.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="19.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG) or not.">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Disjoint union of two almost identical graphs */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0, 1, 1, 2, 2, 0, 2, 3,  2, 4,  0, 4,  4, 3,    5, 0,  6, 5, 1, 1, 4, 4,
                 7, 8, 8, 9, 9, 7, 9, 10, 9, 11, 7, 11, 11, 10, 12, 7, 13, 12,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="19.3. igraph_feedback_arc_set — Calculates a feedback arc set of the graph using different">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, 0, IGRAPH_FAS_EXACT_IP);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="2.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="19.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG) or not.">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* Graph with lots of isolated vertices */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10000, IGRAPH_DIRECTED, 0, 1, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_feedback_arc_set" title="19.3. igraph_feedback_arc_set — Calculates a feedback arc set of the graph using different">igraph_feedback_arc_set</a></strong></span>(&amp;g, &amp;result, 0, IGRAPH_FAS_EXACT_IP);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;result);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="2.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(&amp;result));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_dag" title="19.1. igraph_is_dag — Checks whether a graph is a directed acyclic graph (DAG) or not.">igraph_is_dag</a></strong></span>(&amp;g, &amp;dag);
    <span class="strong"><strong>if</strong></span> (!dag) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;result);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p>
Time complexity: depends on <em class="parameter"><code>algo</code></em>, see the time complexities there.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="maximum-cardinality-search-graph-decomposition-chordal-graphs"></a>20. Maximum Cardinality Search, Graph Decomposition, Chordal Graphs</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_maximum_cardinality_search">20.1. <code class="function">igraph_maximum_cardinality_search</code> —  Maximum cardinality search.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_chordal">20.2. <code class="function">igraph_is_chordal</code> —  Decides whether a graph is chordal.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_maximum_cardinality_search"></a>20.1. <code class="function">igraph_maximum_cardinality_search</code> —  Maximum cardinality search.</h3></div></div></div>
<a class="indexterm" name="idp105545271857864"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_maximum_cardinality_search(const igraph_t *graph,
                                      igraph_vector_t *alpha,
                                      igraph_vector_t *alpham1);
</pre></div>
<p>
</p>
<p>



This function implements the maximum cardinality search algorithm
discussed in
Robert E Tarjan and Mihalis Yannakakis: Simple linear-time
algorithms to test chordality of graphs, test acyclicity of
hypergraphs, and selectively reduce acyclic hypergraphs.
SIAM Journal of Computation 13, 566--579, 1984.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Edge directions will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>alpha</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is stored here.
  It will be resized, as needed. Upon return it contains
  the rank of the each vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>alpham1</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a <code class="constant">NULL</code>
  pointer. If not <code class="constant">NULL</code>, then the inverse of <em class="parameter"><code>alpha</code></em> is stored
  here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in terms of the number of
vertices and edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_chordal" title="20.2. igraph_is_chordal — Decides whether a graph is chordal."><code class="function">igraph_is_chordal()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_chordal"></a>20.2. <code class="function">igraph_is_chordal</code> —  Decides whether a graph is chordal.</h3></div></div></div>
<a class="indexterm" name="idp105545271873224"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_chordal(const igraph_t *graph,
                      const igraph_vector_t *alpha,
                      const igraph_vector_t *alpham1,
                      igraph_bool_t *chordal,
                      igraph_vector_t *fill_in,
                      igraph_t *newgraph);
</pre></div>
<p>
</p>
<p>



A graph is chordal if each of its cycles of four or more nodes
has a chord, i.e. an edge joining two nodes that are not
adjacent in the cycle. An equivalent definition is that any
chordless cycles have at most three nodes.

If either <em class="parameter"><code>alpha</code></em> or <em class="parameter"><code>alpha1</code></em> is given, then the other is
calculated by taking simply the inverse. If neither are given,
then <a class="link" href="igraph-Structural.html#igraph_maximum_cardinality_search" title="20.1. igraph_maximum_cardinality_search — Maximum cardinality search."><code class="function">igraph_maximum_cardinality_search()</code></a> is called to calculate
them.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Edge directions will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>alpha</code></em>:</span></p></td>
<td><p>
  Either an alpha vector coming from
   <a class="link" href="igraph-Structural.html#igraph_maximum_cardinality_search" title="20.1. igraph_maximum_cardinality_search — Maximum cardinality search."><code class="function">igraph_maximum_cardinality_search()</code></a> (on the same graph), or a
   <code class="constant">NULL</code> pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>alpham1</code></em>:</span></p></td>
<td><p>
  Either an inverse alpha vector coming from <a class="link" href="igraph-Structural.html#igraph_maximum_cardinality_search" title="20.1. igraph_maximum_cardinality_search — Maximum cardinality search."><code class="function">igraph_maximum_cardinality_search()</code></a> (on the same graph) or a <code class="constant">NULL</code>
   pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>chordal</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>fill_in</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, or a <code class="constant">NULL</code>
   pointer. If not a <code class="constant">NULL</code> pointer, then the fill-in of the graph is
   stored here. The fill-in is the set of edges that are needed to
   make the graph chordal. The vector is resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>newgraph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph, or a <code class="constant">NULL</code>
  pointer. If not a null pointer, then a new triangulated graph is
  created here. This essentially means adding the fill-in edges to
  the original graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_maximum_cardinality_search" title="20.1. igraph_maximum_cardinality_search — Maximum cardinality search."><code class="function">igraph_maximum_cardinality_search()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="matchings"></a>21. Matchings</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_matching">21.1. <code class="function">igraph_is_matching</code> — Checks whether the given matching is valid for the given graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_maximal_matching">21.2. <code class="function">igraph_is_maximal_matching</code> — Checks whether a matching in a graph is maximal.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_maximum_bipartite_matching">21.3. <code class="function">igraph_maximum_bipartite_matching</code> — Calculates a maximum matching in a bipartite graph.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_matching"></a>21.1. <code class="function">igraph_is_matching</code> — Checks whether the given matching is valid for the given graph.</h3></div></div></div>
<a class="indexterm" name="idp105545271897544"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_matching(const igraph_t* graph,
                       const igraph_vector_bool_t* types, const igraph_vector_long_t* matching,
                       igraph_bool_t* result);
</pre></div>
<p>
</p>
<p>



This function checks a matching vector and verifies whether its length
matches the number of vertices in the given graph, its values are between
-1 (inclusive) and the number of vertices (exclusive), and whether there
exists a corresponding edge in the graph for every matched vertex pair.
For bipartite graphs, it also verifies whether the matched vertices are
in different parts of the graph.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It can be directed but the edge directions
             will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  If the graph is bipartite and you are interested in bipartite
             matchings only, pass the vertex types here. If the graph is
             non-bipartite, simply pass <code class="constant">NULL</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matching</code></em>:</span></p></td>
<td><p>
  The matching itself. It must be a vector where element i
                contains the ID of the vertex that vertex i is matched to,
                or -1 if vertex i is unmatched.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean variable, the result will be returned
              here.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="21.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal."><code class="function">igraph_is_maximal_matching()</code></a> if you are also interested in whether
    the matching is maximal (i.e. non-extendable).
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|) where |V| is the number of vertices and
|E| is the number of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545271909832"></a><p class="title"><b>Example 13.40.  File <code class="code">examples/simple/igraph_maximum_bipartite_matching.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2012  Tamas Nepusz </em></span>&lt;ntamas@gmail.com&gt;

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>test_graph_from_leda_tutorial</strong></span>() {
    <span class="emphasis"><em>/* Test graph from the LEDA tutorial:</em></span>
<span class="emphasis"><em>     * </em></span>http://www.leda-tutorial.org/en/unofficial/ch05s03s05.html
<span class="emphasis"><em>     */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_long_t matching;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_bool_t is_matching;
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0,
                 0, 8, 0, 12, 0, 14,
                 1, 9, 1, 10, 1, 13,
                 2, 8, 2, 9,
                 3, 10, 3, 11, 3, 13,
                 4, 9, 4, 14,
                 5, 14,
                 6, 9, 6, 14,
                 7, 8, 7, 12, 7, 14
                 , -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 15);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 15; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 8);
    }
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, 0, 0);
    <span class="strong"><strong>if</strong></span> (matching_size != 6) {
        <span class="strong"><strong>printf</strong></span>("matching_size is %ld, expected: 6\n", (long)matching_size);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (matching_weight != 6) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: 6\n", (long)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="21.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal.">igraph_is_maximal_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching, &amp;is_matching);
    <span class="strong"><strong>if</strong></span> (!is_matching) {
        <span class="strong"><strong>printf</strong></span>("not a matching: ");
        <span class="strong"><strong>igraph_vector_long_print</strong></span>(&amp;matching);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_from_mit_notes</strong></span>() {
    <span class="emphasis"><em>/* Test graph from the following lecture notes:</em></span>
<span class="emphasis"><em>     * </em></span>http://math.mit.edu/~goemans/18433S07/matching-notes.pdf
<span class="emphasis"><em>     */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_long_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_bool_t is_matching;
    igraph_real_t weight_array[] = { 2, 7, 2, 3,
                                     1, 3, 9, 3, 3,
                                     1, 3, 3, 1, 2,
                                     4, 1, 2,
                                     3
                                   };
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0,
                 0, 6, 0, 7, 0, 8, 0, 9,
                 1, 5, 1, 6, 1, 7, 1, 8, 1, 9,
                 2, 5, 2, 6, 2, 7, 2, 8, 2, 9,
                 3, 5, 3, 7, 3, 9,
                 4, 7, -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 10);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 5);
    }
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_copy" title="2.2.2. igraph_vector_init_copy — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_copy</a></strong></span>(&amp;weights, weight_array,
                            <span class="strong"><strong>sizeof</strong></span>(weight_array) / <span class="strong"><strong>sizeof</strong></span>(weight_array[0]));

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_size != 4) {
        <span class="strong"><strong>printf</strong></span>("matching_size is %ld, expected: 4\n", (long)matching_size);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (matching_weight != 19) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: 19\n", (long)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="21.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal.">igraph_is_maximal_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching, &amp;is_matching);
    <span class="strong"><strong>if</strong></span> (!is_matching) {
        <span class="strong"><strong>printf</strong></span>("not a matching: ");
        <span class="strong"><strong>igraph_vector_long_print</strong></span>(&amp;matching);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_generated</strong></span>() {
    <span class="emphasis"><em>/* Several randomly generated small test graphs */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_long_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_real_t weight_array_1[] = { 8, 5, 9, 18, 20, 13 };
    igraph_real_t weight_array_2[] = { 20, 4, 20, 3, 13, 1 };
    int i;

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 10);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 5);
    }
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);

    <span class="emphasis"><em>/* Case 1 */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0, 0, 8, 2, 7, 3, 7, 3, 8, 4, 5, 4, 9, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_copy" title="2.2.2. igraph_vector_init_copy — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_copy</a></strong></span>(&amp;weights, weight_array_1,
                            <span class="strong"><strong>sizeof</strong></span>(weight_array_1) / <span class="strong"><strong>sizeof</strong></span>(weight_array_1[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_weight != 43) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: 43\n", (long)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="emphasis"><em>/* Case 2 */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0, 0, 5, 0, 6, 1, 7, 2, 5, 3, 5, 3, 9, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_copy" title="2.2.2. igraph_vector_init_copy — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_copy</a></strong></span>(&amp;weights, weight_array_2,
                            <span class="strong"><strong>sizeof</strong></span>(weight_array_2) / <span class="strong"><strong>sizeof</strong></span>(weight_array_2[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_weight != 41) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: 41\n", (long)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_from_file</strong></span>(<span class="strong"><strong>const</strong></span> char* fname, int type1_count, long exp_weight) {
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_long_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_real_t matching_weight;
    FILE* f;
    int i, n;

    f = <span class="strong"><strong>fopen</strong></span>(fname, "r");
    <span class="strong"><strong>if</strong></span> (!f) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "No such file: %s\n", fname);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_ncol" title="1.3. igraph_read_graph_ncol — Reads a .ncol file used by LGL.">igraph_read_graph_ncol</a></strong></span>(&amp;graph, f, 0, 1, IGRAPH_ADD_WEIGHTS_YES, 0);
    <span class="strong"><strong>fclose</strong></span>(f);

    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;graph);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, n);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= type1_count);
    }

    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, 0);
    <span class="strong"><strong><a class="link" href="igraph-Attributes.html#EANV" title="2.1.24. EANV — Query a numeric edge attribute for all edges.">EANV</a></strong></span>(&amp;graph, "weight", &amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, 0, &amp;matching_weight,
                                      &amp;matching, &amp;weights, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);

    <span class="strong"><strong>igraph_vector_long_print</strong></span>(&amp;matching);
    <span class="strong"><strong>if</strong></span> (matching_weight != exp_weight) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: %ld\n", (long)matching_weight,
               (long)exp_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

<span class="emphasis"><em>// This test addresses issue #1110, where an incorrect</em></span>
<span class="emphasis"><em>// types vector (i.e. that doesn't correspond to a bipartite</em></span>
<span class="emphasis"><em>// labelling of the graph) would cause a possible infinite loop.</em></span>
int <span class="strong"><strong>test_incorrect_types</strong></span>() {
    igraph_t g;
    igraph_vector_bool_t types;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;

    igraph_integer_t matching_size;
    igraph_real_t weighted_size;

    igraph_vector_long_t matching;

    <a class="link" href="igraph-Error.html#igraph_error_type_t" title="3.1. igraph_error_type_t — Error code type.">igraph_error_type_t</a> err;


    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 4, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 0, 3,
                 -1);

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 4);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[0] = 0;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[1] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[2] = 0;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[3] = 1;

    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_fill" title="2.3.2. igraph_vector_fill — Fill a vector with a constant element">igraph_vector_fill</a></strong></span>(&amp;weights, 1.0);

    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(&amp;<a class="link" href="igraph-Error.html#igraph_error_handler_ignore" title="2.3. igraph_error_handler_ignore — Ignore errors.">igraph_error_handler_ignore</a>);

    <span class="emphasis"><em>// Test incorrect types</em></span>
    err = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;g, &amp;types, &amp;matching_size, NULL, &amp;matching, NULL, 0);
    <span class="strong"><strong>if</strong></span> (err != IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="emphasis"><em>// Test correct types</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[2] = 1;
    err = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;g, &amp;types, &amp;matching_size, NULL, &amp;matching, NULL, 0);
    <span class="strong"><strong>if</strong></span> (err == IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    <span class="emphasis"><em>// Test incorrect types for weighted graph</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[2] = 0;
    err = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;g, &amp;types, &amp;matching_size, &amp;weighted_size, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (err != IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="emphasis"><em>// Test correct types for weighted graph</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[2] = 1;
    err = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;g, &amp;types, &amp;matching_size, &amp;weighted_size, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (err == IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);

    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {
    <span class="strong"><strong><a class="link" href="igraph-Attributes.html#igraph_set_attribute_table" title="1.2. igraph_set_attribute_table — Attach an attribute table.">igraph_set_attribute_table</a></strong></span>(&amp;igraph_cattribute_table);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_graph_from_leda_tutorial</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_weighted_graph_from_mit_notes</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_weighted_graph_generated</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_incorrect_types</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>printf</strong></span>("Finally stack still has %d elements.\n", <span class="strong"><strong>IGRAPH_FINALLY_STACK_SIZE</strong></span>());
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_maximal_matching"></a>21.2. <code class="function">igraph_is_maximal_matching</code> — Checks whether a matching in a graph is maximal.</h3></div></div></div>
<a class="indexterm" name="idp105545271498184"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_maximal_matching(const igraph_t* graph,
                               const igraph_vector_bool_t* types, const igraph_vector_long_t* matching,
                               igraph_bool_t* result);
</pre></div>
<p>
</p>
<p>



A matching is maximal if and only if there exists no unmatched vertex in a
graph such that one of its neighbors is also unmatched.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It can be directed but the edge directions
             will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  If the graph is bipartite and you are interested in bipartite
             matchings only, pass the vertex types here. If the graph is
             non-bipartite, simply pass <code class="constant">NULL</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matching</code></em>:</span></p></td>
<td><p>
  The matching itself. It must be a vector where element i
                contains the ID of the vertex that vertex i is matched to,
                or -1 if vertex i is unmatched.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean variable, the result will be returned
              here.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_matching" title="21.1. igraph_is_matching — Checks whether the given matching is valid for the given graph."><code class="function">igraph_is_matching()</code></a> if you are only interested in whether a
    matching vector is valid for a given graph.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|) where |V| is the number of vertices and
|E| is the number of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545271510472"></a><p class="title"><b>Example 13.41.  File <code class="code">examples/simple/igraph_maximum_bipartite_matching.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2012  Tamas Nepusz </em></span>&lt;ntamas@gmail.com&gt;

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>test_graph_from_leda_tutorial</strong></span>() {
    <span class="emphasis"><em>/* Test graph from the LEDA tutorial:</em></span>
<span class="emphasis"><em>     * </em></span>http://www.leda-tutorial.org/en/unofficial/ch05s03s05.html
<span class="emphasis"><em>     */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_long_t matching;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_bool_t is_matching;
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0,
                 0, 8, 0, 12, 0, 14,
                 1, 9, 1, 10, 1, 13,
                 2, 8, 2, 9,
                 3, 10, 3, 11, 3, 13,
                 4, 9, 4, 14,
                 5, 14,
                 6, 9, 6, 14,
                 7, 8, 7, 12, 7, 14
                 , -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 15);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 15; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 8);
    }
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, 0, 0);
    <span class="strong"><strong>if</strong></span> (matching_size != 6) {
        <span class="strong"><strong>printf</strong></span>("matching_size is %ld, expected: 6\n", (long)matching_size);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (matching_weight != 6) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: 6\n", (long)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="21.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal.">igraph_is_maximal_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching, &amp;is_matching);
    <span class="strong"><strong>if</strong></span> (!is_matching) {
        <span class="strong"><strong>printf</strong></span>("not a matching: ");
        <span class="strong"><strong>igraph_vector_long_print</strong></span>(&amp;matching);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_from_mit_notes</strong></span>() {
    <span class="emphasis"><em>/* Test graph from the following lecture notes:</em></span>
<span class="emphasis"><em>     * </em></span>http://math.mit.edu/~goemans/18433S07/matching-notes.pdf
<span class="emphasis"><em>     */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_long_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_bool_t is_matching;
    igraph_real_t weight_array[] = { 2, 7, 2, 3,
                                     1, 3, 9, 3, 3,
                                     1, 3, 3, 1, 2,
                                     4, 1, 2,
                                     3
                                   };
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0,
                 0, 6, 0, 7, 0, 8, 0, 9,
                 1, 5, 1, 6, 1, 7, 1, 8, 1, 9,
                 2, 5, 2, 6, 2, 7, 2, 8, 2, 9,
                 3, 5, 3, 7, 3, 9,
                 4, 7, -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 10);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 5);
    }
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_copy" title="2.2.2. igraph_vector_init_copy — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_copy</a></strong></span>(&amp;weights, weight_array,
                            <span class="strong"><strong>sizeof</strong></span>(weight_array) / <span class="strong"><strong>sizeof</strong></span>(weight_array[0]));

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_size != 4) {
        <span class="strong"><strong>printf</strong></span>("matching_size is %ld, expected: 4\n", (long)matching_size);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (matching_weight != 19) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: 19\n", (long)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="21.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal.">igraph_is_maximal_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching, &amp;is_matching);
    <span class="strong"><strong>if</strong></span> (!is_matching) {
        <span class="strong"><strong>printf</strong></span>("not a matching: ");
        <span class="strong"><strong>igraph_vector_long_print</strong></span>(&amp;matching);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_generated</strong></span>() {
    <span class="emphasis"><em>/* Several randomly generated small test graphs */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_long_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_real_t weight_array_1[] = { 8, 5, 9, 18, 20, 13 };
    igraph_real_t weight_array_2[] = { 20, 4, 20, 3, 13, 1 };
    int i;

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 10);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 5);
    }
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);

    <span class="emphasis"><em>/* Case 1 */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0, 0, 8, 2, 7, 3, 7, 3, 8, 4, 5, 4, 9, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_copy" title="2.2.2. igraph_vector_init_copy — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_copy</a></strong></span>(&amp;weights, weight_array_1,
                            <span class="strong"><strong>sizeof</strong></span>(weight_array_1) / <span class="strong"><strong>sizeof</strong></span>(weight_array_1[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_weight != 43) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: 43\n", (long)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="emphasis"><em>/* Case 2 */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0, 0, 5, 0, 6, 1, 7, 2, 5, 3, 5, 3, 9, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_copy" title="2.2.2. igraph_vector_init_copy — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_copy</a></strong></span>(&amp;weights, weight_array_2,
                            <span class="strong"><strong>sizeof</strong></span>(weight_array_2) / <span class="strong"><strong>sizeof</strong></span>(weight_array_2[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_weight != 41) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: 41\n", (long)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_from_file</strong></span>(<span class="strong"><strong>const</strong></span> char* fname, int type1_count, long exp_weight) {
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_long_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_real_t matching_weight;
    FILE* f;
    int i, n;

    f = <span class="strong"><strong>fopen</strong></span>(fname, "r");
    <span class="strong"><strong>if</strong></span> (!f) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "No such file: %s\n", fname);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_ncol" title="1.3. igraph_read_graph_ncol — Reads a .ncol file used by LGL.">igraph_read_graph_ncol</a></strong></span>(&amp;graph, f, 0, 1, IGRAPH_ADD_WEIGHTS_YES, 0);
    <span class="strong"><strong>fclose</strong></span>(f);

    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;graph);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, n);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= type1_count);
    }

    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, 0);
    <span class="strong"><strong><a class="link" href="igraph-Attributes.html#EANV" title="2.1.24. EANV — Query a numeric edge attribute for all edges.">EANV</a></strong></span>(&amp;graph, "weight", &amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, 0, &amp;matching_weight,
                                      &amp;matching, &amp;weights, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);

    <span class="strong"><strong>igraph_vector_long_print</strong></span>(&amp;matching);
    <span class="strong"><strong>if</strong></span> (matching_weight != exp_weight) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: %ld\n", (long)matching_weight,
               (long)exp_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

<span class="emphasis"><em>// This test addresses issue #1110, where an incorrect</em></span>
<span class="emphasis"><em>// types vector (i.e. that doesn't correspond to a bipartite</em></span>
<span class="emphasis"><em>// labelling of the graph) would cause a possible infinite loop.</em></span>
int <span class="strong"><strong>test_incorrect_types</strong></span>() {
    igraph_t g;
    igraph_vector_bool_t types;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;

    igraph_integer_t matching_size;
    igraph_real_t weighted_size;

    igraph_vector_long_t matching;

    <a class="link" href="igraph-Error.html#igraph_error_type_t" title="3.1. igraph_error_type_t — Error code type.">igraph_error_type_t</a> err;


    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 4, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 0, 3,
                 -1);

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 4);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[0] = 0;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[1] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[2] = 0;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[3] = 1;

    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_fill" title="2.3.2. igraph_vector_fill — Fill a vector with a constant element">igraph_vector_fill</a></strong></span>(&amp;weights, 1.0);

    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(&amp;<a class="link" href="igraph-Error.html#igraph_error_handler_ignore" title="2.3. igraph_error_handler_ignore — Ignore errors.">igraph_error_handler_ignore</a>);

    <span class="emphasis"><em>// Test incorrect types</em></span>
    err = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;g, &amp;types, &amp;matching_size, NULL, &amp;matching, NULL, 0);
    <span class="strong"><strong>if</strong></span> (err != IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="emphasis"><em>// Test correct types</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[2] = 1;
    err = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;g, &amp;types, &amp;matching_size, NULL, &amp;matching, NULL, 0);
    <span class="strong"><strong>if</strong></span> (err == IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    <span class="emphasis"><em>// Test incorrect types for weighted graph</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[2] = 0;
    err = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;g, &amp;types, &amp;matching_size, &amp;weighted_size, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (err != IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="emphasis"><em>// Test correct types for weighted graph</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[2] = 1;
    err = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;g, &amp;types, &amp;matching_size, &amp;weighted_size, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (err == IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);

    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {
    <span class="strong"><strong><a class="link" href="igraph-Attributes.html#igraph_set_attribute_table" title="1.2. igraph_set_attribute_table — Attach an attribute table.">igraph_set_attribute_table</a></strong></span>(&amp;igraph_cattribute_table);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_graph_from_leda_tutorial</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_weighted_graph_from_mit_notes</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_weighted_graph_generated</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_incorrect_types</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>printf</strong></span>("Finally stack still has %d elements.\n", <span class="strong"><strong>IGRAPH_FINALLY_STACK_SIZE</strong></span>());
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_maximum_bipartite_matching"></a>21.3. <code class="function">igraph_maximum_bipartite_matching</code> — Calculates a maximum matching in a bipartite graph.</h3></div></div></div>
<a class="indexterm" name="idp105545271623112"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_maximum_bipartite_matching(const igraph_t* graph,
                                      const igraph_vector_bool_t* types, igraph_integer_t* matching_size,
                                      igraph_real_t* matching_weight, igraph_vector_long_t* matching,
                                      const igraph_vector_t* weights, igraph_real_t eps);
</pre></div>
<p>
</p>
<p>



A matching in a bipartite graph is a partial assignment of vertices
of the first kind to vertices of the second kind such that each vertex of
the first kind is matched to at most one vertex of the second kind and
vice versa, and matched vertices must be connected by an edge in the graph.
The size (or cardinality) of a matching is the number of edges.
A matching is a maximum matching if there exists no other matching with
larger cardinality. For weighted graphs, a maximum matching is a matching
whose edges have the largest possible total weight among all possible
matchings.

</p>
<p>
Maximum matchings in bipartite graphs are found by the push-relabel algorithm
with greedy initialization and a global relabeling after every n/2 steps where
n is the number of vertices in the graph.

</p>
<p>
References: Cherkassky BV, Goldberg AV, Martin P, Setubal JC and Stolfi J:
Augment or push: A computational study of bipartite matching and
unit-capacity flow algorithms. ACM Journal of Experimental Algorithmics 3,
1998.

</p>
<p>
Kaya K, Langguth J, Manne F and Ucar B: Experiments on push-relabel-based
maximum cardinality matching algorithms for bipartite graphs. Technical
Report TR/PA/11/33 of the Centre Europeen de Recherche et de Formation
Avancee en Calcul Scientifique, 2011.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It can be directed but the edge directions
             will be ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Boolean vector giving the vertex types of the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matching_size</code></em>:</span></p></td>
<td><p>
  The size of the matching (i.e. the number of matched
                     vertex pairs will be returned here). It may be <code class="constant">NULL</code>
                     if you don't need this.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matching_weight</code></em>:</span></p></td>
<td><p>
  The weight of the matching if the edges are weighted,
                       or the size of the matching again if the edges are
                       unweighted. It may be <code class="constant">NULL</code> if you don't need this.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matching</code></em>:</span></p></td>
<td><p>
  The matching itself. It must be a vector where element i
                contains the ID of the vertex that vertex i is matched to,
                or -1 if vertex i is unmatched.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  A null pointer (=no edge weights), or a vector giving the
               weights of the edges. Note that the algorithm is stable
               only for integer weights.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>eps</code></em>:</span></p></td>
<td><p>
  A small real number used in equality tests in the weighted
           bipartite matching algorithm. Two real numbers are considered
           equal in the algorithm if their difference is smaller than
           <code class="constant">eps</code>. This is required to avoid the accumulation of numerical
           errors. It is advised to pass a value derived from the
           <code class="constant">DBL_EPSILON</code> constant in <code class="constant">float</code>.h here. If you are
           running the algorithm with no <code class="constant">weights</code> vector, this argument
           is ignored.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(sqrt(|V|) |E|) for unweighted graphs (according to the
technical report referenced above), O(|V||E|) for weighted graphs.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545271641672"></a><p class="title"><b>Example 13.42.  File <code class="code">examples/simple/igraph_maximum_bipartite_matching.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/* vim:set ts=4 sw=4 sts=4 et: */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2012  Tamas Nepusz </em></span>&lt;ntamas@gmail.com&gt;

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>test_graph_from_leda_tutorial</strong></span>() {
    <span class="emphasis"><em>/* Test graph from the LEDA tutorial:</em></span>
<span class="emphasis"><em>     * </em></span>http://www.leda-tutorial.org/en/unofficial/ch05s03s05.html
<span class="emphasis"><em>     */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_long_t matching;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_bool_t is_matching;
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0,
                 0, 8, 0, 12, 0, 14,
                 1, 9, 1, 10, 1, 13,
                 2, 8, 2, 9,
                 3, 10, 3, 11, 3, 13,
                 4, 9, 4, 14,
                 5, 14,
                 6, 9, 6, 14,
                 7, 8, 7, 12, 7, 14
                 , -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 15);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 15; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 8);
    }
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, 0, 0);
    <span class="strong"><strong>if</strong></span> (matching_size != 6) {
        <span class="strong"><strong>printf</strong></span>("matching_size is %ld, expected: 6\n", (long)matching_size);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (matching_weight != 6) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: 6\n", (long)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="21.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal.">igraph_is_maximal_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching, &amp;is_matching);
    <span class="strong"><strong>if</strong></span> (!is_matching) {
        <span class="strong"><strong>printf</strong></span>("not a matching: ");
        <span class="strong"><strong>igraph_vector_long_print</strong></span>(&amp;matching);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_from_mit_notes</strong></span>() {
    <span class="emphasis"><em>/* Test graph from the following lecture notes:</em></span>
<span class="emphasis"><em>     * </em></span>http://math.mit.edu/~goemans/18433S07/matching-notes.pdf
<span class="emphasis"><em>     */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_long_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_bool_t is_matching;
    igraph_real_t weight_array[] = { 2, 7, 2, 3,
                                     1, 3, 9, 3, 3,
                                     1, 3, 3, 1, 2,
                                     4, 1, 2,
                                     3
                                   };
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0,
                 0, 6, 0, 7, 0, 8, 0, 9,
                 1, 5, 1, 6, 1, 7, 1, 8, 1, 9,
                 2, 5, 2, 6, 2, 7, 2, 8, 2, 9,
                 3, 5, 3, 7, 3, 9,
                 4, 7, -1);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 10);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 5);
    }
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_copy" title="2.2.2. igraph_vector_init_copy — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_copy</a></strong></span>(&amp;weights, weight_array,
                            <span class="strong"><strong>sizeof</strong></span>(weight_array) / <span class="strong"><strong>sizeof</strong></span>(weight_array[0]));

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_size != 4) {
        <span class="strong"><strong>printf</strong></span>("matching_size is %ld, expected: 4\n", (long)matching_size);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (matching_weight != 19) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: 19\n", (long)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_maximal_matching" title="21.2. igraph_is_maximal_matching — Checks whether a matching in a graph is maximal.">igraph_is_maximal_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching, &amp;is_matching);
    <span class="strong"><strong>if</strong></span> (!is_matching) {
        <span class="strong"><strong>printf</strong></span>("not a matching: ");
        <span class="strong"><strong>igraph_vector_long_print</strong></span>(&amp;matching);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_generated</strong></span>() {
    <span class="emphasis"><em>/* Several randomly generated small test graphs */</em></span>
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_long_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_integer_t matching_size;
    igraph_real_t matching_weight;
    igraph_real_t weight_array_1[] = { 8, 5, 9, 18, 20, 13 };
    igraph_real_t weight_array_2[] = { 20, 4, 20, 3, 13, 1 };
    int i;

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 10);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= 5);
    }
    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);

    <span class="emphasis"><em>/* Case 1 */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0, 0, 8, 2, 7, 3, 7, 3, 8, 4, 5, 4, 9, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_copy" title="2.2.2. igraph_vector_init_copy — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_copy</a></strong></span>(&amp;weights, weight_array_1,
                            <span class="strong"><strong>sizeof</strong></span>(weight_array_1) / <span class="strong"><strong>sizeof</strong></span>(weight_array_1[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_weight != 43) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: 43\n", (long)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="emphasis"><em>/* Case 2 */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;graph, 0, 0, 0, 5, 0, 6, 1, 7, 2, 5, 3, 5, 3, 9, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_copy" title="2.2.2. igraph_vector_init_copy — Initializes a vector from an ordinary C array (constructor).">igraph_vector_init_copy</a></strong></span>(&amp;weights, weight_array_2,
                            <span class="strong"><strong>sizeof</strong></span>(weight_array_2) / <span class="strong"><strong>sizeof</strong></span>(weight_array_2[0]));
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, &amp;matching_size,
                                      &amp;matching_weight, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (matching_weight != 41) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: 41\n", (long)matching_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>test_weighted_graph_from_file</strong></span>(<span class="strong"><strong>const</strong></span> char* fname, int type1_count, long exp_weight) {
    igraph_t graph;
    igraph_vector_bool_t types;
    igraph_vector_long_t matching;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_real_t matching_weight;
    FILE* f;
    int i, n;

    f = <span class="strong"><strong>fopen</strong></span>(fname, "r");
    <span class="strong"><strong>if</strong></span> (!f) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "No such file: %s\n", fname);
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_ncol" title="1.3. igraph_read_graph_ncol — Reads a .ncol file used by LGL.">igraph_read_graph_ncol</a></strong></span>(&amp;graph, f, 0, 1, IGRAPH_ADD_WEIGHTS_YES, 0);
    <span class="strong"><strong>fclose</strong></span>(f);

    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;graph);
    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, n);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[i] = (i &gt;= type1_count);
    }

    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, 0);
    <span class="strong"><strong><a class="link" href="igraph-Attributes.html#EANV" title="2.1.24. EANV — Query a numeric edge attribute for all edges.">EANV</a></strong></span>(&amp;graph, "weight", &amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;graph, &amp;types, 0, &amp;matching_weight,
                                      &amp;matching, &amp;weights, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);

    <span class="strong"><strong>igraph_vector_long_print</strong></span>(&amp;matching);
    <span class="strong"><strong>if</strong></span> (matching_weight != exp_weight) {
        <span class="strong"><strong>printf</strong></span>("matching_weight is %ld, expected: %ld\n", (long)matching_weight,
               (long)exp_weight);
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);
    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}

<span class="emphasis"><em>// This test addresses issue #1110, where an incorrect</em></span>
<span class="emphasis"><em>// types vector (i.e. that doesn't correspond to a bipartite</em></span>
<span class="emphasis"><em>// labelling of the graph) would cause a possible infinite loop.</em></span>
int <span class="strong"><strong>test_incorrect_types</strong></span>() {
    igraph_t g;
    igraph_vector_bool_t types;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;

    igraph_integer_t matching_size;
    igraph_real_t weighted_size;

    igraph_vector_long_t matching;

    <a class="link" href="igraph-Error.html#igraph_error_type_t" title="3.1. igraph_error_type_t — Error code type.">igraph_error_type_t</a> err;


    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 4, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 0, 3,
                 -1);

    <span class="strong"><strong>igraph_vector_bool_init</strong></span>(&amp;types, 4);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[0] = 0;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[1] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[2] = 0;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[3] = 1;

    <span class="strong"><strong>igraph_vector_long_init</strong></span>(&amp;matching, 0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_fill" title="2.3.2. igraph_vector_fill — Fill a vector with a constant element">igraph_vector_fill</a></strong></span>(&amp;weights, 1.0);

    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(&amp;<a class="link" href="igraph-Error.html#igraph_error_handler_ignore" title="2.3. igraph_error_handler_ignore — Ignore errors.">igraph_error_handler_ignore</a>);

    <span class="emphasis"><em>// Test incorrect types</em></span>
    err = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;g, &amp;types, &amp;matching_size, NULL, &amp;matching, NULL, 0);
    <span class="strong"><strong>if</strong></span> (err != IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="emphasis"><em>// Test correct types</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[2] = 1;
    err = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;g, &amp;types, &amp;matching_size, NULL, &amp;matching, NULL, 0);
    <span class="strong"><strong>if</strong></span> (err == IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    <span class="emphasis"><em>// Test incorrect types for weighted graph</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[2] = 0;
    err = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;g, &amp;types, &amp;matching_size, &amp;weighted_size, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (err != IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="emphasis"><em>// Test correct types for weighted graph</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(types)[2] = 1;
    err = <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_maximum_bipartite_matching" title="21.3. igraph_maximum_bipartite_matching — Calculates a maximum matching in a bipartite graph.">igraph_maximum_bipartite_matching</a></strong></span>(&amp;g, &amp;types, &amp;matching_size, &amp;weighted_size, &amp;matching, &amp;weights, 0);
    <span class="strong"><strong>if</strong></span> (err == IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_long_destroy</strong></span>(&amp;matching);

    <span class="strong"><strong>igraph_vector_bool_destroy</strong></span>(&amp;types);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {
    <span class="strong"><strong><a class="link" href="igraph-Attributes.html#igraph_set_attribute_table" title="1.2. igraph_set_attribute_table — Attach an attribute table.">igraph_set_attribute_table</a></strong></span>(&amp;igraph_cattribute_table);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_graph_from_leda_tutorial</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_weighted_graph_from_mit_notes</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_weighted_graph_generated</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>test_incorrect_types</strong></span>()) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>printf</strong></span>("Finally stack still has %d elements.\n", <span class="strong"><strong>IGRAPH_FINALLY_STACK_SIZE</strong></span>());
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="unfolding-a-graph-into-a-tree"></a>22. Unfolding a Graph Into a Tree</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Structural.html#igraph_unfold_tree">22.1. <code class="function">igraph_unfold_tree</code> — Unfolding a graph into a tree, by possibly multiplicating its vertices.</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_unfold_tree"></a>22.1. <code class="function">igraph_unfold_tree</code> — Unfolding a graph into a tree, by possibly multiplicating its vertices.</h3></div></div></div>
<a class="indexterm" name="idp105545271230792"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_unfold_tree(const igraph_t *graph, igraph_t *tree,
                       igraph_neimode_t mode, const igraph_vector_t *roots,
                       igraph_vector_t *vertex_index);
</pre></div>
<p>
</p>
<p>



A graph is converted into a tree (or forest, if it is unconnected),
by performing a breadth-first search on it, and replicating
vertices that were found a second, third, etc. time.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it can be either directed or
  undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>tree</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the result is
  stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  For directed graphs; whether to follow paths along edge
   directions (<code class="constant">IGRAPH_OUT</code>), or the opposite (<code class="constant">IGRAPH_IN</code>), or
   ignore edge directions completely (<code class="constant">IGRAPH_ALL</code>). It is ignored
   for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>roots</code></em>:</span></p></td>
<td><p>
  A numeric vector giving the root vertex, or vertices
  (if the graph is not connected), to start from.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_index</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, or a null
  pointer. If not a null pointer, then a mapping from the vertices
  in the new graph to the ones in the original is created here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n+m), linear in the number vertices and edges.

 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="other-operations"></a>23. Other Operations</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Structural.html#igraph_density">23.1. <code class="function">igraph_density</code> — Calculate the density of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_reciprocity">23.2. <code class="function">igraph_reciprocity</code> —  Calculates the reciprocity of a directed graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_diversity">23.3. <code class="function">igraph_diversity</code> — Structural diversity index of the vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_is_mutual">23.4. <code class="function">igraph_is_mutual</code> — Check whether the edges of a directed graph are mutual.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_avg_nearest_neighbor_degree">23.5. <code class="function">igraph_avg_nearest_neighbor_degree</code> — Average neighbor degree.</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_adjacency">23.6. <code class="function">igraph_get_adjacency</code> —  Returns the adjacency matrix of a graph</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_stochastic">23.7. <code class="function">igraph_get_stochastic</code> — Stochastic adjacency matrix of a graph</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_stochastic_sparsemat">23.8. <code class="function">igraph_get_stochastic_sparsemat</code> —  Stochastic adjacency matrix of a graph</a></span></dt>
<dt><span class="section"><a href="igraph-Structural.html#igraph_get_edgelist">23.9. <code class="function">igraph_get_edgelist</code> —  Returns the list of edges in a graph</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_density"></a>23.1. <code class="function">igraph_density</code> — Calculate the density of a graph.</h3></div></div></div>
<a class="indexterm" name="idp105545271246664"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_density(const igraph_t *graph, igraph_real_t *res,
                   igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>



</p>
<p>The density of a graph is simply the ratio number of
edges and the number of possible edges. Note that density is
ill-defined for graphs with multiple and/or loop edges, so consider
calling <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a> on the graph if you know that it
contains multiple or loop edges.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the result will be stored
  here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Logical constant, whether to include loops in the
  calculation. If this constant is TRUE then
  loop edges are thought to be possible in the graph (this does not
  necessarily mean that the graph really contains any loops). If
  this is FALSE then the result is only correct if the graph does not
  contain loops.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_reciprocity"></a>23.2. <code class="function">igraph_reciprocity</code> —  Calculates the reciprocity of a directed graph.</h3></div></div></div>
<a class="indexterm" name="idp105545271127752"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_reciprocity(const igraph_t *graph, igraph_real_t *res,
                       igraph_bool_t ignore_loops,
                       igraph_reciprocity_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The measure of reciprocity defines the proportion of mutual
connections, in a directed graph. It is most commonly defined as
the probability that the opposite counterpart of a directed edge is
also included in the graph. In adjacency matrix notation:
<code class="literal"> sum(i, j, (A.*A')ij) / sum(i, j, Aij)</code> , where
<code class="literal"> A.*A'</code>  is the element-wise product of matrix
<code class="literal"> A</code>  and its transpose. This measure is
calculated if the <em class="parameter"><code>mode</code></em> argument is <code class="constant">IGRAPH_RECIPROCITY_DEFAULT</code>.

</p>
<p>
Prior to igraph version 0.6, another measure was implemented,
defined as the probability of mutual connection between a vertex
pair if we know that there is a (possibly non-mutual) connection
between them. In other words, (unordered) vertex pairs are
classified into three groups: (1) disconnected, (2)
non-reciprocally connected, (3) reciprocally connected.
The result is the size of group (3), divided by the sum of group
sizes (2)+(3). This measure is calculated if <em class="parameter"><code>mode</code></em> is <code class="constant">IGRAPH_RECIPROCITY_RATIO</code>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an <code class="constant">igraph_real_t</code> which will contain the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ignore_loops</code></em>:</span></p></td>
<td><p>
  Whether to ignore loop edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Type of reciprocity to calculate, possible values are
   <code class="constant">IGRAPH_RECIPROCITY_DEFAULT</code> and <code class="constant">IGRAPH_RECIPROCITY_RATIO</code>,
   please see their description above.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: graph has no edges
        <code class="constant">IGRAPH_ENOMEM</code>: not enough memory for
        temporary data.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), |V| is the number of vertices,
|E| is the number of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545271144648"></a><p class="title"><b>Example 13.43.  File <code class="code">examples/simple/igraph_reciprocity.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;math.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t res;

    <span class="emphasis"><em>/* Trivial cases */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 100, IGRAPH_UNDIRECTED, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_reciprocity" title="23.2. igraph_reciprocity — Calculates the reciprocity of a directed graph.">igraph_reciprocity</a></strong></span>(&amp;g, &amp;res, 0, IGRAPH_RECIPROCITY_DEFAULT);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (res != 1) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="emphasis"><em>/* Small test graph */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED,
                 0,  1,  0,  2,  0,  3,  1,  0,  2,  3,  3,  2, -1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_reciprocity" title="23.2. igraph_reciprocity — Calculates the reciprocity of a directed graph.">igraph_reciprocity</a></strong></span>(&amp;g, &amp;res, 0, IGRAPH_RECIPROCITY_RATIO);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (res != 0.5) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "%f != %f\n", res, 0.5);
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 1, -1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_reciprocity" title="23.2. igraph_reciprocity — Calculates the reciprocity of a directed graph.">igraph_reciprocity</a></strong></span>(&amp;g, &amp;res, 0, IGRAPH_RECIPROCITY_DEFAULT);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(res - 2.0 / 3.0) &gt; 1e-15) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "%f != %f\n", res, 2.0 / 3.0);
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_diversity"></a>23.3. <code class="function">igraph_diversity</code> — Structural diversity index of the vertices</h3></div></div></div>
<a class="indexterm" name="idp105545271169480"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_diversity(igraph_t *graph, const igraph_vector_t *weights,
                     igraph_vector_t *res, const igraph_vs_t vids);
</pre></div>
<p>
</p>
<p>



This measure was defined in Nathan Eagle, Michael Macy and Rob
Claxton: Network Diversity and Economic Development, Science 328,
1029--1031, 2010.

</p>
<p>
It is simply the (normalized) Shannon entropy of the
incident edges' weights. D(i)=H(i)/log(k[i]), and
H(i) = -sum(p[i,j] log(p[i,j]), j=1..k[i]),
where p[i,j]=w[i,j]/sum(w[i,l], l=1..k[i]),  k[i] is the (total)
degree of vertex i, and w[i,j] is the weight of the edge(s) between
vertex i and j.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, edge directions are ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  The edge weights, in the order of the edge ids, must
   have appropriate length.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the results are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  Vector with the vertex ids for which to calculate the
   measure.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear.

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_is_mutual"></a>23.4. <code class="function">igraph_is_mutual</code> — Check whether the edges of a directed graph are mutual.</h3></div></div></div>
<a class="indexterm" name="idp105545271182280"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_is_mutual(igraph_t *graph, igraph_vector_bool_t *res, igraph_es_t es);
</pre></div>
<p>
</p>
<p>



An (A,B) edge is mutual if the graph contains the (B,A) edge, too.
</p>
<p>An undirected graph only has mutual edges, by definition.
</p>
<p>Edge multiplicity is not considered here, e.g. if there are two
(A,B) edges and one (B,A) edge, then all three are considered to be
mutual.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result is stored
       here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>es</code></em>:</span></p></td>
<td><p>
  The sequence of edges to check. Supply
       <code class="literal"> igraph_ess_all()</code>  for all edges, see <a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version)"><code class="function">igraph_ess_all()</code></a>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n log(d)), n is the number of edges supplied, d
is the maximum in-degree of the vertices that are targets of the
supplied edges. An upper limit of the time complexity is O(n log(|E|)),
|E| is the number of edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_avg_nearest_neighbor_degree"></a>23.5. <code class="function">igraph_avg_nearest_neighbor_degree</code> — Average neighbor degree.</h3></div></div></div>
<a class="indexterm" name="idp105545271326536"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_avg_nearest_neighbor_degree(const igraph_t *graph,
                                       igraph_vs_t vids,
                                       igraph_neimode_t mode,
                                       igraph_neimode_t neighbor_degree_mode,
                                       igraph_vector_t *knn,
                                       igraph_vector_t *knnk,
                                       const igraph_vector_t *weights);
</pre></div>
<p>
</p>
<p>



Calculates the average degree of the neighbors for each vertex (<em class="parameter"><code>knn</code></em>), and
optionally, the same quantity as a function of the vertex degree (<em class="parameter"><code>knnk</code></em>).

</p>
<p>
For isolated vertices <em class="parameter"><code>knn</code></em> is set to NaN.
The same is done in <em class="parameter"><code>knnk</code></em> for vertex degrees that
don't appear in the graph.

</p>
<p>
The weighted version computes a weighted average of the neighbor degrees as

<code class="literal"> k_nn_u = 1/s_u sum_v w_uv k_v</code> ,

where <code class="literal"> s_u = sum_v w_uv</code>  is the sum of the incident edge weights
of vertex <code class="constant">u</code>, i.e. its strength.
The sum runs over the neighbors <code class="constant">v</code> of vertex <code class="constant">u</code>
as indicated by <em class="parameter"><code>mode</code></em>. <code class="literal"> w_uv</code>  denotes the weighted adjacency matrix
and <code class="literal"> k_v</code>  is the neighbors' degree, specified by <em class="parameter"><code>neighbor_degree_mode</code></em>.

</p>
<p>
Reference:
A. Barrat, M. Barthélemy, R. Pastor-Satorras, and A. Vespignani,
The architecture of complex weighted networks,
Proc. Natl. Acad. Sci. USA 101, 3747 (2004).
<a class="ulink" href="https://dx.doi.org/10.1073/pnas.0400087101" target="_top">https://dx.doi.org/10.1073/pnas.0400087101</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It may be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  The type of neighbors to consider in directed graphs.
  <code class="constant">IGRAPH_OUT</code> considers out-neighbors, <code class="constant">IGRAPH_IN</code> in-neighbors
  and <code class="constant">IGRAPH_ALL</code> ignores edge directions.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>neighbor_degree_mode</code></em>:</span></p></td>
<td><p>
  The type of degree to average in directed graphs.
  <code class="constant">IGRAPH_OUT</code> averages out-degrees, <code class="constant">IGRAPH_IN</code> averages in-degrees
  and <code class="constant">IGRAPH_ALL</code> ignores edge directions for the degree calculation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  The vertices for which the calculation is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>knn</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the result will be
  stored here. It will be resized as needed. Supply a <code class="constant">NULL</code> pointer
  here, if you only want to calculate <code class="constant">knnk</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>knnk</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the average
  neighbor degree as a function of the vertex degree is stored
  here. The first (zeroth) element is for degree one vertices,
  etc. Supply a <code class="constant">NULL</code> pointer here if you don't want to calculate
  this.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Optional edge weights. Supply a null pointer here
  for the non-weighted version.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545271354312"></a><p class="title"><b>Example 13.44.  File <code class="code">examples/simple/igraph_knn.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2010-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> v, v2;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> v_weighted, v2_weighted;
    igraph_integer_t n;
    igraph_neimode_t mode, neighbour_degree_mode;

    mode = IGRAPH_IN;
    neighbour_degree_mode = IGRAPH_OUT;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;g, 10, <span class="emphasis"><em>/*directed=*/</em></span> 1, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span> 1);
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v, (long int)n);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v2, (long int)n);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_avg_nearest_neighbor_degree" title="23.5. igraph_avg_nearest_neighbor_degree — Average neighbor degree.">igraph_avg_nearest_neighbor_degree</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                       mode, neighbour_degree_mode,
                                       &amp;v, &amp;v2, <span class="emphasis"><em>/*weights=*/</em></span> 0);

    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_fill" title="2.3.2. igraph_vector_fill — Fill a vector with a constant element">igraph_vector_fill</a></strong></span>(&amp;weights, 2.0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v_weighted, (long int)n);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v2_weighted, (long int)n);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_avg_nearest_neighbor_degree" title="23.5. igraph_avg_nearest_neighbor_degree — Average neighbor degree.">igraph_avg_nearest_neighbor_degree</a></strong></span>(&amp;g, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(),
                                       mode, neighbour_degree_mode,
                                       &amp;v_weighted, &amp;v2_weighted, &amp;weights);

    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_all_e" title="2.9.1. igraph_vector_all_e — Are all elements equal?">igraph_vector_all_e</a></strong></span>(&amp;v, &amp;v_weighted)) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v_weighted);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v2_weighted);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v2);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}

</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_adjacency"></a>23.6. <code class="function">igraph_get_adjacency</code> —  Returns the adjacency matrix of a graph</h3></div></div></div>
<a class="indexterm" name="idp105545271385928"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_adjacency(const igraph_t *graph, igraph_matrix_t *res,
                         igraph_get_adjacency_t type, igraph_bool_t eids);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The result is an adjacency matrix. Entry i, j of the matrix
contains the number of edges connecting vertex i to vertex j.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to the graph to convert
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix object, it will be
       resized if needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type</code></em>:</span></p></td>
<td>
<p>
  Constant giving the type of the adjacency matrix to
       create for undirected graphs. It is ignored for directed
       graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_GET_ADJACENCY_UPPER</code></span></p></td>
<td><p>

         the upper right triangle of the matrix is used.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_GET_ADJACENCY_LOWER</code></span></p></td>
<td><p>

         the lower left triangle of the matrix is used.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_GET_ADJACENCY_BOTH</code></span></p></td>
<td><p>

         the whole matrix is used, a symmetric matrix is returned
         if the graph is undirected.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type</code></em>:</span></p></td>
<td><p>
  eids Logical, if true, then the edges ids plus one
       are stored in the adjacency matrix, instead of the number of
       edges between the two vertices. (The plus one is needed, since
       edge ids start from zero, and zero means no edge in this case.)
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
       <code class="constant">IGRAPH_EINVAL</code> invalid type argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  igraph_get_adjacency_sparse if you want a sparse matrix representation
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||V|),
|V| is the
number of vertices in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_stochastic"></a>23.7. <code class="function">igraph_get_stochastic</code> — Stochastic adjacency matrix of a graph</h3></div></div></div>
<a class="indexterm" name="idp105545271273928"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_stochastic(const igraph_t *graph,
                          igraph_matrix_t *matrix,
                          igraph_bool_t column_wise);
</pre></div>
<p>
</p>
<p>



Stochastic matrix of a graph. The stochastic matrix of a graph is
its adjacency matrix, normalized row-wise or column-wise, such that
the sum of each row (or column) is one.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sparsemat</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix, the
   result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>column_wise</code></em>:</span></p></td>
<td><p>
  Whether to normalize column-wise. For undirected
   graphs this argument does not have any effect.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||V|), quadratic in the number of vertices.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  igraph_get_stochastic_sparsemat(), the sparse version of this
function.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_stochastic_sparsemat"></a>23.8. <code class="function">igraph_get_stochastic_sparsemat</code> —  Stochastic adjacency matrix of a graph</h3></div></div></div>
<a class="indexterm" name="idp105545271287240"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_stochastic_sparsemat(const igraph_t *graph,
                                    igraph_sparsemat_t *sparsemat,
                                    igraph_bool_t column_wise);
</pre></div>
<p>
</p>
<p>



Stochastic matrix of a graph. The stochastic matrix of a graph is
its adjacency matrix, normalized row-wise or column-wise, such that
the sum of each row (or column) is one.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sparsemat</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized sparse matrix, the
   result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>column_wise</code></em>:</span></p></td>
<td><p>
  Whether to normalize column-wise. For undirected
   graphs this argument does not have any effect.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  igraph_get_stochastic(), the dense version of this function.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_edgelist"></a>23.9. <code class="function">igraph_get_edgelist</code> —  Returns the list of edges in a graph</h3></div></div></div>
<a class="indexterm" name="idp105545271300552"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_edgelist(const igraph_t *graph, igraph_vector_t *res, igraph_bool_t bycol);
</pre></div>
<p>
</p>
<p>




</p>
<p>The order of the edges is given by the edge ids.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to the graph object
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector object, it will be
       resized.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>bycol</code></em>:</span></p></td>
<td><p>
  Logical, if true, the edges will be returned
       columnwise, eg. the first edge is
       <code class="literal"> res[0]-&gt;res[|E|]</code> , the second is
       <code class="literal"> res[1]-&gt;res[|E|+1]</code> , etc.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|), the
number of edges in the graph.
 
</p>
</div>
</div>
</div>
<table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Attributes.html"><b>← Chapter 12. Graph, Vertex and Edge Attributes</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Cycles.html"><b>Chapter 14. Graph cycles →</b></a></td>
</tr></table>


      </div>
    </div>
  </div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	      &copy; 2003 &ndash; 2025 The igraph core team.
        &bull; Code licensed under <a href="http://www.gnu.org/licenses/gpl-2.0.html"> GNU GPL 2</a> or later,
        documentation under <a href="http://www.gnu.org/copyleft/fdl.html">GNU FDL</a>.
      </p>
      <p class="social">
        <a href="https://twitter.com/igraph2"><i class="fa-brands fa-twitter"></i></a>
        <a rel="me" href="https://fosstodon.org/@igraph"><i class="fa-brands fa-mastodon"></i></a>
        <a href="https://discord.gg/cSyHDPJWDD"><i class="fa-brands fa-discord"></i></a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'c', 'html/');
    </script>





    
  </body>
</html>
