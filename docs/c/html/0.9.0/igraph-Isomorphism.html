




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>igraph Reference Manual</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/fontawesome.min.css" integrity="sha384-QYIZto+st3yW+o8+5OHfT6S482Zsvz2WfOzpFSXMF9zqeLcFV0/wlZpMtyFcZALm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/solid.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/brands.min.css">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DY4MJME11Z"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-DY4MJME11Z');
	</script>

    <link href="/css/manual.css" rel="stylesheet">
<script async src="https://cse.google.com/cse.js?cx=003494361702844740117:dlnifinshhm"></script>

  </head>

  <body class="cc">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/c">igraph library</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            0.9.0
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="https://r.igraph.org">igraph R package</a>
              <a class="dropdown-item" href="https://python.igraph.org">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa-brands fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa-solid fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa-solid fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa-solid fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa-brands fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">igraph Reference Manual</h1>
        <p class="lead">For using the igraph C library</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container search-box-container">
  <div class="row">
    <div class="col-md-12 d-flex flex-row align-items-middle">
      <div class="search-label">Search the manual:</div>
	  <div style="flex: 1; margin: -1em 0 -1em 0"><div class="gcse-search" data-personalizedAds="false"></div></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="bs-docs-section">
        
<div class="navigation-header mb-4" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-light" href="igraph-Cliques.html"><i class="fa fa-chevron-left"></i>
              Previous
            </a><a accesskey="h" class="btn btn-light" href="index.html"><i class="fa fa-home"></i>
              Home
            </a><a accesskey="n" class="btn btn-light" href="igraph-Coloring.html"><i class="fa fa-chevron-right"></i>
              Next
            </a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Isomorphism"></a>Chapter 17. Graph Isomorphism</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#isomorphism-simple-interface">1. The simple interface</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#bliss-algorithm">2. The BLISS algorithm</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#vf2-algorithm">3. The VF2 algorithm</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#lad-algorithm">4. The LAD algorithm</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#functions-for-graphs-with-3-or-4-vertices">5. Functions for graphs with 3 or 4 vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#isomorphism-utility-functions">6. Utility functions</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="isomorphism-simple-interface"></a>1. The simple interface</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic">1.1. <code class="function">igraph_isomorphic</code> —  Decides whether two graphs are isomorphic</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_subisomorphic">1.2. <code class="function">igraph_subisomorphic</code> — Decide subgraph isomorphism</a></span></dt>
</dl></div>
<p>igraph provides four set of functions to deal with graph
isomorphism problems.</p>
<p>The <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.1. igraph_isomorphic — Decides whether two graphs are isomorphic"><code class="function">igraph_isomorphic()</code></a> and <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic" title="1.2. igraph_subisomorphic — Decide subgraph isomorphism"><code class="function">igraph_subisomorphic()</code></a>
functions make up the first set (in addition with the <a class="link" href="igraph-Isomorphism.html#igraph_permute_vertices" title="6.1. igraph_permute_vertices — Permute the vertices"><code class="function">igraph_permute_vertices()</code></a> function). These functions choose the
algorithm which is best for the supplied input graph. (The choice is
not very sophisticated though, see their documentation for
details.)</p>
<p>The VF2 graph (and subgraph) isomorphism algorithm is implemented in
igraph, these functions are the second set. See <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2"><code class="function">igraph_isomorphic_vf2()</code></a> and <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a> for
starters.</p>
<p>Functions for the Bliss algorithm constitute the third set,
see <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.4. igraph_isomorphic_bliss — Graph isomorphism via Bliss"><code class="function">igraph_isomorphic_bliss()</code></a>.</p>
<p>Finally, the isomorphism classes of all graphs with three and
four vertices are precomputed and stored in igraph, so for these
small graphs there is a very simple fast way to decide isomorphism.
See <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_34" title="5.1. igraph_isomorphic_34 — Graph isomorphism for 3-4 vertices"><code class="function">igraph_isomorphic_34()</code></a>.
</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic"></a>1.1. <code class="function">igraph_isomorphic</code> —  Decides whether two graphs are isomorphic</h3></div></div></div>
<a class="indexterm" name="idp105545069222984"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isomorphic(const igraph_t *graph1, const igraph_t *graph2,
                      igraph_bool_t *iso);
</pre></div>
<p>
</p>
<p>



</p>
<p>
In simple terms, two graphs are isomorphic if they become indistinguishable
from each other once their vertex labels are removed (rendering the vertices
within each graph indistiguishable). More precisely, two graphs are isomorphic
if there is a one-to-one mapping from the vertices of the first one
to the vertices of the second such that it transforms the edge set of the
first graph into the edge set of the second. This mapping is called
an <span class="emphasis"><em>isomorphism.</em></span>

</p>
<p>Currently, this function supports simple graphs and graphs
with self-loops, but does not support multigraphs.

</p>
<p>This function decides which graph isomorphism algorithm to be
used based on the input graphs. Right now it does the following:
</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>
If one graph is directed and the other undirected then an
   error is triggered.

</p></li>
<li class="listitem"><p>
If one of the graphs has multi-edges then an error is triggered.

</p></li>
<li class="listitem"><p>
If the two graphs does not have the same number of vertices
   and edges it returns with <code class="constant">FALSE</code>.

</p></li>
<li class="listitem"><p>
Otherwise, if the graphs have three or four vertices then an O(1)
   algorithm is used with precomputed data.

</p></li>
<li class="listitem"><p>
Otherwise Bliss is used, see <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_bliss" title="2.4. igraph_isomorphic_bliss — Graph isomorphism via Bliss"><code class="function">igraph_isomorphic_bliss()</code></a>.

</p></li>
</ol></div>
<p>

</p>
<p>Please call the VF2 and Bliss functions directly if you need
something more sophisticated, e.g. you need the isomorphic mapping.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a logical variable, will be set to TRUE (1)
       if the two graphs are isomorphic, and FALSE (0) otherwise.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isoclass" title="5.2. igraph_isoclass — Determine the isomorphism class of a graph with 3 or 4 vertices"><code class="function">igraph_isoclass()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_isoclass_subgraph" title="5.3. igraph_isoclass_subgraph — The isomorphism class of a subgraph of a graph."><code class="function">igraph_isoclass_subgraph()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isoclass_create" title="5.4. igraph_isoclass_create — Creates a graph from the given isomorphism class."><code class="function">igraph_isoclass_create()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subisomorphic"></a>1.2. <code class="function">igraph_subisomorphic</code> — Decide subgraph isomorphism</h3></div></div></div>
<a class="indexterm" name="idp105545072611912"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_subisomorphic(const igraph_t *graph1, const igraph_t *graph2,
                         igraph_bool_t *iso);
</pre></div>
<p>
</p>
<p>



Check whether <em class="parameter"><code>graph2</code></em> is isomorphic to a subgraph of <em class="parameter"><code>graph1</code></em>.
Currently this function just calls <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a>
for all graphs.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
  undirected. This is supposed to be the bigger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
  directedness as <em class="parameter"><code>graph2</code></em>, or an error is triggered. This is
  supposed to be the smaller graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="bliss-algorithm"></a>2. The BLISS algorithm</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_bliss_sh_t">2.1. <code class="function">igraph_bliss_sh_t</code> —  Splitting heuristics for Bliss.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_bliss_info_t">2.2. <code class="function">igraph_bliss_info_t</code> — Information about a BLISS run</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_canonical_permutation">2.3. <code class="function">igraph_canonical_permutation</code> — Canonical permutation using Bliss</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic_bliss">2.4. <code class="function">igraph_isomorphic_bliss</code> — Graph isomorphism via Bliss</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_automorphisms">2.5. <code class="function">igraph_automorphisms</code> — Number of automorphisms using Bliss</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_automorphism_group">2.6. <code class="function">igraph_automorphism_group</code> — Automorphism group generators using Bliss</a></span></dt>
</dl></div>
<p>
Bliss is a successor of the famous NAUTY algorithm and
implementation. While using the same ideas in general, with better
heuristics and data structures Bliss outperforms NAUTY on most
graphs.
</p>
<p>
Bliss was developed and implemented by Tommi Junttila and Petteri Kaski at
Helsinki University of Technology, Finland. For more information,
see the Bliss homepage at <a class="ulink" href="https://users.aalto.fi/~tjunttil/bliss/" target="_top">https://users.aalto.fi/~tjunttil/bliss/</a> and the following
publication:
</p>
<p>
Tommi Junttila and Petteri Kaski: "Engineering an Efficient Canonical Labeling
Tool for Large and Sparse Graphs" In ALENEX 2007, pages 135–149, 2007
<a class="ulink" href="https://doi.org/10.1137/1.9781611972870.13" target="_top">https://doi.org/10.1137/1.9781611972870.13</a>
</p>
<p>
Tommi Junttila and Petteri Kaski: "Conflict Propagation and Component Recursion
for Canonical Labeling" in TAPAS 2011, pages 151–162, 2011.
<a class="ulink" href="https://doi.org/10.1007/978-3-642-19754-3_16" target="_top">https://doi.org/10.1007/978-3-642-19754-3_16</a>
</p>
<p>
Bliss works with both directed graphs and undirected graphs. It supports graphs with
self-loops, but not graphs with multi-edges.
</p>
<p>
Bliss version 0.75 is included in igraph.
</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bliss_sh_t"></a>2.1. <code class="function">igraph_bliss_sh_t</code> —  Splitting heuristics for Bliss.</h3></div></div></div>
<a class="indexterm" name="idp105545072436808"></a><p>
</p>
<pre class="programlisting">
typedef enum { IGRAPH_BLISS_F = 0, IGRAPH_BLISS_FL,
               IGRAPH_BLISS_FS, IGRAPH_BLISS_FM,
               IGRAPH_BLISS_FLM, IGRAPH_BLISS_FSM
             } igraph_bliss_sh_t;
</pre>
<p>
</p>
<p>


<code class="constant">IGRAPH_BLISS_FL</code> provides good performance for many graphs, and is a reasonable
default choice. <code class="constant">IGRAPH_BLISS_FSM</code> is recommended for graphs that have some
combinatorial structure, and is the default of the Bliss library's command
line tool.

</p>
<p><b>Values: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_F</code>:</span></p></td>
<td><p>
  First non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FL</code>:</span></p></td>
<td><p>
  First largest non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FS</code>:</span></p></td>
<td><p>
  First smallest non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FM</code>:</span></p></td>
<td><p>
  First maximally non-trivially connected
     non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FLM</code>:</span></p></td>
<td><p>
  Largest maximally non-trivially connected
     non-singleton cell.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BLISS_FSM</code>:</span></p></td>
<td><p>
  Smallest maximally non-trivially
     connected non-singletion cell.</p></td>
</tr>
</tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_bliss_info_t"></a>2.2. <code class="function">igraph_bliss_info_t</code> — Information about a BLISS run</h3></div></div></div>
<a class="indexterm" name="idp105545072548040"></a><p>
</p>
<pre class="programlisting">
typedef struct igraph_bliss_info_t {
    unsigned long nof_nodes;
    unsigned long nof_leaf_nodes;
    unsigned long nof_bad_nodes;
    unsigned long nof_canupdates;
    unsigned long nof_generators;
    unsigned long max_level;
    char *group_size;
} igraph_bliss_info_t;
</pre>
<p>
</p>
<p>
</p>
<p>Some secondary information found by the BLISS algorithm is stored
here. It is useful if you wany to study the internal working of the
algorithm.
</p>
<p><b>Values: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">nof_nodes</code>:</span></p></td>
<td><p>
  The number of nodes in the search tree.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">nof_leaf_nodes</code>:</span></p></td>
<td><p>
  The number of leaf nodes in the search tree.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">nof_bad_nodes</code>:</span></p></td>
<td><p>
  Number of bad nodes.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">nof_canupdates</code>:</span></p></td>
<td><p>
  Number of canrep updates.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">nof_generators</code>:</span></p></td>
<td><p>
  Number of generators of the automorphism group.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">max_level</code>:</span></p></td>
<td><p>
  Maximum level.
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">group_size</code>:</span></p></td>
<td><p>
  The size of the automorphism group of the graph,
   given as a string. It should be deallocated via
   <a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions"><code class="function">igraph_free()</code></a> if not needed any more.</p></td>
</tr>
</tbody>
</table></div>
<p>
See <a class="ulink" href="http://www.tcs.hut.fi/Software/bliss/index.html" target="_top">http://www.tcs.hut.fi/Software/bliss/index.html</a>
for details about the algorithm and these parameters.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_canonical_permutation"></a>2.3. <code class="function">igraph_canonical_permutation</code> — Canonical permutation using Bliss</h3></div></div></div>
<a class="indexterm" name="idp105545072530504"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_canonical_permutation(const igraph_t *graph, const igraph_vector_int_t *colors,
                                 igraph_vector_t *labeling, igraph_bliss_sh_t sh, igraph_bliss_info_t *info);
</pre></div>
<p>
</p>
<p>



This function computes the canonical permutation which transforms
the graph into a canonical form by using the Bliss algorithm.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the graph. Supply a
  null pointer is the graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>labeling</code></em>:</span></p></td>
<td><p>
  Pointer to a vector, the result is stored here. The
   permutation takes vertex 0 to the first element of the vector,
   vertex 1 to the second, etc. The vector will be resized as
   needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sh</code></em>:</span></p></td>
<td><p>
  The splitting heuristics to be used in Bliss. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_sh_t" title="2.1. igraph_bliss_sh_t — Splitting heuristics for Bliss."><code class="function">igraph_bliss_sh_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code> then information on Bliss internals is
   stored here. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_info_t" title="2.2. igraph_bliss_info_t — Information about a BLISS run"><code class="function">igraph_bliss_info_t</code></a>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, in practice it is fast for many graphs.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic_bliss"></a>2.4. <code class="function">igraph_isomorphic_bliss</code> — Graph isomorphism via Bliss</h3></div></div></div>
<a class="indexterm" name="idp105545072562376"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isomorphic_bliss(const igraph_t *graph1, const igraph_t *graph2,
                            const igraph_vector_int_t *colors1, const igraph_vector_int_t *colors2,
                            igraph_bool_t *iso, igraph_vector_t *map12,
                            igraph_vector_t *map21, igraph_bliss_sh_t sh,
                            igraph_bliss_info_t *info1, igraph_bliss_info_t *info2);
</pre></div>
<p>
</p>
<p>



This function uses the Bliss graph isomorphism algorithm, a
successor of the famous NAUTY algorithm and implementation. Bliss
is open source and licensed according to the GNU LGPL. See
<a class="ulink" href="https://users.aalto.fi/~tjunttil/bliss/" target="_top">https://users.aalto.fi/~tjunttil/bliss/</a> for
details. Currently the 0.75 version of Bliss is included in igraph.

</p>
<p>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors1</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the first graph. Supply a
  null pointer if your graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors2</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the second graph. Supply a
  null pointer if your graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  A vector or <code class="constant">NULL</code> pointer. If not <code class="constant">NULL</code> then an
  isomorphic mapping from <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph2</code></em> is stored here.
  If the input graphs are not isomorphic then this vector is
  cleared, i.e. it will have length zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  Similar to <em class="parameter"><code>map12</code></em>, but for the mapping from <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sh</code></em>:</span></p></td>
<td><p>
  Splitting heuristics to be used for the graphs. See
  <a class="link" href="igraph-Isomorphism.html#igraph_bliss_sh_t" title="2.1. igraph_bliss_sh_t — Splitting heuristics for Bliss."><code class="function">igraph_bliss_sh_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info1</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code>, information about the canonization of
   the first input graph is stored here. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_info_t" title="2.2. igraph_bliss_info_t — Information about a BLISS run"><code class="function">igraph_bliss_info_t</code></a>
   for details. Note that if the two graphs have different number
   of vertices or edges, then this is not filled.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info2</code></em>:</span></p></td>
<td><p>
  Same as <em class="parameter"><code>info1</code></em>, but for the second graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, but in practice it is quite fast.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_automorphisms"></a>2.5. <code class="function">igraph_automorphisms</code> — Number of automorphisms using Bliss</h3></div></div></div>
<a class="indexterm" name="idp105545072590152"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_automorphisms(const igraph_t *graph, const igraph_vector_int_t *colors,
                         igraph_bliss_sh_t sh, igraph_bliss_info_t *info);
</pre></div>
<p>
</p>
<p>



The number of automorphisms of a graph is computed using Bliss. The
result is returned as part of the <em class="parameter"><code>info</code></em> structure, in tag <code class="constant">group_size</code>. It is returned as a string, as it can be very high even
for relatively small graphs. If the GNU MP library is used then
this number is exact, otherwise a <span class="type">long double</span> is used
and it is only approximate. See also <a class="link" href="igraph-Isomorphism.html#igraph_bliss_info_t" title="2.2. igraph_bliss_info_t — Information about a BLISS run"><code class="function">igraph_bliss_info_t</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the graph. Supply a
  null pointer is the graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sh</code></em>:</span></p></td>
<td><p>
  The splitting heuristics to be used in Bliss. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_sh_t" title="2.1. igraph_bliss_sh_t — Splitting heuristics for Bliss."><code class="function">igraph_bliss_sh_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info</code></em>:</span></p></td>
<td><p>
  The result is stored here, in particular in the <code class="constant">group_size</code> tag of <em class="parameter"><code>info</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, in practice it is fast for many graphs.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_automorphism_group"></a>2.6. <code class="function">igraph_automorphism_group</code> — Automorphism group generators using Bliss</h3></div></div></div>
<a class="indexterm" name="idp105545068797896"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_automorphism_group(
    const igraph_t *graph, const igraph_vector_int_t *colors, igraph_vector_ptr_t *generators,
    igraph_bliss_sh_t sh, igraph_bliss_info_t *info);
</pre></div>
<p>
</p>
<p>



The generators of the automorphism group of a graph are computed
using Bliss. The generator set may not be minimal and may depend on
the splitting heuristics.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Multiple edges between the same nodes
  are not supported and will cause an incorrect result to be returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>colors</code></em>:</span></p></td>
<td><p>
  An optional vertex color vector for the graph. Supply a
  null pointer is the graph is not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>generators</code></em>:</span></p></td>
<td><p>
  Must be an initialized pointer vector. It will
   contain pointers to <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_t</code></a> objects
   representing generators of the automorphism group.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sh</code></em>:</span></p></td>
<td><p>
  The splitting heuristics to be used in Bliss. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_sh_t" title="2.1. igraph_bliss_sh_t — Splitting heuristics for Bliss."><code class="function">igraph_bliss_sh_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>info</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code> then information on Bliss internals is
   stored here. See <a class="link" href="igraph-Isomorphism.html#igraph_bliss_info_t" title="2.2. igraph_bliss_info_t — Information about a BLISS run"><code class="function">igraph_bliss_info_t</code></a>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, in practice it is fast for many graphs.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="vf2-algorithm"></a>3. The VF2 algorithm</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic_vf2">3.1. <code class="function">igraph_isomorphic_vf2</code> —  Isomorphism via VF2</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2">3.2. <code class="function">igraph_count_isomorphisms_vf2</code> — Number of isomorphisms via VF2</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2">3.3. <code class="function">igraph_get_isomorphisms_vf2</code> — Collect the isomorphic mappings</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isohandler_t">3.4. <code class="function">igraph_isohandler_t</code> — Callback type, called when an isomorphism was found</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isocompat_t">3.5. <code class="function">igraph_isocompat_t</code> — Callback type, called to check whether two vertices or edges are compatible</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2">3.6. <code class="function">igraph_isomorphic_function_vf2</code> — The generic VF2 interface</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_subisomorphic_vf2">3.7. <code class="function">igraph_subisomorphic_vf2</code> — Decide subgraph isomorphism using VF2</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2">3.8. <code class="function">igraph_count_subisomorphisms_vf2</code> — Number of subgraph isomorphisms using VF2</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_get_subisomorphisms_vf2">3.9. <code class="function">igraph_get_subisomorphisms_vf2</code> — Return all subgraph isomorphic mappings</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_subisomorphic_function_vf2">3.10. <code class="function">igraph_subisomorphic_function_vf2</code> — Generic VF2 function for subgraph isomorphism problems</a></span></dt>
</dl></div>
<p>
The VF2 algorithm can search for a subgraph in a larger graph, or check if two
graphs are isomorphic. See P. Foggia, C. Sansone, M. Vento, An Improved algorithm for
matching large graphs, Proc. of the 3rd IAPR-TC-15 International
Workshop on Graph-based Representations, Italy, 2001.
</p>
<p>
VF2 supports both vertex and edge-colored graphs, as well as custom vertex or edge
compatibility functions.
</p>
<p>
VF2 works with both directed and undirected graphs. Only simple graphs are supported.
Self-loops or multi-edges must not be present in the graphs. Currently, the VF2
functions do not check that the input graph is simple: it is the responsibility
of the user to pass in valid input.
</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic_vf2"></a>3.1. <code class="function">igraph_isomorphic_vf2</code> —  Isomorphism via VF2</h3></div></div></div>
<a class="indexterm" name="idp105545068966088"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isomorphic_vf2(const igraph_t *graph1, const igraph_t *graph2,
                          const igraph_vector_int_t *vertex_color1,
                          const igraph_vector_int_t *vertex_color2,
                          const igraph_vector_int_t *edge_color1,
                          const igraph_vector_int_t *edge_color2,
                          igraph_bool_t *iso, igraph_vector_t *map12,
                          igraph_vector_t *map21,
                          igraph_isocompat_t *node_compat_fn,
                          igraph_isocompat_t *edge_compat_fn,
                          void *arg);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function performs the VF2 algorithm via calling <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2" title="3.6. igraph_isomorphic_function_vf2 — The generic VF2 interface"><code class="function">igraph_isomorphic_function_vf2()</code></a>.

</p>
<p> Note that this function cannot be used for
deciding subgraph isomorphism, use <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a>
for that.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first graph, may be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second graph. It must have the same directedness
   as <em class="parameter"><code>graph1</code></em>, otherwise an error is reported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a logical constant, the result of the
   algorithm will be placed here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a NULL pointer. If not
   a NULL pointer then the mapping from <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph2</code></em> is
   stored here. If the graphs are not isomorphic then the vector is
   cleared (i.e. has zero elements).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a NULL pointer. If not
   a NULL pointer then the mapping from <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em> is
   stored here. If the graphs are not isomorphic then the vector is
   cleared (i.e. has zero elements).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em>
  and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2"><code class="function">igraph_count_isomorphisms_vf2()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_get_isomorphisms_vf2" title="3.3. igraph_get_isomorphisms_vf2 — Collect the isomorphic mappings"><code class="function">igraph_get_isomorphisms_vf2()</code></a>,
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential, what did you expect?

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545068803528"></a><p class="title"><b>Example 17.1.  File <code class="code">examples/simple/igraph_isomorphic_vf2.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2009-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdlib.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t ring1, ring2;
    igraph_vector_int_t color1, color2;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> perm;
    igraph_bool_t iso;
    igraph_integer_t count;
    long int i;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 12345);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring1, 100, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_seq" title="2.2.3. igraph_vector_init_seq — Initializes a vector with a sequence.">igraph_vector_init_seq</a></strong></span>(&amp;perm, 0, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring1) - 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_shuffle" title="2.7.3. igraph_vector_shuffle — Shuffles a vector in-place using the Fisher-Yates method">igraph_vector_shuffle</a></strong></span>(&amp;perm);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_permute_vertices" title="6.1. igraph_permute_vertices — Permute the vertices">igraph_permute_vertices</a></strong></span>(&amp;ring1, &amp;ring2, &amp;perm);

    <span class="emphasis"><em>/* Without colors */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.1. igraph_isomorphic — Decides whether two graphs are isomorphic">igraph_isomorphic</a></strong></span>(&amp;ring1, &amp;ring2, &amp;iso);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Without color failed.\n");
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="emphasis"><em>/* Without colors, number of isomorphisms */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2">igraph_count_isomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, 0, 0, &amp;count, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (count != 200) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Count without colors failed, expected %li, got %li.\n",
                (long int) 200, (long int) count);
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="emphasis"><em>/* Everything has the same colors */</em></span>
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color1, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring1));
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color2, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring2));
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, &amp;iso, 0, 0, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Single color failed.\n");
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="emphasis"><em>/* Two colors, just counting */</em></span>
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1); i += 2) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i] = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[(long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(perm)[i]] = 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2">igraph_count_isomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, &amp;count, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (count != 100) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with two colors failed, expected %li, got %li.\n",
                (long int) 100, (long int) count);
        <span class="strong"><strong>return</strong></span> 4;
    }

    <span class="emphasis"><em>/* Separate colors for each vertex */</em></span>
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i] = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[(long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(perm)[i]] = i;
    }
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2">igraph_count_isomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, &amp;count, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (count != 1) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with separate colors failed, expected %li, got %li.\n",
                (long int) 1, (long int) count);
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="emphasis"><em>/* Try a negative result */</em></span>
    <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color1, 0);
    <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[0] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, &amp;iso, 0, 0, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (iso) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Negative test failed.\n");
        <span class="strong"><strong>return</strong></span> 6;
    }

    <span class="emphasis"><em>/* Another negative, same color distribution, different topology */</em></span>
    <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color1, 0);
    <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[0] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[1] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[0] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[((long int)<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(perm)[1] + 1) % <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring2)] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0, &amp;iso, 0, 0, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (iso) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Second negative test failed.\n");
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color1);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color2);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;perm);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring2);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring1);

    <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>
    <span class="emphasis"><em>/* SUBGRAPH ISOMORPHISM                                             */</em></span>
    <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring1, 100, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>0);
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring2, 80, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>0);

    <span class="emphasis"><em>/* One color */</em></span>
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color1, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring1));
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color2, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;ring2));
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2" title="3.8. igraph_count_subisomorphisms_vf2 — Number of subgraph isomorphisms using VF2">igraph_count_subisomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0,
                                     &amp;count, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (count != 42) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with one color failed, expected %li, got %li.\n",
                (long int) 42, (long int) count);
        <span class="strong"><strong>return</strong></span> 31;
    }

    <span class="emphasis"><em>/* Two colors */</em></span>
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1); i += 2) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i]   = 0;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i + 1] = 1;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color2); i += 2) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i]   = 0;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i + 1] = 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2" title="3.8. igraph_count_subisomorphisms_vf2 — Number of subgraph isomorphisms using VF2">igraph_count_subisomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, &amp;color1, &amp;color2, 0, 0,
                                     &amp;count, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (count != 21) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with two colors failed, expected %li, got %li.\n",
                (long int) 21, (long int) count);
        <span class="strong"><strong>return</strong></span> 32;
    }

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color1);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color2);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring2);

    <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>
    <span class="emphasis"><em>/* EDGE COLORING, GRAPH ISOMORPHISM                                 */</em></span>
    <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring1, 100, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init_seq" title="2.2.3. igraph_vector_init_seq — Initializes a vector with a sequence.">igraph_vector_init_seq</a></strong></span>(&amp;perm, 0, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;ring1) - 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_shuffle" title="2.7.3. igraph_vector_shuffle — Shuffles a vector in-place using the Fisher-Yates method">igraph_vector_shuffle</a></strong></span>(&amp;perm);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_permute_vertices" title="6.1. igraph_permute_vertices — Permute the vertices">igraph_permute_vertices</a></strong></span>(&amp;ring1, &amp;ring2, &amp;perm);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;perm);

    <span class="emphasis"><em>/* Everything has the same color */</em></span>
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color1, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;ring1));
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color2, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;ring2));
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2, &amp;iso, 0, 0, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Single edge-color failed.\n");
        <span class="strong"><strong>return</strong></span> 41;
    }

    <span class="emphasis"><em>/* Two colors, just counting */</em></span>
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1); i += 2) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i]   = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i] = 0;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i + 1] = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i] = 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2">igraph_count_isomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2, &amp;count, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (count != 100) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with two edge colors failed, expected %li, got %li.\n",
                (long int) 100, (long int) count);
        <span class="strong"><strong>return</strong></span> 42;
    }

    <span class="emphasis"><em>/* Separate colors for each edge */</em></span>
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i]   = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i] = i;
    }
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_isomorphisms_vf2" title="3.2. igraph_count_isomorphisms_vf2 — Number of isomorphisms via VF2">igraph_count_isomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2, &amp;count, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (count != 1) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with separate edge colors failed, expected %li, got %li.\n",
                (long int) 1, (long int) count);
        <span class="strong"><strong>return</strong></span> 43;
    }

    <span class="emphasis"><em>/* Try a negative result */</em></span>
    <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color1, 0);
    <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[0] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2, &amp;iso, 0, 0, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (iso) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Negative edge test failed.\n");
        <span class="strong"><strong>return</strong></span> 44;
    }

    <span class="emphasis"><em>/* Another negative, same color distribution, different topology */</em></span>
    <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color1, 0);
    <span class="strong"><strong>igraph_vector_int_fill</strong></span>(&amp;color2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[0] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[1] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[0] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[2] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2">igraph_isomorphic_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2, &amp;iso, 0, 0, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (iso) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Second negative edge test failed.\n");
        <span class="strong"><strong>return</strong></span> 45;
    }

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color1);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color2);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring2);

    <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>
    <span class="emphasis"><em>/* EDGE COLORED SUBGRAPH ISOMORPHISM                                */</em></span>
    <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring1, 100, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>0);
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a ring graph, a one dimensional lattice.">igraph_ring</a></strong></span>(&amp;ring2, 80, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span>0);

    <span class="emphasis"><em>/* One color */</em></span>
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color1, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;ring1));
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;color2, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="2.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;ring2));
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2" title="3.8. igraph_count_subisomorphisms_vf2 — Number of subgraph isomorphisms using VF2">igraph_count_subisomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2,
                                     &amp;count, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (count != 42) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with one edge color failed, expected %li, got %li.\n",
                (long int) 42, (long int) count);
        <span class="strong"><strong>return</strong></span> 51;
    }

    <span class="emphasis"><em>/* Two colors */</em></span>
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color1) - 1; i += 2) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i]   = 0;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color1)[i + 1] = 1;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong>igraph_vector_int_size</strong></span>(&amp;color2) - 1; i += 2) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i]   = 0;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(color2)[i + 1] = 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2" title="3.8. igraph_count_subisomorphisms_vf2 — Number of subgraph isomorphisms using VF2">igraph_count_subisomorphisms_vf2</a></strong></span>(&amp;ring1, &amp;ring2, 0, 0, &amp;color1, &amp;color2,
                                     &amp;count, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (count != 22) {
        <span class="strong"><strong>fprintf</strong></span>(stderr, "Count with two edge colors failed, expected %li, got %li.\n",
                (long int) 22, (long int) count);
        <span class="strong"><strong>return</strong></span> 52;
    }

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color1);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;color2);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring1);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;ring2);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_count_isomorphisms_vf2"></a>3.2. <code class="function">igraph_count_isomorphisms_vf2</code> — Number of isomorphisms via VF2</h3></div></div></div>
<a class="indexterm" name="idp105545136453192"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_count_isomorphisms_vf2(const igraph_t *graph1, const igraph_t *graph2,
                                  const igraph_vector_int_t *vertex_color1,
                                  const igraph_vector_int_t *vertex_color2,
                                  const igraph_vector_int_t *edge_color1,
                                  const igraph_vector_int_t *edge_color2,
                                  igraph_integer_t *count,
                                  igraph_isocompat_t *node_compat_fn,
                                  igraph_isocompat_t *edge_compat_fn,
                                  void *arg);
</pre></div>
<p>
</p>
<p>



This function counts the number of isomorphic mappings between two
graphs. It uses the generic <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2" title="3.6. igraph_isomorphic_function_vf2 — The generic VF2 interface"><code class="function">igraph_isomorphic_function_vf2()</code></a>
function.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
  directedness as <em class="parameter"><code>graph1</code></em>, or an error will be reported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>count</code></em>:</span></p></td>
<td><p>
  Point to an integer, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em> and
  <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_isomorphisms_vf2"></a>3.3. <code class="function">igraph_get_isomorphisms_vf2</code> — Collect the isomorphic mappings</h3></div></div></div>
<a class="indexterm" name="idp105545136478024"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_isomorphisms_vf2(const igraph_t *graph1,
                                const igraph_t *graph2,
                                const igraph_vector_int_t *vertex_color1,
                                const igraph_vector_int_t *vertex_color2,
                                const igraph_vector_int_t *edge_color1,
                                const igraph_vector_int_t *edge_color2,
                                igraph_vector_ptr_t *maps,
                                igraph_isocompat_t *node_compat_fn,
                                igraph_isocompat_t *edge_compat_fn,
                                void *arg);
</pre></div>
<p>
</p>
<p>



This function finds all the isomorphic mappings between two
graphs. It uses the <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2" title="3.6. igraph_isomorphic_function_vf2 — The generic VF2 interface"><code class="function">igraph_isomorphic_function_vf2()</code></a>
function. Call the function with the same graph as <em class="parameter"><code>graph1</code></em> and <em class="parameter"><code>graph2</code></em> to get automorphisms.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
  directedness as <em class="parameter"><code>graph1</code></em>, or an error will be reported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maps</code></em>:</span></p></td>
<td><p>
  Pointer vector. On return it is empty if the input graphs
  are no isomorphic. Otherwise it contains pointers to
  <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_t</code></a> objects, each vector is an
  isomorphic mapping of <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em>. Please note that
  you need to 1) Destroy the vectors via <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a>, 2) free them via
  <a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions"><code class="function">igraph_free()</code></a> and then 3) call <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector."><code class="function">igraph_vector_ptr_destroy()</code></a> on the pointer vector to deallocate all
  memory when <em class="parameter"><code>maps</code></em> is no longer needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em>
  and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isohandler_t"></a>3.4. <code class="function">igraph_isohandler_t</code> — Callback type, called when an isomorphism was found</h3></div></div></div>
<a class="indexterm" name="idp105545136508488"></a><pre class="programlisting">
typedef igraph_bool_t igraph_isohandler_t(const igraph_vector_t *map12,
        const igraph_vector_t *map21, void *arg);
</pre>
<p>


See the details at the documentation of <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2" title="3.6. igraph_isomorphic_function_vf2 — The generic VF2 interface"><code class="function">igraph_isomorphic_function_vf2()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  The mapping from the first graph to the second.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  The mapping from the second graph to the first, the
  inverse of <em class="parameter"><code>map12</code></em> basically.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  This extra argument was passed to <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2" title="3.6. igraph_isomorphic_function_vf2 — The generic VF2 interface"><code class="function">igraph_isomorphic_function_vf2()</code></a> when it was called.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Boolean, whether to continue with the isomorphism search.
 
  </p></td>
</tr></tbody>
</table></div>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isocompat_t"></a>3.5. <code class="function">igraph_isocompat_t</code> — Callback type, called to check whether two vertices or edges are compatible</h3></div></div></div>
<a class="indexterm" name="idp105545136390216"></a><pre class="programlisting">
typedef igraph_bool_t igraph_isocompat_t(const igraph_t *graph1,
        const igraph_t *graph2,
        const igraph_integer_t g1_num,
        const igraph_integer_t g2_num,
        void *arg);
</pre>
<p>


VF2 (subgraph) isomorphism functions can be restricted by defining
relations on the vertices and/or edges of the graphs, and then checking
whether the vertices (edges) match according to these relations.

</p>
<p>This feature is implemented by two callbacks, one for
vertices, one for edges. Every time igraph tries to match a vertex (edge)
of the first (sub)graph to a vertex of the second graph, the vertex
(edge) compatibility callback is called. The callback returns a
logical value, giving whether the two vertices match.

</p>
<p>Both callback functions are of type <code class="constant">igraph_isocompat_t</code>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>g1_num</code></em>:</span></p></td>
<td><p>
  The id of a vertex or edge in the first graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>g2_num</code></em>:</span></p></td>
<td><p>
  The id of a vertex or edge in the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to pass to the callback functions.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Logical scalar, whether vertex (or edge) <em class="parameter"><code>g1_num</code></em> in <em class="parameter"><code>graph1</code></em>
   is compatible with vertex (or edge) <em class="parameter"><code>g2_num</code></em> in <em class="parameter"><code>graph2</code></em>.
 
  </p></td>
</tr></tbody>
</table></div>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic_function_vf2"></a>3.6. <code class="function">igraph_isomorphic_function_vf2</code> — The generic VF2 interface</h3></div></div></div>
<a class="indexterm" name="idp105545136406728"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isomorphic_function_vf2(const igraph_t *graph1, const igraph_t *graph2,
                                   const igraph_vector_int_t *vertex_color1,
                                   const igraph_vector_int_t *vertex_color2,
                                   const igraph_vector_int_t *edge_color1,
                                   const igraph_vector_int_t *edge_color2,
                                   igraph_vector_t *map12,
                                   igraph_vector_t *map21,
                                   igraph_isohandler_t *isohandler_fn,
                                   igraph_isocompat_t *node_compat_fn,
                                   igraph_isocompat_t *edge_compat_fn,
                                   void *arg);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function is an implementation of the VF2 isomorphism algorithm,
see P. Foggia, C. Sansone, M. Vento, An Improved algorithm for
matching large graphs, Proc. of the 3rd IAPR-TC-15 International
Workshop on Graph-based Representations, Italy, 2001.</p>
<p>For using it you need to define a callback function of type
<a class="link" href="igraph-Isomorphism.html#igraph_isohandler_t" title="3.4. igraph_isohandler_t — Callback type, called when an isomorphism was found"><code class="function">igraph_isohandler_t</code></a>. This function will be called whenever VF2
finds an isomorphism between the two graphs. The mapping between
the two graphs will be also provided to this function. If the
callback returns a nonzero value then the search is continued,
otherwise it stops. The callback function must not destroy the
mapping vectors that are passed to it.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or <code class="constant">NULL</code>. If not <code class="constant">NULL</code> and the supplied graphs are isomorphic then the permutation
  taking <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph</code></em> is stored here. If not <code class="constant">NULL</code> and the
  graphs are not isomorphic then a zero-length vector is returned.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  This is the same as <em class="parameter"><code>map12</code></em>, but for the permutation
  taking <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>isohandler_fn</code></em>:</span></p></td>
<td><p>
  The callback function to be called if an
  isomorphism is found. See also <a class="link" href="igraph-Isomorphism.html#igraph_isohandler_t" title="3.4. igraph_isohandler_t — Callback type, called when an isomorphism was found"><code class="function">igraph_isohandler_t</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>isohandler_fn</code></em>, <em class="parameter"><code>node_compat_fn</code></em> and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subisomorphic_vf2"></a>3.7. <code class="function">igraph_subisomorphic_vf2</code> — Decide subgraph isomorphism using VF2</h3></div></div></div>
<a class="indexterm" name="idp105545136439496"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_subisomorphic_vf2(const igraph_t *graph1, const igraph_t *graph2,
                             const igraph_vector_int_t *vertex_color1,
                             const igraph_vector_int_t *vertex_color2,
                             const igraph_vector_int_t *edge_color1,
                             const igraph_vector_int_t *edge_color2,
                             igraph_bool_t *iso, igraph_vector_t *map12,
                             igraph_vector_t *map21,
                             igraph_isocompat_t *node_compat_fn,
                             igraph_isocompat_t *edge_compat_fn,
                             void *arg);
</pre></div>
<p>
</p>
<p>



Decides whether a subgraph of <em class="parameter"><code>graph1</code></em> is isomorphic to <em class="parameter"><code>graph2</code></em>. It uses <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_function_vf2" title="3.10. igraph_subisomorphic_function_vf2 — Generic VF2 function for subgraph isomorphism problems"><code class="function">igraph_subisomorphic_function_vf2()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
   undirected. This is supposed to be the larger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
   directedness as <em class="parameter"><code>graph1</code></em>. This is supposed to be the smaller
   graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the subgraph isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean. The result of the decision problem
   is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  Pointer to a vector or <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, then an
   isomorphic mapping from <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph2</code></em> is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  Pointer to a vector ot <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, then
   an isomorphic mapping from <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em> is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em>
  and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_count_subisomorphisms_vf2"></a>3.8. <code class="function">igraph_count_subisomorphisms_vf2</code> — Number of subgraph isomorphisms using VF2</h3></div></div></div>
<a class="indexterm" name="idp105545136602824"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_count_subisomorphisms_vf2(const igraph_t *graph1, const igraph_t *graph2,
                                     const igraph_vector_int_t *vertex_color1,
                                     const igraph_vector_int_t *vertex_color2,
                                     const igraph_vector_int_t *edge_color1,
                                     const igraph_vector_int_t *edge_color2,
                                     igraph_integer_t *count,
                                     igraph_isocompat_t *node_compat_fn,
                                     igraph_isocompat_t *edge_compat_fn,
                                     void *arg);
</pre></div>
<p>
</p>
<p>



Count the number of isomorphisms between subgraphs of <em class="parameter"><code>graph1</code></em> and
<em class="parameter"><code>graph2</code></em>. This function uses <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_function_vf2" title="3.10. igraph_subisomorphic_function_vf2 — Generic VF2 function for subgraph isomorphism problems"><code class="function">igraph_subisomorphic_function_vf2()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
   undirected. This is supposed to be the larger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
   directedness as <em class="parameter"><code>graph1</code></em>. This is supposed to be the smaller
   graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the subgraph isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>count</code></em>:</span></p></td>
<td><p>
  Pointer to an integer. The number of subgraph
   isomorphisms is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em> and
  <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_get_subisomorphisms_vf2"></a>3.9. <code class="function">igraph_get_subisomorphisms_vf2</code> — Return all subgraph isomorphic mappings</h3></div></div></div>
<a class="indexterm" name="idp105545136628680"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_subisomorphisms_vf2(const igraph_t *graph1,
                                   const igraph_t *graph2,
                                   const igraph_vector_int_t *vertex_color1,
                                   const igraph_vector_int_t *vertex_color2,
                                   const igraph_vector_int_t *edge_color1,
                                   const igraph_vector_int_t *edge_color2,
                                   igraph_vector_ptr_t *maps,
                                   igraph_isocompat_t *node_compat_fn,
                                   igraph_isocompat_t *edge_compat_fn,
                                   void *arg);
</pre></div>
<p>
</p>
<p>



This function collects all isomorphic mappings of <em class="parameter"><code>graph2</code></em> to a
subgraph of <em class="parameter"><code>graph1</code></em>. It uses the <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_function_vf2" title="3.10. igraph_subisomorphic_function_vf2 — Generic VF2 function for subgraph isomorphism problems"><code class="function">igraph_subisomorphic_function_vf2()</code></a> function.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
   undirected. This is supposed to be the larger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
   directedness as <em class="parameter"><code>graph1</code></em>. This is supposed to be the smaller
   graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the subgraph isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maps</code></em>:</span></p></td>
<td><p>
  Pointer vector. On return it contains pointers to
  <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_t</code></a> objects, each vector is an
  isomorphic mapping of <em class="parameter"><code>graph2</code></em> to a subgraph of <em class="parameter"><code>graph1</code></em>. Please note that
  you need to 1) Destroy the vectors via <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a>, 2) free them via
  <a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions"><code class="function">igraph_free()</code></a> and then 3) call <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector."><code class="function">igraph_vector_ptr_destroy()</code></a> on the pointer vector to deallocate all
  memory when <em class="parameter"><code>maps</code></em> is no longer needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>node_compat_fn</code></em>
  and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subisomorphic_function_vf2"></a>3.10. <code class="function">igraph_subisomorphic_function_vf2</code> — Generic VF2 function for subgraph isomorphism problems</h3></div></div></div>
<a class="indexterm" name="idp105545136528072"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_subisomorphic_function_vf2(const igraph_t *graph1,
                                      const igraph_t *graph2,
                                      const igraph_vector_int_t *vertex_color1,
                                      const igraph_vector_int_t *vertex_color2,
                                      const igraph_vector_int_t *edge_color1,
                                      const igraph_vector_int_t *edge_color2,
                                      igraph_vector_t *map12,
                                      igraph_vector_t *map21,
                                      igraph_isohandler_t *isohandler_fn,
                                      igraph_isocompat_t *node_compat_fn,
                                      igraph_isocompat_t *edge_compat_fn,
                                      void *arg);
</pre></div>
<p>
</p>
<p>



This function is the pair of <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_function_vf2" title="3.6. igraph_isomorphic_function_vf2 — The generic VF2 interface"><code class="function">igraph_isomorphic_function_vf2()</code></a>,
for subgraph isomorphism problems. It searches for subgraphs of <em class="parameter"><code>graph1</code></em> which are isomorphic to <em class="parameter"><code>graph2</code></em>. When it founds an
isomorphic mapping it calls the supplied callback <em class="parameter"><code>isohandler_fn</code></em>.
The mapping (and its inverse) and the additional <em class="parameter"><code>arg</code></em> argument
are supplied to the callback.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph, may be directed or
   undirected. This is supposed to be the larger graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph, it must have the same
   directedness as <em class="parameter"><code>graph1</code></em>. This is supposed to be the smaller
   graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color1</code></em>:</span></p></td>
<td><p>
  An optional color vector for the first graph. If
  color vectors are given for both graphs, then the subgraph isomorphism is
  calculated on the colored graphs; i.e. two vertices can match
  only if their color also matches. Supply a null pointer here if
  your graphs are not colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color2</code></em>:</span></p></td>
<td><p>
  An optional color vector for the second graph. See
  the previous argument for explanation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color1</code></em>:</span></p></td>
<td><p>
  An optional edge color vector for the first
  graph. The matching edges in the two graphs must have matching
  colors as well. Supply a null pointer here if your graphs are not
  edge-colored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color2</code></em>:</span></p></td>
<td><p>
  The edge color vector for the second graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map12</code></em>:</span></p></td>
<td><p>
  Pointer to a vector or <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, then an
   isomorphic mapping from <em class="parameter"><code>graph1</code></em> to <em class="parameter"><code>graph2</code></em> is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map21</code></em>:</span></p></td>
<td><p>
  Pointer to a vector ot <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, then
   an isomorphic mapping from <em class="parameter"><code>graph2</code></em> to <em class="parameter"><code>graph1</code></em> is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>isohandler_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isohandler_t" title="3.4. igraph_isohandler_t — Callback type, called when an isomorphism was found"><code class="function">igraph_isohandler_t</code></a>. This will be called whenever a subgraph
  isomorphism is found. If the function returns with a non-zero value
  then the search is continued, otherwise it stops and the function
  returns.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two nodes are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_compat_fn</code></em>:</span></p></td>
<td><p>
  A pointer to a function of type <a class="link" href="igraph-Isomorphism.html#igraph_isocompat_t" title="3.5. igraph_isocompat_t — Callback type, called to check whether two vertices or edges are compatible"><code class="function">igraph_isocompat_t</code></a>. This function will be called by the algorithm to
  determine whether two edges are compatible.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>arg</code></em>:</span></p></td>
<td><p>
  Extra argument to supply to functions <em class="parameter"><code>isohandler_fn</code></em>, <em class="parameter"><code>node_compat_fn</code></em> and <em class="parameter"><code>edge_compat_fn</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="lad-algorithm"></a>4. The LAD algorithm</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Isomorphism.html#igraph_subisomorphic_lad">4.1. <code class="function">igraph_subisomorphic_lad</code> — Check subgraph isomorphism with the LAD algorithm</a></span></dt></dl></div>
<p>
The LAD algorithm can search for a subgraph in a larger graph, or check
if two graphs are isomorphic.
See Christine Solnon: AllDifferent-based Filtering for Subgraph
Isomorphism. Artificial Intelligence, 174(12-13):850-864, 2010.
<a class="ulink" href="https://doi.org/10.1016/j.artint.2010.05.002" target="_top">https://doi.org/10.1016/j.artint.2010.05.002</a>
as well as the homepage of the LAD library at <a class="ulink" href="http://liris.cnrs.fr/csolnon/LAD.html" target="_top">http://liris.cnrs.fr/csolnon/LAD.html</a>
The implementation in igraph is based on LADv1, but it is
modified to use igraph's own memory allocation and error handling.
</p>
<p>
LAD uses the concept of domains to indicate vertex compatibility when matching the
pattern graph. Domains can be used to implement matching of colored vertices.
</p>
<p>
LAD works with both directed and undirected graphs. Graphs with multi-edges are not supported.
</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_subisomorphic_lad"></a>4.1. <code class="function">igraph_subisomorphic_lad</code> — Check subgraph isomorphism with the LAD algorithm</h3></div></div></div>
<a class="indexterm" name="idp105545136565704"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_subisomorphic_lad(const igraph_t *pattern, const igraph_t *target,
                             const igraph_vector_ptr_t *domains,
                             igraph_bool_t *iso, igraph_vector_t *map,
                             igraph_vector_ptr_t *maps,
                             igraph_bool_t induced, int time_limit);
</pre></div>
<p>
</p>
<p>



Check whether <em class="parameter"><code>pattern</code></em> is isomorphic to a subgraph os <em class="parameter"><code>target</code></em>.
The original LAD implementation by Christine Solnon was used as the
basis of this code.

</p>
<p>
See more about LAD at <a class="ulink" href="http://liris.cnrs.fr/csolnon/LAD.html" target="_top">http://liris.cnrs.fr/csolnon/LAD.html</a> and in
Christine Solnon: AllDifferent-based Filtering for Subgraph
Isomorphism. Artificial Intelligence, 174(12-13):850-864, 2010.
<a class="ulink" href="https://doi.org/10.1016/j.artint.2010.05.002" target="_top">https://doi.org/10.1016/j.artint.2010.05.002</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>pattern</code></em>:</span></p></td>
<td><p>
  The smaller graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  The bigger graph, it can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>domains</code></em>:</span></p></td>
<td><p>
  A pointer vector, or a null pointer. If a pointer
   vector, then it must contain pointers to <code class="constant">igraph_vector_t</code>
   objects and the length of the vector must match the number of
   vertices in the <em class="parameter"><code>pattern</code></em> graph. For each vertex, the ids of
   the compatible vertices in the target graph are listed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, or a null pointer. If not a null
   pointer, then the boolean is set to TRUE (1) if a subgraph
   isomorphism is found, and to FALSE (0) otherwise.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>map</code></em>:</span></p></td>
<td><p>
  Pointer to a vector or a null pointer. If not a null
   pointer and a subgraph isomorphism is found, the matching
   vertices from the target graph are listed here, for each vertex
   (in vertex id order) from the pattern graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maps</code></em>:</span></p></td>
<td><p>
  Pointer vector or a null pointer. If not a null
   pointer, then all subgraph isomorphisms are stored in the
   pointer vector, in <code class="constant">igraph_vector_t</code> objects.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>induced</code></em>:</span></p></td>
<td><p>
  Boolean, whether to search for induced matching
   subgraphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>time_limit</code></em>:</span></p></td>
<td><p>
  Processor time limit in seconds. Supply zero
   here for no limit. If the time limit is over, then the function
   signals an error.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a> for the VF2 algorithm.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: exponential.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="idp105545136195784"></a><p class="title"><b>Example 17.2.  File <code class="code">examples/simple/igraph_subisomorphic_lad.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;


<span class="emphasis"><em>/* This test counts motifs using LAD and compares the results with</em></span>
<span class="emphasis"><em> * the RANDESU motif finder */</em></span>
void <span class="strong"><strong>test_motifs</strong></span>() {
    igraph_t graph;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> randesu_counts, lad_counts;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> cut_prob;
    int i, n;
    igraph_bool_t equal;
    igraph_integer_t vcount;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);

    <span class="strong"><strong>igraph_erdos_renyi_game_gnm</strong></span>(&amp;graph, 40, 400, <span class="emphasis"><em>/* directed = */</em></span> 1, <span class="emphasis"><em>/* loops = */</em></span> 0);
    vcount = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="2.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;graph);

    <span class="emphasis"><em>/* 3-motifs */</em></span>

    n = 16; <span class="emphasis"><em>/* there are 16 size-3 directed graphs */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;lad_counts, n);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        igraph_t pattern;
        igraph_vector_ptr_t maps;
        igraph_integer_t nAutomorphisms;

        <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isoclass_create" title="5.4. igraph_isoclass_create — Creates a graph from the given isomorphism class.">igraph_isoclass_create</a></strong></span>(&amp;pattern, 3, i, <span class="emphasis"><em>/* directed = */</em></span> 1);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;maps, 0);

        <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;graph, NULL, NULL, NULL, &amp;maps, <span class="emphasis"><em>/* induced = */</em></span> 1, 0);

        <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2" title="3.8. igraph_count_subisomorphisms_vf2 — Number of subgraph isomorphisms using VF2">igraph_count_subisomorphisms_vf2</a></strong></span>(&amp;pattern, &amp;pattern, NULL, NULL, NULL, NULL, &amp;nAutomorphisms, NULL, NULL, NULL);

        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(lad_counts)[i] = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;maps) / nAutomorphisms;

        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR" title="2.16.14. IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR — Sets the item destructor for this pointer vector (macro version).">IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR</a></strong></span>(&amp;maps, <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a>);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy_all" title="2.16.5. igraph_vector_ptr_destroy_all — Frees all the elements and destroys the pointer vector.">igraph_vector_ptr_destroy_all</a></strong></span>(&amp;maps);

        <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;pattern);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;cut_prob, 3);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;randesu_counts, 0);
    <span class="strong"><strong><a class="link" href="igraph-Motifs.html#igraph_motifs_randesu" title="4.1. igraph_motifs_randesu — Count the number of motifs in a graph">igraph_motifs_randesu</a></strong></span>(&amp;graph, &amp;randesu_counts, 3, &amp;cut_prob);

    equal = 1 <span class="emphasis"><em>/* true */</em></span>;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_is_nan</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(randesu_counts)[i])) {
            <span class="strong"><strong>continue</strong></span>;
        }
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(randesu_counts)[i] != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(lad_counts)[i]) {
            equal = 0;
            <span class="strong"><strong>break</strong></span>;
        }
    }

    <span class="strong"><strong>if</strong></span> (! equal) {
        <span class="strong"><strong>printf</strong></span>("LAD 3-motif count does not agree with RANDESU.\n");
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_sum" title="2.11.4. igraph_vector_sum — Calculates the sum of the elements in the vector.">igraph_vector_sum</a></strong></span>(&amp;lad_counts) != vcount * (vcount - 1) * (vcount - 2) / 6) {
        <span class="strong"><strong>printf</strong></span>("Total 3-vertex subgraph count is incorrect.\n");
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;randesu_counts);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;lad_counts);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;cut_prob);

    <span class="emphasis"><em>/* 4-motifs */</em></span>

    n = 218; <span class="emphasis"><em>/* there are 218 size-4 directed graphs */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;lad_counts, n);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        igraph_t pattern;
        igraph_vector_ptr_t maps;
        igraph_integer_t nAutomorphisms;

        <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isoclass_create" title="5.4. igraph_isoclass_create — Creates a graph from the given isomorphism class.">igraph_isoclass_create</a></strong></span>(&amp;pattern, 4, i, <span class="emphasis"><em>/* directed = */</em></span> 1);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;maps, 0);

        <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;graph, NULL, NULL, NULL, &amp;maps, <span class="emphasis"><em>/* induced = */</em></span> 1, 0);

        <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_count_subisomorphisms_vf2" title="3.8. igraph_count_subisomorphisms_vf2 — Number of subgraph isomorphisms using VF2">igraph_count_subisomorphisms_vf2</a></strong></span>(&amp;pattern, &amp;pattern, NULL, NULL, NULL, NULL, &amp;nAutomorphisms, NULL, NULL, NULL);

        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(lad_counts)[i] = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;maps) / nAutomorphisms;

        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR" title="2.16.14. IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR — Sets the item destructor for this pointer vector (macro version).">IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR</a></strong></span>(&amp;maps, <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a>);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy_all" title="2.16.5. igraph_vector_ptr_destroy_all — Frees all the elements and destroys the pointer vector.">igraph_vector_ptr_destroy_all</a></strong></span>(&amp;maps);

        <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;pattern);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;cut_prob, 4);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;randesu_counts, 0);
    <span class="strong"><strong><a class="link" href="igraph-Motifs.html#igraph_motifs_randesu" title="4.1. igraph_motifs_randesu — Count the number of motifs in a graph">igraph_motifs_randesu</a></strong></span>(&amp;graph, &amp;randesu_counts, 4, &amp;cut_prob);

    equal = 1 <span class="emphasis"><em>/* true */</em></span>;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>igraph_is_nan</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(randesu_counts)[i])) {
            <span class="strong"><strong>continue</strong></span>;
        }
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(randesu_counts)[i] != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(lad_counts)[i]) {
            equal = 0;
            <span class="strong"><strong>break</strong></span>;
        }
    }

    <span class="strong"><strong>if</strong></span> (! equal) {
        <span class="strong"><strong>printf</strong></span>("LAD 4-motif count does not agree with RANDESU.\n");
    }

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_sum" title="2.11.4. igraph_vector_sum — Calculates the sum of the elements in the vector.">igraph_vector_sum</a></strong></span>(&amp;lad_counts) != vcount * (vcount - 1) * (vcount - 2) * (vcount - 3) / 24) {
        <span class="strong"><strong>printf</strong></span>("Total 4-vertex subgraph count is incorrect.\n");
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;randesu_counts);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;lad_counts);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;cut_prob);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);
}


int <span class="strong"><strong>main</strong></span>() {
    igraph_t target, pattern;
    igraph_bool_t iso;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> map;
    igraph_vector_ptr_t maps;
    int i, n, result;
    int domainsvec[] = { 0, 2, 8, -1,
                         4, 5, 6, 7, -1,
                         1, 3, 5, 6, 7, 8, -1,
                         0, 2, 8, -1,
                         1, 3, 7, 8, -1, -2
                       };
    igraph_vector_ptr_t domains;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v = 0;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;target, 9, IGRAPH_UNDIRECTED,
                 0, 1, 0, 4, 0, 6,
                 1, 0, 1, 4, 1, 2,
                 2, 1, 2, 3,
                 3, 2, 3, 4, 3, 5, 3, 7, 3, 8,
                 4, 0, 4, 1, 4, 3, 4, 5, 4, 6,
                 5, 6, 5, 4, 5, 3, 5, 8,
                 6, 0, 6, 4, 6, 5,
                 7, 3, 7, 8,
                 8, 5, 8, 3, 8, 7,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph.">igraph_simplify</a></strong></span>(&amp;target, <span class="emphasis"><em>/*multiple=*/</em></span> 1, <span class="emphasis"><em>/*loops=*/</em></span> 0, <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;pattern, 5, IGRAPH_UNDIRECTED,
                 0, 1, 0, 4,
                 1, 0, 1, 4, 1, 2,
                 2, 1, 2, 3,
                 3, 2, 3, 4,
                 4, 3, 4, 1, 4, 0,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph.">igraph_simplify</a></strong></span>(&amp;pattern, <span class="emphasis"><em>/*multiple=*/</em></span> 1, <span class="emphasis"><em>/*loops=*/</em></span> 0, <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;map, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;maps, 0);

    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;target, <span class="emphasis"><em>/*domains=*/</em></span> 0, &amp;iso, &amp;map,
                             &amp;maps, <span class="emphasis"><em>/*induced=*/</em></span> 0, <span class="emphasis"><em>/*time_limit=*/</em></span> 0);

    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;map);
    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;maps);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(maps)[i];
        <span class="strong"><strong>igraph_vector_print</strong></span>(v);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
        <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>(v);
    }

    <span class="strong"><strong>printf</strong></span>("---------\n");

    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;target, <span class="emphasis"><em>/*domains=*/</em></span> 0, &amp;iso, &amp;map,
                             &amp;maps, <span class="emphasis"><em>/*induced=*/</em></span> 1, <span class="emphasis"><em>/*time_limit=*/</em></span> 0);

    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;map);
    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;maps);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(maps)[i];
        <span class="strong"><strong>igraph_vector_print</strong></span>(v);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
        <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>(v);
    }

    <span class="strong"><strong>printf</strong></span>("---------\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;domains, 0);
    i = 0;
    <span class="strong"><strong>while</strong></span> (1) {
        <span class="strong"><strong>if</strong></span> (domainsvec[i] == -2) {
            <span class="strong"><strong>break</strong></span>;
        } <span class="strong"><strong>else</strong></span> <span class="strong"><strong>if</strong></span> (domainsvec[i] == -1) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_push_back" title="2.16.8. igraph_vector_ptr_push_back — Appends an element to the back of a pointer vector.">igraph_vector_ptr_push_back</a></strong></span>(&amp;domains, v);
            v = 0;
        } <span class="strong"><strong>else</strong></span> {
            <span class="strong"><strong>if</strong></span> (!v) {
                v = (<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *) <span class="strong"><strong>malloc</strong></span>(<span class="strong"><strong>sizeof</strong></span>(<a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a>));
                <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(v, 0);
            }
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_push_back" title="2.13.5. igraph_vector_push_back — Appends one element to a vector.">igraph_vector_push_back</a></strong></span>(v, domainsvec[i]);
        }
        i++;
    }

    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;target, &amp;domains, &amp;iso, &amp;map, &amp;maps,
                             <span class="emphasis"><em>/*induced=*/</em></span> 0, <span class="emphasis"><em>/*time_limit=*/</em></span> 0);

    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;map);
    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;maps);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(maps)[i];
        <span class="strong"><strong>igraph_vector_print</strong></span>(v);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
        <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions">igraph_free</a></strong></span>(v);
    }

    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;domains);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *v = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(domains)[i];
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(v);
        <span class="strong"><strong>free</strong></span>(v);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;domains);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;map);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;maps);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;pattern);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;target);

    <span class="strong"><strong>printf</strong></span>("---------\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;map, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;maps, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;target, 9, IGRAPH_UNDIRECTED,
                 0, 1, 0, 4, 0, 6,
                 1, 0, 1, 4, 1, 2,
                 2, 1, 2, 3,
                 3, 2, 3, 4, 3, 5, 3, 7, 3, 8,
                 4, 0, 4, 1, 4, 3, 4, 5, 4, 6,
                 5, 6, 5, 4, 5, 3, 5, 8,
                 6, 0, 6, 4, 6, 5,
                 7, 3, 7, 8,
                 8, 5, 8, 3, 8, 7,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph.">igraph_simplify</a></strong></span>(&amp;target, <span class="emphasis"><em>/*multiple=*/</em></span> 1, <span class="emphasis"><em>/*loops=*/</em></span> 0, <span class="emphasis"><em>/*edge_comb=*/</em></span> 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;pattern, 0, IGRAPH_DIRECTED, -1);
    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(<a class="link" href="igraph-Error.html#igraph_error_handler_ignore" title="2.3. igraph_error_handler_ignore — Ignore errors.">igraph_error_handler_ignore</a>);
    result = <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;target, <span class="emphasis"><em>/*domains=*/</em></span> 0,
                                      &amp;iso, &amp;map, &amp;maps, <span class="emphasis"><em>/*induced=*/</em></span> 0,
                                      <span class="emphasis"><em>/*time_limit=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Error.html#igraph_set_error_handler" title="5.1.1. igraph_set_error_handler — Sets a new error handler.">igraph_set_error_handler</a></strong></span>(<a class="link" href="igraph-Error.html#igraph_error_handler_abort" title="2.2. igraph_error_handler_abort — Abort program in case of error.">igraph_error_handler_abort</a>);
    <span class="strong"><strong>if</strong></span> (result != IGRAPH_EINVAL) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;pattern);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;pattern, 0, IGRAPH_UNDIRECTED, -1);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_lad" title="4.1. igraph_subisomorphic_lad — Check subgraph isomorphism with the LAD algorithm">igraph_subisomorphic_lad</a></strong></span>(&amp;pattern, &amp;target, <span class="emphasis"><em>/*domains=*/</em></span> 0, &amp;iso, &amp;map, &amp;maps,
                             <span class="emphasis"><em>/*induced=*/</em></span> 0, <span class="emphasis"><em>/*time_limit=*/</em></span> 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;map) != 0) {
        <span class="strong"><strong>return</strong></span> 6;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;maps) != 0) {
        <span class="strong"><strong>return</strong></span> 7;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;pattern);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="2.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;target);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;map);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;maps);

    <span class="strong"><strong>test_motifs</strong></span>();

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="functions-for-graphs-with-3-or-4-vertices"></a>5. Functions for graphs with 3 or 4 vertices</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isomorphic_34">5.1. <code class="function">igraph_isomorphic_34</code> — Graph isomorphism for 3-4 vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isoclass">5.2. <code class="function">igraph_isoclass</code> —  Determine the isomorphism class of a graph with 3 or 4 vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isoclass_subgraph">5.3. <code class="function">igraph_isoclass_subgraph</code> —  The isomorphism class of a subgraph of a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_isoclass_create">5.4. <code class="function">igraph_isoclass_create</code> —  Creates a graph from the given isomorphism class.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isomorphic_34"></a>5.1. <code class="function">igraph_isomorphic_34</code> — Graph isomorphism for 3-4 vertices</h3></div></div></div>
<a class="indexterm" name="idp105545136333896"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isomorphic_34(const igraph_t *graph1, const igraph_t *graph2,
                         igraph_bool_t *iso);
</pre></div>
<p>
</p>
<p>



This function uses precomputed indices to decide isomorphism
problems for graphs with only 3 or 4 vertices. Multi-edges
and self-loops are ignored by this function.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second input graph. Must have the same
  directedness as <em class="parameter"><code>graph1</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>iso</code></em>:</span></p></td>
<td><p>
  Pointer to a boolean, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isoclass"></a>5.2. <code class="function">igraph_isoclass</code> —  Determine the isomorphism class of a graph with 3 or 4 vertices</h3></div></div></div>
<a class="indexterm" name="idp105545136345672"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isoclass(const igraph_t *graph, igraph_integer_t *isoclass);
</pre></div>
<p>
</p>
<p>



</p>
<p>
All graphs with a given number of vertices belong to a number of
isomorphism classes, with every graph in a given class being
isomorphic to each other.

</p>
<p>
This function gives the isomorphism class (a number) of a
graph. Two graphs have the same isomorphism class if and only if
they are isomorphic.

</p>
<p>
The first isomorphism class is numbered zero and it is the empty
graph, the last isomorphism class is the full graph. The number of
isomorphism class for directed graphs with three vertices is 16
(between 0 and 15), for undirected graph it is only 4. For graphs
with four vertices it is 218 (directed) and 11 (undirected).

</p>
<p>
Multi-edges and self-loops are ignored by this function.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>isoclass</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, the isomorphism class will
       be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.1. igraph_isomorphic — Decides whether two graphs are isomorphic"><code class="function">igraph_isomorphic()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_isoclass_subgraph" title="5.3. igraph_isoclass_subgraph — The isomorphism class of a subgraph of a graph."><code class="function">igraph_isoclass_subgraph()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isoclass_create" title="5.4. igraph_isoclass_create — Creates a graph from the given isomorphism class."><code class="function">igraph_isoclass_create()</code></a>, <a class="link" href="igraph-Motifs.html#igraph_motifs_randesu" title="4.1. igraph_motifs_randesu — Count the number of motifs in a graph"><code class="function">igraph_motifs_randesu()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Because of some limitations this function works only for graphs
with three of four vertices.

</p>
<p>
Time complexity: O(|E|), the number of edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isoclass_subgraph"></a>5.3. <code class="function">igraph_isoclass_subgraph</code> —  The isomorphism class of a subgraph of a graph.</h3></div></div></div>
<a class="indexterm" name="idp105545136361800"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isoclass_subgraph(const igraph_t *graph, igraph_vector_t *vids,
                             igraph_integer_t *isoclass);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function is only implemented for subgraphs with three or four
vertices.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vids</code></em>:</span></p></td>
<td><p>
  A vector containing the vertex ids to be considered as
       a subgraph. Each vertex id should be included at most once.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>isoclass</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, this will be set to the
       isomorphism class.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isoclass" title="5.2. igraph_isoclass — Determine the isomorphism class of a graph with 3 or 4 vertices"><code class="function">igraph_isoclass()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.1. igraph_isomorphic — Decides whether two graphs are isomorphic"><code class="function">igraph_isomorphic()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isoclass_create" title="5.4. igraph_isoclass_create — Creates a graph from the given isomorphism class."><code class="function">igraph_isoclass_create()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O((d+n)*n), d is the average degree in the network,
and n is the number of vertices in <code class="constant">vids</code>.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_isoclass_create"></a>5.4. <code class="function">igraph_isoclass_create</code> —  Creates a graph from the given isomorphism class.</h3></div></div></div>
<a class="indexterm" name="idp105545135964744"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_isoclass_create(igraph_t *graph, igraph_integer_t size,
                           igraph_integer_t number, igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function is implemented only for graphs with three or four
vertices.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>size</code></em>:</span></p></td>
<td><p>
  The number of vertices to add to the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>number</code></em>:</span></p></td>
<td><p>
  The isomorphism class.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical constant, whether to create a directed
       graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Isomorphism.html#igraph_isoclass" title="5.2. igraph_isoclass — Determine the isomorphism class of a graph with 3 or 4 vertices"><code class="function">igraph_isoclass()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isoclass_subgraph" title="5.3. igraph_isoclass_subgraph — The isomorphism class of a subgraph of a graph."><code class="function">igraph_isoclass_subgraph()</code></a>,
<a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.1. igraph_isomorphic — Decides whether two graphs are isomorphic"><code class="function">igraph_isomorphic()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges in the graph to create.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="isomorphism-utility-functions"></a>6. Utility functions</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_permute_vertices">6.1. <code class="function">igraph_permute_vertices</code> — Permute the vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Isomorphism.html#igraph_simplify_and_colorize">6.2. <code class="function">igraph_simplify_and_colorize</code> —  Simplify the graph and compute self-loop and edge multiplicities.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_permute_vertices"></a>6.1. <code class="function">igraph_permute_vertices</code> — Permute the vertices</h3></div></div></div>
<a class="indexterm" name="idp105545135949896"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_permute_vertices(const igraph_t *graph, igraph_t *res,
                            const igraph_vector_t *permutation);
</pre></div>
<p>
</p>
<p>



This function creates a new graph from the input graph by permuting
its vertices according to the specified mapping. Call this function
with the output of <a class="link" href="igraph-Isomorphism.html#igraph_canonical_permutation" title="2.3. igraph_canonical_permutation — Canonical permutation using Bliss"><code class="function">igraph_canonical_permutation()</code></a> to create
the canonical form of a graph.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object. The new graph
   is created here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>permutation</code></em>:</span></p></td>
<td><p>
  The permutation to apply. Vertex 0 is mapped to
   the first element of the vector, vertex 1 to the second,
etc. Note that it is not checked that the vector contains every
   element only once, and no range checking is performed either.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in terms of the number of
vertices and edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_simplify_and_colorize"></a>6.2. <code class="function">igraph_simplify_and_colorize</code> —  Simplify the graph and compute self-loop and edge multiplicities.</h3></div></div></div>
<a class="indexterm" name="idp105545135929032"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_simplify_and_colorize(
    const igraph_t *graph, igraph_t *res,
    igraph_vector_int_t *vertex_color, igraph_vector_int_t *edge_color);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function creates a vertex and edge colored simple graph from the input
graph. The vertex colors are computed as the number of incident self-loops
to each vertex in the input graph. The edge colors are computed as the number of
parallel edges in the input graph that were merged to create each edge
in the simple graph.

</p>
<p>
The resulting colored simple graph is suitable for use by isomorphism checking
algorithms such as VF2, which only support simple graphs, but can consider
vertex and edge colors.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object, typically having self-loops or multi-edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An uninitialized graph object. The result will be stored here
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vertex_color</code></em>:</span></p></td>
<td><p>
  Computed vertex colors corresponding to self-loop multiplicities.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edge_color</code></em>:</span></p></td>
<td><p>
  Computed edge colors corresponding to edge multiplicities
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2"><code class="function">igraph_isomorphic_vf2()</code></a>, <a class="link" href="igraph-Isomorphism.html#igraph_subisomorphic_vf2" title="3.7. igraph_subisomorphic_vf2 — Decide subgraph isomorphism using VF2"><code class="function">igraph_subisomorphic_vf2()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
</div>
</div>
<table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Cliques.html"><b>← Chapter 16. Cliques and Independent Vertex Sets</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Coloring.html"><b>Chapter 18. Graph Coloring →</b></a></td>
</tr></table>


      </div>
    </div>
  </div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	      &copy; 2003 &ndash; 2023 The igraph core team.
        &bull; Code licensed under <a href="http://www.gnu.org/licenses/gpl-2.0.html"> GNU GPL 2</a> or later,
        documentation under <a href="http://www.gnu.org/copyleft/fdl.html">GNU FDL</a>.
      </p>
      <p class="social">
        <a href="https://twitter.com/igraph2"><i class="fa-brands fa-twitter"></i></a>
        <a rel="me" href="https://fosstodon.org/@igraph"><i class="fa-brands fa-mastodon"></i></a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'c', 'html/');
    </script>





    
  </body>
</html>
