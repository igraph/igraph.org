




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>igraph Reference Manual</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/fontawesome.min.css" integrity="sha384-QYIZto+st3yW+o8+5OHfT6S482Zsvz2WfOzpFSXMF9zqeLcFV0/wlZpMtyFcZALm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/solid.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/brands.min.css">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DY4MJME11Z"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-DY4MJME11Z');
	</script>

    <link href="/css/manual.css" rel="stylesheet">
<script async src="https://cse.google.com/cse.js?cx=003494361702844740117:dlnifinshhm"></script>

  </head>

  <body class="cc">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/c">igraph library</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            0.9.10
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="https://r.igraph.org">igraph R package</a>
              <a class="dropdown-item" href="https://python.igraph.org">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa-brands fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa-solid fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa-solid fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa-solid fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa-brands fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">igraph Reference Manual</h1>
        <p class="lead">For using the igraph C library</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container search-box-container">
  <div class="row">
    <div class="col-md-12 d-flex flex-row align-items-middle">
      <div class="search-label">Search the manual:</div>
	  <div style="flex: 1; margin: -1em 0 -1em 0"><div class="gcse-search" data-personalizedAds="false"></div></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="bs-docs-section">
        
<div class="navigation-header mb-4" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-light" href="igraph-HRG.html"><i class="fa fa-chevron-left"></i>
              Previous
            </a><a accesskey="h" class="btn btn-light" href="index.html"><i class="fa fa-home"></i>
              Home
            </a><a accesskey="n" class="btn btn-light" href="igraph-Embedding.html"><i class="fa fa-chevron-right"></i>
              Next
            </a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-SCG"></a>Chapter 27. Spectral coarse graining</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-SCG.html#about-scg">1. Introduction</a></span></dt>
<dt><span class="section"><a href="igraph-SCG.html#scg-functions">2. SCG functions</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="about-scg"></a>1. Introduction</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-SCG.html#scg-in-brief">1.1. SCG in brief</a></span></dt>
<dt><span class="section"><a href="igraph-SCG.html#functions-for-performing-scg">1.2. Functions for performing SCG</a></span></dt>
<dt><span class="section"><a href="igraph-SCG.html#scg-references">1.3. References</a></span></dt>
</dl></div>
<p>
The SCG functions provide a framework, called Spectral Coarse Graining
(SCG), for reducing large graphs while preserving their
<span class="emphasis"><em>spectral-related features</em></span>, that is features
closely related with the eigenvalues and eigenvectors of a graph
matrix (which for now can be the adjacency, the stochastic, or the
Laplacian matrix).
</p>
<p>
Common examples of such features comprise the first-passage-time of
random walkers on Markovian graphs, thermodynamic properties of
lattice models in statistical physics (e.g. Ising model), and the
epidemic threshold of epidemic network models (SIR and SIS models).
</p>
<p>
SCG differs from traditional clustering schemes by producing a
<span class="emphasis"><em>coarse-grained graph</em></span> (not just a partition of
the vertices), representative of the original one. As shown in [1],
Principal Component Analysis can be viewed as a particular SCG,
called <span class="emphasis"><em>exact SCG</em></span>, where the matrix to be
coarse-grained is the covariance matrix of some data set.
</p>
<p>
SCG should be of interest to practitioners of various
fields dealing with problems where matrix eigenpairs play an important
role, as for instance is the case of dynamical processes on networks.
</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="scg-in-brief"></a>1.1. SCG in brief</h3></div></div></div>
<p>
The main idea of SCG is to operate on a matrix a shrinkage operation
specifically designed to preserve some of the matrix eigenpairs while
not altering other important matrix features (such as its structure).
Mathematically, this idea was expressed as follows. Consider a
(complex) n x n matrix M and form the product
</p>
<div class="blockquote"><blockquote class="blockquote"><p><span class="math">
  M'=LMR*,
</span></p></blockquote></div>
<p>
where n' &lt; n and L, R are from C[n'xn]} and are such
that LR*=I[n'] (R* denotes the conjugate transpose of R). Under
these assumptions, it can be shown that P=R*L is an n'-rank
projector and that, if (lambda, v) is a (right)
eigenpair of M (i.e. Mv=lambda v} and P is orthogonal, there exists
an eigenvalue lambda' of M' such that
</p>
<div class="blockquote"><blockquote class="blockquote"><p><span class="math">
  |lambda-lambda'| &lt;= const ||e[P](v)||
  [1+O(||e[P](v)||<sup>2</sup>)],
</span></p></blockquote></div>
<p>
where ||e[P](v)||=||v-Pv||. Hence, if P (or equivalently
L, R) is chosen so as to make ||e[P](v)|| as small as possible, one
can preserve to any desired level the original eigenvalue
lambda in the coarse-grained matrix M';
under extra assumptions on M, this result can be generalized to
eigenvectors [1]. This leads to the following generic definition of a
SCG problem.
</p>
<p>
Given M (C[nxn]) and (lambda, v), a (right) eigenpair of M to be
preserved by the coarse graining, the problem is to find a projector
P' solving
</p>
<div class="blockquote"><blockquote class="blockquote"><p><span class="math">
  min(||e[P](v)||, p in Omega),
</span></p></blockquote></div>
<p>
where Omega is a set of projectors in C[nxn] described by some
ad hoc constraints c[1], ..., c[r]
(e.g. c[1]: P in R[nxn], c[2]: P=t(P), c[3]: P[i,j] &gt;= 0}, etc).
</p>
<p>
Choosing pertinent constraints to solve the SCG problem is of great
importance in applications. For instance, in the absence of
constraints the SCG problem is solved trivially by
P'=vv* (v is assumed normalized). We have designed a particular
constraint, called <span class="emphasis"><em>homogeneous mixing</em></span>, which
ensures that vertices belonging to the same group are merged
consistently from a physical point of view (see [1] for
details). Under this constraint the SCG problem reduces to finding
the partition of 1, ..., n (labeling the original vertices)
minimizing
</p>
<div class="blockquote"><blockquote class="blockquote"><p><span class="math">
  ||e[P](v)||<sup>2</sup> =
  sum([v(i)-(Pv)(i)]<sup>2</sup>;
  alpha=1,...,n', i in alpha),
</span></p></blockquote></div>
<p>
where alpha denotes a group (i.e. a block) in a partition of
{1, ..., n}, and |alpha| is the number of elements in alpha.
</p>
<p>
If M is symmetric or stochastic, for instance, then it may be
desirable (or mandatory) to choose L, R so that M' is symmetric or
stochastic as well. This <span class="emphasis"><em>structural constraint</em></span>
has led to the construction of particular semi-projectors for
symmetric [1], stochastic [3] and Laplacian [2] matrices, that are
made available.
</p>
<p>
In short, the coarse graining of matrices and graphs involves:
</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>
Retrieving a matrix or a graph matrix M from the
    problem.
  
</p></li>
<li class="listitem"><p>
Computing the eigenpairs of M to be preserved in the
    coarse-grained graph or matrix.
  
</p></li>
<li class="listitem"><p>
Setting some problem-specific constraints (e.g. dimension of
    the coarse-grained object).
  
</p></li>
<li class="listitem"><p>
Solving the constrained SCG problem, that is finding P'.
  
</p></li>
<li class="listitem"><p>
Computing from P' two semi-projectors L' and R'
    (e.g. following the method proposed in [1]).
  
</p></li>
<li class="listitem"><p>
Working out the product M'=L'MR'* and, if needed, defining
    from M' a coarse-grained graph.

</p></li>
</ol></div>
<p>
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="functions-for-performing-scg"></a>1.2. Functions for performing SCG</h3></div></div></div>
<p>
The main functions are <a class="link" href="igraph-SCG.html#igraph_scg_adjacency" title="2.1. igraph_scg_adjacency — Spectral coarse graining, symmetric case."><code class="function">igraph_scg_adjacency()</code></a>, <a class="link" href="igraph-SCG.html#igraph_scg_laplacian" title="2.3. igraph_scg_laplacian — Spectral coarse graining, Laplacian case."><code class="function">igraph_scg_laplacian()</code></a> and <a class="link" href="igraph-SCG.html#igraph_scg_stochastic" title="2.2. igraph_scg_stochastic — Spectral coarse graining, stochastic case."><code class="function">igraph_scg_stochastic()</code></a>.
These functions handle all the steps involved in the
Spectral Coarse Graining (SCG) of some particular matrices and graphs
as described above and in reference [1]. In more details,
they compute some prescribed eigenpairs of a matrix or a
graph matrix, (for now adjacency, Laplacian and stochastic matrices are
available), work out an optimal partition to preserve the eigenpairs,
and finally output a coarse-grained matrix or graph along with other
useful information.
</p>
<p>
These steps can also be carried out independently: (1) Use
<a class="link" href="igraph-Structural.html#igraph_get_adjacency" title="23.6. igraph_get_adjacency — Returns the adjacency matrix of a graph"><code class="function">igraph_get_adjacency()</code></a>, <a class="link" href="igraph-Data-structures.html#igraph_get_sparsemat" title="5.9.2. igraph_get_sparsemat — Converts an igraph graph to a sparse matrix."><code class="function">igraph_get_sparsemat()</code></a>,
<a class="link" href="igraph-Structural.html#igraph_laplacian" title="15.1. igraph_laplacian — Returns the Laplacian matrix of a graph"><code class="function">igraph_laplacian()</code></a>, <a class="link" href="igraph-Structural.html#igraph_get_stochastic" title="23.7. igraph_get_stochastic — Stochastic adjacency matrix of a graph"><code class="function">igraph_get_stochastic()</code></a> or <a class="link" href="igraph-Structural.html#igraph_get_stochastic_sparsemat" title="23.8. igraph_get_stochastic_sparsemat — Stochastic adjacency matrix of a graph"><code class="function">igraph_get_stochastic_sparsemat()</code></a> to compute a matrix M.
(2) Work out some prescribed eigenpairs of M e.g. by
means of <a class="link" href="igraph-Arpack.html#igraph_arpack_rssolve" title="3.2.1. igraph_arpack_rssolve — ARPACK solver for symmetric matrices"><code class="function">igraph_arpack_rssolve()</code></a> or <a class="link" href="igraph-Arpack.html#igraph_arpack_rnsolve" title="3.2.2. igraph_arpack_rnsolve — ARPACK solver for non-symmetric matrices"><code class="function">igraph_arpack_rnsolve()</code></a>. (3) Invoke one the four
algorithms of the function <a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver."><code class="function">igraph_scg_grouping()</code></a> to get a
partition that will preserve the eigenpairs in the coarse-grained
matrix. (4) Compute the semi-projectors L and R using
<a class="link" href="igraph-SCG.html#igraph_scg_semiprojectors" title="2.5. igraph_scg_semiprojectors — Compute SCG semi-projectors for a given partition."><code class="function">igraph_scg_semiprojectors()</code></a> and from there the coarse-grained
matrix M'=LMR*. If necessary, construct a coarse-grained graph from
M' (e.g. as in [1]).
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="scg-references"></a>1.3. References</h3></div></div></div>
<p>
[1] D. Morton de Lachapelle, D. Gfeller, and P. De Los Rios,
Shrinking Matrices while Preserving their Eigenpairs with Application
to the Spectral Coarse Graining of Graphs. Submitted to
<span class="emphasis"><em>SIAM Journal on Matrix Analysis and
Applications</em></span>, 2008.
<a class="ulink" href="http://people.epfl.ch/david.morton" target="_top">http://people.epfl.ch/david.morton</a>
</p>
<p>
[2] D. Gfeller, and P. De Los Rios, Spectral Coarse Graining and
Synchronization in Oscillator Networks.
<span class="emphasis"><em>Physical Review Letters</em></span>,
<span class="strong"><strong>100</strong></span>(17), 2008.
<a class="ulink" href="http://arxiv.org/abs/0708.2055" target="_top">http://arxiv.org/abs/0708.2055</a>
</p>
<p>
[3] D. Gfeller, and P. De Los Rios, Spectral Coarse Graining of Complex
Networks, <span class="emphasis"><em>Physical Review Letters</em></span>,
<span class="strong"><strong>99</strong></span>(3), 2007.
<a class="ulink" href="http://arxiv.org/abs/0706.0812" target="_top">http://arxiv.org/abs/0706.0812</a>
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="scg-functions"></a>2. SCG functions</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-SCG.html#igraph_scg_adjacency">2.1. <code class="function">igraph_scg_adjacency</code> — Spectral coarse graining, symmetric case.</a></span></dt>
<dt><span class="section"><a href="igraph-SCG.html#igraph_scg_stochastic">2.2. <code class="function">igraph_scg_stochastic</code> — Spectral coarse graining, stochastic case.</a></span></dt>
<dt><span class="section"><a href="igraph-SCG.html#igraph_scg_laplacian">2.3. <code class="function">igraph_scg_laplacian</code> —  Spectral coarse graining, Laplacian case.</a></span></dt>
<dt><span class="section"><a href="igraph-SCG.html#igraph_scg_grouping">2.4. <code class="function">igraph_scg_grouping</code> —  SCG problem solver.</a></span></dt>
<dt><span class="section"><a href="igraph-SCG.html#igraph_scg_semiprojectors">2.5. <code class="function">igraph_scg_semiprojectors</code> —  Compute SCG semi-projectors for a given partition.</a></span></dt>
<dt><span class="section"><a href="igraph-SCG.html#igraph_scg_norm_eps">2.6. <code class="function">igraph_scg_norm_eps</code> —  Calculate SCG residuals.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_scg_adjacency"></a>2.1. <code class="function">igraph_scg_adjacency</code> — Spectral coarse graining, symmetric case.</h3></div></div></div>
<a class="indexterm" name="id-1.28.3.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_scg_adjacency(const igraph_t *graph,
                         const igraph_matrix_t *matrix,
                         const igraph_sparsemat_t *sparsemat,
                         const igraph_vector_t *ev,
                         igraph_integer_t nt,
                         const igraph_vector_t *nt_vec,
                         igraph_scg_algorithm_t algo,
                         igraph_vector_t *values,
                         igraph_matrix_t *vectors,
                         igraph_vector_t *groups,
                         igraph_bool_t use_arpack,
                         igraph_integer_t maxiter,
                         igraph_t *scg_graph,
                         igraph_matrix_t *scg_matrix,
                         igraph_sparsemat_t *scg_sparsemat,
                         igraph_matrix_t *L,
                         igraph_matrix_t *R,
                         igraph_sparsemat_t *Lsparse,
                         igraph_sparsemat_t *Rsparse);
</pre></div>
<p>
</p>
<p>



This function handles all the steps involved in the Spectral Coarse
Graining (SCG) of some matrices and graphs as described in the
reference below.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Exactly one of <em class="parameter"><code>graph</code></em>, <em class="parameter"><code>matrix</code></em>
   and <em class="parameter"><code>sparsemat</code></em> must be given, the other two must be <code class="constant">NULL</code>
   pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matrix</code></em>:</span></p></td>
<td><p>
  The input matrix. Exactly one of <em class="parameter"><code>graph</code></em>, <em class="parameter"><code>matrix</code></em>
   and <em class="parameter"><code>sparsemat</code></em> must be given, the other two must be <code class="constant">NULL</code>
   pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sparsemat</code></em>:</span></p></td>
<td><p>
  The input sparse matrix. Exactly one of <em class="parameter"><code>graph</code></em>,
   <em class="parameter"><code>matrix</code></em> and <em class="parameter"><code>sparsemat</code></em> must be given, the other two must be
   <code class="constant">NULL</code> pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ev</code></em>:</span></p></td>
<td><p>
  A vector of positive integers giving the indexes of the
  eigenpairs to be preserved. 1 designates the eigenvalue with
   largest algebraic value, 2 the one with second largest algebraic
   value, etc.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nt</code></em>:</span></p></td>
<td><p>
  Positive integer. When <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_OPTIMUM</code>,
   it gives the number of groups to partition each eigenvector
   separately. When <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_INTERV</code> or <code class="constant">IGRAPH_SCG_INTERV_KM</code>, it gives the number of intervals to
   partition each eigenvector. This is ignored when <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_EXACT</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nt_vec</code></em>:</span></p></td>
<td><p>
  A numeric vector of length one or the length must
   match the number of eigenvectors given in <em class="parameter"><code>V</code></em>, or a <code class="constant">NULL</code>
   pointer. If not <code class="constant">NULL</code>, then this argument gives the number of
   groups or intervals, and <em class="parameter"><code>nt</code></em> is ignored. Different number of
   groups or intervals can be specified for each eigenvector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td><p>
  The algorithm to solve the SCG problem. Possible
   values: <code class="constant">IGRAPH_SCG_OPTIMUM</code>, <code class="constant">IGRAPH_SCG_INTERV_KM</code>, <code class="constant">IGRAPH_SCG_INTERV</code> and <code class="constant">IGRAPH_SCG_EXACT</code>. Please see the
   details about them above.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>values</code></em>:</span></p></td>
<td><p>
  If this is not <code class="constant">NULL</code> and the eigenvectors are
   re-calculated, then the eigenvalues are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vectors</code></em>:</span></p></td>
<td><p>
  If this is not <code class="constant">NULL</code>, and not a zero-length
   matrix, then it is interpreted as the eigenvectors to use for
   the coarse-graining. Otherwise the eigenvectors are
   re-calculated, and they are stored here. (If this is not <code class="constant">NULL</code>.)
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>groups</code></em>:</span></p></td>
<td><p>
  If this is not <code class="constant">NULL</code>, and not a zero-length vector,
   then it is interpreted as the vector of group labels. (Group
   labels are integers from zero and are sequential.) Otherwise
   group labels are re-calculated and stored here, if this argument
   is not a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>use_arpack</code></em>:</span></p></td>
<td><p>
  Whether to use ARPACK for solving the
   eigenproblem. Currently ARPACK is not implemented.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maxiter</code></em>:</span></p></td>
<td><p>
  A positive integer giving the number of iterations
   of the k-means algorithm when <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_INTERV_KM</code>. It is ignored in other cases. A reasonable
   (initial) value for this argument is 100.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scg_graph</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then the coarse-grained
   graph is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scg_matrix</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be an
   initialied matrix, and the coarse-grained matrix is returned
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scg_sparsemat</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then the coarse
   grained matrix is returned here, in sparse matrix form.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>L</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be an initialized
   matrix and the left semi-projector is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>R</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be an initialized
   matrix and the right semi-projector is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>Lsparse</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then the left
   semi-projector is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>Rsparse</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then the right
   semi-projector is returned here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver."><code class="function">igraph_scg_grouping()</code></a>, <a class="link" href="igraph-SCG.html#igraph_scg_semiprojectors" title="2.5. igraph_scg_semiprojectors — Compute SCG semi-projectors for a given partition."><code class="function">igraph_scg_semiprojectors()</code></a>,
<a class="link" href="igraph-SCG.html#igraph_scg_stochastic" title="2.2. igraph_scg_stochastic — Spectral coarse graining, stochastic case."><code class="function">igraph_scg_stochastic()</code></a> and <a class="link" href="igraph-SCG.html#igraph_scg_laplacian" title="2.3. igraph_scg_laplacian — Spectral coarse graining, Laplacian case."><code class="function">igraph_scg_laplacian()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.28.3.2.10.1"></a><p class="title"><b>Example 27.1.  File <code class="code">examples/simple/scg.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2011-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> ev;
    igraph_t scg_graph;
    igraph_matrix_t scg_matrix;
    igraph_sparsemat_t scg_sparsemat;
    igraph_matrix_t L, R;
    igraph_sparsemat_t Lsparse, Rsparse;
    igraph_matrix_t input_matrix;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> groups;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> eval;
    igraph_matrix_t evec;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_tree" title="1.9. igraph_tree — Creates a tree in which almost all vertices have the same number of children.">igraph_tree</a></strong></span>(&amp;g, 10, <span class="emphasis"><em>/* children= */</em></span> 3, IGRAPH_TREE_UNDIRECTED);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;ev, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;L, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;R, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;scg_matrix, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;groups, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;eval, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;evec, 0, 0);

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>CALLSYM</strong></span>(algo) <span class="strong"><strong>do</strong></span> {                      \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_clear" title="2.13.1. igraph_vector_clear — Removes all elements from a vector.">igraph_vector_clear</a></strong></span>(&amp;eval);                     \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_resize" title="3.13.1. igraph_matrix_resize — Resizes a matrix.">igraph_matrix_resize</a></strong></span>(&amp;evec, 0, 0);                  \
        <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_adjacency" title="2.1. igraph_scg_adjacency — Spectral coarse graining, symmetric case.">igraph_scg_adjacency</a></strong></span>(&amp;g, <span class="emphasis"><em>/*matrix=*/</em></span> 0, <span class="emphasis"><em>/*sparsemat=*/</em></span> 0, &amp;ev,  \
                             <span class="emphasis"><em>/* intervals= */</em></span> 3, <span class="emphasis"><em>/* intervals_vector= */</em></span> 0, \
                             <span class="emphasis"><em>/* algorithm= */</em></span> algo, &amp;eval, &amp;evec,       \
                             <span class="emphasis"><em>/* groups= */</em></span> &amp;groups, <span class="emphasis"><em>/* use_arpack= */</em></span> 0,    \
                             <span class="emphasis"><em>/* maxiter= */</em></span> 0, &amp;scg_graph, &amp;scg_matrix, \
                             &amp;scg_sparsemat, &amp;L, &amp;R,            \
                             &amp;Lsparse, &amp;Rsparse); } <span class="strong"><strong>while</strong></span>(0)


<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>PRINTRES</strong></span>()                      \
    <span class="strong"><strong>do</strong></span> {                              \
        <span class="strong"><strong>printf</strong></span>("------------------------------------\n");       \
        <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;scg_graph, stdout);        \
        <span class="strong"><strong>printf</strong></span>("---\n");                        \
        <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);               \
        <span class="strong"><strong>printf</strong></span>("---\n");                        \
        <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;eval);                 \
        <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;evec);                 \
        <span class="strong"><strong>printf</strong></span>("---\n");                        \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;scg_sparsemat, stdout);     \
        <span class="strong"><strong>printf</strong></span>("---\n");                        \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;Lsparse, stdout);           \
        <span class="strong"><strong>printf</strong></span>("---\n");                        \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;Rsparse, stdout);           \
        <span class="strong"><strong>printf</strong></span>("---\n");                        \
    } <span class="strong"><strong>while</strong></span> (0)

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(ev)[0] = 1;
    <span class="strong"><strong>CALLSYM</strong></span>(IGRAPH_SCG_EXACT);
    <span class="strong"><strong>PRINTRES</strong></span>();
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;scg_graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;scg_sparsemat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Lsparse);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Rsparse);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(ev)[0] = 3;
    <span class="strong"><strong>CALLSYM</strong></span>(IGRAPH_SCG_EXACT);
    <span class="strong"><strong>PRINTRES</strong></span>();
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;scg_graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;scg_sparsemat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Lsparse);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Rsparse);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_resize" title="2.13.3. igraph_vector_resize — Resize the vector.">igraph_vector_resize</a></strong></span>(&amp;ev, 2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(ev)[0] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(ev)[1] = 3;
    <span class="strong"><strong>CALLSYM</strong></span>(IGRAPH_SCG_EXACT);
    <span class="strong"><strong>PRINTRES</strong></span>();
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;scg_graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;scg_sparsemat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Lsparse);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Rsparse);

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>CALLSYM2</strong></span>(algo) <span class="strong"><strong>do</strong></span> {                     \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_clear" title="2.13.1. igraph_vector_clear — Removes all elements from a vector.">igraph_vector_clear</a></strong></span>(&amp;eval);                     \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_resize" title="3.13.1. igraph_matrix_resize — Resizes a matrix.">igraph_matrix_resize</a></strong></span>(&amp;evec, 0, 0);                  \
        <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_adjacency" title="2.1. igraph_scg_adjacency — Spectral coarse graining, symmetric case.">igraph_scg_adjacency</a></strong></span>(<span class="emphasis"><em>/* graph=*/</em></span> 0, &amp;input_matrix, <span class="emphasis"><em>/*sparsemat=*/</em></span> 0, \
                                         &amp;ev, <span class="emphasis"><em>/* intervals= */</em></span> 3,           \
                                         <span class="emphasis"><em>/* intervals_vector= */</em></span> 0,         \
                                         <span class="emphasis"><em>/* algorithm= */</em></span> algo, &amp;eval, &amp;evec,       \
                                         <span class="emphasis"><em>/* groups= */</em></span> &amp;groups, <span class="emphasis"><em>/* use_arpack= */</em></span> 0,    \
                                         <span class="emphasis"><em>/* maxiter= */</em></span> 0, &amp;scg_graph, &amp;scg_matrix, \
                                         &amp;scg_sparsemat, &amp;L, &amp;R,            \
                                         &amp;Lsparse, &amp;Rsparse); } <span class="strong"><strong>while</strong></span> (0)

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;input_matrix, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_adjacency" title="23.6. igraph_get_adjacency — Returns the adjacency matrix of a graph">igraph_get_adjacency</a></strong></span>(&amp;g, &amp;input_matrix, IGRAPH_GET_ADJACENCY_BOTH,
                         <span class="emphasis"><em>/* eids= */</em></span> 0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_resize" title="2.13.3. igraph_vector_resize — Resize the vector.">igraph_vector_resize</a></strong></span>(&amp;ev, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(ev)[0] = 1;
    <span class="strong"><strong>CALLSYM2</strong></span>(IGRAPH_SCG_EXACT);
    <span class="strong"><strong>PRINTRES</strong></span>();
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;scg_graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;scg_sparsemat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Lsparse);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Rsparse);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(ev)[0] = 3;
    <span class="strong"><strong>CALLSYM2</strong></span>(IGRAPH_SCG_EXACT);
    <span class="strong"><strong>PRINTRES</strong></span>();
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;scg_graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;scg_sparsemat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Lsparse);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Rsparse);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_resize" title="2.13.3. igraph_vector_resize — Resize the vector.">igraph_vector_resize</a></strong></span>(&amp;ev, 2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(ev)[0] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(ev)[1] = 3;
    <span class="strong"><strong>CALLSYM2</strong></span>(IGRAPH_SCG_EXACT);
    <span class="strong"><strong>PRINTRES</strong></span>();
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;scg_graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;scg_sparsemat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Lsparse);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Rsparse);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;evec);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;eval);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;groups);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;input_matrix);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;scg_matrix);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;L);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;R);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;ev);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* -------------------------------------------------------------------- */</em></span>

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_scg_stochastic"></a>2.2. <code class="function">igraph_scg_stochastic</code> — Spectral coarse graining, stochastic case.</h3></div></div></div>
<a class="indexterm" name="id-1.28.3.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_scg_stochastic(const igraph_t *graph,
                          const igraph_matrix_t *matrix,
                          const igraph_sparsemat_t *sparsemat,
                          const igraph_vector_t *ev,
                          igraph_integer_t nt,
                          const igraph_vector_t *nt_vec,
                          igraph_scg_algorithm_t algo,
                          igraph_scg_norm_t norm,
                          igraph_vector_complex_t *values,
                          igraph_matrix_complex_t *vectors,
                          igraph_vector_t *groups,
                          igraph_vector_t *p,
                          igraph_bool_t use_arpack,
                          igraph_integer_t maxiter,
                          igraph_t *scg_graph,
                          igraph_matrix_t *scg_matrix,
                          igraph_sparsemat_t *scg_sparsemat,
                          igraph_matrix_t *L,
                          igraph_matrix_t *R,
                          igraph_sparsemat_t *Lsparse,
                          igraph_sparsemat_t *Rsparse);
</pre></div>
<p>
</p>
<p>



This function handles all the steps involved in the Spectral Coarse
Graining (SCG) of some matrices and graphs as described in the
reference below.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Exactly one of <em class="parameter"><code>graph</code></em>, <em class="parameter"><code>matrix</code></em>
   and <em class="parameter"><code>sparsemat</code></em> must be given, the other two must be <code class="constant">NULL</code>
   pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matrix</code></em>:</span></p></td>
<td><p>
  The input matrix. Exactly one of <em class="parameter"><code>graph</code></em>, <em class="parameter"><code>matrix</code></em>
   and <em class="parameter"><code>sparsemat</code></em> must be given, the other two must be <code class="constant">NULL</code>
   pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sparsemat</code></em>:</span></p></td>
<td><p>
  The input sparse matrix. Exactly one of <em class="parameter"><code>graph</code></em>,
   <em class="parameter"><code>matrix</code></em> and <em class="parameter"><code>sparsemat</code></em> must be given, the other two must be
   <code class="constant">NULL</code> pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ev</code></em>:</span></p></td>
<td><p>
  A vector of positive integers giving the indexes of the
  eigenpairs to be preserved. 1 designates the eigenvalue with
   largest magnitude, 2 the one with second largest magnitude, etc.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nt</code></em>:</span></p></td>
<td><p>
  Positive integer. When <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_OPTIMUM</code>,
   it gives the number of groups to partition each eigenvector
   separately. When <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_INTERV</code> or <code class="constant">IGRAPH_SCG_INTERV_KM</code>, it gives the number of intervals to
   partition each eigenvector. This is ignored when <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_EXACT</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nt_vec</code></em>:</span></p></td>
<td><p>
  A numeric vector of length one or the length must
   match the number of eigenvectors given in <em class="parameter"><code>V</code></em>, or a <code class="constant">NULL</code>
   pointer. If not <code class="constant">NULL</code>, then this argument gives the number of
   groups or intervals, and <em class="parameter"><code>nt</code></em> is ignored. Different number of
   groups or intervals can be specified for each eigenvector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td><p>
  The algorithm to solve the SCG problem. Possible
   values: <code class="constant">IGRAPH_SCG_OPTIMUM</code>, <code class="constant">IGRAPH_SCG_INTERV_KM</code>, <code class="constant">IGRAPH_SCG_INTERV</code> and <code class="constant">IGRAPH_SCG_EXACT</code>. Please see the
   details about them above.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>norm</code></em>:</span></p></td>
<td><p>
  Either <code class="constant">IGRAPH_SCG_NORM_ROW</code> or <code class="constant">IGRAPH_SCG_NORM_COL</code>.
   Specifies whether the rows or the columns of the
   stochastic matrix sum up to one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>values</code></em>:</span></p></td>
<td><p>
  If this is not <code class="constant">NULL</code> and the eigenvectors are
   re-calculated, then the eigenvalues are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vectors</code></em>:</span></p></td>
<td><p>
  If this is not <code class="constant">NULL</code>, and not a zero-length
   matrix, then it is interpreted as the eigenvectors to use for
   the coarse-graining. Otherwise the eigenvectors are
   re-calculated, and they are stored here. (If this is not <code class="constant">NULL</code>.)
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>groups</code></em>:</span></p></td>
<td><p>
  If this is not <code class="constant">NULL</code>, and not a zero-length vector,
   then it is interpreted as the vector of group labels. (Group
   labels are integers from zero and are sequential.) Otherwise
   group labels are re-calculated and stored here, if this argument
   is not a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  If this is not <code class="constant">NULL</code>, and not zero length, then it is
   interpreted as the stationary probability distribution of the
   Markov chain corresponding to the input matrix/graph. Its length
   must match the number of  vertices in the input graph (or number
   of rows in the input matrix). If not given, then the stationary
   distribution is calculated and stored here. (Unless this
   argument is a <code class="constant">NULL</code> pointer, in which case it is not stored.)
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>use_arpack</code></em>:</span></p></td>
<td><p>
  Whether to use ARPACK for solving the
   eigenproblem. Currently ARPACK is not implemented.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maxiter</code></em>:</span></p></td>
<td><p>
  A positive integer giving the number of iterations
   of the k-means algorithm when <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_INTERV_KM</code>. It is ignored in other cases. A reasonable
   (initial) value for this argument is 100.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scg_graph</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then the coarse-grained
   graph is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scg_matrix</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be an
   initialied matrix, and the coarse-grained matrix is returned
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scg_sparsemat</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then the coarse
   grained matrix is returned here, in sparse matrix form.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>L</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be an initialized
   matrix and the left semi-projector is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>R</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be an initialized
   matrix and the right semi-projector is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>Lsparse</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then the left
   semi-projector is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>Rsparse</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then the right
   semi-projector is returned here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver."><code class="function">igraph_scg_grouping()</code></a>, <a class="link" href="igraph-SCG.html#igraph_scg_semiprojectors" title="2.5. igraph_scg_semiprojectors — Compute SCG semi-projectors for a given partition."><code class="function">igraph_scg_semiprojectors()</code></a>,
<a class="link" href="igraph-SCG.html#igraph_scg_adjacency" title="2.1. igraph_scg_adjacency — Spectral coarse graining, symmetric case."><code class="function">igraph_scg_adjacency()</code></a> and <a class="link" href="igraph-SCG.html#igraph_scg_laplacian" title="2.3. igraph_scg_laplacian — Spectral coarse graining, Laplacian case."><code class="function">igraph_scg_laplacian()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_scg_laplacian"></a>2.3. <code class="function">igraph_scg_laplacian</code> —  Spectral coarse graining, Laplacian case.</h3></div></div></div>
<a class="indexterm" name="id-1.28.3.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_scg_laplacian(const igraph_t *graph,
                         const igraph_matrix_t *matrix,
                         const igraph_sparsemat_t *sparsemat,
                         const igraph_vector_t *ev,
                         igraph_integer_t nt,
                         const igraph_vector_t *nt_vec,
                         igraph_scg_algorithm_t algo,
                         igraph_scg_norm_t norm,
                         igraph_scg_direction_t direction,
                         igraph_vector_complex_t *values,
                         igraph_matrix_complex_t *vectors,
                         igraph_vector_t *groups,
                         igraph_bool_t use_arpack,
                         igraph_integer_t maxiter,
                         igraph_t *scg_graph,
                         igraph_matrix_t *scg_matrix,
                         igraph_sparsemat_t *scg_sparsemat,
                         igraph_matrix_t *L,
                         igraph_matrix_t *R,
                         igraph_sparsemat_t *Lsparse,
                         igraph_sparsemat_t *Rsparse);
</pre></div>
<p>
</p>
<p>



This function handles all the steps involved in the Spectral Coarse
Graining (SCG) of some matrices and graphs as described in the
reference below.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. Exactly one of <em class="parameter"><code>graph</code></em>, <em class="parameter"><code>matrix</code></em>
   and <em class="parameter"><code>sparsemat</code></em> must be given, the other two must be <code class="constant">NULL</code>
   pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>matrix</code></em>:</span></p></td>
<td><p>
  The input matrix. Exactly one of <em class="parameter"><code>graph</code></em>, <em class="parameter"><code>matrix</code></em>
   and <em class="parameter"><code>sparsemat</code></em> must be given, the other two must be <code class="constant">NULL</code>
   pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sparsemat</code></em>:</span></p></td>
<td><p>
  The input sparse matrix. Exactly one of <em class="parameter"><code>graph</code></em>,
   <em class="parameter"><code>matrix</code></em> and <em class="parameter"><code>sparsemat</code></em> must be given, the other two must be
   <code class="constant">NULL</code> pointers.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ev</code></em>:</span></p></td>
<td><p>
  A vector of positive integers giving the indexes of the
  eigenpairs to be preserved. 1 designates the eigenvalue with
   largest magnitude, 2 the one with second largest magnitude, etc.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nt</code></em>:</span></p></td>
<td><p>
  Positive integer. When <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_OPTIMUM</code>,
   it gives the number of groups to partition each eigenvector
   separately. When <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_INTERV</code> or <code class="constant">IGRAPH_SCG_INTERV_KM</code>, it gives the number of intervals to
   partition each eigenvector. This is ignored when <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_EXACT</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nt_vec</code></em>:</span></p></td>
<td><p>
  A numeric vector of length one or the length must
   match the number of eigenvectors given in <em class="parameter"><code>V</code></em>, or a <code class="constant">NULL</code>
   pointer. If not <code class="constant">NULL</code>, then this argument gives the number of
   groups or intervals, and <em class="parameter"><code>nt</code></em> is ignored. Different number of
   groups or intervals can be specified for each eigenvector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td><p>
  The algorithm to solve the SCG problem. Possible
   values: <code class="constant">IGRAPH_SCG_OPTIMUM</code>, <code class="constant">IGRAPH_SCG_INTERV_KM</code>, <code class="constant">IGRAPH_SCG_INTERV</code> and <code class="constant">IGRAPH_SCG_EXACT</code>. Please see the
   details about them above.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>norm</code></em>:</span></p></td>
<td><p>
  Either <code class="constant">IGRAPH_SCG_NORM_ROW</code> or <code class="constant">IGRAPH_SCG_NORM_COL</code>.
   Specifies whether the rows or the columns of the Laplacian
   matrix sum up to zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>direction</code></em>:</span></p></td>
<td><p>
  Whether to work with left or right eigenvectors.
   Possible values: <code class="constant">IGRAPH_SCG_DIRECTION_DEFAULT</code>, <code class="constant">IGRAPH_SCG_DIRECTION_LEFT</code>, <code class="constant">IGRAPH_SCG_DIRECTION_RIGHT</code>. This
   argument is currently ignored and right eigenvectors are always
   used.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>values</code></em>:</span></p></td>
<td><p>
  If this is not <code class="constant">NULL</code> and the eigenvectors are
   re-calculated, then the eigenvalues are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vectors</code></em>:</span></p></td>
<td><p>
  If this is not <code class="constant">NULL</code>, and not a zero-length
   matrix, then it is interpreted as the eigenvectors to use for
   the coarse-graining. Otherwise the eigenvectors are
   re-calculated, and they are stored here. (If this is not <code class="constant">NULL</code>.)
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>groups</code></em>:</span></p></td>
<td><p>
  If this is not <code class="constant">NULL</code>, and not a zero-length vector,
   then it is interpreted as the vector of group labels. (Group
   labels are integers from zero and are sequential.) Otherwise
   group labels are re-calculated and stored here, if this argument
   is not a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>use_arpack</code></em>:</span></p></td>
<td><p>
  Whether to use ARPACK for solving the
   eigenproblem. Currently ARPACK is not implemented.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maxiter</code></em>:</span></p></td>
<td><p>
  A positive integer giving the number of iterations
   of the k-means algorithm when <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_INTERV_KM</code>. It is ignored in other cases. A reasonable
   (initial) value for this argument is 100.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scg_graph</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then the coarse-grained
   graph is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scg_matrix</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be an
   initialied matrix, and the coarse-grained matrix is returned
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>scg_sparsemat</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then the coarse
   grained matrix is returned here, in sparse matrix form.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>L</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be an initialized
   matrix and the left semi-projector is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>R</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be an initialized
   matrix and the right semi-projector is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>Lsparse</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then the left
   semi-projector is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>Rsparse</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then the right
   semi-projector is returned here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver."><code class="function">igraph_scg_grouping()</code></a>, <a class="link" href="igraph-SCG.html#igraph_scg_semiprojectors" title="2.5. igraph_scg_semiprojectors — Compute SCG semi-projectors for a given partition."><code class="function">igraph_scg_semiprojectors()</code></a>,
<a class="link" href="igraph-SCG.html#igraph_scg_stochastic" title="2.2. igraph_scg_stochastic — Spectral coarse graining, stochastic case."><code class="function">igraph_scg_stochastic()</code></a> and <a class="link" href="igraph-SCG.html#igraph_scg_adjacency" title="2.1. igraph_scg_adjacency — Spectral coarse graining, symmetric case."><code class="function">igraph_scg_adjacency()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_scg_grouping"></a>2.4. <code class="function">igraph_scg_grouping</code> —  SCG problem solver.</h3></div></div></div>
<a class="indexterm" name="id-1.28.3.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_scg_grouping(const igraph_matrix_t *V,
                        igraph_vector_t *groups,
                        igraph_integer_t nt,
                        const igraph_vector_t *nt_vec,
                        igraph_scg_matrix_t mtype,
                        igraph_scg_algorithm_t algo,
                        const igraph_vector_t *p,
                        igraph_integer_t maxiter);
</pre></div>
<p>
</p>
<p>



This function solves the Spectral Coarse Graining (SCG) problem;
either exactly, or approximately but faster.

</p>
<p>
The algorithm <code class="constant">IGRAPH_SCG_OPTIMUM</code> solves the SCG problem exactly
for each eigenvector in <em class="parameter"><code>V</code></em>. The running time of this algorithm is
O(max(nt) m^2) for the symmetric and Laplacian matrix problems.
It is O(m^3) for the stochastic problem. Here m is the number
of rows in <em class="parameter"><code>V</code></em>. In all three cases, the memory usage is O(m^2).

</p>
<p>
The algorithms <code class="constant">IGRAPH_SCG_INTERV</code> and <code class="constant">IGRAPH_SCG_INTERV_KM</code> solve
the SCG problem approximately by performing a (for now) constant
binning of the components of the eigenvectors, that is <code class="literal">nt_vec[i]</code>
constant-size bins are used to partition the <code class="literal">i</code>th eigenvector in <code class="constant">V</code>.
When <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_INTERV_KM</code>, the (Lloyd) k-means algorithm is
run on each partition obtained by <code class="constant">IGRAPH_SCG_INTERV</code> to improve
accuracy.

</p>
<p>
Once a minimizing partition (either exact or approximate) has been
found for each eigenvector, the final grouping is worked out as
follows: two vertices are grouped together in the final partition if
they are grouped together in each minimizing partition. In general, the
size of the final partition is not known in advance when the number
of columns in <em class="parameter"><code>V</code></em> is larger than one.

</p>
<p>
Finally, the algorithm <code class="constant">IGRAPH_SCG_EXACT</code> groups the vertices with
equal components in each eigenvector. The last three algorithms
essentially have linear running time and memory load.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>V</code></em>:</span></p></td>
<td><p>
  The matrix of eigenvectors to be preserved by coarse
   graining, each column is an eigenvector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>groups</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector; the result of the
   SCG is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nt</code></em>:</span></p></td>
<td><p>
  Positive integer. When <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_OPTIMUM</code>,
   it gives the number of groups to partition each eigenvector
   separately. When <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_INTERV</code> or <code class="constant">IGRAPH_SCG_INTERV_KM</code>, it gives the number of intervals to
   partition each eigenvector. This is ignored when <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_EXACT</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nt_vec</code></em>:</span></p></td>
<td><p>
  May be (1) a numeric vector of length one, or
   (2) a vector of the same length as the number of eigenvectors given in <em class="parameter"><code>V</code></em>, or
   (3) a <code class="constant">NULL</code> pointer.
   If not <code class="constant">NULL</code>, then this argument gives the number of
   groups or intervals, and <em class="parameter"><code>nt</code></em> is ignored. Different number of
   groups or intervals can be specified for each eigenvector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mtype</code></em>:</span></p></td>
<td><p>
  The type of semi-projectors used in the SCG. Possible
   values are <code class="constant">IGRAPH_SCG_SYMMETRIC</code>, <code class="constant">IGRAPH_SCG_STOCHASTIC</code> and
   <code class="constant">IGRAPH_SCG_LAPLACIAN</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td><p>
  The algorithm to solve the SCG problem. Possible
   values: <code class="constant">IGRAPH_SCG_OPTIMUM</code>, <code class="constant">IGRAPH_SCG_INTERV_KM</code>, <code class="constant">IGRAPH_SCG_INTERV</code> and <code class="constant">IGRAPH_SCG_EXACT</code>. Please see the
   details about them above.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  A probability vector, or <code class="constant">NULL</code>. This argument must be
   given if <em class="parameter"><code>mtype</code></em> is <code class="constant">IGRAPH_SCG_STOCHASTIC</code>, but it is ignored
   otherwise. For the stochastic case it gives the stationary
   probability distribution of a Markov chain, the one specified by
   the graph/matrix under study.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>maxiter</code></em>:</span></p></td>
<td><p>
  A positive integer giving the number of iterations
   of the k-means algorithm when <em class="parameter"><code>algo</code></em> is <code class="constant">IGRAPH_SCG_INTERV_KM</code>. It is ignored in other cases. A reasonable
   (initial) value for this argument is 100.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: see description above.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-SCG.html#igraph_scg_adjacency" title="2.1. igraph_scg_adjacency — Spectral coarse graining, symmetric case."><code class="function">igraph_scg_adjacency()</code></a>, <a class="link" href="igraph-SCG.html#igraph_scg_laplacian" title="2.3. igraph_scg_laplacian — Spectral coarse graining, Laplacian case."><code class="function">igraph_scg_laplacian()</code></a>, <a class="link" href="igraph-SCG.html#igraph_scg_stochastic" title="2.2. igraph_scg_stochastic — Spectral coarse graining, stochastic case."><code class="function">igraph_scg_stochastic()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.28.3.5.14.1"></a><p class="title"><b>Example 27.2.  File <code class="code">examples/simple/igraph_scg_grouping.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2011-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge, MA, 02138 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>SIZE</strong></span> (1000)

int <span class="strong"><strong>main</strong></span>() {

    igraph_matrix_t M, M2;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> lambda;
    igraph_matrix_t V;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> groups;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> ivec;
    int i, j;
    int n;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);

    <span class="emphasis"><em>/* Symmetric matrix, exponentially distributed elements */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;M, SIZE, SIZE);
    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(&amp;M);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; n; j++) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(M, i, j) = <span class="strong"><strong>igraph_rng_get_exp</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 1);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;M2, n, n);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_update" title="3.4.2. igraph_matrix_update — Update from another matrix.">igraph_matrix_update</a></strong></span>(&amp;M2, &amp;M);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_transpose" title="3.7.11. igraph_matrix_transpose — Transpose a matrix.">igraph_matrix_transpose</a></strong></span>(&amp;M2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_add" title="3.7.3. igraph_matrix_add — Add two matrices.">igraph_matrix_add</a></strong></span>(&amp;M, &amp;M2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_scale" title="3.7.2. igraph_matrix_scale — Multiplies each element of the matrix by a constant.">igraph_matrix_scale</a></strong></span>(&amp;M, 0.5);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;M2);

    <span class="emphasis"><em>/* Get first (most positive) two eigenvectors */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;lambda, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;V, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Arpack.html#igraph_lapack_dsyevr" title="2.2.1. igraph_lapack_dsyevr — Selected eigenvalues and optionally eigenvectors of a symmetric matrix">igraph_lapack_dsyevr</a></strong></span>(&amp;M, IGRAPH_LAPACK_DSYEV_SELECT, <span class="emphasis"><em>/*vl=*/</em></span> 0, <span class="emphasis"><em>/*vu=*/</em></span> 0,
                         <span class="emphasis"><em>/*vestimate=*/</em></span> 0, <span class="emphasis"><em>/*il=*/</em></span> n - 1, <span class="emphasis"><em>/*iu=*/</em></span> n,
                         <span class="emphasis"><em>/*abstol=*/</em></span> 0.0, <span class="emphasis"><em>/*values=*/</em></span> &amp;lambda, <span class="emphasis"><em>/*vectors=*/</em></span> &amp;V,
                         <span class="emphasis"><em>/*support=*/</em></span> 0);

    <span class="emphasis"><em>/* Grouping */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;groups, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;ivec, 2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(ivec)[0] = 2;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(ivec)[1] = 3;
    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*invervals=*/</em></span> 0,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> &amp;ivec, IGRAPH_SCG_SYMMETRIC,
                        IGRAPH_SCG_OPTIMUM, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 100);

    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;ivec);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;groups);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;lambda);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;V);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;M);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.28.3.5.14.2"></a><p class="title"><b>Example 27.3.  File <code class="code">examples/simple/igraph_scg_grouping2.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2011-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t adj, V;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> groups;
    igraph_eigen_which_t which;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;adj, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;V, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;groups, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_tree" title="1.9. igraph_tree — Creates a tree in which almost all vertices have the same number of children.">igraph_tree</a></strong></span>(&amp;g, 10, <span class="emphasis"><em>/* children= */</em></span> 3, IGRAPH_TREE_UNDIRECTED);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_adjacency" title="23.6. igraph_get_adjacency — Returns the adjacency matrix of a graph">igraph_get_adjacency</a></strong></span>(&amp;g, &amp;adj, IGRAPH_GET_ADJACENCY_BOTH, <span class="emphasis"><em>/*eids=*/</em></span> 0);

    which.pos = IGRAPH_EIGEN_LM;
    which.howmany = 1;
    <span class="strong"><strong>igraph_eigen_matrix_symmetric</strong></span>(&amp;adj, <span class="emphasis"><em>/*sparsemat=*/</em></span> 0, <span class="emphasis"><em>/*fun=*/</em></span> 0,
                                  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="3.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g), <span class="emphasis"><em>/*extra=*/</em></span> 0,
                                  <span class="emphasis"><em>/*algorithm=*/</em></span> IGRAPH_EIGEN_LAPACK,
                                  &amp;which, <span class="emphasis"><em>/*options=*/</em></span> 0, <span class="emphasis"><em>/*storage=*/</em></span> 0,
                                  <span class="emphasis"><em>/*values=*/</em></span> 0, &amp;V);

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_SYMMETRIC,
                        IGRAPH_SCG_OPTIMUM, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_SYMMETRIC,
                        IGRAPH_SCG_INTERV_KM, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_SYMMETRIC,
                        IGRAPH_SCG_INTERV, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*(ignored) intervals=*/</em></span> 0,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_SYMMETRIC,
                        IGRAPH_SCG_EXACT, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);


    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;groups);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;V);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;adj);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.28.3.5.14.3"></a><p class="title"><b>Example 27.4.  File <code class="code">examples/simple/igraph_scg_grouping3.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2011-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    <span class="strong"><strong>const</strong></span> int nodes = 10;
    igraph_t g;
    igraph_matrix_t V, V3;
    igraph_matrix_complex_t V2;
    igraph_sparsemat_t stochastic;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> groups;
    igraph_eigen_which_t which;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> p, selcol;

    <span class="emphasis"><em>/* This is a 10-node tree with no non-trivial automorphisms. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, nodes, IGRAPH_UNDIRECTED,
                 3, 5, 4, 5, 4, 9, 8, 9, 0, 9, 0, 6, 1, 6, 1, 2, 7, 8,
                 -1);

    <span class="strong"><strong>igraph_matrix_complex_init</strong></span>(&amp;V2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;V, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;V3, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;groups, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;p, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;selcol, 1);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_stochastic_sparsemat" title="23.8. igraph_get_stochastic_sparsemat — Stochastic adjacency matrix of a graph">igraph_get_stochastic_sparsemat</a></strong></span>(&amp;g, &amp;stochastic, <span class="emphasis"><em>/*column-wise=*/</em></span> 0);

    <span class="emphasis"><em>/* p is always the eigenvector corresponding to the 1-eigenvalue.</em></span>
<span class="emphasis"><em>     * Since the graph is undirected, p is proportional to the degree vector. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="3.2.15. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;p, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, IGRAPH_LOOPS);

    which.pos = IGRAPH_EIGEN_LR;
    which.howmany = 3;
    <span class="strong"><strong>igraph_eigen_matrix</strong></span>(<span class="emphasis"><em>/*matrix=*/</em></span> 0, &amp;stochastic, <span class="emphasis"><em>/*fun=*/</em></span> 0, nodes,
                                    <span class="emphasis"><em>/*extra=*/</em></span> 0, <span class="emphasis"><em>/*algorithm=*/</em></span> IGRAPH_EIGEN_LAPACK,
                                    &amp;which, <span class="emphasis"><em>/*options=*/</em></span> 0, <span class="emphasis"><em>/*storage=*/</em></span> 0,
                                    <span class="emphasis"><em>/*values=*/</em></span> 0, &amp;V2);
    <span class="strong"><strong>igraph_matrix_complex_real</strong></span>(&amp;V2, &amp;V3);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(selcol)[0] = 2;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_select_cols" title="3.6.8. igraph_matrix_select_cols — Select some columns of a matrix.">igraph_matrix_select_cols</a></strong></span>(&amp;V3, &amp;V, &amp;selcol);

    <span class="emphasis"><em>/* ------------ */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_STOCHASTIC,
                        IGRAPH_SCG_OPTIMUM, &amp;p, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);

    <span class="emphasis"><em>/* ------------ */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_STOCHASTIC,
                        IGRAPH_SCG_INTERV_KM, &amp;p, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);

    <span class="emphasis"><em>/* ------------ */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_STOCHASTIC,
                        IGRAPH_SCG_INTERV, &amp;p, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);

    <span class="emphasis"><em>/* ------------ */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*(ignored) intervals=*/</em></span> 0,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_STOCHASTIC,
                        IGRAPH_SCG_EXACT, &amp;p, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);

    <span class="emphasis"><em>/* ------------ */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;p);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;selcol);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;groups);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;V);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;V3);
    <span class="strong"><strong>igraph_matrix_complex_destroy</strong></span>(&amp;V2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;stochastic);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.28.3.5.14.4"></a><p class="title"><b>Example 27.5.  File <code class="code">examples/simple/igraph_scg_grouping4.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2011-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    <span class="strong"><strong>const</strong></span> int nodes = 10;
    igraph_t g;
    igraph_matrix_t V;
    igraph_matrix_complex_t V2;
    igraph_sparsemat_t laplacian;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> groups;
    igraph_eigen_which_t which;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_tree" title="1.9. igraph_tree — Creates a tree in which almost all vertices have the same number of children.">igraph_tree</a></strong></span>(&amp;g, nodes, <span class="emphasis"><em>/* children= */</em></span> 3, IGRAPH_TREE_UNDIRECTED);

    <span class="strong"><strong>igraph_matrix_complex_init</strong></span>(&amp;V2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;V, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;groups, 0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;laplacian, 0, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_laplacian" title="15.1. igraph_laplacian — Returns the Laplacian matrix of a graph">igraph_laplacian</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> 0, <span class="emphasis"><em>/*sparseres=*/</em></span> &amp;laplacian,
                     <span class="emphasis"><em>/*normalized=*/</em></span> 0, <span class="emphasis"><em>/*weights=*/</em></span> 0);

    which.pos = IGRAPH_EIGEN_LR;
    which.howmany = 1;

    <span class="strong"><strong>igraph_eigen_matrix</strong></span>(<span class="emphasis"><em>/*matrix=*/</em></span> 0, &amp;laplacian, <span class="emphasis"><em>/*fun=*/</em></span> 0, nodes,
                                    <span class="emphasis"><em>/*extra=*/</em></span> 0, <span class="emphasis"><em>/*algorithm=*/</em></span> IGRAPH_EIGEN_LAPACK,
                                    &amp;which, <span class="emphasis"><em>/*options=*/</em></span> 0, <span class="emphasis"><em>/*storage=*/</em></span> 0,
                                    <span class="emphasis"><em>/*values=*/</em></span> 0, &amp;V2);
    <span class="strong"><strong>igraph_matrix_complex_real</strong></span>(&amp;V2, &amp;V);

    <span class="emphasis"><em>/* ------------ */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_LAPLACIAN,
                        IGRAPH_SCG_OPTIMUM, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);

    <span class="emphasis"><em>/* ------------ */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_LAPLACIAN,
                        IGRAPH_SCG_INTERV_KM, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);

    <span class="emphasis"><em>/* ------------ */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_LAPLACIAN,
                        IGRAPH_SCG_INTERV, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);

    <span class="emphasis"><em>/* ------------ */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*(ignored) intervals=*/</em></span> 0,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_LAPLACIAN,
                        IGRAPH_SCG_EXACT, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;groups);

    <span class="emphasis"><em>/* ------------ */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;groups);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;V);
    <span class="strong"><strong>igraph_matrix_complex_destroy</strong></span>(&amp;V2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;laplacian);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_scg_semiprojectors"></a>2.5. <code class="function">igraph_scg_semiprojectors</code> —  Compute SCG semi-projectors for a given partition.</h3></div></div></div>
<a class="indexterm" name="id-1.28.3.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_scg_semiprojectors(const igraph_vector_t *groups,
                              igraph_scg_matrix_t mtype,
                              igraph_matrix_t *L,
                              igraph_matrix_t *R,
                              igraph_sparsemat_t *Lsparse,
                              igraph_sparsemat_t *Rsparse,
                              const igraph_vector_t *p,
                              igraph_scg_norm_t norm);
</pre></div>
<p>
</p>
<p>



The three types of semi-projectors are defined as follows.
Let gamma(j) label the group of vertex j in a partition of all the
vertices.

</p>
<p>
The symmetric semi-projectors are defined as
</p>
<div class="blockquote"><blockquote class="blockquote"><p><span class="math">
  L[alpha,j] = R[alpha,j] = 1/sqrt(|alpha|) delta[alpha,gamma(j)],
</span></p></blockquote></div>
<p>
the (row) Laplacian semi-projectors as
</p>
<div class="blockquote"><blockquote class="blockquote"><p><span class="math">
  L[alpha,j] = 1/|alpha| delta[alpha,gamma(j)]
</span></p></blockquote></div>
<p>
and
</p>
<div class="blockquote"><blockquote class="blockquote"><p><span class="math">
  R[alpha,j] = delta[alpha,gamma(j)],
</span></p></blockquote></div>
<p>
and the (row) stochastic semi-projectors as
</p>
<div class="blockquote"><blockquote class="blockquote"><p><span class="math">
    L[alpha,j] = p[1][j] / sum(p[1][k]; k in gamma(j))
    delta[alpha,gamma(j)]
</span></p></blockquote></div>
<p>
and
</p>
<div class="blockquote"><blockquote class="blockquote"><p><span class="math">
    R[alpha,j] = delta[alpha,gamma(j)],
</span></p></blockquote></div>
<p>
where p[1] is the (left) eigenvector associated with the
one-eigenvalue of the stochastic matrix. L and R are
defined in a symmetric way when <em class="parameter"><code>norm</code></em> is <code class="constant">IGRAPH_SCG_NORM_COL</code>. All these semi-projectors verify various
properties described in the reference.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>groups</code></em>:</span></p></td>
<td><p>
  A vector of integers, giving the group label of every
   vertex in the partition. Group labels should start at zero and
   should be sequential.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mtype</code></em>:</span></p></td>
<td><p>
  The type of semi-projectors. For now <code class="constant">IGRAPH_SCG_SYMMETRIC</code>, <code class="constant">IGRAPH_SCG_STOCHASTIC</code> and <code class="constant">IGRAP_SCG_LAPLACIAN</code> are supported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>L</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be a pointer to
   an initialized matrix. The left semi-projector is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>R</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be a pointer to
   an initialized matrix. The right semi-projector is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>Lsparse</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be a pointer
   to an uninitialized sparse matrix. The left semi-projector is
   stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>Rsparse</code></em>:</span></p></td>
<td><p>
  If not a <code class="constant">NULL</code> pointer, then it must be a pointer
   to an uninitialized sparse matrix. The right semi-projector is
   stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  <code class="constant">NULL</code>, or a probability vector of the same length as <em class="parameter"><code>groups</code></em>. <em class="parameter"><code>p</code></em> is the stationary probability distribution of a
   Markov chain when <em class="parameter"><code>mtype</code></em> is <code class="constant">IGRAPH_SCG_STOCHASTIC</code>. This
   argument is ignored in all other cases.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>norm</code></em>:</span></p></td>
<td><p>
  Either <code class="constant">IGRAPH_SCG_NORM_ROW</code> or <code class="constant">IGRAPH_SCG_NORM_COL</code>.
   Specifies whether the rows or the columns of the Laplacian
   matrix sum up to zero, or whether the rows or the columns of the
   stochastic matrix sum up to one.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-SCG.html#igraph_scg_adjacency" title="2.1. igraph_scg_adjacency — Spectral coarse graining, symmetric case."><code class="function">igraph_scg_adjacency()</code></a>, <a class="link" href="igraph-SCG.html#igraph_scg_stochastic" title="2.2. igraph_scg_stochastic — Spectral coarse graining, stochastic case."><code class="function">igraph_scg_stochastic()</code></a> and
<a class="link" href="igraph-SCG.html#igraph_scg_laplacian" title="2.3. igraph_scg_laplacian — Spectral coarse graining, Laplacian case."><code class="function">igraph_scg_laplacian()</code></a>, <a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver."><code class="function">igraph_scg_grouping()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.28.3.6.11.1"></a><p class="title"><b>Example 27.6.  File <code class="code">examples/simple/igraph_scg_semiprojectors.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2011-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t L, R;
    igraph_sparsemat_t Lsparse, Rsparse;
    igraph_matrix_t adj, V;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> groups;
    igraph_eigen_which_t which;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;L, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;R, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;adj, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;V, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;groups, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_tree" title="1.9. igraph_tree — Creates a tree in which almost all vertices have the same number of children.">igraph_tree</a></strong></span>(&amp;g, 10, <span class="emphasis"><em>/* children= */</em></span> 3, IGRAPH_TREE_UNDIRECTED);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_adjacency" title="23.6. igraph_get_adjacency — Returns the adjacency matrix of a graph">igraph_get_adjacency</a></strong></span>(&amp;g, &amp;adj, IGRAPH_GET_ADJACENCY_BOTH, <span class="emphasis"><em>/*eids=*/</em></span> 0);

    which.pos = IGRAPH_EIGEN_LM;
    which.howmany = 1;
    <span class="strong"><strong>igraph_eigen_matrix_symmetric</strong></span>(&amp;adj, <span class="emphasis"><em>/*sparsemat=*/</em></span> 0, <span class="emphasis"><em>/*fun=*/</em></span> 0,
                                  <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="3.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g), <span class="emphasis"><em>/*extra=*/</em></span> 0,
                                  <span class="emphasis"><em>/*algorithm=*/</em></span> IGRAPH_EIGEN_LAPACK,
                                  &amp;which, <span class="emphasis"><em>/*options=*/</em></span> 0, <span class="emphasis"><em>/*storage=*/</em></span> 0,
                                  <span class="emphasis"><em>/*values=*/</em></span> 0, &amp;V);

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>SEMI</strong></span>()                              \
    <span class="strong"><strong>do</strong></span> {                                  \
        <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_semiprojectors" title="2.5. igraph_scg_semiprojectors — Compute SCG semi-projectors for a given partition.">igraph_scg_semiprojectors</a></strong></span>(&amp;groups, IGRAPH_SCG_SYMMETRIC, &amp;L, &amp;R,    \
                                  &amp;Lsparse, &amp;Rsparse, <span class="emphasis"><em>/*p=*/</em></span> 0,     \
                                  IGRAPH_SCG_NORM_ROW);         \
    } <span class="strong"><strong>while</strong></span>(0)

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>PRINTRES</strong></span>()              \
    <span class="strong"><strong>do</strong></span> {                      \
        <span class="strong"><strong>printf</strong></span>("----------------------\n");     \
        <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;L);            \
        <span class="strong"><strong>printf</strong></span>("---\n");                \
        <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;R);            \
        <span class="strong"><strong>printf</strong></span>("---\n");                \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Lsparse);         \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Rsparse);         \
    } <span class="strong"><strong>while</strong></span> (0)

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_SYMMETRIC,
                        IGRAPH_SCG_OPTIMUM, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>SEMI</strong></span>();
    <span class="strong"><strong>PRINTRES</strong></span>();

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 2,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_SYMMETRIC,
                        IGRAPH_SCG_INTERV_KM, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>SEMI</strong></span>();
    <span class="strong"><strong>PRINTRES</strong></span>();

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 2,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_SYMMETRIC,
                        IGRAPH_SCG_INTERV, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>SEMI</strong></span>();
    <span class="strong"><strong>PRINTRES</strong></span>();

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*(ignored) intervals=*/</em></span> 0,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_SYMMETRIC,
                        IGRAPH_SCG_EXACT, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>SEMI</strong></span>();
    <span class="strong"><strong>PRINTRES</strong></span>();

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;groups);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;L);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;R);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;V);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;adj);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.28.3.6.11.2"></a><p class="title"><b>Example 27.7.  File <code class="code">examples/simple/igraph_scg_semiprojectors2.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2011-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_matrix_t L, R;
    igraph_sparsemat_t Lsparse, Rsparse;
    igraph_matrix_t V, V3;
    igraph_matrix_complex_t V2;
    igraph_sparsemat_t stochastic;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> groups;
    igraph_eigen_which_t which;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> p, selcol;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;L, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;R, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;V, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;V3, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;groups, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;selcol, 1);

    <span class="emphasis"><em>/* This is a 10-node tree with no non-trivial automorphisms. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_UNDIRECTED,
                 3, 5, 4, 5, 4, 9, 8, 9, 0, 9, 0, 6, 1, 6, 1, 2, 7, 8,
                 -1);

    <span class="strong"><strong>igraph_matrix_complex_init</strong></span>(&amp;V2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;p, 0);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_stochastic_sparsemat" title="23.8. igraph_get_stochastic_sparsemat — Stochastic adjacency matrix of a graph">igraph_get_stochastic_sparsemat</a></strong></span>(&amp;g, &amp;stochastic, <span class="emphasis"><em>/*column-wise=*/</em></span> 0);

    <span class="emphasis"><em>/* p is always the eigenvector corresponding to the 1-eigenvalue.</em></span>
<span class="emphasis"><em>     * Since the graph is undirected, p is proportional to the degree vector. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="3.2.15. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;p, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, IGRAPH_LOOPS);

    which.pos = IGRAPH_EIGEN_LR;
    which.howmany = 3;
    <span class="strong"><strong>igraph_eigen_matrix</strong></span>(<span class="emphasis"><em>/*matrix=*/</em></span> 0, &amp;stochastic, <span class="emphasis"><em>/*fun=*/</em></span> 0, 10,
                                    <span class="emphasis"><em>/*extra=*/</em></span> 0, <span class="emphasis"><em>/*algorithm=*/</em></span> IGRAPH_EIGEN_LAPACK,
                                    &amp;which, <span class="emphasis"><em>/*options=*/</em></span> 0, <span class="emphasis"><em>/*storage=*/</em></span> 0,
                                    <span class="emphasis"><em>/*values=*/</em></span> 0, &amp;V2);
    <span class="strong"><strong>igraph_matrix_complex_real</strong></span>(&amp;V2, &amp;V3);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(selcol)[0] = 2;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_select_cols" title="3.6.8. igraph_matrix_select_cols — Select some columns of a matrix.">igraph_matrix_select_cols</a></strong></span>(&amp;V3, &amp;V, &amp;selcol);

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>SEMI</strong></span>()                              \
    <span class="strong"><strong>do</strong></span> {                                  \
        <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_semiprojectors" title="2.5. igraph_scg_semiprojectors — Compute SCG semi-projectors for a given partition.">igraph_scg_semiprojectors</a></strong></span>(&amp;groups, IGRAPH_SCG_STOCHASTIC, &amp;L, &amp;R,   \
                                  &amp;Lsparse, &amp;Rsparse, &amp;p,           \
                                  IGRAPH_SCG_NORM_ROW);         \
    } <span class="strong"><strong>while</strong></span>(0)

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>PRINTRES</strong></span>()              \
    <span class="strong"><strong>do</strong></span> {                      \
        <span class="strong"><strong>printf</strong></span>("----------------------\n");     \
        <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;L);            \
        <span class="strong"><strong>printf</strong></span>("---\n");                \
        <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;R);            \
        <span class="strong"><strong>printf</strong></span>("---\n");                \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Lsparse);         \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Rsparse);         \
    } <span class="strong"><strong>while</strong></span> (0)

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_STOCHASTIC,
                        IGRAPH_SCG_OPTIMUM, &amp;p, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>SEMI</strong></span>();
    <span class="strong"><strong>PRINTRES</strong></span>();

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_STOCHASTIC,
                        IGRAPH_SCG_INTERV_KM, &amp;p, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>SEMI</strong></span>();
    <span class="strong"><strong>PRINTRES</strong></span>();

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_STOCHASTIC,
                        IGRAPH_SCG_INTERV, &amp;p, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>SEMI</strong></span>();
    <span class="strong"><strong>PRINTRES</strong></span>();

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*(ignored) intervals=*/</em></span> 0,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_STOCHASTIC,
                        IGRAPH_SCG_EXACT, &amp;p, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>SEMI</strong></span>();
    <span class="strong"><strong>PRINTRES</strong></span>();

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;p);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;selcol);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;groups);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;L);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;R);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;V);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;V3);
    <span class="strong"><strong>igraph_matrix_complex_destroy</strong></span>(&amp;V2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;stochastic);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.28.3.6.11.3"></a><p class="title"><b>Example 27.8.  File <code class="code">examples/simple/igraph_scg_semiprojectors3.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2011-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    int nodes = 10;
    igraph_t g;
    igraph_matrix_t L, R;
    igraph_sparsemat_t Lsparse, Rsparse;
    igraph_matrix_t V;
    igraph_matrix_complex_t V2;
    igraph_sparsemat_t laplacian;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> groups;
    igraph_eigen_which_t which;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;L, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;R, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;V, 0, 0);
    <span class="strong"><strong>igraph_matrix_complex_init</strong></span>(&amp;V2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;groups, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_tree" title="1.9. igraph_tree — Creates a tree in which almost all vertices have the same number of children.">igraph_tree</a></strong></span>(&amp;g, 10, <span class="emphasis"><em>/* children= */</em></span> 3, IGRAPH_TREE_UNDIRECTED);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;laplacian, nodes, nodes, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="3.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g) * 2);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_laplacian" title="15.1. igraph_laplacian — Returns the Laplacian matrix of a graph">igraph_laplacian</a></strong></span>(&amp;g, <span class="emphasis"><em>/*res=*/</em></span> 0, <span class="emphasis"><em>/*sparseres=*/</em></span> &amp;laplacian,
                     <span class="emphasis"><em>/*normalized=*/</em></span> 0, <span class="emphasis"><em>/*weights=*/</em></span> 0);

    which.pos = IGRAPH_EIGEN_LM;
    which.howmany = 1;

    <span class="strong"><strong>igraph_eigen_matrix</strong></span>(<span class="emphasis"><em>/*matrix=*/</em></span> 0, &amp;laplacian, <span class="emphasis"><em>/*fun=*/</em></span> 0, 10,
                                    <span class="emphasis"><em>/*extra=*/</em></span> 0, <span class="emphasis"><em>/*algorithm=*/</em></span> IGRAPH_EIGEN_LAPACK,
                                    &amp;which, <span class="emphasis"><em>/*options=*/</em></span> 0, <span class="emphasis"><em>/*storage=*/</em></span> 0,
                                    <span class="emphasis"><em>/*values=*/</em></span> 0, &amp;V2);
    <span class="strong"><strong>igraph_matrix_complex_real</strong></span>(&amp;V2, &amp;V);

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>SEMI</strong></span>()                              \
    <span class="strong"><strong>do</strong></span> {                                  \
        <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_semiprojectors" title="2.5. igraph_scg_semiprojectors — Compute SCG semi-projectors for a given partition.">igraph_scg_semiprojectors</a></strong></span>(&amp;groups, IGRAPH_SCG_LAPLACIAN, &amp;L, &amp;R,    \
                                  &amp;Lsparse, &amp;Rsparse, <span class="emphasis"><em>/*p=*/</em></span> 0,     \
                                  IGRAPH_SCG_NORM_ROW);         \
    } <span class="strong"><strong>while</strong></span>(0)

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>PRINTRES</strong></span>()              \
    <span class="strong"><strong>do</strong></span> {                      \
        <span class="strong"><strong>printf</strong></span>("----------------------\n");     \
        <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;L);            \
        <span class="strong"><strong>printf</strong></span>("---\n");                \
        <span class="strong"><strong>igraph_matrix_print</strong></span>(&amp;R);            \
        <span class="strong"><strong>printf</strong></span>("---\n");                \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Lsparse);         \
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;Rsparse);         \
    } <span class="strong"><strong>while</strong></span> (0)

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 3,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_LAPLACIAN,
                        IGRAPH_SCG_OPTIMUM, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>SEMI</strong></span>();
    <span class="strong"><strong>PRINTRES</strong></span>();

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 2,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_LAPLACIAN,
                        IGRAPH_SCG_INTERV_KM, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>SEMI</strong></span>();
    <span class="strong"><strong>PRINTRES</strong></span>();

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*intervals=*/</em></span> 2,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_LAPLACIAN,
                        IGRAPH_SCG_INTERV, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>SEMI</strong></span>();
    <span class="strong"><strong>PRINTRES</strong></span>();

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver.">igraph_scg_grouping</a></strong></span>(&amp;V, &amp;groups, <span class="emphasis"><em>/*(ignored) intervals=*/</em></span> 0,
                        <span class="emphasis"><em>/*intervals_vector=*/</em></span> 0, IGRAPH_SCG_LAPLACIAN,
                        IGRAPH_SCG_EXACT, <span class="emphasis"><em>/*p=*/</em></span> 0, <span class="emphasis"><em>/*maxiter=*/</em></span> 10000);
    <span class="strong"><strong>SEMI</strong></span>();
    <span class="strong"><strong>PRINTRES</strong></span>();

    <span class="emphasis"><em>/* -------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;L);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;R);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;V);
    <span class="strong"><strong>igraph_matrix_complex_destroy</strong></span>(&amp;V2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;groups);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;laplacian);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_scg_norm_eps"></a>2.6. <code class="function">igraph_scg_norm_eps</code> —  Calculate SCG residuals.</h3></div></div></div>
<a class="indexterm" name="id-1.28.3.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_scg_norm_eps(const igraph_matrix_t *V,
                        const igraph_vector_t *groups,
                        igraph_vector_t *eps,
                        igraph_scg_matrix_t mtype,
                        const igraph_vector_t *p,
                        igraph_scg_norm_t norm);
</pre></div>
<p>
</p>
<p>



Computes |v[i]-Pv[i]|, where v[i] is the i-th eigenvector in <em class="parameter"><code>V</code></em>
and P is the projector corresponding to the <em class="parameter"><code>mtype</code></em> argument.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>V</code></em>:</span></p></td>
<td><p>
  The matrix of eigenvectors to be preserved by coarse
   graining, each column is an eigenvector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>groups</code></em>:</span></p></td>
<td><p>
  A vector of integers, giving the group label of every
   vertex in the partition. Group labels should start at zero and
   should be sequential.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>eps</code></em>:</span></p></td>
<td><p>
  Pointer to a real value, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mtype</code></em>:</span></p></td>
<td><p>
  The type of semi-projectors. For now <code class="constant">IGRAPH_SCG_SYMMETRIC</code>, <code class="constant">IGRAPH_SCG_STOCHASTIC</code> and <code class="constant">IGRAP_SCG_LAPLACIAN</code> are supported.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  <code class="constant">NULL</code>, or a probability vector of the same length as <em class="parameter"><code>groups</code></em>. <em class="parameter"><code>p</code></em> is the stationary probability distribution of a
   Markov chain when <em class="parameter"><code>mtype</code></em> is <code class="constant">IGRAPH_SCG_STOCHASTIC</code>. This
   argument is ignored in all other cases.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>norm</code></em>:</span></p></td>
<td><p>
  Either <code class="constant">IGRAPH_SCG_NORM_ROW</code> or <code class="constant">IGRAPH_SCG_NORM_COL</code>.
   Specifies whether the rows or the columns of the Laplacian
   matrix sum up to zero, or whether the rows or the columns of the
   stochastic matrix sum up to one.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-SCG.html#igraph_scg_adjacency" title="2.1. igraph_scg_adjacency — Spectral coarse graining, symmetric case."><code class="function">igraph_scg_adjacency()</code></a>, <a class="link" href="igraph-SCG.html#igraph_scg_stochastic" title="2.2. igraph_scg_stochastic — Spectral coarse graining, stochastic case."><code class="function">igraph_scg_stochastic()</code></a> and
<a class="link" href="igraph-SCG.html#igraph_scg_laplacian" title="2.3. igraph_scg_laplacian — Spectral coarse graining, Laplacian case."><code class="function">igraph_scg_laplacian()</code></a>, <a class="link" href="igraph-SCG.html#igraph_scg_grouping" title="2.4. igraph_scg_grouping — SCG problem solver."><code class="function">igraph_scg_grouping()</code></a>, <a class="link" href="igraph-SCG.html#igraph_scg_semiprojectors" title="2.5. igraph_scg_semiprojectors — Compute SCG semi-projectors for a given partition."><code class="function">igraph_scg_semiprojectors()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
</div>
<table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-HRG.html"><b>← Chapter 26. Hierarchical random graphs</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Embedding.html"><b>Chapter 28. Embedding of graphs →</b></a></td>
</tr></table>


      </div>
    </div>
  </div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	      &copy; 2003 &ndash; 2025 The igraph core team.
        &bull; Code licensed under <a href="http://www.gnu.org/licenses/gpl-2.0.html"> GNU GPL 2</a> or later,
        documentation under <a href="http://www.gnu.org/copyleft/fdl.html">GNU FDL</a>.
      </p>
      <p class="social">
        <a href="https://twitter.com/igraph2"><i class="fa-brands fa-twitter"></i></a>
        <a rel="me" href="https://fosstodon.org/@igraph"><i class="fa-brands fa-mastodon"></i></a>
        <a href="https://discord.gg/cSyHDPJWDD"><i class="fa-brands fa-discord"></i></a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'c', 'html/');
    </script>





    
  </body>
</html>
