




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>igraph Reference Manual</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/fontawesome.min.css" integrity="sha384-QYIZto+st3yW+o8+5OHfT6S482Zsvz2WfOzpFSXMF9zqeLcFV0/wlZpMtyFcZALm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/solid.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/brands.min.css">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DY4MJME11Z"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-DY4MJME11Z');
	</script>

    <link href="/css/manual.css" rel="stylesheet">
<script async src="https://cse.google.com/cse.js?cx=003494361702844740117:dlnifinshhm"></script>

  </head>

  <body class="cc">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/c">igraph library</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            0.9.10
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="https://r.igraph.org">igraph R package</a>
              <a class="dropdown-item" href="https://python.igraph.org">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa-brands fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa-solid fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa-solid fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa-solid fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa-brands fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">igraph Reference Manual</h1>
        <p class="lead">For using the igraph C library</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container search-box-container">
  <div class="row">
    <div class="col-md-12 d-flex flex-row align-items-middle">
      <div class="search-label">Search the manual:</div>
	  <div style="flex: 1; margin: -1em 0 -1em 0"><div class="gcse-search" data-personalizedAds="false"></div></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="bs-docs-section">
        
<div class="navigation-header mb-4" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-light" href="igraph-Memory.html"><i class="fa fa-chevron-left"></i>
              Previous
            </a><a accesskey="h" class="btn btn-light" href="index.html"><i class="fa fa-home"></i>
              Home
            </a><a accesskey="n" class="btn btn-light" href="igraph-Random.html"><i class="fa fa-chevron-right"></i>
              Next
            </a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Data-structures"></a>Chapter 7. Data structure library: vector, matrix, other data types</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph-PMT">1. About template types</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph-Vectors">2. Vectors</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph-Matrices">3. Matrices</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph-SparseMatrices">4. Sparse matrices</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph-SparseMatrices2">5. Sparse matrices, another kind</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph-Stacks">6. Stacks</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph-Dqueues">7. Double-ended queues</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph-Heaps">8. Maximum and minimum heaps</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph-Strvector">9. String vectors</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph-Adjlists">10. Adjacency lists</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph-Partial-prefix-sum-trees">11. Partial prefix sum trees</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="igraph-PMT"></a>1. About template types</h2></div></div></div>
<p>
Some of the container types listed in this section are defined for
many base types. This is similar to templates in C++ and generics in
Ada, but it is implemented via preprocessor macros since the C language
cannot handle it. Here is the list of template types and the all base
types they currently support:
</p>
<div class="glosslist"><dl>
<dt><span class="glossterm">vector</span></dt>
<dd class="glossdef"><p>
  Vector is currently defined for <span class="type">igraph_real_t</span>,
  <span class="type">long int</span> (long), <span class="type">char</span> (char),
  <span class="type">igraph_bool_t</span> (bool). The default is
  <span class="type">igraph_real_t</span>.
</p></dd>
<dt><span class="glossterm">matrix</span></dt>
<dd class="glossdef"><p>
  Matrix is currently defined for <span class="type">igraph_real_t</span>,
  <span class="type">long int</span> (long), <span class="type">char</span> (char),
  <span class="type">igraph_bool_t</span> (bool). The default is
  <span class="type">igraph_real_t</span>.
</p></dd>
<dt><span class="glossterm">array3</span></dt>
<dd class="glossdef"><p>
  Array3 is currently defined for <span class="type">igraph_real_t</span>,
  <span class="type">long int</span> (long), <span class="type">char</span> (char),
  <span class="type">igraph_bool_t</span> (bool). The default is
  <span class="type">igraph_real_t</span>.
</p></dd>
<dt><span class="glossterm">stack</span></dt>
<dd class="glossdef"><p>
  Stack is currently defined for <span class="type">igraph_real_t</span>,
  <span class="type">long int</span> (long), <span class="type">char</span> (char),
  <span class="type">igraph_bool_t</span> (bool). The default is
  <span class="type">igraph_real_t</span>.
</p></dd>
<dt><span class="glossterm">double-ended queue</span></dt>
<dd class="glossdef"><p>
  Dqueue is currently defined for <span class="type">igraph_real_t</span>,
  <span class="type">long int</span> (long), <span class="type">char</span> (char),
  <span class="type">igraph_bool_t</span> (bool). The default is
  <span class="type">igraph_real_t</span>.
</p></dd>
<dt><span class="glossterm">heap</span></dt>
<dd class="glossdef"><p>
  Heap is currently defined for <span class="type">igraph_real_t</span>,
  <span class="type">long int</span> (long), <span class="type">char</span> (char).
  In addition both maximum and minimum heaps are available.
  The default is the <span class="type">igraph_real_t</span> maximum heap.
</p></dd>
</dl></div>
<p>
</p>
<p>
The name of the base element (in parentheses) is added to the function
names, except for the default type.
</p>
<p>
Some examples:
</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem"><p>
  <span class="type">igraph_vector_t</span> is a vector of
  <span class="type">igraph_real_t</span> elements. Its functions are
  <code class="function">igraph_vector_init</code>,
  <code class="function">igraph_vector_destroy</code>,
  <code class="function">igraph_vector_sort</code>, etc.
</p></li>
<li class="listitem"><p>
  <span class="type">igraph_vector_bool_t</span> is a vector of
  <span class="type">igraph_bool_t</span> elements, initialize it with
  <code class="function">igraph_vector_bool_init</code>, destroy it with
  <code class="function">igraph_vector_bool_destroy</code>, etc.
</p></li>
<li class="listitem"><p>
  <span class="type">igraph_heap_t</span> is a maximum heap with
  <span class="type">igraph_real_t</span> elements. The corresponding functions are
  <code class="function">igraph_heap_init</code>,
  <code class="function">igraph_heap_pop</code>, etc.
</p></li>
<li class="listitem"><p>
  <span class="type">igraph_heap_min_t</span> is a minimum heap with
  <span class="type">igraph_real_t</span> elements. The corresponding functions are
  called <code class="function">igraph_heap_min_init</code>,
  <code class="function">igraph_heap_min_pop</code>, etc.
</p></li>
<li class="listitem"><p>
  <span class="type">igraph_heap_long_t</span> is a maximum heap with <span class="type">long
  int</span> elements. Its function have the
  <code class="function">igraph_heap_long_</code> prefix.
</p></li>
<li class="listitem"><p>
  <span class="type">igraph_heap_min_long_t</span> is a minimum heap containing
  <span class="type">long int</span> elements. Its functions have the
  <code class="function">igraph_heap_min_long_</code> prefix.
</p></li>
</ul></div>
<p>
</p>
<p>
Note that the <a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a> and the <a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a> macros can be used on <span class="emphasis"><em>all</em></span>
vector and matrix types.
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="igraph-Vectors"></a>2. Vectors</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_t">2.1.  About <span class="type">igraph_vector_t</span> objects</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#vector-constructors-and-destructors">2.2.  Constructors and
Destructors</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#initializing-elements">2.3. Initializing elements</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#vector-accessing-elements">2.4.  Accessing elements</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#vector-views">2.5. Vector views</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#copying-vectors">2.6. Copying vectors</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#vector-exchanging-elements">2.7. Exchanging elements</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#vector-operations">2.8. Vector operations</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#vector-comparisons">2.9. Vector comparisons</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#vector-finding-minimum-and-maximum">2.10. Finding minimum and maximum</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#vector-properties">2.11. Vector properties</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#vector-searching-for-elements">2.12. Searching for elements</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#vector-resizing-operations">2.13. Resizing operations</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#vector-sorting">2.14. Sorting</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#set-operations-on-sorted-vectors">2.15. Set operations on sorted vectors</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#about-vector-ptr">2.16.  Pointer vectors
(<span class="type">igraph_vector_ptr_t</span>)</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_vector_t"></a>2.1.  About <span class="type">igraph_vector_t</span> objects</h3></div></div></div>
<p>The <span class="type">igraph_vector_t</span> data type is a simple and efficient
interface to arrays containing numbers. It is something
similar as (but much simpler than) the <span class="type">vector</span> template
in the C++ standard library.</p>
<p>Vectors are used extensively in <span class="command"><strong>igraph</strong></span>, all
functions which expect or return a list of numbers use
igraph_vector_t to achieve this.</p>
<p>The <span class="type">igraph_vector_t</span> type usually uses
O(n) space
to store n elements. Sometimes it
uses more, this is because vectors can shrink, but even if they
shrink, the current implementation does not free a single bit of
memory.</p>
<p>The elements in an <span class="type">igraph_vector_t</span>
object are indexed from zero, we follow the usual C convention
here.</p>
<p>The elements of a vector always occupy a single block of
memory, the starting address of this memory block can be queried
with the <a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector."><code class="function">VECTOR</code></a> macro. This way, vector objects can be used
with standard mathematical libraries, like the GNU Scientific
Library.</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="vector-constructors-and-destructors"></a>2.2.  Constructors and
Destructors</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_init">2.2.1. <code class="function">igraph_vector_init</code> —  Initializes a vector object (constructor).</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_init_copy">2.2.2. <code class="function">igraph_vector_init_copy</code> —  Initializes a vector from an ordinary C array (constructor).</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_init_seq">2.2.3. <code class="function">igraph_vector_init_seq</code> —  Initializes a vector with a sequence.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_copy">2.2.4. <code class="function">igraph_vector_copy</code> —  Initializes a vector from another vector object (constructor).</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_destroy">2.2.5. <code class="function">igraph_vector_destroy</code> —  Destroys a vector object.</a></span></dt>
</dl></div>
<p><span class="type">igraph_vector_t</span> objects have to be initialized before using
them, this is analogous to calling a constructor on them. There are a
number of <span class="type">igraph_vector_t</span> constructors, for your
convenience. <a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor)."><code class="function">igraph_vector_init()</code></a> is the basic constructor, it
creates a vector of the given length, filled with zeros.
<a class="link" href="igraph-Data-structures.html#igraph_vector_copy" title="2.2.4. igraph_vector_copy — Initializes a vector from another vector object (constructor)."><code class="function">igraph_vector_copy()</code></a> creates a new identical copy
of an already existing and initialized vector. <a class="link" href="igraph-Data-structures.html#igraph_vector_init_copy" title="2.2.2. igraph_vector_init_copy — Initializes a vector from an ordinary C array (constructor)."><code class="function">igraph_vector_init_copy()</code></a> creates a vector by copying a regular C array.
<a class="link" href="igraph-Data-structures.html#igraph_vector_init_seq" title="2.2.3. igraph_vector_init_seq — Initializes a vector with a sequence."><code class="function">igraph_vector_init_seq()</code></a> creates a vector containing a regular
sequence with increment one.</p>
<p><a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t."><code class="function">igraph_vector_view()</code></a> is a special constructor, it allows you to
handle a regular C array as a <span class="type">vector</span> without copying
its elements.
</p>
<p>If a <span class="type">igraph_vector_t</span> object is not needed any more, it
should be destroyed to free its allocated memory by calling the
<span class="type">igraph_vector_t</span> destructor, <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a>.</p>
<p> Note that vectors created by <a class="link" href="igraph-Data-structures.html#igraph_vector_view" title="2.5.1. igraph_vector_view — Handle a regular C array as a igraph_vector_t."><code class="function">igraph_vector_view()</code></a> are special,
you mustn't call <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a> on these.</p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_init"></a>2.2.1. <code class="function">igraph_vector_init</code> —  Initializes a vector object (constructor).</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.3.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_init(igraph_vector_t* v, int long size);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Every vector needs to be initialized before it can be used, and
there are a number of initialization functions or otherwise called
constructors. This function constructs a vector of the given size and
initializes each entry to 0. Note that <a class="link" href="igraph-Data-structures.html#igraph_vector_null" title="2.3.1. igraph_vector_null — Sets each element in the vector to zero."><code class="function">igraph_vector_null()</code></a> can be
used to set each element of a vector to zero. However, if you want a
vector of zeros, it is much faster to use this function than to create a
vector and then invoke <a class="link" href="igraph-Data-structures.html#igraph_vector_null" title="2.3.1. igraph_vector_null — Sets each element in the vector to zero."><code class="function">igraph_vector_null()</code></a>.

</p>
<p>
Every vector object initialized by this function should be
destroyed (ie. the memory allocated for it should be freed) when it
is not needed anymore, the <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a> function is
responsible for this.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to a not yet initialized vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>size</code></em>:</span></p></td>
<td><p>
  The size of the vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  error code:
      <code class="constant">IGRAPH_ENOMEM</code> if there is not enough memory.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: operating system dependent, the amount of
<span class="quote">“<span class="quote">time</span>”</span> required to allocate
O(n) elements,
n is the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_init_copy"></a>2.2.2. <code class="function">igraph_vector_init_copy</code> —  Initializes a vector from an ordinary C array (constructor).</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.3.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_init_copy(igraph_vector_t *v,
                                       const igraph_real_t *data, long int length);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>data</code></em>:</span></p></td>
<td><p>
  A regular C array.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>length</code></em>:</span></p></td>
<td><p>
  The length of the C array.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code> if there is not enough memory.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: operating system specific, usually
O(<em class="parameter"><code>length</code></em>).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_init_seq"></a>2.2.3. <code class="function">igraph_vector_init_seq</code> —  Initializes a vector with a sequence.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.3.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_init_seq(igraph_vector_t *v,
                                      igraph_real_t from, igraph_real_t to);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The vector will contain the numbers <em class="parameter"><code>from</code></em>,
<em class="parameter"><code>from</code></em>+1, ..., <em class="parameter"><code>to</code></em>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The lower limit in the sequence (inclusive).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The upper limit in the sequence (inclusive).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>: out of memory.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number
of elements in the vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_copy"></a>2.2.4. <code class="function">igraph_vector_copy</code> —  Initializes a vector from another vector object (constructor).</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.3.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_copy(igraph_vector_t *to,
                                  const igraph_vector_t *from);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The contents of the existing vector object will be copied to
the new one.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Pointer to a not yet initialized vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The original vector object to copy.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code> if there is not enough memory.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: operating system dependent, usually
O(n),
n is the size of the vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_destroy"></a>2.2.5. <code class="function">igraph_vector_destroy</code> —  Destroys a vector object.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.3.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_destroy(igraph_vector_t* v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
All vectors initialized by <a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor)."><code class="function">igraph_vector_init()</code></a> should be properly
destroyed by this function. A destroyed vector needs to be
reinitialized by <a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor)."><code class="function">igraph_vector_init()</code></a>, <a class="link" href="igraph-Data-structures.html#igraph_vector_init_copy" title="2.2.2. igraph_vector_init_copy — Initializes a vector from an ordinary C array (constructor)."><code class="function">igraph_vector_init_copy()</code></a> or
another constructor.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to the (previously initialized) vector object to
       destroy.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: operating system dependent.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="initializing-elements"></a>2.3. Initializing elements</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_null">2.3.1. <code class="function">igraph_vector_null</code> —  Sets each element in the vector to zero.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_fill">2.3.2. <code class="function">igraph_vector_fill</code> —  Fill a vector with a constant element</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_null"></a>2.3.1. <code class="function">igraph_vector_null</code> —  Sets each element in the vector to zero.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.4.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_null(igraph_vector_t* v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Note that <a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor)."><code class="function">igraph_vector_init()</code></a> sets the elements to zero as well, so
it makes no sense to call this function on a just initialized
vector. Thus if you want to construct a vector of zeros, then you should
use <a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor)."><code class="function">igraph_vector_init()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(n), the size of
the vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_fill"></a>2.3.2. <code class="function">igraph_vector_fill</code> —  Fill a vector with a constant element</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.4.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_fill(igraph_vector_t* v, igraph_real_t e);
</pre></div>
<p>
</p>
<p>



Sets each element of the vector to the supplied constant.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>vector</code></em>:</span></p></td>
<td><p>
  The vector to work on.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>e</code></em>:</span></p></td>
<td><p>
  The element to fill with.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(n), the size of the vector.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="vector-accessing-elements"></a>2.4.  Accessing elements</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#VECTOR">2.4.1. <code class="function">VECTOR</code> —  Accessing an element of a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_e">2.4.2. <code class="function">igraph_vector_e</code> —  Access an element of a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_e_ptr">2.4.3. <code class="function">igraph_vector_e_ptr</code> —  Get the address of an element of a vector</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_set">2.4.4. <code class="function">igraph_vector_set</code> —  Assignment to an element of a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_tail">2.4.5. <code class="function">igraph_vector_tail</code> —  Returns the last element in a vector.</a></span></dt>
</dl></div>
<p>The simplest way to access an element of a vector is to use the
<a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector."><code class="function">VECTOR</code></a> macro. This macro can be used both for querying and setting
<span class="type">igraph_vector_t</span> elements. If you need a function, <a class="link" href="igraph-Data-structures.html#igraph_vector_e" title="2.4.2. igraph_vector_e — Access an element of a vector."><code class="function">igraph_vector_e()</code></a> queries and <a class="link" href="igraph-Data-structures.html#igraph_vector_set" title="2.4.4. igraph_vector_set — Assignment to an element of a vector."><code class="function">igraph_vector_set()</code></a> sets an element of a
vector. <a class="link" href="igraph-Data-structures.html#igraph_vector_e_ptr" title="2.4.3. igraph_vector_e_ptr — Get the address of an element of a vector"><code class="function">igraph_vector_e_ptr()</code></a> returns the address of an element.</p>
<p><a class="link" href="igraph-Data-structures.html#igraph_vector_tail" title="2.4.5. igraph_vector_tail — Returns the last element in a vector."><code class="function">igraph_vector_tail()</code></a> returns the last element of a non-empty
vector. There is no <code class="function">igraph_vector_head()</code> function
however, as it is easy to write <code class="literal">VECTOR(v)[0]</code>
instead.</p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="VECTOR"></a>2.4.1. <code class="function">VECTOR</code> —  Accessing an element of a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.5.4.2"></a><p>
</p>
<pre class="programlisting">
#define VECTOR(v)
</pre>
<p>
</p>
<p>



Usage:
</p>
<div class="informalexample"><pre class="programlisting"> VECTOR(v)[0] </pre></div>
<p>
to access the first element of the vector, you can also use this in
assignments, like:
</p>
<div class="informalexample"><pre class="programlisting"> VECTOR(v)[10]=5; </pre></div>
<p>

Note that there are no range checks right now.
This functionality might be redefined later as a real function
instead of a <code class="literal">#define</code>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_e"></a>2.4.2. <code class="function">igraph_vector_e</code> —  Access an element of a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.5.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_vector_e(const igraph_vector_t* v, long int pos);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The <span class="type">igraph_vector_t</span> object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pos</code></em>:</span></p></td>
<td><p>
  The position of the element, the index of the first
   element is zero.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The desired element.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Data-structures.html#igraph_vector_e_ptr" title="2.4.3. igraph_vector_e_ptr — Get the address of an element of a vector"><code class="function">igraph_vector_e_ptr()</code></a> and the <a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector."><code class="function">VECTOR</code></a> macro.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_e_ptr"></a>2.4.3. <code class="function">igraph_vector_e_ptr</code> —  Get the address of an element of a vector</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.5.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t* igraph_vector_e_ptr(const igraph_vector_t* v, long int pos);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The <span class="type">igraph_vector_t</span> object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pos</code></em>:</span></p></td>
<td><p>
  The position of the element, the position of the first
  element is zero.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Pointer to the desired element.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Data-structures.html#igraph_vector_e" title="2.4.2. igraph_vector_e — Access an element of a vector."><code class="function">igraph_vector_e()</code></a> and the <a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector."><code class="function">VECTOR</code></a> macro.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_set"></a>2.4.4. <code class="function">igraph_vector_set</code> —  Assignment to an element of a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.5.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_set(igraph_vector_t* v,
        long int pos, igraph_real_t value);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The <span class="type">igraph_vector_t</span> element.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pos</code></em>:</span></p></td>
<td><p>
  Position of the element to set.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  New value of the element.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Data-structures.html#igraph_vector_e" title="2.4.2. igraph_vector_e — Access an element of a vector."><code class="function">igraph_vector_e()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_tail"></a>2.4.5. <code class="function">igraph_vector_tail</code> —  Returns the last element in a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.5.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_vector_tail(const igraph_vector_t *v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
It is an error to call this function on an empty vector, the result
is undefined.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The last element.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="vector-views"></a>2.5. Vector views</h3></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_view">2.5.1. <code class="function">igraph_vector_view</code> —  Handle a regular C array as a <span class="type">igraph_vector_t</span>.</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_view"></a>2.5.1. <code class="function">igraph_vector_view</code> —  Handle a regular C array as a <span class="type">igraph_vector_t</span>.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.6.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
const igraph_vector_t*igraph_vector_view(const igraph_vector_t *v,
        const igraph_real_t *data,
        long int length);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This is a special <span class="type">igraph_vector_t</span> constructor. It allows to
handle a regular C array as a <span class="type">igraph_vector_t</span> temporarily.
Be sure that you <span class="emphasis"><em>don't</em></span> ever call the destructor (<a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a>) on objects created by this constructor.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized <span class="type">igraph_vector_t</span> object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>data</code></em>:</span></p></td>
<td><p>
  Pointer, the C array. It may not be <code class="constant">NULL</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>length</code></em>:</span></p></td>
<td><p>
  The length of the C array.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Pointer to the vector object, the same as the
    <em class="parameter"><code>v</code></em> parameter, for convenience.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1)
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="copying-vectors"></a>2.6. Copying vectors</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_copy_to">2.6.1. <code class="function">igraph_vector_copy_to</code> —  Copies the contents of a vector to a C array.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_update">2.6.2. <code class="function">igraph_vector_update</code> —  Update a vector from another one.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_append">2.6.3. <code class="function">igraph_vector_append</code> —  Append a vector to another one.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_swap">2.6.4. <code class="function">igraph_vector_swap</code> —  Swap elements of two vectors.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_copy_to"></a>2.6.1. <code class="function">igraph_vector_copy_to</code> —  Copies the contents of a vector to a C array.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.7.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_copy_to(const igraph_vector_t *v, igraph_real_t *to);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The C array should have sufficient length.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The C array.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(n),
n is the size of the vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_update"></a>2.6.2. <code class="function">igraph_vector_update</code> —  Update a vector from another one.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.7.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_update(igraph_vector_t *to,
                                    const igraph_vector_t *from);
</pre></div>
<p>
</p>
<p>



After this operation the contents of <em class="parameter"><code>to</code></em> will be exactly the same
as that of <em class="parameter"><code>from</code></em>. The vector <em class="parameter"><code>to</code></em> will be resized if it was originally
shorter or longer than <em class="parameter"><code>from</code></em>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The vector to update.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The vector to update from.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements in <em class="parameter"><code>from</code></em>.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_append"></a>2.6.3. <code class="function">igraph_vector_append</code> —  Append a vector to another one.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.7.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_append(igraph_vector_t *to,
                                    const igraph_vector_t *from);
</pre></div>
<p>
</p>
<p>



The target vector will be resized (except when <em class="parameter"><code>from</code></em> is empty).
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The vector to append to.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The vector to append, it is kept unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements in the new vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_swap"></a>2.6.4. <code class="function">igraph_vector_swap</code> —  Swap elements of two vectors.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.7.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_swap(igraph_vector_t *v1, igraph_vector_t *v2);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v1</code></em>:</span></p></td>
<td><p>
  The first vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v2</code></em>:</span></p></td>
<td><p>
  The second vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="vector-exchanging-elements"></a>2.7. Exchanging elements</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_swap_elements">2.7.1. <code class="function">igraph_vector_swap_elements</code> —  Swap two elements in a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_reverse">2.7.2. <code class="function">igraph_vector_reverse</code> —  Reverse the elements of a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_shuffle">2.7.3. <code class="function">igraph_vector_shuffle</code> —  Shuffles a vector in-place using the Fisher-Yates method</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_swap_elements"></a>2.7.1. <code class="function">igraph_vector_swap_elements</code> —  Swap two elements in a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.8.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_swap_elements(igraph_vector_t *v,
        long int i, long int j);
</pre></div>
<p>
</p>
<p>



Note that currently no range checking is performed.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The input vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>i</code></em>:</span></p></td>
<td><p>
  Index of the first element.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>j</code></em>:</span></p></td>
<td><p>
  Index of the second element (may be the same as the
first one).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, currently always <code class="constant">IGRAPH_SUCCESS</code>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_reverse"></a>2.7.2. <code class="function">igraph_vector_reverse</code> —  Reverse the elements of a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.8.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_reverse(igraph_vector_t *v);
</pre></div>
<p>
</p>
<p>



The first element will be last, the last element will be
first, etc.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The input vector.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, currently always <code class="constant">IGRAPH_SUCCESS</code>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_shuffle"></a>2.7.3. <code class="function">igraph_vector_shuffle</code> —  Shuffles a vector in-place using the Fisher-Yates method</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.8.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_shuffle(igraph_vector_t *v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The Fisher-Yates shuffle ensures that every permutation is
equally probable when using a proper randomness source. Of course
this does not apply to pseudo-random generators as the cycle of
these generators is less than the number of possible permutations
of the vector if the vector is long enough.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, currently always <code class="constant">IGRAPH_SUCCESS</code>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n),
n is the number of elements in the
vector.

</p>
<p>
References:
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">(Fisher &amp; Yates 1963)</code></span></p></td>
<td><p>

  R. A. Fisher and F. Yates. <span class="emphasis"><em> Statistical Tables for Biological,
  Agricultural and Medical Research. </em></span> Oliver and Boyd, 6th edition,
  1963, page 37.

</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">(Knuth 1998)</code></span></p></td>
<td><p>

  D. E. Knuth. <span class="emphasis"><em> Seminumerical Algorithms, </em></span> volume 2 of <span class="emphasis"><em> The Art
  of Computer Programming. </em></span> Addison-Wesley, 3rd edition, 1998, page 145.

</p></td>
</tr>
</tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.3.8.4.10.2"></a><p class="title"><b>Example 7.1.  File <code class="code">examples/simple/igraph_fisher_yates_shuffle.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>  Test suite for the Fisher-Yates shuffle.</em></span>
<span class="emphasis"><em>  Copyright (C) 2011 Minh Van Nguyen </em></span>&lt;nguyenminh2@gmail.com&gt;

<span class="emphasis"><em>  This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>  it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>  the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>  (at your option) any later version.</em></span>

<span class="emphasis"><em>  This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>  but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>  GNU General Public License for more details.</em></span>

<span class="emphasis"><em>  You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>  along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>  Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>  02110-1301 USA</em></span>
<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>R_INTEGER</strong></span>(a,b) (<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_get_integer" title="4.1. igraph_rng_get_integer — Generate an integer random number from an interval.">igraph_rng_get_integer</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), (a), (b)))
<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>R_UNIF</strong></span>(a,b) (<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_get_unif" title="4.2. igraph_rng_get_unif — Generate real, uniform random numbers from an interval.">igraph_rng_get_unif</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), (a), (b)))

int <span class="strong"><strong>main</strong></span>() {
    igraph_real_t d;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> u, v;
    int ret;
    long int i, k, n;

    <span class="emphasis"><em>/********************************</em></span>
<span class="emphasis"><em>     * Example usage</em></span>
<span class="emphasis"><em>     ********************************/</em></span>

    <span class="emphasis"><em>/* Sequences with one element. Such sequences are trivially permuted.</em></span>
<span class="emphasis"><em>     * The result of any Fisher-Yates shuffle on a sequence with one element</em></span>
<span class="emphasis"><em>     * must be the original sequence itself.</em></span>
<span class="emphasis"><em>     */</em></span>
    n = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v, n);
    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42); <span class="emphasis"><em>/* make tests deterministic */</em></span>
    k = <span class="strong"><strong>R_INTEGER</strong></span>(-1000, 1000);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[0] = k;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_shuffle" title="2.7.3. igraph_vector_shuffle — Shuffles a vector in-place using the Fisher-Yates method">igraph_vector_shuffle</a></strong></span>(&amp;v);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[0] != k) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    d = <span class="strong"><strong>R_UNIF</strong></span>(-1000.0, 1000.0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[0] = d;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_shuffle" title="2.7.3. igraph_vector_shuffle — Shuffles a vector in-place using the Fisher-Yates method">igraph_vector_shuffle</a></strong></span>(&amp;v);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[0] != d) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v);

    <span class="emphasis"><em>/* Sequences with multiple elements. A Fisher-Yates shuffle of a sequence S</em></span>
<span class="emphasis"><em>     * is a random permutation \pi(S) of S. Thus \pi(S) must have the same</em></span>
<span class="emphasis"><em>     * length and elements as the original sequence S. A major difference between</em></span>
<span class="emphasis"><em>     * S and its random permutation \pi(S) is that the order in which elements</em></span>
<span class="emphasis"><em>     * appear in \pi(S) is probably different from how elements are ordered in S.</em></span>
<span class="emphasis"><em>     * If S has length n = 1, then both \pi(S) and S are equivalent sequences in</em></span>
<span class="emphasis"><em>     * that \pi(S) is merely S and no permutation has taken place. If S has</em></span>
<span class="emphasis"><em>     * length n &gt; 1, then there are n! possible permutations of S. Assume that</em></span>
<span class="emphasis"><em>     * each such permutation is equally likely to appear as a result of the</em></span>
<span class="emphasis"><em>     * Fisher-Yates shuffle. As n increases, the probability that S is different</em></span>
<span class="emphasis"><em>     * from \pi(S) also increases. We have a probability of 1 / n! that S and</em></span>
<span class="emphasis"><em>     * \pi(S) are equivalent sequences.</em></span>
<span class="emphasis"><em>     */</em></span>
    n = 100;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;u, n);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v, n);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        k = <span class="strong"><strong>R_INTEGER</strong></span>(-1000, 1000);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(u)[i] = k;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[i] = k;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_shuffle" title="2.7.3. igraph_vector_shuffle — Shuffles a vector in-place using the Fisher-Yates method">igraph_vector_shuffle</a></strong></span>(&amp;v);
    <span class="emphasis"><em>/* must have same length */</em></span>
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;v) != n) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;u) != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;v)) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="emphasis"><em>/* must have same elements */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_sort" title="2.14.1. igraph_vector_sort — Sorts the elements of the vector into ascending order.">igraph_vector_sort</a></strong></span>(&amp;u);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_sort" title="2.14.1. igraph_vector_sort — Sorts the elements of the vector into ascending order.">igraph_vector_sort</a></strong></span>(&amp;v);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_all_e" title="2.9.1. igraph_vector_all_e — Are all elements equal?">igraph_vector_all_e</a></strong></span>(&amp;u, &amp;v)) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;u);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v);

    <span class="emphasis"><em>/* empty sequence */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;v, 0);
    ret = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_shuffle" title="2.7.3. igraph_vector_shuffle — Shuffles a vector in-place using the Fisher-Yates method">igraph_vector_shuffle</a></strong></span>(&amp;v);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;v);

    <span class="strong"><strong>return</strong></span> ret == 0 ? 0 : 6;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="vector-operations"></a>2.8. Vector operations</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_add_constant">2.8.1. <code class="function">igraph_vector_add_constant</code> —  Add a constant to the vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_scale">2.8.2. <code class="function">igraph_vector_scale</code> —  Multiply all elements of a vector by a constant</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_add">2.8.3. <code class="function">igraph_vector_add</code> —  Add two vectors.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_sub">2.8.4. <code class="function">igraph_vector_sub</code> —  Subtract a vector from another one.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_mul">2.8.5. <code class="function">igraph_vector_mul</code> —  Multiply two vectors.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_div">2.8.6. <code class="function">igraph_vector_div</code> —  Divide a vector by another one.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_floor">2.8.7. <code class="function">igraph_vector_floor</code> —  Transform a real vector to a long vector by flooring each element.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_add_constant"></a>2.8.1. <code class="function">igraph_vector_add_constant</code> —  Add a constant to the vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.9.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_add_constant(igraph_vector_t *v, igraph_real_t plus);
</pre></div>
<p>
</p>
<p>



<em class="parameter"><code>plus</code></em> is added to every element of <em class="parameter"><code>v</code></em>. Note that overflow
might happen.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The input vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>plus</code></em>:</span></p></td>
<td><p>
  The constant to add.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(n), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_scale"></a>2.8.2. <code class="function">igraph_vector_scale</code> —  Multiply all elements of a vector by a constant</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.9.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_scale(igraph_vector_t *v, igraph_real_t by);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>by</code></em>:</span></p></td>
<td><p>
  The constant.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code. The current implementation always returns with success.
  </p></td>
</tr></tbody>
</table></div>
<p>

Added in version 0.2.</p>
<p>

Time complexity: O(n), the number of elements in a vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_add"></a>2.8.3. <code class="function">igraph_vector_add</code> —  Add two vectors.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.9.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_add(igraph_vector_t *v1,
                                 const igraph_vector_t *v2);
</pre></div>
<p>
</p>
<p>



Add the elements of <em class="parameter"><code>v2</code></em> to <em class="parameter"><code>v1</code></em>, the result is stored in <em class="parameter"><code>v1</code></em>. The two vectors must have the same length.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v1</code></em>:</span></p></td>
<td><p>
  The first vector, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v2</code></em>:</span></p></td>
<td><p>
  The second vector, its contents will be unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_sub"></a>2.8.4. <code class="function">igraph_vector_sub</code> —  Subtract a vector from another one.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.9.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_sub(igraph_vector_t *v1,
                                 const igraph_vector_t *v2);
</pre></div>
<p>
</p>
<p>



Subtract the elements of <em class="parameter"><code>v2</code></em> from <em class="parameter"><code>v1</code></em>, the result is stored in
<em class="parameter"><code>v1</code></em>. The two vectors must have the same length.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v1</code></em>:</span></p></td>
<td><p>
  The first vector, to subtract from. The result is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v2</code></em>:</span></p></td>
<td><p>
  The vector to subtract, it will be unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the length of the vectors.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_mul"></a>2.8.5. <code class="function">igraph_vector_mul</code> —  Multiply two vectors.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.9.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_mul(igraph_vector_t *v1,
                                 const igraph_vector_t *v2);
</pre></div>
<p>
</p>
<p>



<em class="parameter"><code>v1</code></em> will be multiplied by <em class="parameter"><code>v2</code></em>, elementwise. The two vectors
must have the same length.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v1</code></em>:</span></p></td>
<td><p>
  The first vector, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v2</code></em>:</span></p></td>
<td><p>
  The second vector, it is left unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_div"></a>2.8.6. <code class="function">igraph_vector_div</code> —  Divide a vector by another one.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.9.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_div(igraph_vector_t *v1,
                                 const igraph_vector_t *v2);
</pre></div>
<p>
</p>
<p>



<em class="parameter"><code>v1</code></em> is divided by <em class="parameter"><code>v2</code></em>, elementwise. They must have the same length. If the
base type of the vector can generate divide by zero errors then
please make sure that <em class="parameter"><code>v2</code></em> contains no zero if you want to avoid
trouble.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v1</code></em>:</span></p></td>
<td><p>
  The dividend. The result is also stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v2</code></em>:</span></p></td>
<td><p>
  The divisor, it is left unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the length of the vectors.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_floor"></a>2.8.7. <code class="function">igraph_vector_floor</code> —  Transform a real vector to a long vector by flooring each element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.9.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_floor(const igraph_vector_t *from, igraph_vector_long_t *to);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Flooring means rounding down to the nearest integer.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The original real vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized long vector. The result will
          be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>: out of memory
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), where n is the number of elements in the vector.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="vector-comparisons"></a>2.9. Vector comparisons</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_all_e">2.9.1. <code class="function">igraph_vector_all_e</code> —  Are all elements equal?</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_all_l">2.9.2. <code class="function">igraph_vector_all_l</code> —  Are all elements less?</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_all_g">2.9.3. <code class="function">igraph_vector_all_g</code> —  Are all elements greater?</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_all_le">2.9.4. <code class="function">igraph_vector_all_le</code> —  Are all elements less or equal?</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_all_ge">2.9.5. <code class="function">igraph_vector_all_ge</code> —  Are all elements greater or equal?</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_lex_cmp">2.9.6. <code class="function">igraph_vector_lex_cmp</code> —  Lexicographical comparison of two vectors.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_colex_cmp">2.9.7. <code class="function">igraph_vector_colex_cmp</code> —  Colexicographical comparison of two vectors.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_all_e"></a>2.9.1. <code class="function">igraph_vector_all_e</code> —  Are all elements equal?</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.10.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_vector_all_e(const igraph_vector_t *lhs,
        const igraph_vector_t *rhs);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>lhs</code></em>:</span></p></td>
<td><p>
  The first vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rhs</code></em>:</span></p></td>
<td><p>
  The second vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (=true) if the elements in the <em class="parameter"><code>lhs</code></em> are all
   equal to the corresponding elements in <em class="parameter"><code>rhs</code></em>. Returns <code class="constant">0</code>
   (=false) if the lengths of the vectors don't match.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the length of the vectors.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_all_l"></a>2.9.2. <code class="function">igraph_vector_all_l</code> —  Are all elements less?</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.10.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_vector_all_l(const igraph_vector_t *lhs,
        const igraph_vector_t *rhs);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>lhs</code></em>:</span></p></td>
<td><p>
  The first vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rhs</code></em>:</span></p></td>
<td><p>
  The second vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (=true) if the elements in the <em class="parameter"><code>lhs</code></em> are all
   less than the corresponding elements in <em class="parameter"><code>rhs</code></em>. Returns <code class="constant">0</code>
   (=false) if the lengths of the vectors don't match. If any element
   is NaN, it will return <code class="constant">0</code> (=false).
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the length of the vectors.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_all_g"></a>2.9.3. <code class="function">igraph_vector_all_g</code> —  Are all elements greater?</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.10.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_vector_all_g(const igraph_vector_t *lhs,
        const igraph_vector_t *rhs);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>lhs</code></em>:</span></p></td>
<td><p>
  The first vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rhs</code></em>:</span></p></td>
<td><p>
  The second vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (=true) if the elements in the <em class="parameter"><code>lhs</code></em> are all
   greater than the corresponding elements in <em class="parameter"><code>rhs</code></em>. Returns <code class="constant">0</code>
   (=false) if the lengths of the vectors don't match. If any element
   is NaN, it will return <code class="constant">0</code> (=false).
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the length of the vectors.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_all_le"></a>2.9.4. <code class="function">igraph_vector_all_le</code> —  Are all elements less or equal?</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.10.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t
igraph_vector_all_le(const igraph_vector_t *lhs,
                                const igraph_vector_t *rhs);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>lhs</code></em>:</span></p></td>
<td><p>
  The first vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rhs</code></em>:</span></p></td>
<td><p>
  The second vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (=true) if the elements in the <em class="parameter"><code>lhs</code></em> are all
   less than or equal to the corresponding elements in <em class="parameter"><code>rhs</code></em>. Returns <code class="constant">0</code> (=false) if the lengths of the vectors don't
   match. If any element is NaN, it will return <code class="constant">0</code> (=false).
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the length of the vectors.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_all_ge"></a>2.9.5. <code class="function">igraph_vector_all_ge</code> —  Are all elements greater or equal?</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.10.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t
igraph_vector_all_ge(const igraph_vector_t *lhs,
                                const igraph_vector_t *rhs);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>lhs</code></em>:</span></p></td>
<td><p>
  The first vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rhs</code></em>:</span></p></td>
<td><p>
  The second vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (=true) if the elements in the <em class="parameter"><code>lhs</code></em> are all
   greater than or equal to the corresponding elements in <em class="parameter"><code>rhs</code></em>. Returns <code class="constant">0</code> (=false) if the lengths of the vectors don't
   match.  If any element is NaN, it will return <code class="constant">0</code> (=false).
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the length of the vectors.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_lex_cmp"></a>2.9.6. <code class="function">igraph_vector_lex_cmp</code> —  Lexicographical comparison of two vectors.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.10.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_lex_cmp(const void *lhs, const void *rhs);
</pre></div>
<p>
</p>
<p>



</p>
<p>
If the elements of two vectors match but one is shorter, the shorter
one comes first. Thus {1, 3} comes after {1, 2, 3}, but before {1, 3, 4}.

</p>
<p>
This function is typically used together with <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_sort" title="2.16.13. igraph_vector_ptr_sort — Sorts the pointer vector based on an external comparison function."><code class="function">igraph_vector_ptr_sort()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>lhs</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer to the first vector (interpreted as an <code class="literal">igraph_vector_t **</code>).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rhs</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer to the second vector (interpreted as an <code class="literal">igraph_vector_t **</code>).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  -1 if <em class="parameter"><code>lhs</code></em> is lexicographically smaller,
        0 if <em class="parameter"><code>lhs</code></em> and <em class="parameter"><code>rhs</code></em> are equal, else 1.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Data-structures.html#igraph_vector_colex_cmp" title="2.9.7. igraph_vector_colex_cmp — Colexicographical comparison of two vectors."><code class="function">igraph_vector_colex_cmp()</code></a> to compare vectors starting from
    the last element.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements in the smaller vector.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.3.10.7.12.1"></a><p class="title"><b>Example 7.2.  File <code class="code">examples/simple/igraph_vector_ptr_sort.c</code></b></p>
<div class="example-contents">
<pre class="programlisting">
<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    igraph_vector_ptr_t <a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>;
    long int i, n;

    <span class="emphasis"><em>/* Set a random seed to make the program deterministic */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 31415);

    <span class="emphasis"><em>/* Create a random graph with a given number of vertices and edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game" title="2.3. igraph_erdos_renyi_game — Generates a random (Erdős-Rényi) graph.">igraph_erdos_renyi_game</a></strong></span>(&amp;graph, IGRAPH_ERDOS_RENYI_GNM, 15, 80, IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS);

    <span class="emphasis"><em>/* Find all maximal cliques in the graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, 0);
    <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_maximal_cliques" title="1.6. igraph_maximal_cliques — Finds all maximal cliques in a graph.">igraph_maximal_cliques</a></strong></span>(&amp;graph, &amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, -1, -1);

    <span class="emphasis"><em>/* Print the cliques in lexicographical order */</em></span>
    <span class="strong"><strong>printf</strong></span>("Maximal <a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a> in lexicographical order:\n");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_sort" title="2.16.13. igraph_vector_ptr_sort — Sorts the pointer vector based on an external comparison function.">igraph_vector_ptr_sort</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, <a class="link" href="igraph-Data-structures.html#igraph_vector_lex_cmp" title="2.9.6. igraph_vector_lex_cmp — Lexicographical comparison of two vectors.">igraph_vector_lex_cmp</a>);
    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>);
    <span class="strong"><strong>for</strong></span> (i=0; i &lt; n; ++i) {
        <span class="strong"><strong>igraph_vector_print</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>)[i]);
    }

    <span class="emphasis"><em>/* Print the cliques in colexicographical order */</em></span>
    <span class="strong"><strong>printf</strong></span>("\nMaximal <a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a> in colexicographical order:\n");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_sort" title="2.16.13. igraph_vector_ptr_sort — Sorts the pointer vector based on an external comparison function.">igraph_vector_ptr_sort</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, <a class="link" href="igraph-Data-structures.html#igraph_vector_colex_cmp" title="2.9.7. igraph_vector_colex_cmp — Colexicographical comparison of two vectors.">igraph_vector_colex_cmp</a>);
    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>);
    <span class="strong"><strong>for</strong></span> (i=0; i &lt; n; ++i) {
        <span class="strong"><strong>igraph_vector_print</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>)[i]);
    }

    <span class="emphasis"><em>/* Destroy data structures when we no longer need them */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR" title="2.16.16. IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR — Sets the item destructor for this pointer vector (macro version).">IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a>);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy_all" title="2.16.5. igraph_vector_ptr_destroy_all — Frees all the elements and destroys the pointer vector.">igraph_vector_ptr_destroy_all</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_colex_cmp"></a>2.9.7. <code class="function">igraph_vector_colex_cmp</code> —  Colexicographical comparison of two vectors.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.10.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_colex_cmp(const void *lhs, const void *rhs);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This comparison starts from the last element of both vectors and
moves backward. If the elements of two vectors match but one is
shorter, the shorter one comes first. Thus {1, 2} comes after {3, 2, 1},
but before {0, 1, 2}.

</p>
<p>
This function is typically used together with <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_sort" title="2.16.13. igraph_vector_ptr_sort — Sorts the pointer vector based on an external comparison function."><code class="function">igraph_vector_ptr_sort()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>lhs</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer to the first vector (interpreted as an <code class="literal">igraph_vector_t **</code>).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rhs</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer to the second vector (interpreted as an <code class="literal">igraph_vector_t **</code>).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  -1 if <em class="parameter"><code>lhs</code></em> in reverse order is
        lexicographically smaller than the reverse of <em class="parameter"><code>rhs</code></em>,
        0 if <em class="parameter"><code>lhs</code></em> and <em class="parameter"><code>rhs</code></em> are equal, else 1.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Data-structures.html#igraph_vector_lex_cmp" title="2.9.6. igraph_vector_lex_cmp — Lexicographical comparison of two vectors."><code class="function">igraph_vector_lex_cmp()</code></a> to compare vectors starting from
    the first element.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements in the smaller vector.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.3.10.8.12.1"></a><p class="title"><b>Example 7.3.  File <code class="code">examples/simple/igraph_vector_ptr_sort.c</code></b></p>
<div class="example-contents">
<pre class="programlisting">
<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    igraph_vector_ptr_t <a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>;
    long int i, n;

    <span class="emphasis"><em>/* Set a random seed to make the program deterministic */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 31415);

    <span class="emphasis"><em>/* Create a random graph with a given number of vertices and edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game" title="2.3. igraph_erdos_renyi_game — Generates a random (Erdős-Rényi) graph.">igraph_erdos_renyi_game</a></strong></span>(&amp;graph, IGRAPH_ERDOS_RENYI_GNM, 15, 80, IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS);

    <span class="emphasis"><em>/* Find all maximal cliques in the graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, 0);
    <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_maximal_cliques" title="1.6. igraph_maximal_cliques — Finds all maximal cliques in a graph.">igraph_maximal_cliques</a></strong></span>(&amp;graph, &amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, -1, -1);

    <span class="emphasis"><em>/* Print the cliques in lexicographical order */</em></span>
    <span class="strong"><strong>printf</strong></span>("Maximal <a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a> in lexicographical order:\n");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_sort" title="2.16.13. igraph_vector_ptr_sort — Sorts the pointer vector based on an external comparison function.">igraph_vector_ptr_sort</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, <a class="link" href="igraph-Data-structures.html#igraph_vector_lex_cmp" title="2.9.6. igraph_vector_lex_cmp — Lexicographical comparison of two vectors.">igraph_vector_lex_cmp</a>);
    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>);
    <span class="strong"><strong>for</strong></span> (i=0; i &lt; n; ++i) {
        <span class="strong"><strong>igraph_vector_print</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>)[i]);
    }

    <span class="emphasis"><em>/* Print the cliques in colexicographical order */</em></span>
    <span class="strong"><strong>printf</strong></span>("\nMaximal <a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a> in colexicographical order:\n");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_sort" title="2.16.13. igraph_vector_ptr_sort — Sorts the pointer vector based on an external comparison function.">igraph_vector_ptr_sort</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, <a class="link" href="igraph-Data-structures.html#igraph_vector_colex_cmp" title="2.9.7. igraph_vector_colex_cmp — Colexicographical comparison of two vectors.">igraph_vector_colex_cmp</a>);
    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>);
    <span class="strong"><strong>for</strong></span> (i=0; i &lt; n; ++i) {
        <span class="strong"><strong>igraph_vector_print</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>)[i]);
    }

    <span class="emphasis"><em>/* Destroy data structures when we no longer need them */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR" title="2.16.16. IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR — Sets the item destructor for this pointer vector (macro version).">IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a>);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy_all" title="2.16.5. igraph_vector_ptr_destroy_all — Frees all the elements and destroys the pointer vector.">igraph_vector_ptr_destroy_all</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="vector-finding-minimum-and-maximum"></a>2.10. Finding minimum and maximum</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_min">2.10.1. <code class="function">igraph_vector_min</code> —  Smallest element of a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_max">2.10.2. <code class="function">igraph_vector_max</code> —  Largest element of a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_which_min">2.10.3. <code class="function">igraph_vector_which_min</code> —  Index of the smallest element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_which_max">2.10.4. <code class="function">igraph_vector_which_max</code> —  Gives the index of the maximum element of the vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_minmax">2.10.5. <code class="function">igraph_vector_minmax</code> —  Minimum and maximum elements of a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_which_minmax">2.10.6. <code class="function">igraph_vector_which_minmax</code> —  Index of the minimum and maximum elements</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_min"></a>2.10.1. <code class="function">igraph_vector_min</code> —  Smallest element of a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.11.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_vector_min(const igraph_vector_t* v);
</pre></div>
<p>
</p>
<p>




The vector must be non-empty.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The input vector.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The smallest element of <em class="parameter"><code>v</code></em>, or NaN if any element is NaN.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_max"></a>2.10.2. <code class="function">igraph_vector_max</code> —  Largest element of a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.11.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_vector_max(const igraph_vector_t* v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If the size of the vector is zero, an arbitrary number is
returned.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The maximum element of <em class="parameter"><code>v</code></em>, or NaN if any element is NaN.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_which_min"></a>2.10.3. <code class="function">igraph_vector_which_min</code> —  Index of the smallest element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.11.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_vector_which_min(const igraph_vector_t* v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The vector must be non-empty. If the smallest element is not unique,
then the index of the first is returned. If the vector contains NaN
values, the index of the first NaN value is returned.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The input vector.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Index of the smallest element.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_which_max"></a>2.10.4. <code class="function">igraph_vector_which_max</code> —  Gives the index of the maximum element of the vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.11.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_vector_which_max(const igraph_vector_t* v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If the size of the vector is zero, -1 is returned. If the largest
element is not unique, then the index of the first is returned.
If the vector contains NaN values, the index of the first NaN value
is returned.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The index of the first maximum element.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), n is the size of the vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_minmax"></a>2.10.5. <code class="function">igraph_vector_minmax</code> —  Minimum and maximum elements of a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.11.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_minmax(const igraph_vector_t *v,
                                    igraph_real_t *min, igraph_real_t *max);
</pre></div>
<p>
</p>
<p>



Handy if you want to have both the smallest and largest element of
a vector. The vector is only traversed once. The vector must be non-empty.
If a vector contains at least one NaN, both <code class="constant">min</code> and <code class="constant">max</code> will be NaN.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The input vector. It must contain at least one element.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>min</code></em>:</span></p></td>
<td><p>
  Pointer to a base type variable, the minimum is stored
    here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>max</code></em>:</span></p></td>
<td><p>
  Pointer to a base type variable, the maximum is stored
    here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_which_minmax"></a>2.10.6. <code class="function">igraph_vector_which_minmax</code> —  Index of the minimum and maximum elements</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.11.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_which_minmax(const igraph_vector_t *v,
        long int *which_min, long int *which_max);
</pre></div>
<p>
</p>
<p>



</p>
<p>
Handy if you need the indices of the smallest and largest
elements. The vector is traversed only once. The vector must be
non-empty. If the minimum or maximum is not unique, the index
of the first minimum or the first maximum is returned, respectively.
If a vector contains at least one NaN, both <code class="constant">which_min</code> and <code class="constant">which_max</code>
will point to the first NaN value.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The input vector. It must contain at least one element.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>which_min</code></em>:</span></p></td>
<td><p>
  The index of the minimum element will be stored
  here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>which_max</code></em>:</span></p></td>
<td><p>
  The index of the maximum element will be stored
  here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="vector-properties"></a>2.11. Vector properties</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_empty">2.11.1. <code class="function">igraph_vector_empty</code> —  Decides whether the size of the vector is zero.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_size">2.11.2. <code class="function">igraph_vector_size</code> —  Returns the size (=length) of the vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_capacity">2.11.3. <code class="function">igraph_vector_capacity</code> —  Returns the allocated capacity of the vector</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_sum">2.11.4. <code class="function">igraph_vector_sum</code> —  Calculates the sum of the elements in the vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_prod">2.11.5. <code class="function">igraph_vector_prod</code> —  Calculates the product of the elements in the vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_isininterval">2.11.6. <code class="function">igraph_vector_isininterval</code> —  Checks if all elements of a vector are in the given</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_maxdifference">2.11.7. <code class="function">igraph_vector_maxdifference</code> —  The maximum absolute difference of <em class="parameter"><code>m1</code></em> and <em class="parameter"><code>m2</code></em></a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_order">2.11.8. <code class="function">igraph_vector_order</code> —  Calculate the order of the elements in a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_is_nan">2.11.9. <code class="function">igraph_vector_is_nan</code> —  Check for each element if it is NaN.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_is_any_nan">2.11.10. <code class="function">igraph_vector_is_any_nan</code> —  Check if any element is NaN.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_empty"></a>2.11.1. <code class="function">igraph_vector_empty</code> —  Decides whether the size of the vector is zero.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.12.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_vector_empty(const igraph_vector_t* v);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Non-zero number (true) if the size of the vector is zero and
        zero (false) otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_size"></a>2.11.2. <code class="function">igraph_vector_size</code> —  Returns the size (=length) of the vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.12.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_vector_size(const igraph_vector_t* v);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The size of the vector.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_capacity"></a>2.11.3. <code class="function">igraph_vector_capacity</code> —  Returns the allocated capacity of the vector</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.12.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_vector_capacity(const igraph_vector_t*v);
</pre></div>
<p>
</p>
<p>




Note that this might be different from the size of the vector (as
queried by <a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector."><code class="function">igraph_vector_size()</code></a>, and specifies how many elements
the vector can hold, without reallocation.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to the (previously initialized) vector object
         to query.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The allocated capacity.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector."><code class="function">igraph_vector_size()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_sum"></a>2.11.4. <code class="function">igraph_vector_sum</code> —  Calculates the sum of the elements in the vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.12.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_vector_sum(const igraph_vector_t *v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
For the empty vector 0.0 is returned.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The sum of the elements.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the size of
the vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_prod"></a>2.11.5. <code class="function">igraph_vector_prod</code> —  Calculates the product of the elements in the vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.12.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_vector_prod(const igraph_vector_t *v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
For the empty vector one (1) is returned.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The product of the elements.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the size of
the vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_isininterval"></a>2.11.6. <code class="function">igraph_vector_isininterval</code> —  Checks if all elements of a vector are in the given</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.12.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_vector_isininterval(const igraph_vector_t *v,
        igraph_real_t low,
        igraph_real_t high);
</pre></div>
<p>
</p>
<p>



interval.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>low</code></em>:</span></p></td>
<td><p>
  The lower limit of the interval (inclusive).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>high</code></em>:</span></p></td>
<td><p>
  The higher limit of the interval (inclusive).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  True (positive integer) if all vector elements are in the
  interval, false (zero) otherwise. If any element is NaN, it will
  return <code class="constant">0</code> (=false).
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number
of elements in the vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_maxdifference"></a>2.11.7. <code class="function">igraph_vector_maxdifference</code> —  The maximum absolute difference of <em class="parameter"><code>m1</code></em> and <em class="parameter"><code>m2</code></em>
</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.12.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_vector_maxdifference(const igraph_vector_t *m1,
        const igraph_vector_t *m2);
</pre></div>
<p>
</p>
<p>



The element with the largest absolute value in <em class="parameter"><code>m1</code></em> - <em class="parameter"><code>m2</code></em> is
returned. Both vectors must be non-empty, but they not need to have
the same length, the extra elements in the longer vector are ignored. If
any value is NaN in the shorter vector, the result will be NaN.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m1</code></em>:</span></p></td>
<td><p>
  The first vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m2</code></em>:</span></p></td>
<td><p>
  The second vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The maximum absolute difference of <em class="parameter"><code>m1</code></em> and <em class="parameter"><code>m2</code></em>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements in the shorter
vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_order"></a>2.11.8. <code class="function">igraph_vector_order</code> —  Calculate the order of the elements in a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.12.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_order(const igraph_vector_t* v,
                        const igraph_vector_t *v2,
                        igraph_vector_t* res, igraph_real_t nodes);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The smallest element will have order zero, the second smallest
order one, etc.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The original <span class="type">igraph_vector_t</span> object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v2</code></em>:</span></p></td>
<td><p>
  A secondary key, another <span class="type">igraph_vector_t</span> object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized <span class="type">igraph_vector_t</span> object, it will be
   resized to match the size of <em class="parameter"><code>v</code></em>. The
   result of the computation will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  Hint, the largest element in <em class="parameter"><code>v</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>: out of memory
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O()
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_is_nan"></a>2.11.9. <code class="function">igraph_vector_is_nan</code> —  Check for each element if it is NaN.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.12.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_is_nan(const igraph_vector_t *v, igraph_vector_bool_t *is_nan);
</pre></div>
<p>
</p>
<p>




</p>
<p>
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The <span class="type">igraph_vector_t</span> object to check.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>is_nan</code></em>:</span></p></td>
<td><p>
  The resulting boolean vector indicating for each element
              whether it is NaN or not.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code,
        <code class="constant">IGRAPH_ENOMEM</code> if there is not enough
        memory. Note that this function <span class="emphasis"><em>never</em></span> returns an error
        if the vector <em class="parameter"><code>is_nan</code></em> will already be large enough.
Time complexity: O(n), the number of elements.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_is_any_nan"></a>2.11.10. <code class="function">igraph_vector_is_any_nan</code> —  Check if any element is NaN.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.12.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_vector_is_any_nan(const igraph_vector_t *v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The <span class="type">igraph_vector_t</span> object to check.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  1 if any element is NaN, 0 otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="vector-searching-for-elements"></a>2.12. Searching for elements</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_contains">2.12.1. <code class="function">igraph_vector_contains</code> —  Linear search in a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_search">2.12.2. <code class="function">igraph_vector_search</code> —  Search from a given position</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_binsearch">2.12.3. <code class="function">igraph_vector_binsearch</code> —  Finds an element by binary searching a sorted vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_binsearch_slice">2.12.4. <code class="function">igraph_vector_binsearch_slice</code> —  Finds an element by binary searching a sorted slice of a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_binsearch2">2.12.5. <code class="function">igraph_vector_binsearch2</code> —  Binary search, without returning the index.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_contains"></a>2.12.1. <code class="function">igraph_vector_contains</code> —  Linear search in a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.13.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_vector_contains(const igraph_vector_t *v,
        igraph_real_t e);
</pre></div>
<p>
</p>
<p>



Check whether the supplied element is included in the vector, by
linear search.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The input vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>e</code></em>:</span></p></td>
<td><p>
  The element to look for.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <code class="constant">TRUE</code> if the element is found and <code class="constant">FALSE</code> otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the length of the vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_search"></a>2.12.2. <code class="function">igraph_vector_search</code> —  Search from a given position</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.13.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_vector_search(const igraph_vector_t *v,
        long int from, igraph_real_t what,
        long int *pos);
</pre></div>
<p>
</p>
<p>



The supplied element <em class="parameter"><code>what</code></em> is searched in vector <em class="parameter"><code>v</code></em>, starting
from element index <em class="parameter"><code>from</code></em>. If found then the index of the first
instance (after <em class="parameter"><code>from</code></em>) is stored in <em class="parameter"><code>pos</code></em>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The input vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The index to start searching from. No range checking is
    performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>what</code></em>:</span></p></td>
<td><p>
  The element to find.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pos</code></em>:</span></p></td>
<td><p>
  If not <code class="constant">NULL</code> then the index of the found element is
   stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Boolean, <code class="constant">TRUE</code> if the element was found, <code class="constant">FALSE</code>
  otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(m), the number of elements to search, the length
of the vector minus the <em class="parameter"><code>from</code></em> argument.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_binsearch"></a>2.12.3. <code class="function">igraph_vector_binsearch</code> —  Finds an element by binary searching a sorted vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.13.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_vector_binsearch(const igraph_vector_t *v,
        igraph_real_t what, long int *pos);
</pre></div>
<p>
</p>
<p>




</p>
<p>
It is assumed that the vector is sorted. If the specified element
(<em class="parameter"><code>what</code></em>) is not in the vector, then the
position of where it should be inserted (to keep the vector sorted)
is returned. If the vector contains any NaN values, the returned
value is undefined and <em class="parameter"><code>pos</code></em> may point to any position.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The <span class="type">igraph_vector_t</span> object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>what</code></em>:</span></p></td>
<td><p>
  The element to search for.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pos</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long</span> int. This is set to the
  position of an instance of <em class="parameter"><code>what</code></em> in the
  vector if it is present. If <em class="parameter"><code>v</code></em> does not
  contain <em class="parameter"><code>what</code></em> then
  <em class="parameter"><code>pos</code></em> is set to the position to which it
  should be inserted (to keep the the vector sorted of course).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (true) if <em class="parameter"><code>what</code></em> is
  found in the vector, zero (false) otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(log(n)),
n is the number of elements in
<em class="parameter"><code>v</code></em>.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_binsearch_slice"></a>2.12.4. <code class="function">igraph_vector_binsearch_slice</code> —  Finds an element by binary searching a sorted slice of a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.13.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_vector_binsearch_slice(const igraph_vector_t *v,
        igraph_real_t what, long int *pos,
        long int start, long int end);
</pre></div>
<p>
</p>
<p>




</p>
<p>
It is assumed that the indicated slice of the vector, from <em class="parameter"><code>start</code></em> to <em class="parameter"><code>end</code></em>,
is sorted. If the specified element (<em class="parameter"><code>what</code></em>) is not in the slice of the
vector, then the position of where it should be inserted (to keep the <span class="emphasis"><em>slice</em></span>
sorted) is returned. Note that this means that the returned index will point
<span class="emphasis"><em>inside</em></span> the slice (including its endpoints), but will not evaluate values
<span class="emphasis"><em>outside</em></span> the slice. If the indicated slice contains any NaN values, the
returned value is undefined and <code class="constant">pos</code> may point to any position within
the slice.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The <span class="type">igraph_vector_t</span> object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>what</code></em>:</span></p></td>
<td><p>
  The element to search for.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pos</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long</span> int. This is set to the position of an
       instance of <em class="parameter"><code>what</code></em> in the slice of the vector if it is present. If <em class="parameter"><code>v</code></em> does not contain <em class="parameter"><code>what</code></em> then <em class="parameter"><code>pos</code></em> is set to the position to which
       it should be inserted (to keep the the vector sorted).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>start</code></em>:</span></p></td>
<td><p>
  The start position of the slice to search (inclusive).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>end</code></em>:</span></p></td>
<td><p>
  The end position of the slice to search (exclusive).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (true) if <em class="parameter"><code>what</code></em> is found in the vector,
        zero (false) otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(log(n)),
n is the number of elements in the slice of <em class="parameter"><code>v</code></em>, i.e. <em class="parameter"><code>end</code></em> - <em class="parameter"><code>start</code></em>.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_binsearch2"></a>2.12.5. <code class="function">igraph_vector_binsearch2</code> —  Binary search, without returning the index.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.13.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_vector_binsearch2(const igraph_vector_t *v,
        igraph_real_t what);
</pre></div>
<p>
</p>
<p>




</p>
<p>
It is assumed that the vector is sorted.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The <span class="type">igraph_vector_t</span> object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>what</code></em>:</span></p></td>
<td><p>
  The element to search for.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (true) if <em class="parameter"><code>what</code></em> is
  found in the vector, zero (false) otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(log(n)),
n is the number of elements in
<em class="parameter"><code>v</code></em>.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="vector-resizing-operations"></a>2.13. Resizing operations</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_clear">2.13.1. <code class="function">igraph_vector_clear</code> —  Removes all elements from a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_reserve">2.13.2. <code class="function">igraph_vector_reserve</code> —  Reserves memory for a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_resize">2.13.3. <code class="function">igraph_vector_resize</code> —  Resize the vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_resize_min">2.13.4. <code class="function">igraph_vector_resize_min</code> —  Deallocate the unused memory of a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_push_back">2.13.5. <code class="function">igraph_vector_push_back</code> —  Appends one element to a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_pop_back">2.13.6. <code class="function">igraph_vector_pop_back</code> —  Removes and returns the last element of a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_insert">2.13.7. <code class="function">igraph_vector_insert</code> —  Inserts a single element into a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_remove">2.13.8. <code class="function">igraph_vector_remove</code> —  Removes a single element from a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_remove_section">2.13.9. <code class="function">igraph_vector_remove_section</code> —  Deletes a section from a vector.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_clear"></a>2.13.1. <code class="function">igraph_vector_clear</code> —  Removes all elements from a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.14.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_clear(igraph_vector_t* v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function simply sets the size of the vector to zero, it does
not free any allocated memory. For that you have to call
<a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_reserve"></a>2.13.2. <code class="function">igraph_vector_reserve</code> —  Reserves memory for a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.14.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_reserve(igraph_vector_t* v, long int size);
</pre></div>
<p>
</p>
<p>




</p>
<p>
<span class="command"><strong>igraph</strong></span> vectors are flexible, they can grow and
shrink. Growing
however occasionally needs the data in the vector to be copied.
In order to avoid this, you can call this function to reserve space for
future growth of the vector.

</p>
<p>
Note that this function does <span class="emphasis"><em>not</em></span> change the size of the
vector. Let us see a small example to clarify things: if you
reserve space for 100 elements and the size of your
vector was (and still is) 60, then you can surely add additional 40
elements to your vector before it will be copied.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>size</code></em>:</span></p></td>
<td><p>
  The new <span class="emphasis"><em>allocated</em></span> size of the vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code> if there is not enough memory.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: operating system dependent, should be around
O(n), n
is the new allocated size of the vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_resize"></a>2.13.3. <code class="function">igraph_vector_resize</code> —  Resize the vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.14.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_resize(igraph_vector_t* v, long int newsize);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Note that this function does not free any memory, just sets the
size of the vector to the given one. It can on the other hand
allocate more memory if the new size is larger than the previous
one. In this case the newly appeared elements in the vector are
<span class="emphasis"><em>not</em></span> set to zero, they are uninitialized.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>newsize</code></em>:</span></p></td>
<td><p>
  The new size of the vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code,
        <code class="constant">IGRAPH_ENOMEM</code> if there is not enough
        memory. Note that this function <span class="emphasis"><em>never</em></span> returns an error
        if the vector is made smaller.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Data-structures.html#igraph_vector_reserve" title="2.13.2. igraph_vector_reserve — Reserves memory for a vector."><code class="function">igraph_vector_reserve()</code></a> for allocating memory for future
extensions of a vector. <a class="link" href="igraph-Data-structures.html#igraph_vector_resize_min" title="2.13.4. igraph_vector_resize_min — Deallocate the unused memory of a vector."><code class="function">igraph_vector_resize_min()</code></a> for
deallocating the unnneded memory for a vector.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1) if the new
size is smaller, operating system dependent if it is larger. In the
latter case it is usually around
O(n),
n is the new size of the vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_resize_min"></a>2.13.4. <code class="function">igraph_vector_resize_min</code> —  Deallocate the unused memory of a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.14.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_resize_min(igraph_vector_t*v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Note that this function involves additional memory allocation and
may result an out-of-memory error.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Data-structures.html#igraph_vector_resize" title="2.13.3. igraph_vector_resize — Resize the vector."><code class="function">igraph_vector_resize()</code></a>, <a class="link" href="igraph-Data-structures.html#igraph_vector_reserve" title="2.13.2. igraph_vector_reserve — Reserves memory for a vector."><code class="function">igraph_vector_reserve()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: operating system dependent.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_push_back"></a>2.13.5. <code class="function">igraph_vector_push_back</code> —  Appends one element to a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.14.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_push_back(igraph_vector_t* v, igraph_real_t e);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function resizes the vector to be one element longer and
sets the very last element in the vector to <em class="parameter"><code>e</code></em>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>e</code></em>:</span></p></td>
<td><p>
  The element to append to the vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code>: not enough memory.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: operating system dependent. What is important is that
a sequence of n
subsequent calls to this function has time complexity
O(n), even if there
hadn't been any space reserved for the new elements by
<a class="link" href="igraph-Data-structures.html#igraph_vector_reserve" title="2.13.2. igraph_vector_reserve — Reserves memory for a vector."><code class="function">igraph_vector_reserve()</code></a>. This is implemented by a trick similar to the C++
<span class="type">vector</span> class: each time more memory is allocated for a
vector, the size of the additionally allocated memory is the same
as the vector's current length. (We assume here that the time
complexity of memory allocation is at most linear.)
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_pop_back"></a>2.13.6. <code class="function">igraph_vector_pop_back</code> —  Removes and returns the last element of a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.14.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_vector_pop_back(igraph_vector_t* v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
It is an error to call this function with an empty vector.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The removed last element.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_insert"></a>2.13.7. <code class="function">igraph_vector_insert</code> —  Inserts a single element into a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.14.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_insert(igraph_vector_t *v, long int pos,
                                    igraph_real_t value);
</pre></div>
<p>
</p>
<p>




Note that this function does not do range checking. Insertion will shift the
elements from the position given to the end of the vector one position to the
right, and the new element will be inserted in the empty space created at
the given position. The size of the vector will increase by one.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pos</code></em>:</span></p></td>
<td><p>
  The position where the new element is to be inserted.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  The new element to be inserted.</p></td>
</tr>
</tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_remove"></a>2.13.8. <code class="function">igraph_vector_remove</code> —  Removes a single element from a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.14.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_remove(igraph_vector_t *v, long int elem);
</pre></div>
<p>
</p>
<p>




Note that this function does not do range checking.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>elem</code></em>:</span></p></td>
<td><p>
  The position of the element to remove.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(n-elem),
n is the number of elements in the
vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_remove_section"></a>2.13.9. <code class="function">igraph_vector_remove_section</code> —  Deletes a section from a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.14.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_remove_section(igraph_vector_t *v,
        long int from, long int to);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Note that this function does not do range checking. The result is
undefined if you supply invalid limits.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The position of the first element to remove.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The position of the first element <span class="emphasis"><em>not</em></span> to remove.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(n-from),
n is the number of elements in the
vector.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="vector-sorting"></a>2.14. Sorting</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_sort">2.14.1. <code class="function">igraph_vector_sort</code> —  Sorts the elements of the vector into ascending order.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_reverse_sort">2.14.2. <code class="function">igraph_vector_reverse_sort</code> —  Sorts the elements of the vector into descending order.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_sort"></a>2.14.1. <code class="function">igraph_vector_sort</code> —  Sorts the elements of the vector into ascending order.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.15.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_sort(igraph_vector_t *v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If the vector contains any NaN values, the resulting ordering of
NaN values is undefined and may appear anywhere in the vector.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector object.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity:
O(n log n) for n elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_reverse_sort"></a>2.14.2. <code class="function">igraph_vector_reverse_sort</code> —  Sorts the elements of the vector into descending order.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.15.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_reverse_sort(igraph_vector_t *v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
If the vector contains any NaN values, the resulting ordering of
NaN values is undefined and may appear anywhere in the vector.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector object.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity:
O(n log n) for n elements.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="set-operations-on-sorted-vectors"></a>2.15. Set operations on sorted vectors</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_intersect_sorted">2.15.1. <code class="function">igraph_vector_intersect_sorted</code> —  Calculates the intersection of two sorted vectors</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_difference_sorted">2.15.2. <code class="function">igraph_vector_difference_sorted</code> —  Calculates the difference between two sorted vectors (considered as sets)</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_intersect_sorted"></a>2.15.1. <code class="function">igraph_vector_intersect_sorted</code> —  Calculates the intersection of two sorted vectors</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.16.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_intersect_sorted(const igraph_vector_t *v1,
        const igraph_vector_t *v2, igraph_vector_t *result);
</pre></div>
<p>
</p>
<p>



The elements that are contained in both vectors are stored in the result
vector. All three vectors must be initialized.

</p>
<p>
Instead of the naive intersection which takes O(n), this function uses
the set intersection method of Ricardo Baeza-Yates, which is more efficient
when one of the vectors is significantly smaller than the other, and
gives similar performance on average when the two vectors are equal.

</p>
<p>
The algorithm keeps the multiplicities of the elements: if an element appears
k1 times in the first vector and k2 times in the second, the result
will include that element min(k1, k2) times.

</p>
<p>
Reference: Baeza-Yates R: A fast set intersection algorithm for sorted
sequences. In: Lecture Notes in Computer Science, vol. 3109/2004, pp.
400--408, 2004. Springer Berlin/Heidelberg. ISBN: 978-3-540-22341-2.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v1</code></em>:</span></p></td>
<td><p>
  the first vector
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v2</code></em>:</span></p></td>
<td><p>
  the second vector
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  the result vector, which will also be sorted.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(m log(n)) where m is the size of the smaller vector
and n is the size of the larger one.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_difference_sorted"></a>2.15.2. <code class="function">igraph_vector_difference_sorted</code> —  Calculates the difference between two sorted vectors (considered as sets)</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.16.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_difference_sorted(const igraph_vector_t *v1,
        const igraph_vector_t *v2, igraph_vector_t *result);
</pre></div>
<p>
</p>
<p>



The elements that are contained in only the first vector but not the second are
stored in the result vector. All three vectors must be initialized.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v1</code></em>:</span></p></td>
<td><p>
  the first vector
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v2</code></em>:</span></p></td>
<td><p>
  the second vector
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>result</code></em>:</span></p></td>
<td><p>
  the result vector</p></td>
</tr>
</tbody>
</table></div>
<p>

 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="about-vector-ptr"></a>2.16.  Pointer vectors
(<span class="type">igraph_vector_ptr_t</span>)</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_init">2.16.1. <code class="function">igraph_vector_ptr_init</code> —  Initialize a pointer vector (constructor).</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_copy">2.16.2. <code class="function">igraph_vector_ptr_copy</code> —  Copy a pointer vector (constructor).</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_destroy">2.16.3. <code class="function">igraph_vector_ptr_destroy</code> —  Destroys a pointer vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_free_all">2.16.4. <code class="function">igraph_vector_ptr_free_all</code> —  Frees all the elements of a pointer vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_destroy_all">2.16.5. <code class="function">igraph_vector_ptr_destroy_all</code> —  Frees all the elements and destroys the pointer vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_size">2.16.6. <code class="function">igraph_vector_ptr_size</code> —  Gives the number of elements in the pointer vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_clear">2.16.7. <code class="function">igraph_vector_ptr_clear</code> —  Removes all elements from a pointer vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_push_back">2.16.8. <code class="function">igraph_vector_ptr_push_back</code> —  Appends an element to the back of a pointer vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_insert">2.16.9. <code class="function">igraph_vector_ptr_insert</code> —  Inserts a single element into a pointer vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_e">2.16.10. <code class="function">igraph_vector_ptr_e</code> —  Access an element of a pointer vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_set">2.16.11. <code class="function">igraph_vector_ptr_set</code> —  Assign to an element of a pointer vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_resize">2.16.12. <code class="function">igraph_vector_ptr_resize</code> —  Resizes a pointer vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_sort">2.16.13. <code class="function">igraph_vector_ptr_sort</code> —  Sorts the pointer vector based on an external comparison function.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_get_item_destructor">2.16.14. <code class="function">igraph_vector_ptr_get_item_destructor</code> —  Gets the current item destructor for this pointer vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_vector_ptr_set_item_destructor">2.16.15. <code class="function">igraph_vector_ptr_set_item_destructor</code> —  Sets the item destructor for this pointer vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR">2.16.16. <code class="function">IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR</code> —  Sets the item destructor for this pointer vector (macro version).</a></span></dt>
</dl></div>
<p>The <span class="type">igraph_vector_ptr_t</span> data type is very similar to
the <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_t</code></a> type, but it stores generic pointers instead of
real numbers.</p>
<p>This type has the same space complexity as <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_t</code></a>, and most implemented operations work the same way
as for <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects"><code class="function">igraph_vector_t</code></a>.</p>
<p>This type is mostly used to pass to or receive from a set of
graphs to some <span class="command"><strong>igraph</strong></span> functions, such as <a class="link" href="igraph-Structural.html#igraph_decompose" title="6.4. igraph_decompose — Decompose a graph into connected components."><code class="function">igraph_decompose()</code></a>, which decomposes a graph to connected
components.</p>
<p>The same <a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector."><code class="function">VECTOR</code></a> macro used for ordinary vectors can be
used for pointer vectors as well, please note that a typeless
generic pointer will be provided by this macro and you may need to
cast it to a specific pointer before starting to work with it.</p>
<p>Pointer vectors may have an associated item destructor function
which takes a pointer and returns nothing. The item destructor will
be called on each item in the pointer vector when it is destroyed by
<a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector."><code class="function">igraph_vector_ptr_destroy()</code></a> or <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy_all" title="2.16.5. igraph_vector_ptr_destroy_all — Frees all the elements and destroys the pointer vector."><code class="function">igraph_vector_ptr_destroy_all()</code></a>,
or when its elements are freed by <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_free_all" title="2.16.4. igraph_vector_ptr_free_all — Frees all the elements of a pointer vector."><code class="function">igraph_vector_ptr_free_all()</code></a>.
Note that the semantics of an item destructor does not coincide with
C++ destructors; for instance, when a pointer vector is resized to a
smaller size, the extra items will <span class="emphasis"><em>not</em></span> be destroyed automatically!
Nevertheless, item destructors may become handy in many cases; for
instance, a vector of graphs generated by <a class="link" href="igraph-Structural.html#igraph_decompose" title="6.4. igraph_decompose — Decompose a graph into connected components."><code class="function">igraph_decompose()</code></a> can
be destroyed with a single call to <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy_all" title="2.16.5. igraph_vector_ptr_destroy_all — Frees all the elements and destroys the pointer vector."><code class="function">igraph_vector_ptr_destroy_all()</code></a>
if the item destructor is set to <a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object."><code class="function">igraph_destroy()</code></a>.</p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_init"></a>2.16.1. <code class="function">igraph_vector_ptr_init</code> —  Initialize a pointer vector (constructor).</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_ptr_init(igraph_vector_ptr_t* v, int long size);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This is the constructor of the pointer vector data type. All
pointer vectors constructed this way should be destroyed via
calling <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector."><code class="function">igraph_vector_ptr_destroy()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized
       <span class="type">igraph_vector_ptr_t</span> object, to be created.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>size</code></em>:</span></p></td>
<td><p>
  Integer, the size of the pointer vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code> if out of memory
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: operating system dependent, the amount of <span class="quote">“<span class="quote">time</span>”</span> required to allocate <em class="parameter"><code>size</code></em> elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_copy"></a>2.16.2. <code class="function">igraph_vector_ptr_copy</code> —  Copy a pointer vector (constructor).</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_ptr_copy(igraph_vector_ptr_t *to, const igraph_vector_ptr_t *from);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function creates a pointer vector by copying another one. This
is shallow copy, only the pointers in the vector will be copied.

</p>
<p>
It is potentially dangerous to copy a pointer vector with an associated
item destructor. The copied vector will inherit the item destructor,
which may cause problems when both vectors are destroyed as the items
might get destroyed twice. Make sure you know what you are doing when
copying a pointer vector with an item destructor, or unset the item
destructor on one of the vectors later.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized pointer vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  A pointer vector object.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_ENOMEM</code> if out of memory
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n) if allocating memory for n elements can be
done in O(n) time.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_destroy"></a>2.16.3. <code class="function">igraph_vector_ptr_destroy</code> —  Destroys a pointer vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_ptr_destroy(igraph_vector_ptr_t* v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The destructor for pointer vectors.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to the pointer vector to destroy.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: operating system dependent, the <span class="quote">“<span class="quote">time</span>”</span> required to deallocate O(n) bytes, n is the number of
elements allocated for the pointer vector (not necessarily the
number of elements in the vector).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_free_all"></a>2.16.4. <code class="function">igraph_vector_ptr_free_all</code> —  Frees all the elements of a pointer vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_ptr_free_all(igraph_vector_ptr_t* v);
</pre></div>
<p>
</p>
<p>




If an item destructor is set for this pointer vector, this function will
first call the destructor on all elements of the vector and then
free all the elements using <a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions."><code class="function">igraph_free()</code></a>. If an item destructor is not set,
the elements will simply be freed.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to the pointer vector whose elements will be freed.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: operating system dependent, the <span class="quote">“<span class="quote">time</span>”</span> required to call the destructor n times and then
deallocate O(n) pointers, each pointing to a memory area of
arbitrary size. n is the number of elements in the pointer vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_destroy_all"></a>2.16.5. <code class="function">igraph_vector_ptr_destroy_all</code> —  Frees all the elements and destroys the pointer vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_ptr_destroy_all(igraph_vector_ptr_t* v);
</pre></div>
<p>
</p>
<p>




This function is equivalent to <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_free_all" title="2.16.4. igraph_vector_ptr_free_all — Frees all the elements of a pointer vector."><code class="function">igraph_vector_ptr_free_all()</code></a>
followed by <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector."><code class="function">igraph_vector_ptr_destroy()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to the pointer vector to destroy.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: operating system dependent, the <span class="quote">“<span class="quote">time</span>”</span> required to deallocate O(n) pointers, each pointing to
a memory area of arbitrary size, plus the <span class="quote">“<span class="quote">time</span>”</span>
required to deallocate O(n) bytes, n being the number of elements
allocated for the pointer vector (not necessarily the number of
elements in the vector).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_size"></a>2.16.6. <code class="function">igraph_vector_ptr_size</code> —  Gives the number of elements in the pointer vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_vector_ptr_size(const igraph_vector_ptr_t* v);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The pointer vector object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The size of the object, i.e. the number of pointers stored.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_clear"></a>2.16.7. <code class="function">igraph_vector_ptr_clear</code> —  Removes all elements from a pointer vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.13.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_ptr_clear(igraph_vector_ptr_t* v);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function resizes a pointer to vector to zero length. Note that
the pointed objects are <span class="emphasis"><em>not</em></span> deallocated, you should call
<a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions."><code class="function">igraph_free()</code></a> on them, or make sure that their allocated memory is freed
in some other way, you'll get memory leaks otherwise. If you have
set up an item destructor earlier, the destructor will be called
on every element.

</p>
<p>
Note that the current implementation of this function does
<span class="emphasis"><em>not</em></span> deallocate the memory required for storing the
pointers, so making a pointer vector smaller this way does not give
back any memory. This behavior might change in the future.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The pointer vector to clear.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_push_back"></a>2.16.8. <code class="function">igraph_vector_ptr_push_back</code> —  Appends an element to the back of a pointer vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.14.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_ptr_push_back(igraph_vector_ptr_t* v, void* e);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The pointer vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>e</code></em>:</span></p></td>
<td><p>
  The new element to include in the pointer vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  igraph_vector_push_back() for the corresponding operation of
the ordinary vector type.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1) or O(n), n is the number of elements in the
vector. The pointer vector implementation ensures that n subsequent
push_back operations need O(n) time to complete.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_insert"></a>2.16.9. <code class="function">igraph_vector_ptr_insert</code> —  Inserts a single element into a pointer vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.15.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_ptr_insert(igraph_vector_ptr_t* v, long int pos, void* e);
</pre></div>
<p>
</p>
<p>




Note that this function does not do range checking. Insertion will shift the
elements from the position given to the end of the vector one position to the
right, and the new element will be inserted in the empty space created at
the given position. The size of the vector will increase by one.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The pointer vector object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pos</code></em>:</span></p></td>
<td><p>
  The position where the new element is inserted.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>e</code></em>:</span></p></td>
<td><p>
  The inserted element</p></td>
</tr>
</tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_e"></a>2.16.10. <code class="function">igraph_vector_ptr_e</code> —  Access an element of a pointer vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.16.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void *igraph_vector_ptr_e(const igraph_vector_ptr_t* v, long int pos);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pos</code></em>:</span></p></td>
<td><p>
  The index of the pointer to return.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The pointer at <em class="parameter"><code>pos</code></em> position.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_set"></a>2.16.11. <code class="function">igraph_vector_ptr_set</code> —  Assign to an element of a pointer vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.17.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_ptr_set(igraph_vector_ptr_t* v, long int pos, void* value);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to a pointer vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pos</code></em>:</span></p></td>
<td><p>
  The index of the pointer to update.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  The new pointer to set in the vector.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_resize"></a>2.16.12. <code class="function">igraph_vector_ptr_resize</code> —  Resizes a pointer vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.18.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vector_ptr_resize(igraph_vector_ptr_t* v, long int newsize);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Note that if a vector is made smaller the pointed object are not
deallocated by this function and the item destructor is not called
on the extra elements.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  A pointer vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>newsize</code></em>:</span></p></td>
<td><p>
  The new size of the pointer vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1) if the vector if made smaller. Operating
system dependent otherwise, the amount of <span class="quote">“<span class="quote">time</span>”</span>
needed to allocate the memory for the vector elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_sort"></a>2.16.13. <code class="function">igraph_vector_ptr_sort</code> —  Sorts the pointer vector based on an external comparison function.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.19.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_vector_ptr_sort(igraph_vector_ptr_t *v, int (*compar)(const void*, const void*));
</pre></div>
<p>
</p>
<p>




Sometimes it is necessary to sort the pointers in the vector based on
the property of the element being referenced by the pointer. This
function allows us to sort the vector based on an arbitrary external
comparison function which accepts two <span class="type">void *</span> pointers <code class="constant">p1</code> and <code class="constant">p2</code>
and returns an integer less than, equal to or greater than zero if the
first argument is considered to be respectively less than, equal to, or
greater than the second. <code class="constant">p1</code> and <code class="constant">p2</code> will point to the pointer in the
vector, so they have to be double-dereferenced if one wants to get access
to the underlying object the address of which is stored in <code class="constant">v</code>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The pointer vector to be sorted.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>compar</code></em>:</span></p></td>
<td><p>
  A qsort-compatible comparison function. It must take pointers to the
   elements of the pointer vector. For example, if the pointer vector contains
   <code class="literal">igraph_vector_t *</code> pointers, then the comparison function must
   interpret its arguments as <code class="literal">igraph_vector_t **</code>.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.3.17.19.6.1"></a><p class="title"><b>Example 7.4.  File <code class="code">examples/simple/igraph_vector_ptr_sort.c</code></b></p>
<div class="example-contents">
<pre class="programlisting">
<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_t graph;
    igraph_vector_ptr_t <a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>;
    long int i, n;

    <span class="emphasis"><em>/* Set a random seed to make the program deterministic */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 31415);

    <span class="emphasis"><em>/* Create a random graph with a given number of vertices and edges */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game" title="2.3. igraph_erdos_renyi_game — Generates a random (Erdős-Rényi) graph.">igraph_erdos_renyi_game</a></strong></span>(&amp;graph, IGRAPH_ERDOS_RENYI_GNM, 15, 80, IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS);

    <span class="emphasis"><em>/* Find all maximal cliques in the graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, 0);
    <span class="strong"><strong><a class="link" href="igraph-Cliques.html#igraph_maximal_cliques" title="1.6. igraph_maximal_cliques — Finds all maximal cliques in a graph.">igraph_maximal_cliques</a></strong></span>(&amp;graph, &amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, -1, -1);

    <span class="emphasis"><em>/* Print the cliques in lexicographical order */</em></span>
    <span class="strong"><strong>printf</strong></span>("Maximal <a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a> in lexicographical order:\n");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_sort" title="2.16.13. igraph_vector_ptr_sort — Sorts the pointer vector based on an external comparison function.">igraph_vector_ptr_sort</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, <a class="link" href="igraph-Data-structures.html#igraph_vector_lex_cmp" title="2.9.6. igraph_vector_lex_cmp — Lexicographical comparison of two vectors.">igraph_vector_lex_cmp</a>);
    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>);
    <span class="strong"><strong>for</strong></span> (i=0; i &lt; n; ++i) {
        <span class="strong"><strong>igraph_vector_print</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>)[i]);
    }

    <span class="emphasis"><em>/* Print the cliques in colexicographical order */</em></span>
    <span class="strong"><strong>printf</strong></span>("\nMaximal <a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a> in colexicographical order:\n");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_sort" title="2.16.13. igraph_vector_ptr_sort — Sorts the pointer vector based on an external comparison function.">igraph_vector_ptr_sort</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, <a class="link" href="igraph-Data-structures.html#igraph_vector_colex_cmp" title="2.9.7. igraph_vector_colex_cmp — Colexicographical comparison of two vectors.">igraph_vector_colex_cmp</a>);
    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>);
    <span class="strong"><strong>for</strong></span> (i=0; i &lt; n; ++i) {
        <span class="strong"><strong>igraph_vector_print</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>)[i]);
    }

    <span class="emphasis"><em>/* Destroy data structures when we no longer need them */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR" title="2.16.16. IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR — Sets the item destructor for this pointer vector (macro version).">IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>, <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a>);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy_all" title="2.16.5. igraph_vector_ptr_destroy_all — Frees all the elements and destroys the pointer vector.">igraph_vector_ptr_destroy_all</a></strong></span>(&amp;<a class="link" href="igraph-Cliques.html#cliques" title="1. Cliques">cliques</a>);

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_get_item_destructor"></a>2.16.14. <code class="function">igraph_vector_ptr_get_item_destructor</code> —  Gets the current item destructor for this pointer vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.20.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_finally_func_t* igraph_vector_ptr_get_item_destructor(const igraph_vector_ptr_t *v);
</pre></div>
<p>
</p>
<p>




The item destructor is a function which will be called on every non-null
pointer stored in this vector when <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector."><code class="function">igraph_vector_ptr_destroy()</code></a>,
igraph_vector_ptr_destroy_all() or <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_free_all" title="2.16.4. igraph_vector_ptr_free_all — Frees all the elements of a pointer vector."><code class="function">igraph_vector_ptr_free_all()</code></a>
is called.

</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The current item destructor.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_vector_ptr_set_item_destructor"></a>2.16.15. <code class="function">igraph_vector_ptr_set_item_destructor</code> —  Sets the item destructor for this pointer vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.21.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_finally_func_t* igraph_vector_ptr_set_item_destructor(
    igraph_vector_ptr_t *v, igraph_finally_func_t *func);
</pre></div>
<p>
</p>
<p>




The item destructor is a function which will be called on every non-null
pointer stored in this vector when <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector."><code class="function">igraph_vector_ptr_destroy()</code></a>,
igraph_vector_ptr_destroy_all() or <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_free_all" title="2.16.4. igraph_vector_ptr_free_all — Frees all the elements of a pointer vector."><code class="function">igraph_vector_ptr_free_all()</code></a>
is called.

</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The old item destructor.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR"></a>2.16.16. <code class="function">IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR</code> —  Sets the item destructor for this pointer vector (macro version).</h4></div></div></div>
<a class="indexterm" name="id-1.8.3.17.22.2"></a><p>
</p>
<pre class="programlisting">
#define IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR(v, func)
</pre>
<p>
</p>
<p>


This macro is expanded to <a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_set_item_destructor" title="2.16.15. igraph_vector_ptr_set_item_destructor — Sets the item destructor for this pointer vector."><code class="function">igraph_vector_ptr_set_item_destructor()</code></a>, the
only difference is that the second argument is automatically cast to an
<code class="constant">igraph_finally_func_t</code>*. The cast is necessary in most cases as the
destructor functions we use (such as <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a>) take a
pointer to some concrete igraph data type, while <code class="constant">igraph_finally_func_t</code>
expects <code class="constant">void</code>*
 
</p>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="igraph-Matrices"></a>3. Matrices</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#about-matrix">3.1.  About <span class="type">igraph_matrix_t</span> objects</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#matrix-constructor-and-destructor">3.2.  Matrix constructors and
destructors</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#matrix-initializing-elements">3.3. Initializing elements</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#copying-matrices">3.4. Copying matrices</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#matrix-accessing-elements">3.5.  Accessing elements of a matrix</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#operations-on-rows-and-columns">3.6. Operations on rows and columns</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#matrix-operations">3.7. Matrix operations</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#matrix-comparisons">3.8. Matrix comparisons</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#combining-matrices">3.9. Combining matrices</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#matrix-finding-minimum-and-maximum">3.10. Finding minimum and maximum</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#matrix-properties">3.11. Matrix properties</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#matrix-searching-for-elements">3.12. Searching for elements</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#matrix-resizing-operations">3.13. Resizing operations</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="about-matrix"></a>3.1.  About <span class="type">igraph_matrix_t</span> objects</h3></div></div></div>
<p>This type is just an interface to <span class="type">igraph_vector_t</span>.</p>
<p>The <span class="type">igraph_matrix_t</span> type usually stores n
elements in O(n) space, but not always. See the documentation of
the vector type.</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="matrix-constructor-and-destructor"></a>3.2.  Matrix constructors and
destructors</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_init">3.2.1. <code class="function">igraph_matrix_init</code> —  Initializes a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_copy">3.2.2. <code class="function">igraph_matrix_copy</code> —  Copies a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_destroy">3.2.3. <code class="function">igraph_matrix_destroy</code> —  Destroys a matrix object.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_init"></a>3.2.1. <code class="function">igraph_matrix_init</code> —  Initializes a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.3.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_init(igraph_matrix_t *m, long int nrow, long int ncol);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Every matrix needs to be initialized before using it. This is done
by calling this function. A matrix has to be destroyed if it is not
needed any more; see <a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object."><code class="function">igraph_matrix_destroy()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to a not yet initialized matrix object to be
       initialized.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nrow</code></em>:</span></p></td>
<td><p>
  The number of rows in the matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ncol</code></em>:</span></p></td>
<td><p>
  The number of columns in the matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: usually O(n),
n is the
number of elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_copy"></a>3.2.2. <code class="function">igraph_matrix_copy</code> —  Copies a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.3.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_copy(igraph_matrix_t *to, const igraph_matrix_t *from);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Creates a matrix object by copying from an existing matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The initialized matrix object to copy.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, <code class="constant">IGRAPH_ENOMEM</code> if there
  isn't enough memory to allocate the new matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number
of elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_destroy"></a>3.2.3. <code class="function">igraph_matrix_destroy</code> —  Destroys a matrix object.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.3.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_matrix_destroy(igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function frees all the memory allocated for a matrix
object. The destroyed object needs to be reinitialized before using
it again.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix to destroy.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: operating system dependent.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="matrix-initializing-elements"></a>3.3. Initializing elements</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_null">3.3.1. <code class="function">igraph_matrix_null</code> —  Sets all elements in a matrix to zero.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_fill">3.3.2. <code class="function">igraph_matrix_fill</code> — Fill with an element.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_null"></a>3.3.1. <code class="function">igraph_matrix_null</code> —  Sets all elements in a matrix to zero.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.4.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_matrix_null(igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix object.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(n),
n is the number of  elements in
the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_fill"></a>3.3.2. <code class="function">igraph_matrix_fill</code> — Fill with an element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.4.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_matrix_fill(igraph_matrix_t *m, igraph_real_t e);
</pre></div>
<p>
</p>
<p>



Set the matrix to a constant matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>e</code></em>:</span></p></td>
<td><p>
  The element to set.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(mn), the number of elements.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="copying-matrices"></a>3.4. Copying matrices</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_copy_to">3.4.1. <code class="function">igraph_matrix_copy_to</code> —  Copies a matrix to a regular C array.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_update">3.4.2. <code class="function">igraph_matrix_update</code> — Update from another matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_swap">3.4.3. <code class="function">igraph_matrix_swap</code> — Swap two matrices.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_copy_to"></a>3.4.1. <code class="function">igraph_matrix_copy_to</code> —  Copies a matrix to a regular C array.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.5.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_matrix_copy_to(const igraph_matrix_t *m, igraph_real_t *to);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The matrix is copied columnwise, as this is the format most
programs and languages use.
The C array should be of sufficient size; there are (of course) no
range checks.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Pointer to a C array; the place to copy the data to.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n),
n is the number of
elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_update"></a>3.4.2. <code class="function">igraph_matrix_update</code> — Update from another matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.5.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_update(igraph_matrix_t *to,
                                    const igraph_matrix_t *from);
</pre></div>
<p>
</p>
<p>



This function replicates <em class="parameter"><code>from</code></em> in the matrix <em class="parameter"><code>to</code></em>.
Note that <em class="parameter"><code>to</code></em> must be already initialized.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The result matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The matrix to replicate; it is left unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_swap"></a>3.4.3. <code class="function">igraph_matrix_swap</code> — Swap two matrices.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.5.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_swap(igraph_matrix_t *m1, igraph_matrix_t *m2);
</pre></div>
<p>
</p>
<p>



The contents of the two matrices will be swapped.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m1</code></em>:</span></p></td>
<td><p>
  The first matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m2</code></em>:</span></p></td>
<td><p>
  The second matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="matrix-accessing-elements"></a>3.5.  Accessing elements of a matrix</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#MATRIX">3.5.1. <code class="function">MATRIX</code> —  Accessing an element of a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_e">3.5.2. <code class="function">igraph_matrix_e</code> — Extract an element from a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_e_ptr">3.5.3. <code class="function">igraph_matrix_e_ptr</code> — Pointer to an element of a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_set">3.5.4. <code class="function">igraph_matrix_set</code> — Set an element.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="MATRIX"></a>3.5.1. <code class="function">MATRIX</code> —  Accessing an element of a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.6.2.2"></a><p>
</p>
<pre class="programlisting">
#define MATRIX(m,i,j)
</pre>
<p>
</p>
<p>



Note that there are no range checks right now.
This functionality might be redefined as a proper function later.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>i</code></em>:</span></p></td>
<td><p>
  The index of the row, starting with zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>j</code></em>:</span></p></td>
<td><p>
  The index of the column, starting with zero.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_e"></a>3.5.2. <code class="function">igraph_matrix_e</code> — Extract an element from a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.6.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_matrix_e(const igraph_matrix_t *m,
                                long int row, long int col);
</pre></div>
<p>
</p>
<p>



Use this if you need a function for some reason and cannot use the
<a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix."><code class="function">MATRIX</code></a> macro. Note that no range checking is performed.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>row</code></em>:</span></p></td>
<td><p>
  The row index.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>col</code></em>:</span></p></td>
<td><p>
  The column index.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The element in the given row and column.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_e_ptr"></a>3.5.3. <code class="function">igraph_matrix_e_ptr</code> — Pointer to an element of a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.6.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t* igraph_matrix_e_ptr(const igraph_matrix_t *m,
                                     long int row, long int col);
</pre></div>
<p>
</p>
<p>



The function returns a pointer to an element. No range checking is
performed.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>row</code></em>:</span></p></td>
<td><p>
  The row index.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>col</code></em>:</span></p></td>
<td><p>
  The column index.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Pointer to the element in the given row and column.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_set"></a>3.5.4. <code class="function">igraph_matrix_set</code> — Set an element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.6.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_matrix_set(igraph_matrix_t* m, long int row, long int col,
                                  igraph_real_t value);
</pre></div>
<p>
</p>
<p>



Set an element of a matrix. No range checking is performed.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>row</code></em>:</span></p></td>
<td><p>
  The row index.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>col</code></em>:</span></p></td>
<td><p>
  The column index.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  The new value of the element.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="operations-on-rows-and-columns"></a>3.6. Operations on rows and columns</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_get_row">3.6.1. <code class="function">igraph_matrix_get_row</code> — Extract a row.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_get_col">3.6.2. <code class="function">igraph_matrix_get_col</code> —  Select a column.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_set_row">3.6.3. <code class="function">igraph_matrix_set_row</code> — Set a row from a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_set_col">3.6.4. <code class="function">igraph_matrix_set_col</code> — Set a column from a vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_swap_rows">3.6.5. <code class="function">igraph_matrix_swap_rows</code> — Swap two rows.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_swap_cols">3.6.6. <code class="function">igraph_matrix_swap_cols</code> — Swap two columns.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_select_rows">3.6.7. <code class="function">igraph_matrix_select_rows</code> —  Select some rows of a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_select_cols">3.6.8. <code class="function">igraph_matrix_select_cols</code> —  Select some columns of a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_select_rows_cols">3.6.9. <code class="function">igraph_matrix_select_rows_cols</code> —  Select some rows and columns of a matrix.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_get_row"></a>3.6.1. <code class="function">igraph_matrix_get_row</code> — Extract a row.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.7.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_get_row(const igraph_matrix_t *m,
                                     igraph_vector_t *res, long int index);
</pre></div>
<p>
</p>
<p>



Extract a row from a matrix and return it as a vector.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector; it will be resized if
  needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>index</code></em>:</span></p></td>
<td><p>
  The index of the row to select.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of columns in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_get_col"></a>3.6.2. <code class="function">igraph_matrix_get_col</code> —  Select a column.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.7.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_get_col(const igraph_matrix_t *m,
                                     igraph_vector_t *res,
                                     long int index);
</pre></div>
<p>
</p>
<p>



Extract a column of a matrix and return it as a vector.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result will we stored in this vector. It should be
  initialized and will be resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>index</code></em>:</span></p></td>
<td><p>
  The index of the column to select.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of rows in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_set_row"></a>3.6.3. <code class="function">igraph_matrix_set_row</code> — Set a row from a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.7.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_set_row(igraph_matrix_t *m,
                                     const igraph_vector_t *v, long int index);
</pre></div>
<p>
</p>
<p>



Sets the elements of a row with the given vector. This has the effect of
setting row <code class="constant">index</code> to have the elements in the vector <code class="constant">v</code>. The length of
the vector and the number of columns in the matrix must match,
otherwise an error is triggered.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector containing the new elements of the row.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>index</code></em>:</span></p></td>
<td><p>
  Index of the row to set.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of columns in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_set_col"></a>3.6.4. <code class="function">igraph_matrix_set_col</code> — Set a column from a vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.7.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_set_col(igraph_matrix_t *m,
                                     const igraph_vector_t *v, long int index);
</pre></div>
<p>
</p>
<p>



Sets the elements of a column with the given vector. In effect, column
<code class="constant">index</code> will be set with elements from the vector <code class="constant">v</code>. The length of
the vector and the number of rows in the matrix must match,
otherwise an error is triggered.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The vector containing the new elements of the column.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>index</code></em>:</span></p></td>
<td><p>
  Index of the column to set.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(m), the number of rows in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_swap_rows"></a>3.6.5. <code class="function">igraph_matrix_swap_rows</code> — Swap two rows.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.7.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_swap_rows(igraph_matrix_t *m,
                                       long int i, long int j);
</pre></div>
<p>
</p>
<p>



Swap two rows in the matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>i</code></em>:</span></p></td>
<td><p>
  The index of the first row.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>j</code></em>:</span></p></td>
<td><p>
  The index of the second row.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of columns.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_swap_cols"></a>3.6.6. <code class="function">igraph_matrix_swap_cols</code> — Swap two columns.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.7.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_swap_cols(igraph_matrix_t *m,
                                       long int i, long int j);
</pre></div>
<p>
</p>
<p>



Swap two columns in the matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>i</code></em>:</span></p></td>
<td><p>
  The index of the first column.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>j</code></em>:</span></p></td>
<td><p>
  The index of the second column.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(m), the number of rows.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_select_rows"></a>3.6.7. <code class="function">igraph_matrix_select_rows</code> —  Select some rows of a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.7.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_select_rows(const igraph_matrix_t *m,
        igraph_matrix_t *res,
        const igraph_vector_t *rows);
</pre></div>
<p>
</p>
<p>



This function selects some rows of a matrix and returns them in a
new matrix. The result matrix should be initialized before calling
the function.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result matrix. It should be initialized and will be
   resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rows</code></em>:</span></p></td>
<td><p>
  Vector; it contains the row indices (starting with
   zero) to extract. Note that no range checking is performed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nm), n is the number of rows, m the number of
columns of the result matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_select_cols"></a>3.6.8. <code class="function">igraph_matrix_select_cols</code> —  Select some columns of a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.7.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_select_cols(const igraph_matrix_t *m,
        igraph_matrix_t *res,
        const igraph_vector_t *cols);
</pre></div>
<p>
</p>
<p>



This function selects some columns of a matrix and returns them in a
new matrix. The result matrix should be initialized before calling
the function.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result matrix. It should be initialized and will be
   resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cols</code></em>:</span></p></td>
<td><p>
  Vector; it contains the column indices (starting with
   zero) to extract. Note that no range checking is performed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nm), n is the number of rows, m the number of
columns of the result matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_select_rows_cols"></a>3.6.9. <code class="function">igraph_matrix_select_rows_cols</code> —  Select some rows and columns of a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.7.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_select_rows_cols(const igraph_matrix_t *m,
        igraph_matrix_t *res,
        const igraph_vector_t *rows,
        const igraph_vector_t *cols);
</pre></div>
<p>
</p>
<p>



This function selects some rows and columns of a matrix and returns
them in a new matrix. The result matrix should be initialized before
calling the function.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  The result matrix. It should be initialized and will be
   resized as needed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rows</code></em>:</span></p></td>
<td><p>
  Vector; it contains the row indices (starting with
   zero) to extract. Note that no range checking is performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cols</code></em>:</span></p></td>
<td><p>
  Vector; it contains the column indices (starting with
   zero) to extract. Note that no range checking is performed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nm), n is the number of rows, m the number of
columns of the result matrix.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="matrix-operations"></a>3.7. Matrix operations</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_add_constant">3.7.1. <code class="function">igraph_matrix_add_constant</code> — Add a constant to every element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_scale">3.7.2. <code class="function">igraph_matrix_scale</code> — Multiplies each element of the matrix by a constant.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_add">3.7.3. <code class="function">igraph_matrix_add</code> — Add two matrices.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_sub">3.7.4. <code class="function">igraph_matrix_sub</code> — Difference of two matrices.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_mul_elements">3.7.5. <code class="function">igraph_matrix_mul_elements</code> — Elementwise multiplication.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_div_elements">3.7.6. <code class="function">igraph_matrix_div_elements</code> — Elementwise division.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_sum">3.7.7. <code class="function">igraph_matrix_sum</code> —  Sum of elements.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_prod">3.7.8. <code class="function">igraph_matrix_prod</code> — Product of the elements.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_rowsum">3.7.9. <code class="function">igraph_matrix_rowsum</code> — Rowwise sum.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_colsum">3.7.10. <code class="function">igraph_matrix_colsum</code> — Columnwise sum.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_transpose">3.7.11. <code class="function">igraph_matrix_transpose</code> —  Transpose a matrix.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_add_constant"></a>3.7.1. <code class="function">igraph_matrix_add_constant</code> — Add a constant to every element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.8.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_matrix_add_constant(igraph_matrix_t *m, igraph_real_t plus);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>plud</code></em>:</span></p></td>
<td><p>
  The constant to add.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(mn), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_scale"></a>3.7.2. <code class="function">igraph_matrix_scale</code> — Multiplies each element of the matrix by a constant.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.8.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_matrix_scale(igraph_matrix_t *m, igraph_real_t by);
</pre></div>
<p>
</p>
<p>


</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>by</code></em>:</span></p></td>
<td><p>
  The constant.</p></td>
</tr>
</tbody>
</table></div>
<p>


Added in version 0.2.</p>
<p>

Time complexity: O(n), the number of elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_add"></a>3.7.3. <code class="function">igraph_matrix_add</code> — Add two matrices.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.8.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_add(igraph_matrix_t *m1,
                                 const igraph_matrix_t *m2);
</pre></div>
<p>
</p>
<p>



Add <em class="parameter"><code>m2</code></em> to <em class="parameter"><code>m1</code></em>, and store the result in <em class="parameter"><code>m1</code></em>. The dimensions of the
matrices must match.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m1</code></em>:</span></p></td>
<td><p>
  The first matrix; the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m2</code></em>:</span></p></td>
<td><p>
  The second matrix; it is left unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_sub"></a>3.7.4. <code class="function">igraph_matrix_sub</code> — Difference of two matrices.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.8.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_sub(igraph_matrix_t *m1,
                                 const igraph_matrix_t *m2);
</pre></div>
<p>
</p>
<p>



Subtract <em class="parameter"><code>m2</code></em> from <em class="parameter"><code>m1</code></em> and store the result in <em class="parameter"><code>m1</code></em>.
The dimensions of the two matrices must match.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m1</code></em>:</span></p></td>
<td><p>
  The first matrix; the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m2</code></em>:</span></p></td>
<td><p>
  The second matrix; it is left unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_mul_elements"></a>3.7.5. <code class="function">igraph_matrix_mul_elements</code> — Elementwise multiplication.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.8.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_mul_elements(igraph_matrix_t *m1,
        const igraph_matrix_t *m2);
</pre></div>
<p>
</p>
<p>



Multiply <em class="parameter"><code>m1</code></em> by <em class="parameter"><code>m2</code></em> elementwise and store the result in <em class="parameter"><code>m1</code></em>.
The dimensions of the two matrices must match.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m1</code></em>:</span></p></td>
<td><p>
  The first matrix; the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m2</code></em>:</span></p></td>
<td><p>
  The second matrix; it is left unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_div_elements"></a>3.7.6. <code class="function">igraph_matrix_div_elements</code> — Elementwise division.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.8.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_div_elements(igraph_matrix_t *m1,
        const igraph_matrix_t *m2);
</pre></div>
<p>
</p>
<p>



Divide <em class="parameter"><code>m1</code></em> by <em class="parameter"><code>m2</code></em> elementwise and store the result in <em class="parameter"><code>m1</code></em>.
The dimensions of the two matrices must match.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m1</code></em>:</span></p></td>
<td><p>
  The dividend. The result is store here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m2</code></em>:</span></p></td>
<td><p>
  The divisor. It is left unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_sum"></a>3.7.7. <code class="function">igraph_matrix_sum</code> —  Sum of elements.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.8.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_matrix_sum(const igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>



Returns the sum of the elements of a matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The sum of the elements.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_prod"></a>3.7.8. <code class="function">igraph_matrix_prod</code> — Product of the elements.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.8.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_matrix_prod(const igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>



Note this function can result in overflow easily, even for not too
big matrices.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The product of the elements.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_rowsum"></a>3.7.9. <code class="function">igraph_matrix_rowsum</code> — Rowwise sum.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.8.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_rowsum(const igraph_matrix_t *m,
                                    igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>



Calculate the sum of the elements in each row.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector; the result is stored
  here. It will be resized if necessary.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_colsum"></a>3.7.10. <code class="function">igraph_matrix_colsum</code> — Columnwise sum.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.8.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_colsum(const igraph_matrix_t *m,
                                    igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>



Calculate the sum of the elements in each column.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector; the result is stored
  here. It will be resized if necessary.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_transpose"></a>3.7.11. <code class="function">igraph_matrix_transpose</code> —  Transpose a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.8.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_transpose(igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>



Calculate the transpose of a matrix. Note that the function
reallocates the memory used for the matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input (and output) matrix.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements in the matrix.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="matrix-comparisons"></a>3.8. Matrix comparisons</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_all_e">3.8.1. <code class="function">igraph_matrix_all_e</code> —  Are all elements equal?</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_all_l">3.8.2. <code class="function">igraph_matrix_all_l</code> —  Are all elements less?</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_all_g">3.8.3. <code class="function">igraph_matrix_all_g</code> —  Are all elements greater?</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_all_le">3.8.4. <code class="function">igraph_matrix_all_le</code> —  Are all elements less or equal?</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_all_ge">3.8.5. <code class="function">igraph_matrix_all_ge</code> —  Are all elements greater or equal?</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_all_e"></a>3.8.1. <code class="function">igraph_matrix_all_e</code> —  Are all elements equal?</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.9.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_matrix_all_e(const igraph_matrix_t *lhs,
        const igraph_matrix_t *rhs);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>lhs</code></em>:</span></p></td>
<td><p>
  The first matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rhs</code></em>:</span></p></td>
<td><p>
  The second matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (=true) if the elements in the <em class="parameter"><code>lhs</code></em> are all
   equal to the corresponding elements in <em class="parameter"><code>rhs</code></em>. Returns <code class="constant">0</code>
   (=false) if the dimensions of the matrices don't match.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nm), the size of the matrices.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_all_l"></a>3.8.2. <code class="function">igraph_matrix_all_l</code> —  Are all elements less?</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.9.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_matrix_all_l(const igraph_matrix_t *lhs,
        const igraph_matrix_t *rhs);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>lhs</code></em>:</span></p></td>
<td><p>
  The first matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rhs</code></em>:</span></p></td>
<td><p>
  The second matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (=true) if the elements in the <em class="parameter"><code>lhs</code></em> are all
   less than the corresponding elements in <em class="parameter"><code>rhs</code></em>. Returns <code class="constant">0</code>
   (=false) if the dimensions of the matrices don't match.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nm), the size of the matrices.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_all_g"></a>3.8.3. <code class="function">igraph_matrix_all_g</code> —  Are all elements greater?</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.9.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_matrix_all_g(const igraph_matrix_t *lhs,
        const igraph_matrix_t *rhs);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>lhs</code></em>:</span></p></td>
<td><p>
  The first matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rhs</code></em>:</span></p></td>
<td><p>
  The second matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (=true) if the elements in the <em class="parameter"><code>lhs</code></em> are all
   greater than the corresponding elements in <em class="parameter"><code>rhs</code></em>. Returns <code class="constant">0</code>
   (=false) if the dimensions of the matrices don't match.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nm), the size of the matrices.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_all_le"></a>3.8.4. <code class="function">igraph_matrix_all_le</code> —  Are all elements less or equal?</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.9.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t
igraph_matrix_all_le(const igraph_matrix_t *lhs,
                                const igraph_matrix_t *rhs);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>lhs</code></em>:</span></p></td>
<td><p>
  The first matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rhs</code></em>:</span></p></td>
<td><p>
  The second matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (=true) if the elements in the <em class="parameter"><code>lhs</code></em> are all
   less than or equal to the corresponding elements in <em class="parameter"><code>rhs</code></em>. Returns <code class="constant">0</code> (=false) if the dimensions of the matrices
   don't match.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nm), the size of the matrices.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_all_ge"></a>3.8.5. <code class="function">igraph_matrix_all_ge</code> —  Are all elements greater or equal?</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.9.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t
igraph_matrix_all_ge(const igraph_matrix_t *lhs,
                                const igraph_matrix_t *rhs);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>lhs</code></em>:</span></p></td>
<td><p>
  The first matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rhs</code></em>:</span></p></td>
<td><p>
  The second matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Positive integer (=true) if the elements in the <em class="parameter"><code>lhs</code></em> are all
   greater than or equal to the corresponding elements in <em class="parameter"><code>rhs</code></em>. Returns <code class="constant">0</code> (=false) if the dimensions of the matrices
   don't match.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nm), the size of the matrices.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="combining-matrices"></a>3.9. Combining matrices</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_rbind">3.9.1. <code class="function">igraph_matrix_rbind</code> — Combine two matrices rowwise.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_cbind">3.9.2. <code class="function">igraph_matrix_cbind</code> — Combine matrices columnwise.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_rbind"></a>3.9.1. <code class="function">igraph_matrix_rbind</code> — Combine two matrices rowwise.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.10.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_rbind(igraph_matrix_t *to,
                                   const igraph_matrix_t *from);
</pre></div>
<p>
</p>
<p>



This function places the rows of <em class="parameter"><code>from</code></em> below the rows of <code class="constant">to</code>
and stores the result in <em class="parameter"><code>to</code></em>. The number of columns in the two
matrices must match.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The upper matrix; the result is also stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The lower matrix. It is left unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements in the newly created
matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_cbind"></a>3.9.2. <code class="function">igraph_matrix_cbind</code> — Combine matrices columnwise.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.10.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_cbind(igraph_matrix_t *to,
                                   const igraph_matrix_t *from);
</pre></div>
<p>
</p>
<p>



This function places the columns of <em class="parameter"><code>from</code></em> on the right of <em class="parameter"><code>to</code></em>,
and stores the result in <em class="parameter"><code>to</code></em>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The left matrix; the result is stored here too.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The right matrix. It is left unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements on the new matrix.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="matrix-finding-minimum-and-maximum"></a>3.10. Finding minimum and maximum</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_min">3.10.1. <code class="function">igraph_matrix_min</code> —  Smallest element of a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_max">3.10.2. <code class="function">igraph_matrix_max</code> —  Largest element of a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_which_min">3.10.3. <code class="function">igraph_matrix_which_min</code> —  Indices of the smallest element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_which_max">3.10.4. <code class="function">igraph_matrix_which_max</code> —  Indices of the largest element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_minmax">3.10.5. <code class="function">igraph_matrix_minmax</code> —  Minimum and maximum elements of a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_which_minmax">3.10.6. <code class="function">igraph_matrix_which_minmax</code> —  Indices of the minimum and maximum elements</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_min"></a>3.10.1. <code class="function">igraph_matrix_min</code> —  Smallest element of a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.11.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_matrix_min(const igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>



The matrix must be non-empty.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The smallest element of <em class="parameter"><code>m</code></em>, or NaN if any element is NaN.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_max"></a>3.10.2. <code class="function">igraph_matrix_max</code> —  Largest element of a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.11.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_matrix_max(const igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>



</p>
<p>
If the matrix is empty, an arbitrary number is returned.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The maximum element of <em class="parameter"><code>m</code></em>, or NaN if any element is NaN.
  </p></td>
</tr></tbody>
</table></div>
<p>

Added in version 0.2.</p>
<p>

Time complexity: O(mn), the number of elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_which_min"></a>3.10.3. <code class="function">igraph_matrix_which_min</code> —  Indices of the smallest element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.11.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_which_min(const igraph_matrix_t *m,
                                       long int *i, long int *j);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The matrix must be non-empty. If the smallest element is not unique,
then the indices of the first such element are returned. If the matrix contains
NaN values, the indices of the first NaN value are returned.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>i</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long int</span>. The row index of the
  minimum is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>j</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long int</span>. The column index of
  the minimum is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_which_max"></a>3.10.4. <code class="function">igraph_matrix_which_max</code> —  Indices of the largest element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.11.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_which_max(const igraph_matrix_t *m,
                                       long int *i, long int *j);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The matrix must be non-empty. If the largest element is not unique,
then the indices of the first such element are returned. If the matrix contains
NaN values, the indices of the first NaN value are returned.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>i</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long int</span>. The row index of the
  maximum is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>j</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long int</span>. The column index of
  the maximum is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_minmax"></a>3.10.5. <code class="function">igraph_matrix_minmax</code> —  Minimum and maximum elements of a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.11.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_minmax(const igraph_matrix_t *m,
                                    igraph_real_t *min, igraph_real_t *max);
</pre></div>
<p>
</p>
<p>



Handy if you want to have both the smallest and largest element of
a matrix. The matrix is only traversed once. The matrix must be non-empty.
If a matrix contains at least one NaN, both <code class="constant">min</code> and <code class="constant">max</code> will be NaN.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix. It must contain at least one element.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>min</code></em>:</span></p></td>
<td><p>
  Pointer to a base type variable. The minimum is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>max</code></em>:</span></p></td>
<td><p>
  Pointer to a base type variable. The maximum is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_which_minmax"></a>3.10.6. <code class="function">igraph_matrix_which_minmax</code> —  Indices of the minimum and maximum elements</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.11.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_which_minmax(const igraph_matrix_t *m,
        long int *imin, long int *jmin,
        long int *imax, long int *jmax);
</pre></div>
<p>
</p>
<p>



</p>
<p>
Handy if you need the indices of the smallest and largest
elements. The matrix is traversed only once. The matrix must be
non-empty. If the minimum or maximum is not unique, the index
of the first minimum or the first maximum is returned, respectively.
If a matrix contains at least one NaN, both <code class="constant">which_min</code> and <code class="constant">which_max</code>
will point to the first NaN value.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>imin</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long int</span>, the row index of
  the minimum is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>jmin</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long int</span>, the column index of
  the minimum is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>imax</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long int</span>, the row index of
  the maximum is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>jmax</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long int</span>, the column index of
  the maximum is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="matrix-properties"></a>3.11. Matrix properties</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_empty">3.11.1. <code class="function">igraph_matrix_empty</code> — Check for an empty matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_isnull">3.11.2. <code class="function">igraph_matrix_isnull</code> — Check for a null matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_size">3.11.3. <code class="function">igraph_matrix_size</code> —  The number of elements in a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_capacity">3.11.4. <code class="function">igraph_matrix_capacity</code> —  Returns the number of elements allocated for a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_nrow">3.11.5. <code class="function">igraph_matrix_nrow</code> —  The number of rows in a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_ncol">3.11.6. <code class="function">igraph_matrix_ncol</code> —  The number of columns in a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_is_symmetric">3.11.7. <code class="function">igraph_matrix_is_symmetric</code> — Check for symmetric matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_maxdifference">3.11.8. <code class="function">igraph_matrix_maxdifference</code> —  Maximum absolute difference between two matrices.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_empty"></a>3.11.1. <code class="function">igraph_matrix_empty</code> — Check for an empty matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.12.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_matrix_empty(const igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>



It is possible to have a matrix with zero rows or zero columns, or
even both. This functions checks for these.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Boolean, <code class="constant">TRUE</code> if the matrix contains zero elements, and
   <code class="constant">FALSE</code> otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_isnull"></a>3.11.2. <code class="function">igraph_matrix_isnull</code> — Check for a null matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.12.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_matrix_isnull(const igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>



Checks whether all elements are zero.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Boolean, <code class="constant">TRUE</code> is <em class="parameter"><code>m</code></em> contains only zeros and <code class="constant">FALSE</code>
  otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_size"></a>3.11.3. <code class="function">igraph_matrix_size</code> —  The number of elements in a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.12.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_matrix_size(const igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The size of the matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_capacity"></a>3.11.4. <code class="function">igraph_matrix_capacity</code> —  Returns the number of elements allocated for a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.12.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_matrix_capacity(const igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>




Note that this might be different from the size of the matrix (as
queried by <a class="link" href="igraph-Data-structures.html#igraph_matrix_size" title="3.11.3. igraph_matrix_size — The number of elements in a matrix."><code class="function">igraph_matrix_size()</code></a>, and specifies how many elements
the matrix can hold, without reallocation.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  Pointer to the (previously initialized) matrix object
         to query.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The allocated capacity.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Data-structures.html#igraph_matrix_size" title="3.11.3. igraph_matrix_size — The number of elements in a matrix."><code class="function">igraph_matrix_size()</code></a>, <a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix."><code class="function">igraph_matrix_nrow()</code></a>,
<a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix."><code class="function">igraph_matrix_ncol()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_nrow"></a>3.11.5. <code class="function">igraph_matrix_nrow</code> —  The number of rows in a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.12.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_matrix_nrow(const igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of rows in the matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_ncol"></a>3.11.6. <code class="function">igraph_matrix_ncol</code> —  The number of columns in a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.12.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_matrix_ncol(const igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of columns in the matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_is_symmetric"></a>3.11.7. <code class="function">igraph_matrix_is_symmetric</code> — Check for symmetric matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.12.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_matrix_is_symmetric(const igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>



A non-square matrix is not symmetric by definition.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Boolean, <code class="constant">TRUE</code> if the matrix is square and symmetric, <code class="constant">FALSE</code> otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements. O(1) for non-square
matrices.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_maxdifference"></a>3.11.8. <code class="function">igraph_matrix_maxdifference</code> —  Maximum absolute difference between two matrices.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.12.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_matrix_maxdifference(const igraph_matrix_t *m1,
        const igraph_matrix_t *m2);
</pre></div>
<p>
</p>
<p>



Calculate the maximum absolute difference of two matrices. Both matrices
must be non-empty. If their dimensions differ then a warning is given and
the comparison is performed by vectors columnwise from both matrices.
The remaining elements in the larger vector are ignored.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m1</code></em>:</span></p></td>
<td><p>
  The first matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m2</code></em>:</span></p></td>
<td><p>
  The second matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The element with the largest absolute value in <code class="constant">m1</code> - <code class="constant">m2</code>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the elements in the smaller matrix.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="matrix-searching-for-elements"></a>3.12. Searching for elements</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_contains">3.12.1. <code class="function">igraph_matrix_contains</code> — Search for an element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_search">3.12.2. <code class="function">igraph_matrix_search</code> — Search from a given position.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_contains"></a>3.12.1. <code class="function">igraph_matrix_contains</code> — Search for an element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.13.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_matrix_contains(const igraph_matrix_t *m,
        igraph_real_t e);
</pre></div>
<p>
</p>
<p>



Search for the given element in the matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>e</code></em>:</span></p></td>
<td><p>
  The element to search for.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Boolean, <code class="constant">TRUE</code> if the matrix contains <em class="parameter"><code>e</code></em>, <code class="constant">FALSE</code>
otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_search"></a>3.12.2. <code class="function">igraph_matrix_search</code> — Search from a given position.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.13.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_matrix_search(const igraph_matrix_t *m,
        long int from, igraph_real_t what,
        long int *pos,
        long int *row, long int *col);
</pre></div>
<p>
</p>
<p>



Search for an element in a matrix and start the search from the
given position. The search is performed columnwise.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The position to search from, the positions are
   enumerated columnwise.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>what</code></em>:</span></p></td>
<td><p>
  The element to search for.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pos</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long int</span>. If the element is
   found, then this is set to the position of its first appearance.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>row</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long int</span>. If the element is
   found, then this is set to its row index.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>col</code></em>:</span></p></td>
<td><p>
  Pointer to a <span class="type">long int</span>. If the element is
   found, then this is set to its column index.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Boolean, <code class="constant">TRUE</code> if the element is found, <code class="constant">FALSE</code>
   otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="matrix-resizing-operations"></a>3.13. Resizing operations</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_resize">3.13.1. <code class="function">igraph_matrix_resize</code> —  Resizes a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_resize_min">3.13.2. <code class="function">igraph_matrix_resize_min</code> —  Deallocates unused memory for a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_add_rows">3.13.3. <code class="function">igraph_matrix_add_rows</code> —  Adds rows to a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_add_cols">3.13.4. <code class="function">igraph_matrix_add_cols</code> —  Adds columns to a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_remove_row">3.13.5. <code class="function">igraph_matrix_remove_row</code> — Remove a row.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_remove_col">3.13.6. <code class="function">igraph_matrix_remove_col</code> —  Removes a column from a matrix.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_resize"></a>3.13.1. <code class="function">igraph_matrix_resize</code> —  Resizes a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.14.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_resize(igraph_matrix_t *m, long int nrow, long int ncol);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function resizes a matrix by adding more elements to it.
The matrix contains arbitrary data after resizing it.
That is, after calling this function you cannot expect that element
(i,j) in the matrix remains the
same as before.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to an already initialized matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nrow</code></em>:</span></p></td>
<td><p>
  The number of rows in the resized matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ncol</code></em>:</span></p></td>
<td><p>
  The number of columns in the resized matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1) if the
matrix gets smaller, usually O(n)
if it gets larger, n is the
number of elements in the resized matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_resize_min"></a>3.13.2. <code class="function">igraph_matrix_resize_min</code> —  Deallocates unused memory for a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.14.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_resize_min(igraph_matrix_t *m);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Note that this function might fail if there is not enough memory
available.

</p>
<p>
Also note, that this function leaves the matrix intact, i.e.
it does not destroy any of the elements. However, usually it involves
copying the matrix in memory.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Data-structures.html#igraph_matrix_resize" title="3.13.1. igraph_matrix_resize — Resizes a matrix."><code class="function">igraph_matrix_resize()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: operating system dependent.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_add_rows"></a>3.13.3. <code class="function">igraph_matrix_add_rows</code> —  Adds rows to a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.14.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_add_rows(igraph_matrix_t *m, long int n);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of rows to add.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, <code class="constant">IGRAPH_ENOMEM</code> if there
  isn't enough memory for the operation.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: linear with the number of elements of the new,
resized matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_add_cols"></a>3.13.4. <code class="function">igraph_matrix_add_cols</code> —  Adds columns to a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.14.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_add_cols(igraph_matrix_t *m, long int n);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of columns to add.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, <code class="constant">IGRAPH_ENOMEM</code> if there is
  not enough memory to perform the operation.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: linear with the number of elements of the new,
resized matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_remove_row"></a>3.13.5. <code class="function">igraph_matrix_remove_row</code> — Remove a row.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.14.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_remove_row(igraph_matrix_t *m, long int row);
</pre></div>
<p>
</p>
<p>



A row is removed from the matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>row</code></em>:</span></p></td>
<td><p>
  The index of the row to remove.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_remove_col"></a>3.13.6. <code class="function">igraph_matrix_remove_col</code> —  Removes a column from a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.4.14.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_remove_col(igraph_matrix_t *m, long int col);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>col</code></em>:</span></p></td>
<td><p>
  The column to remove.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, always returns with success.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: linear with the number of elements of the new,
resized matrix.
 
</p>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="igraph-SparseMatrices"></a>4. Sparse matrices</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#about-spmatrix">4.1.  About <span class="type">igraph_spmatrix_t</span> objects</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#spmatrix-constructor-and-destructor">4.2.  Sparse matrix constructors
and destructors.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#spmatrix-accessing-elements">4.3.  Accessing elements of a sparse matrix</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#spmatrix-iterating">4.4.  Iterating over the non-zero elements of a sparse matrix</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#spmatrix-query-operations">4.5. Matrix query operations</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#spmatrix-operations">4.6. Matrix operations</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#spmatrix-printing">4.7. Printing sparse matrices</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="about-spmatrix"></a>4.1.  About <span class="type">igraph_spmatrix_t</span> objects</h3></div></div></div>
<p>The <span class="type">igraph_spmatrix_t</span> type stores a sparse matrix with the
assumption that the number of nonzero elements in the matrix scales
linearly with the row or column count of the matrix (so most of the
elements are zero). Of course it can store an arbitrary real matrix,
but if most of the elements are nonzero, one should use <span class="type">igraph_matrix_t</span>
instead.</p>
<p>The elements are stored in column compressed format, so the elements
in the same column are stored adjacent in the computer's memory. The storage
requirement for a sparse matrix is O(n) where n is the number of nonzero
elements. Actually it can be a bit larger, see the documentation of
the vector type for an explanation.</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="spmatrix-constructor-and-destructor"></a>4.2.  Sparse matrix constructors
and destructors.</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_init">4.2.1. <code class="function">igraph_spmatrix_init</code> —  Initializes a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_copy">4.2.2. <code class="function">igraph_spmatrix_copy</code> —  Copies a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_destroy">4.2.3. <code class="function">igraph_spmatrix_destroy</code> —  Destroys a sparse matrix object.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_init"></a>4.2.1. <code class="function">igraph_spmatrix_init</code> —  Initializes a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.3.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_init(igraph_spmatrix_t *m, long int nrow, long int ncol);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Every sparse matrix needs to be initialized before using it, this is done
by calling this function. A matrix has to be destroyed if it is not
needed any more, see <a class="link" href="igraph-Data-structures.html#igraph_spmatrix_destroy" title="4.2.3. igraph_spmatrix_destroy — Destroys a sparse matrix object."><code class="function">igraph_spmatrix_destroy()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to a not yet initialized sparse matrix object to be
       initialized.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nrow</code></em>:</span></p></td>
<td><p>
  The number of rows in the matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ncol</code></em>:</span></p></td>
<td><p>
  The number of columns in the matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: operating system dependent.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_copy"></a>4.2.2. <code class="function">igraph_spmatrix_copy</code> —  Copies a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.3.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_copy(igraph_spmatrix_t *to, const igraph_spmatrix_t *from);
</pre></div>
<p>
</p>
<p>




</p>
<p>
Creates a sparse matrix object by copying another one.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized sparse matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The initialized sparse matrix object to copy.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, <code class="constant">IGRAPH_ENOMEM</code> if there
  isn't enough memory to allocate the new sparse matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number
of elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_destroy"></a>4.2.3. <code class="function">igraph_spmatrix_destroy</code> —  Destroys a sparse matrix object.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.3.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_spmatrix_destroy(igraph_spmatrix_t *m);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function frees all the memory allocated for a sparse matrix
object. The destroyed object needs to be reinitialized before using
it again.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix to destroy.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: operating system dependent.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="spmatrix-accessing-elements"></a>4.3.  Accessing elements of a sparse matrix</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_e">4.3.1. <code class="function">igraph_spmatrix_e</code> —  Accessing an element of a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_set">4.3.2. <code class="function">igraph_spmatrix_set</code> —  Setting an element of a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_add_e">4.3.3. <code class="function">igraph_spmatrix_add_e</code> —  Adding a real value to an element of a sparse matrix.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_e"></a>4.3.1. <code class="function">igraph_spmatrix_e</code> —  Accessing an element of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.4.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_spmatrix_e(const igraph_spmatrix_t *m,
                                long int row, long int col);
</pre></div>
<p>
</p>
<p>




Note that there are no range checks right now.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>row</code></em>:</span></p></td>
<td><p>
  The index of the row, starting with zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>col</code></em>:</span></p></td>
<td><p>
  The index of the column, starting with zero.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(log n), where n is the number of nonzero elements in
the requested column.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_set"></a>4.3.2. <code class="function">igraph_spmatrix_set</code> —  Setting an element of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.4.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_set(igraph_spmatrix_t *m, long int row, long int col,
                        igraph_real_t value);
</pre></div>
<p>
</p>
<p>




Note that there are no range checks right now.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>row</code></em>:</span></p></td>
<td><p>
  The index of the row, starting with zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>col</code></em>:</span></p></td>
<td><p>
  The index of the column, starting with zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  The new value.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(log n), where n is the number of nonzero elements in
the requested column.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_add_e"></a>4.3.3. <code class="function">igraph_spmatrix_add_e</code> —  Adding a real value to an element of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.4.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_add_e(igraph_spmatrix_t *m, long int row, long int col,
                          igraph_real_t value);
</pre></div>
<p>
</p>
<p>




Note that there are no range checks right now. This is implemented to avoid
double lookup of a given element in the matrix by using <a class="link" href="igraph-Data-structures.html#igraph_spmatrix_e" title="4.3.1. igraph_spmatrix_e — Accessing an element of a sparse matrix."><code class="function">igraph_spmatrix_e()</code></a>
and <a class="link" href="igraph-Data-structures.html#igraph_spmatrix_set" title="4.3.2. igraph_spmatrix_set — Setting an element of a sparse matrix."><code class="function">igraph_spmatrix_set()</code></a> consecutively.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>row</code></em>:</span></p></td>
<td><p>
  The index of the row, starting with zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>col</code></em>:</span></p></td>
<td><p>
  The index of the column, starting with zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  The value to add.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(log n), where n is the number of nonzero elements in
the requested column.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="spmatrix-iterating"></a>4.4.  Iterating over the non-zero elements of a sparse matrix</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_iter_create">4.4.1. <code class="function">igraph_spmatrix_iter_create</code> —  Creates a sparse matrix iterator corresponding to the given matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_iter_reset">4.4.2. <code class="function">igraph_spmatrix_iter_reset</code> —  Resets a sparse matrix iterator.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_iter_next">4.4.3. <code class="function">igraph_spmatrix_iter_next</code> —  Moves a sparse matrix iterator to the next nonzero element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_iter_end">4.4.4. <code class="function">igraph_spmatrix_iter_end</code> —  Checks whether there are more elements in the iterator.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_iter_destroy">4.4.5. <code class="function">igraph_spmatrix_iter_destroy</code> —  Frees the memory used by the iterator.</a></span></dt>
</dl></div>
<p>The <span class="type">igraph_spmatrix_iter_t</span> type represents an iterator that can
be used to step over the non-zero elements of a sparse matrix in columnwise
order efficiently. In general, you shouldn't modify the elements of the matrix
while iterating over it; doing so will probably invalidate the iterator, but
there are no checks to prevent you from doing this.</p>
<p>To access the row index of the current element of the iterator, use its
<code class="constant">ri</code> field. Similarly, the <code class="constant">ci</code> field stores the column index of the current
element and the <code class="constant">value</code> field stores the value of the element.</p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_iter_create"></a>4.4.1. <code class="function">igraph_spmatrix_iter_create</code> —  Creates a sparse matrix iterator corresponding to the given matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.5.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_iter_create(igraph_spmatrix_iter_t *mit, const igraph_spmatrix_t *m);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>mit</code></em>:</span></p></td>
<td><p>
  pointer to the matrix iterator being initialized
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  pointer to the matrix we will be iterating over
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code. The current implementation is always successful.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_iter_reset"></a>4.4.2. <code class="function">igraph_spmatrix_iter_reset</code> —  Resets a sparse matrix iterator.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.5.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_iter_reset(igraph_spmatrix_iter_t *mit);
</pre></div>
<p>
</p>
<p>



</p>
<p>
After resetting, the iterator will point to the first nonzero element (if any).

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>mit</code></em>:</span></p></td>
<td><p>
  pointer to the matrix iterator being reset
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code. The current implementation is always successful.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_iter_next"></a>4.4.3. <code class="function">igraph_spmatrix_iter_next</code> —  Moves a sparse matrix iterator to the next nonzero element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.5.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_iter_next(igraph_spmatrix_iter_t *mit);
</pre></div>
<p>
</p>
<p>



</p>
<p>
You should call this function only if <a class="link" href="igraph-Data-structures.html#igraph_spmatrix_iter_end" title="4.4.4. igraph_spmatrix_iter_end — Checks whether there are more elements in the iterator."><code class="function">igraph_spmatrix_iter_end()</code></a>
returns FALSE (0).

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>mit</code></em>:</span></p></td>
<td><p>
  pointer to the matrix iterator being moved
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code. The current implementation is always successful.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_iter_end"></a>4.4.4. <code class="function">igraph_spmatrix_iter_end</code> —  Checks whether there are more elements in the iterator.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.5.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_spmatrix_iter_end(igraph_spmatrix_iter_t *mit);
</pre></div>
<p>
</p>
<p>



</p>
<p>
You should call this function before calling <a class="link" href="igraph-Data-structures.html#igraph_spmatrix_iter_next" title="4.4.3. igraph_spmatrix_iter_next — Moves a sparse matrix iterator to the next nonzero element."><code class="function">igraph_spmatrix_iter_next()</code></a>
to make sure you have more elements in the iterator.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>mit</code></em>:</span></p></td>
<td><p>
  pointer to the matrix iterator being checked
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  TRUE (1) if there are more elements in the iterator,
          FALSE (0) otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_iter_destroy"></a>4.4.5. <code class="function">igraph_spmatrix_iter_destroy</code> —  Frees the memory used by the iterator.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.5.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_spmatrix_iter_destroy(igraph_spmatrix_iter_t *mit);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The current implementation does not allocate any memory upon
creation, so this function does nothing. However, since there is
no guarantee that future implementations will not allocate any
memory in <a class="link" href="igraph-Data-structures.html#igraph_spmatrix_iter_create" title="4.4.1. igraph_spmatrix_iter_create — Creates a sparse matrix iterator corresponding to the given matrix."><code class="function">igraph_spmatrix_iter_create()</code></a>, you are still
required to call this function whenever you are done with the
iterator.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>mit</code></em>:</span></p></td>
<td><p>
  pointer to the matrix iterator being destroyed</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="spmatrix-query-operations"></a>4.5. Matrix query operations</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_size">4.5.1. <code class="function">igraph_spmatrix_size</code> —  The number of elements in a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_nrow">4.5.2. <code class="function">igraph_spmatrix_nrow</code> —  The number of rows in a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_ncol">4.5.3. <code class="function">igraph_spmatrix_ncol</code> —  The number of columns in a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_count_nonzero">4.5.4. <code class="function">igraph_spmatrix_count_nonzero</code> —  The number of non-zero elements in a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_max">4.5.5. <code class="function">igraph_spmatrix_max</code> —  Returns the maximum element of a matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_rowsums">4.5.6. <code class="function">igraph_spmatrix_rowsums</code> —  Calculates the row sums of the matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_colsums">4.5.7. <code class="function">igraph_spmatrix_colsums</code> —  Calculates the column sums of the matrix.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_size"></a>4.5.1. <code class="function">igraph_spmatrix_size</code> —  The number of elements in a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.6.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_spmatrix_size(const igraph_spmatrix_t *m);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized sparse matrix object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The size of the matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_nrow"></a>4.5.2. <code class="function">igraph_spmatrix_nrow</code> —  The number of rows in a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.6.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_spmatrix_nrow(const igraph_spmatrix_t *m);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized sparse matrix object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of rows in the matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_ncol"></a>4.5.3. <code class="function">igraph_spmatrix_ncol</code> —  The number of columns in a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.6.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_spmatrix_ncol(const igraph_spmatrix_t *m);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized sparse matrix object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of columns in the sparse matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_count_nonzero"></a>4.5.4. <code class="function">igraph_spmatrix_count_nonzero</code> —  The number of non-zero elements in a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.6.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_spmatrix_count_nonzero(const igraph_spmatrix_t *m);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized sparse matrix object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The size of the matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_max"></a>4.5.5. <code class="function">igraph_spmatrix_max</code> —  Returns the maximum element of a matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.6.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_spmatrix_max(const igraph_spmatrix_t *m,
                                  igraph_real_t *ridx, igraph_real_t *cidx);
</pre></div>
<p>
</p>
<p>


If the matrix is empty, zero is returned.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  the matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ridx</code></em>:</span></p></td>
<td><p>
  the row index of the maximum element if not <code class="constant">NULL</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cidx</code></em>:</span></p></td>
<td><p>
  the column index of the maximum element if not <code class="constant">NULL</code>.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(n), the number of nonzero elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_rowsums"></a>4.5.6. <code class="function">igraph_spmatrix_rowsums</code> —  Calculates the row sums of the matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.6.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_rowsums(const igraph_spmatrix_t *m, igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>


</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized <code class="constant">igraph_vector_t</code>, the result will be stored here.
  The vector will be resized as needed.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(n), the number of nonzero elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_colsums"></a>4.5.7. <code class="function">igraph_spmatrix_colsums</code> —  Calculates the column sums of the matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.6.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_colsums(const igraph_spmatrix_t *m, igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>


</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized <code class="constant">igraph_vector_t</code>, the result will be stored here.
  The vector will be resized as needed.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(n), the number of nonzero elements in the matrix.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="spmatrix-operations"></a>4.6. Matrix operations</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_scale">4.6.1. <code class="function">igraph_spmatrix_scale</code> —  Multiplies each element of the sparse matrix by a constant.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_add_rows">4.6.2. <code class="function">igraph_spmatrix_add_rows</code> —  Adds rows to a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_add_cols">4.6.3. <code class="function">igraph_spmatrix_add_cols</code> —  Adds columns to a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_resize">4.6.4. <code class="function">igraph_spmatrix_resize</code> —  Resizes a sparse matrix.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_scale"></a>4.6.1. <code class="function">igraph_spmatrix_scale</code> —  Multiplies each element of the sparse matrix by a constant.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.7.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_spmatrix_scale(igraph_spmatrix_t *m, igraph_real_t by);
</pre></div>
<p>
</p>
<p>


</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>by</code></em>:</span></p></td>
<td><p>
  The constant.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(n), the number of elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_add_rows"></a>4.6.2. <code class="function">igraph_spmatrix_add_rows</code> —  Adds rows to a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.7.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_add_rows(igraph_spmatrix_t *m, long int n);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The sparse matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of rows to add.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_add_cols"></a>4.6.3. <code class="function">igraph_spmatrix_add_cols</code> —  Adds columns to a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.7.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_add_cols(igraph_spmatrix_t *m, long int n);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The sparse matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of columns to add.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_resize"></a>4.6.4. <code class="function">igraph_spmatrix_resize</code> —  Resizes a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.7.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_resize(igraph_spmatrix_t *m, long int nrow, long int ncol);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function resizes a sparse matrix by adding more elements to it.
The matrix retains its data even after resizing it, except for the data
which lies outside the new boundaries (if the new size is smaller).
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Pointer to an already initialized sparse matrix object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nrow</code></em>:</span></p></td>
<td><p>
  The number of rows in the resized matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ncol</code></em>:</span></p></td>
<td><p>
  The number of columns in the resized matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n).
n is the number of elements in the old matrix.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="spmatrix-printing"></a>4.7. Printing sparse matrices</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_print">4.7.1. <code class="function">igraph_spmatrix_print</code> —  Prints a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_spmatrix_fprint">4.7.2. <code class="function">igraph_spmatrix_fprint</code> —  Prints a sparse matrix to the given file.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_print"></a>4.7.1. <code class="function">igraph_spmatrix_print</code> —  Prints a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.8.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_print(const igraph_spmatrix_t* matrix);
</pre></div>
<p>
</p>
<p>



Prints a sparse matrix to the standard output. Only the non-zero entries
are printed.

</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of non-zero elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_spmatrix_fprint"></a>4.7.2. <code class="function">igraph_spmatrix_fprint</code> —  Prints a sparse matrix to the given file.</h4></div></div></div>
<a class="indexterm" name="id-1.8.5.8.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_spmatrix_fprint(const igraph_spmatrix_t* matrix, FILE *file);
</pre></div>
<p>
</p>
<p>



Prints a sparse matrix to the given file. Only the non-zero entries
are printed.

</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of non-zero elements.
 
</p>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="igraph-SparseMatrices2"></a>5. Sparse matrices, another kind</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#about-sparsemat">5.1.  About sparse matrices</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#creating-sparse-matrix-objects">5.2. Creating sparse matrix objects</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#query-properties-of-a-sparse-matrix">5.3. Query properties of a sparse matrix</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#operations-on-sparse-matrices">5.4. Operations on sparse matrices</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#operations-on_sparse_matrix_iterators">5.5. Operations on sparse matrix iterators</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#operations-that-change-the-internal-representation">5.6. Operations that change the internal representation</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#decompositions-and-solving-linear-systems">5.7. Decompositions and solving linear systems</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#eigenvalues-and-eigenvectors">5.8. Eigenvalues and eigenvectors</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#conversion-to-other-data-types">5.9. Conversion to other data types</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#writing-to-a-file-or-to-the-screen">5.10. Writing to a file, or to the screen</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="about-sparsemat"></a>5.1.  About sparse matrices</h3></div></div></div>
<p>
The <code class="literal">igraph_sparsemat_t</code> data type stores sparse matrices,
i.e. matrices in which the majority of the elements are zero.
</p>
<p>The data type is essentially a wrapper to some of the
functions in the CXSparse library, by Tim Davis, see
<a class="ulink" href="http://faculty.cse.tamu.edu/davis/suitesparse.html" target="_top">http://faculty.cse.tamu.edu/davis/suitesparse.html</a>
</p>
<p>
Matrices can be stored in two formats: triplet and
column-compressed. The triplet format is intended for sparse matrix
initialization, as it is easy to add new (non-zero) elements to
it. Most of the computations are done on sparse matrices in
column-compressed format, after the user has converted the triplet
matrix to column-compressed, via <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format."><code class="function">igraph_sparsemat_compress()</code></a>.
</p>
<p>
Both formats are dynamic, in the sense that new elements can be
added to them, possibly resulting the allocation of more memory.
</p>
<p>
Row and column indices follow the C convention and are zero-based.
</p>
<p>
</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.6.2.7.1"></a><p class="title"><b>Example 7.5.  File <code class="code">examples/simple/igraph_sparsemat.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2009-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_sparsemat_t A, B, C, D;
    igraph_t G, H;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> vect;
    long int i;

    <span class="emphasis"><em>/* Create, compress, destroy */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;A, 100, 20, 50);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);

    <span class="emphasis"><em>/* Convert a ring graph to a matrix, print it, compress, print again */</em></span>
<span class="strong"><strong>#define</strong></span> VC 10
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;G, VC, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_get_sparsemat" title="5.9.2. igraph_get_sparsemat — Converts an igraph graph to a sparse matrix.">igraph_get_sparsemat</a></strong></span>(&amp;G, &amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;G);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;A, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;B, stdout);

    <span class="emphasis"><em>/* Basic query, nrow, ncol, type, is_triplet, is_cc */</em></span>
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_nrow" title="5.3.2. igraph_sparsemat_nrow — Number of rows.">igraph_sparsemat_nrow</a></strong></span>(&amp;A) != VC ||
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_ncol" title="5.3.3. igraph_sparsemat_ncol — Number of columns.">igraph_sparsemat_ncol</a></strong></span>(&amp;A) != VC ||
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_nrow" title="5.3.2. igraph_sparsemat_nrow — Number of rows.">igraph_sparsemat_nrow</a></strong></span>(&amp;B) != VC ||
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_ncol" title="5.3.3. igraph_sparsemat_ncol — Number of columns.">igraph_sparsemat_ncol</a></strong></span>(&amp;B) != VC) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_is_triplet" title="5.3.5. igraph_sparsemat_is_triplet — Is this sparse matrix in triplet format?">igraph_sparsemat_is_triplet</a></strong></span>(&amp;A)) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_is_cc" title="5.3.6. igraph_sparsemat_is_cc — Is this sparse matrix in column-compressed format?">igraph_sparsemat_is_cc</a></strong></span>(&amp;B))      {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_type" title="5.3.4. igraph_sparsemat_type — Type of a sparse matrix (triplet or column-compressed).">igraph_sparsemat_type</a></strong></span>(&amp;A) != IGRAPH_SPARSEMAT_TRIPLET) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_type" title="5.3.4. igraph_sparsemat_type — Type of a sparse matrix (triplet or column-compressed).">igraph_sparsemat_type</a></strong></span>(&amp;B) != IGRAPH_SPARSEMAT_CC)      {
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);
<span class="strong"><strong>#undef</strong></span> VC

    <span class="strong"><strong>printf</strong></span>("------------------------\n");

    <span class="emphasis"><em>/* Create unit matrices */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_eye" title="5.2.5. igraph_sparsemat_eye — Creates a sparse identity matrix.">igraph_sparsemat_eye</a></strong></span>(&amp;A, <span class="emphasis"><em>/*n=*/</em></span> 5, <span class="emphasis"><em>/*nzmax=*/</em></span> 5, <span class="emphasis"><em>/*value=*/</em></span> 1.0,
                         <span class="emphasis"><em>/*compress=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_eye" title="5.2.5. igraph_sparsemat_eye — Creates a sparse identity matrix.">igraph_sparsemat_eye</a></strong></span>(&amp;B, <span class="emphasis"><em>/*n=*/</em></span> 5, <span class="emphasis"><em>/*nzmax=*/</em></span> 5, <span class="emphasis"><em>/*value=*/</em></span> 1.0,
                         <span class="emphasis"><em>/*compress=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;A, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;B, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);

    <span class="strong"><strong>printf</strong></span>("------------------------\n");

    <span class="emphasis"><em>/* Create diagonal matrices */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;vect, 5);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 5; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(vect)[i] = i;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_diag" title="5.2.6. igraph_sparsemat_diag — Creates a sparse diagonal matrix.">igraph_sparsemat_diag</a></strong></span>(&amp;A, <span class="emphasis"><em>/*nzmax=*/</em></span> 5, <span class="emphasis"><em>/*values=*/</em></span> &amp;vect, <span class="emphasis"><em>/*compress=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_diag" title="5.2.6. igraph_sparsemat_diag — Creates a sparse diagonal matrix.">igraph_sparsemat_diag</a></strong></span>(&amp;B, <span class="emphasis"><em>/*nzmax=*/</em></span> 5, <span class="emphasis"><em>/*values=*/</em></span> &amp;vect, <span class="emphasis"><em>/*compress=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;vect);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;A, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;B, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);

    <span class="strong"><strong>printf</strong></span>("------------------------\n");

    <span class="emphasis"><em>/* Transpose matrices */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_tree" title="1.9. igraph_tree — Creates a tree in which almost all vertices have the same number of children.">igraph_tree</a></strong></span>(&amp;G, 10, <span class="emphasis"><em>/*children=*/</em></span> 2, IGRAPH_TREE_OUT);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_get_sparsemat" title="5.9.2. igraph_get_sparsemat — Converts an igraph graph to a sparse matrix.">igraph_get_sparsemat</a></strong></span>(&amp;G, &amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;G);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;B, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_transpose" title="5.4.7. igraph_sparsemat_transpose — Transposes a sparse matrix.">igraph_sparsemat_transpose</a></strong></span>(&amp;B, &amp;C, <span class="emphasis"><em>/*values=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;C, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;C);

    <span class="strong"><strong>printf</strong></span>("------------------------\n");

    <span class="emphasis"><em>/* Add duplicate elements */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;A, 10, 10, <span class="emphasis"><em>/*nzmax=*/</em></span> 20);
    <span class="strong"><strong>for</strong></span> (i = 1; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, 0, i, 1.0);
    }
    <span class="strong"><strong>for</strong></span> (i = 1; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, 0, i, 1.0);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;A, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;B, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dupl" title="5.6.2. igraph_sparsemat_dupl — Removes duplicate elements from a sparse matrix.">igraph_sparsemat_dupl</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;B, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);

    <span class="strong"><strong>printf</strong></span>("------------------------\n");

    <span class="emphasis"><em>/* Drop zero elements */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;A, 10, 10, <span class="emphasis"><em>/*nzmax=*/</em></span> 20);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, 7, 3, 0.0);
    <span class="strong"><strong>for</strong></span> (i = 1; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, 0, i, 1.0);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, 0, i, 0.0);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, 0, 0, 0.0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;A, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;B, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dropzeros" title="5.4.3. igraph_sparsemat_dropzeros — Drops the zero elements from a sparse matrix.">igraph_sparsemat_dropzeros</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;B, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);

    <span class="strong"><strong>printf</strong></span>("------------------------\n");

    <span class="emphasis"><em>/* Add two matrices */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.6. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;G, 10, IGRAPH_STAR_OUT, <span class="emphasis"><em>/*center=*/</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.8. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;H, 10, <span class="emphasis"><em>/*directed=*/</em></span> 0, <span class="emphasis"><em>/*mutual=*/</em></span> 0, <span class="emphasis"><em>/*circular=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_get_sparsemat" title="5.9.2. igraph_get_sparsemat — Converts an igraph graph to a sparse matrix.">igraph_get_sparsemat</a></strong></span>(&amp;G, &amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_get_sparsemat" title="5.9.2. igraph_get_sparsemat — Converts an igraph graph to a sparse matrix.">igraph_get_sparsemat</a></strong></span>(&amp;H, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;G);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;H);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;C);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;B, &amp;D);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_add" title="5.4.8. igraph_sparsemat_add — Sum of two sparse matrices.">igraph_sparsemat_add</a></strong></span>(&amp;C, &amp;D, <span class="emphasis"><em>/*alpha=*/</em></span> 1.0, <span class="emphasis"><em>/*beta=*/</em></span> 2.0, &amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;C);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;D);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_print" title="5.10.1. igraph_sparsemat_print — Prints a sparse matrix to a file.">igraph_sparsemat_print</a></strong></span>(&amp;A, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.6.2.7.2"></a><p class="title"><b>Example 7.6.  File <code class="code">examples/simple/igraph_sparsemat3.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2009-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#define</strong></span> NCOMPLEX  <span class="emphasis"><em>/* to make it compile with MSVC on Windows */</em></span>

<span class="strong"><strong>#include</strong></span> &lt;cs.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>permute</strong></span>(<span class="strong"><strong>const</strong></span> igraph_matrix_t *M,
            <span class="strong"><strong>const</strong></span> igraph_vector_int_t *p,
            <span class="strong"><strong>const</strong></span> igraph_vector_int_t *q,
            igraph_matrix_t *res) {

    long int nrow = <span class="strong"><strong>igraph_vector_int_size</strong></span>(p);
    long int ncol = <span class="strong"><strong>igraph_vector_int_size</strong></span>(q);
    long int i, j;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_resize" title="3.13.1. igraph_matrix_resize — Resizes a matrix.">igraph_matrix_resize</a></strong></span>(res, nrow, ncol);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; nrow; i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; ncol; j++) {
            int ii = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*p)[i];
            int jj = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*q)[j];
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*res, i, j) = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*M, ii, jj);
        }
    }

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>permute_rows</strong></span>(<span class="strong"><strong>const</strong></span> igraph_matrix_t *M,
                 <span class="strong"><strong>const</strong></span> igraph_vector_int_t *p,
                 igraph_matrix_t *res) {

    long int nrow = <span class="strong"><strong>igraph_vector_int_size</strong></span>(p);
    long int ncol = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(M);
    long int i, j;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_resize" title="3.13.1. igraph_matrix_resize — Resizes a matrix.">igraph_matrix_resize</a></strong></span>(res, nrow, ncol);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; nrow; i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; ncol; j++) {
            int ii = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*p)[i];
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*res, i, j) = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*M, ii, j);
        }
    }

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>permute_cols</strong></span>(<span class="strong"><strong>const</strong></span> igraph_matrix_t *M,
                 <span class="strong"><strong>const</strong></span> igraph_vector_int_t *q,
                 igraph_matrix_t *res) {

    long int nrow = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(M);
    long int ncol = <span class="strong"><strong>igraph_vector_int_size</strong></span>(q);
    long int i, j;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_resize" title="3.13.1. igraph_matrix_resize — Resizes a matrix.">igraph_matrix_resize</a></strong></span>(res, nrow, ncol);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; nrow; i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; ncol; j++) {
            int jj = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*q)[j];
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*res, i, j) = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*M, i, jj);
        }
    }

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>random_permutation</strong></span>(igraph_vector_int_t *vec) {
    <span class="emphasis"><em>/* We just do size(vec) * 2 swaps */</em></span>
    long int one, two, i, n = <span class="strong"><strong>igraph_vector_int_size</strong></span>(vec);
    int tmp;
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 2 * n; i++) {
        one = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, n - 1);
        two = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, n - 1);
        tmp = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec)[one];
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec)[one] = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec)[two];
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec)[two] = tmp;
    }
    <span class="strong"><strong>return</strong></span> 0;
}

igraph_bool_t <span class="strong"><strong>check_same</strong></span>(<span class="strong"><strong>const</strong></span> igraph_sparsemat_t *A,
                         <span class="strong"><strong>const</strong></span> igraph_matrix_t *M) {

    long int nrow = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_nrow" title="5.3.2. igraph_sparsemat_nrow — Number of rows.">igraph_sparsemat_nrow</a></strong></span>(A);
    long int ncol = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_ncol" title="5.3.3. igraph_sparsemat_ncol — Number of columns.">igraph_sparsemat_ncol</a></strong></span>(A);
    long int j, p, nzero = 0;

    <span class="strong"><strong>if</strong></span> (nrow != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(M) ||
        ncol != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(M)) {
        <span class="strong"><strong>return</strong></span> 0;
    }

    <span class="strong"><strong>for</strong></span> (j = 0; j &lt; A-&gt;cs-&gt;n; j++) {
        <span class="strong"><strong>for</strong></span> (p = A-&gt;cs-&gt;p[j]; p &lt; A-&gt;cs-&gt;p[j + 1]; p++) {
            long int to = A-&gt;cs-&gt;i[p];
            igraph_real_t value = A-&gt;cs-&gt;x[p];
            <span class="strong"><strong>if</strong></span> (value != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*M, to, j)) {
                <span class="strong"><strong>return</strong></span> 0;
            }
            nzero += 1;
        }
    }

    <span class="strong"><strong>for</strong></span> (j = 0; j &lt; nrow; j++) {
        <span class="strong"><strong>for</strong></span> (p = 0; p &lt; ncol; p++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(*M, j, p) != 0) {
                nzero -= 1;
            }
        }
    }

    <span class="strong"><strong>return</strong></span> nzero == 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_sparsemat_t A, B;
    igraph_matrix_t M, N;
    igraph_vector_int_t p, q;
    long int i;

    <span class="emphasis"><em>/* Permutation of a matrix */</em></span>

<span class="strong"><strong>#define</strong></span> NROW 10
<span class="strong"><strong>#define</strong></span> NCOL 5
<span class="strong"><strong>#define</strong></span> EDGES NROW*NCOL/3
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;M, NROW, NCOL);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;A, NROW, NCOL, EDGES);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; EDGES; i++) {
        long int r = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, NROW - 1);
        long int c = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, NCOL - 1);
        igraph_real_t value = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 5);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(M, r, c) = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(M, r, c) + value;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, r, c, value);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);

    <span class="strong"><strong>igraph_vector_int_init_seq</strong></span>(&amp;p, 0, NROW - 1);
    <span class="strong"><strong>igraph_vector_int_init_seq</strong></span>(&amp;q, 0, NCOL - 1);

    <span class="emphasis"><em>/* Identity */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;N, 0, 0);
    <span class="strong"><strong>permute</strong></span>(&amp;M, &amp;p, &amp;q, &amp;N);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_permute" title="5.4.6. igraph_sparsemat_permute — Permutes the rows and columns of a sparse matrix.">igraph_sparsemat_permute</a></strong></span>(&amp;B, &amp;p, &amp;q, &amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dupl" title="5.6.2. igraph_sparsemat_dupl — Removes duplicate elements from a sparse matrix.">igraph_sparsemat_dupl</a></strong></span>(&amp;A);

    <span class="strong"><strong>if</strong></span> (! <span class="strong"><strong>check_same</strong></span>(&amp;A, &amp;N)) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="emphasis"><em>/* Random permutation */</em></span>
    <span class="strong"><strong>random_permutation</strong></span>(&amp;p);
    <span class="strong"><strong>random_permutation</strong></span>(&amp;q);

    <span class="strong"><strong>permute</strong></span>(&amp;M, &amp;p, &amp;q, &amp;N);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_permute" title="5.4.6. igraph_sparsemat_permute — Permutes the rows and columns of a sparse matrix.">igraph_sparsemat_permute</a></strong></span>(&amp;B, &amp;p, &amp;q, &amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dupl" title="5.6.2. igraph_sparsemat_dupl — Removes duplicate elements from a sparse matrix.">igraph_sparsemat_dupl</a></strong></span>(&amp;A);

    <span class="strong"><strong>if</strong></span> (! <span class="strong"><strong>check_same</strong></span>(&amp;A, &amp;N)) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;p);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;q);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;M);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;N);

<span class="strong"><strong>#undef</strong></span> NROW
<span class="strong"><strong>#undef</strong></span> NCOL
<span class="strong"><strong>#undef</strong></span> EDGES

    <span class="emphasis"><em>/* Indexing */</em></span>

<span class="strong"><strong>#define</strong></span> NROW 10
<span class="strong"><strong>#define</strong></span> NCOL 5
<span class="strong"><strong>#define</strong></span> EDGES NROW*NCOL/3
<span class="strong"><strong>#define</strong></span> I_NROW 6
<span class="strong"><strong>#define</strong></span> I_NCOL 3
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;M, NROW, NCOL);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;A, NROW, NCOL, EDGES);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; EDGES; i++) {
        long int r = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, NROW - 1);
        long int c = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, NCOL - 1);
        igraph_real_t value = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 5);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(M, r, c) = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(M, r, c) + value;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, r, c, value);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);

    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;p, I_NROW);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;q, I_NCOL);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; I_NROW; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(p)[i] = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, I_NROW - 1);
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; I_NCOL; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(p)[i] = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, I_NCOL - 1);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;N, 0, 0);
    <span class="strong"><strong>permute</strong></span>(&amp;M, &amp;p, &amp;q, &amp;N);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_index" title="5.3.1. igraph_sparsemat_index — Extracts a submatrix or a single element.">igraph_sparsemat_index</a></strong></span>(&amp;B, &amp;p, &amp;q, &amp;A, 0);

    <span class="strong"><strong>if</strong></span> (! <span class="strong"><strong>check_same</strong></span>(&amp;A, &amp;N)) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="emphasis"><em>/* A single element */</em></span>

    <span class="strong"><strong>igraph_vector_int_resize</strong></span>(&amp;p, 1);
    <span class="strong"><strong>igraph_vector_int_resize</strong></span>(&amp;q, 1);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 100; i++) {
        igraph_real_t value;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(p)[0] = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, NROW - 1);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(q)[0] = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, NCOL - 1);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_index" title="5.3.1. igraph_sparsemat_index — Extracts a submatrix or a single element.">igraph_sparsemat_index</a></strong></span>(&amp;B, &amp;p, &amp;q, <span class="emphasis"><em>/*res=*/</em></span> 0, &amp;value);
        <span class="strong"><strong>if</strong></span> (value != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(M, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(p)[0], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(q)[0])) {
            <span class="strong"><strong>return</strong></span> 4;
        }
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 100; i++) {
        igraph_real_t value;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(p)[0] = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, NROW - 1);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(q)[0] = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, NCOL - 1);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_index" title="5.3.1. igraph_sparsemat_index — Extracts a submatrix or a single element.">igraph_sparsemat_index</a></strong></span>(&amp;B, &amp;p, &amp;q, <span class="emphasis"><em>/*res=*/</em></span> &amp;A, &amp;value);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
        <span class="strong"><strong>if</strong></span> (value != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(M, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(p)[0], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(q)[0])) {
            <span class="strong"><strong>return</strong></span> 4;
        }
    }

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;p);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;q);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;M);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;N);

    <span class="emphasis"><em>/* Indexing only the rows or the columns */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;M, NROW, NCOL);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;A, NROW, NCOL, EDGES);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; EDGES; i++) {
        long int r = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, NROW - 1);
        long int c = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, NCOL - 1);
        igraph_real_t value = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 5);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(M, r, c) = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(M, r, c) + value;
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, r, c, value);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);

    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;p, I_NROW);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;q, I_NCOL);

    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; I_NROW; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(p)[i] = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, I_NROW - 1);
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; I_NCOL; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(p)[i] = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, I_NCOL - 1);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;N, 0, 0);
    <span class="strong"><strong>permute_rows</strong></span>(&amp;M, &amp;p, &amp;N);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_index" title="5.3.1. igraph_sparsemat_index — Extracts a submatrix or a single element.">igraph_sparsemat_index</a></strong></span>(&amp;B, &amp;p, 0, &amp;A, 0);

    <span class="strong"><strong>if</strong></span> (! <span class="strong"><strong>check_same</strong></span>(&amp;A, &amp;N)) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="strong"><strong>permute_cols</strong></span>(&amp;M, &amp;q, &amp;N);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_index" title="5.3.1. igraph_sparsemat_index — Extracts a submatrix or a single element.">igraph_sparsemat_index</a></strong></span>(&amp;B, 0, &amp;q, &amp;A, 0);

    <span class="strong"><strong>if</strong></span> (! <span class="strong"><strong>check_same</strong></span>(&amp;A, &amp;N)) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;p);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;q);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;M);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;N);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.6.2.7.3"></a><p class="title"><b>Example 7.7.  File <code class="code">examples/simple/igraph_sparsemat4.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2009-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#define</strong></span> NCOMPLEX  <span class="emphasis"><em>/* to make it compile with MSVC on Windows */</em></span>

<span class="strong"><strong>#include</strong></span> &lt;cs.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

igraph_bool_t <span class="strong"><strong>check_solution</strong></span>(<span class="strong"><strong>const</strong></span> igraph_sparsemat_t *A,
                             <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *x,
                             <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *b) {

    long int dim = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(x);
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> res;
    int j, p;
    igraph_real_t min, max;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_copy" title="2.2.4. igraph_vector_copy — Initializes a vector from another vector object (constructor).">igraph_vector_copy</a></strong></span>(&amp;res, b);

    <span class="strong"><strong>for</strong></span> (j = 0; j &lt; dim; j++) {
        <span class="strong"><strong>for</strong></span> (p = A-&gt;cs-&gt;p[j]; p &lt; A-&gt;cs-&gt;p[j + 1]; p++) {
            long int from = A-&gt;cs-&gt;i[p];
            igraph_real_t value = A-&gt;cs-&gt;x[p];
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(res)[from] -= <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*x)[j] * value;
        }
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_minmax" title="2.10.5. igraph_vector_minmax — Minimum and maximum elements of a vector.">igraph_vector_minmax</a></strong></span>(&amp;res, &amp;min, &amp;max);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;res);

    <span class="strong"><strong>return</strong></span> <span class="strong"><strong>fabs</strong></span>(min) &lt; 1e-15 &amp;&amp; <span class="strong"><strong>fabs</strong></span>(max) &lt; 1e-15;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_sparsemat_t A, B, C;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> b, x;
    long int i;

    <span class="emphasis"><em>/* lsolve */</em></span>

<span class="strong"><strong>#define</strong></span> DIM 10
<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>EDGES</strong></span> (DIM*DIM/6)
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;A, DIM, DIM, EDGES + DIM);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; DIM; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, i, i, <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 3));
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; EDGES; i++) {
        long int r = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, DIM - 1);
        long int c = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, r);
        igraph_real_t value = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 5);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, r, c, value);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dupl" title="5.6.2. igraph_sparsemat_dupl — Removes duplicate elements from a sparse matrix.">igraph_sparsemat_dupl</a></strong></span>(&amp;B);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;b, DIM);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; DIM; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(b)[i] = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 10);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;x, DIM);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_lsolve" title="5.7.3. igraph_sparsemat_lsolve — Solves a lower-triangular linear system.">igraph_sparsemat_lsolve</a></strong></span>(&amp;B, &amp;b, &amp;x);

    <span class="strong"><strong>if</strong></span> (! <span class="strong"><strong>check_solution</strong></span>(&amp;B, &amp;x, &amp;b)) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;b);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;x);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);

<span class="strong"><strong>#undef</strong></span> DIM
<span class="strong"><strong>#undef</strong></span> EDGES

    <span class="emphasis"><em>/* ltsolve */</em></span>

<span class="strong"><strong>#define</strong></span> DIM 10
<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>EDGES</strong></span> (DIM*DIM/6)
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;A, DIM, DIM, EDGES + DIM);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; DIM; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, i, i, <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 3));
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; EDGES; i++) {
        long int r = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, DIM - 1);
        long int c = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, r);
        igraph_real_t value = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 5);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, r, c, value);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dupl" title="5.6.2. igraph_sparsemat_dupl — Removes duplicate elements from a sparse matrix.">igraph_sparsemat_dupl</a></strong></span>(&amp;B);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;b, DIM);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; DIM; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(b)[i] = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 10);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;x, DIM);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_ltsolve" title="5.7.4. igraph_sparsemat_ltsolve — Solves an upper-triangular linear system.">igraph_sparsemat_ltsolve</a></strong></span>(&amp;B, &amp;b, &amp;x);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_transpose" title="5.4.7. igraph_sparsemat_transpose — Transposes a sparse matrix.">igraph_sparsemat_transpose</a></strong></span>(&amp;B, &amp;A, <span class="emphasis"><em>/*values=*/</em></span> 1);
    <span class="strong"><strong>if</strong></span> (! <span class="strong"><strong>check_solution</strong></span>(&amp;A, &amp;x, &amp;b)) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;b);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;x);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);

<span class="strong"><strong>#undef</strong></span> DIM
<span class="strong"><strong>#undef</strong></span> EDGES

    <span class="emphasis"><em>/* usolve */</em></span>

<span class="strong"><strong>#define</strong></span> DIM 10
<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>EDGES</strong></span> (DIM*DIM/6)
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;A, DIM, DIM, EDGES + DIM);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; DIM; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, i, i, <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 3));
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; EDGES; i++) {
        long int r = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, DIM - 1);
        long int c = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, r);
        igraph_real_t value = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 5);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, r, c, value);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dupl" title="5.6.2. igraph_sparsemat_dupl — Removes duplicate elements from a sparse matrix.">igraph_sparsemat_dupl</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_transpose" title="5.4.7. igraph_sparsemat_transpose — Transposes a sparse matrix.">igraph_sparsemat_transpose</a></strong></span>(&amp;B, &amp;A, <span class="emphasis"><em>/*values=*/</em></span> 1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;b, DIM);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; DIM; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(b)[i] = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 10);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;x, DIM);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_usolve" title="5.7.5. igraph_sparsemat_usolve — Solves an upper-triangular linear system.">igraph_sparsemat_usolve</a></strong></span>(&amp;A, &amp;b, &amp;x);

    <span class="strong"><strong>if</strong></span> (! <span class="strong"><strong>check_solution</strong></span>(&amp;A, &amp;x, &amp;b)) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;b);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;x);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);

<span class="strong"><strong>#undef</strong></span> DIM
<span class="strong"><strong>#undef</strong></span> EDGES

    <span class="emphasis"><em>/* utsolve */</em></span>

<span class="strong"><strong>#define</strong></span> DIM 10
<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>EDGES</strong></span> (DIM*DIM/6)
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;A, DIM, DIM, EDGES + DIM);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; DIM; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, i, i, <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 3));
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; EDGES; i++) {
        long int r = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, DIM - 1);
        long int c = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, r);
        igraph_real_t value = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 5);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, r, c, value);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dupl" title="5.6.2. igraph_sparsemat_dupl — Removes duplicate elements from a sparse matrix.">igraph_sparsemat_dupl</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_transpose" title="5.4.7. igraph_sparsemat_transpose — Transposes a sparse matrix.">igraph_sparsemat_transpose</a></strong></span>(&amp;B, &amp;A, <span class="emphasis"><em>/*values=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;b, DIM);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; DIM; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(b)[i] = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 10);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;x, DIM);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_utsolve" title="5.7.6. igraph_sparsemat_utsolve — Solves a lower-triangular linear system.">igraph_sparsemat_utsolve</a></strong></span>(&amp;A, &amp;b, &amp;x);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_transpose" title="5.4.7. igraph_sparsemat_transpose — Transposes a sparse matrix.">igraph_sparsemat_transpose</a></strong></span>(&amp;A, &amp;B, <span class="emphasis"><em>/*values=*/</em></span> 1);
    <span class="strong"><strong>if</strong></span> (! <span class="strong"><strong>check_solution</strong></span>(&amp;B, &amp;x, &amp;b)) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;b);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;x);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);

<span class="strong"><strong>#undef</strong></span> DIM
<span class="strong"><strong>#undef</strong></span> EDGES

    <span class="emphasis"><em>/* cholsol */</em></span>
    <span class="emphasis"><em>/* We need a positive definite matrix, so we create a full-rank</em></span>
<span class="emphasis"><em>       matrix first and then calculate A'A, which will be positive</em></span>
<span class="emphasis"><em>       definite. */</em></span>

<span class="strong"><strong>#define</strong></span> DIM 10
<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>EDGES</strong></span> (DIM*DIM/6)
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;A, DIM, DIM, EDGES + DIM);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; DIM; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, i, i, <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 3));
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; EDGES; i++) {
        long int from = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, DIM - 1);
        long int to = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, DIM - 1);
        igraph_real_t value = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 5);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, from, to, value);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dupl" title="5.6.2. igraph_sparsemat_dupl — Removes duplicate elements from a sparse matrix.">igraph_sparsemat_dupl</a></strong></span>(&amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_transpose" title="5.4.7. igraph_sparsemat_transpose — Transposes a sparse matrix.">igraph_sparsemat_transpose</a></strong></span>(&amp;B, &amp;A, <span class="emphasis"><em>/*values=*/</em></span> 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_multiply" title="5.4.9. igraph_sparsemat_multiply — Matrix multiplication.">igraph_sparsemat_multiply</a></strong></span>(&amp;A, &amp;B, &amp;C);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;b, DIM);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; DIM; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(b)[i] = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 10);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;x, DIM);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_cholsol" title="5.7.7. igraph_sparsemat_cholsol — Solves a symmetric linear system via Cholesky decomposition.">igraph_sparsemat_cholsol</a></strong></span>(&amp;C, &amp;b, &amp;x, <span class="emphasis"><em>/*order=*/</em></span> 0);

    <span class="strong"><strong>if</strong></span> (! <span class="strong"><strong>check_solution</strong></span>(&amp;C, &amp;x, &amp;b)) {
        <span class="strong"><strong>return</strong></span> 5;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;b);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;x);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;C);

<span class="strong"><strong>#undef</strong></span> DIM
<span class="strong"><strong>#undef</strong></span> EDGES

    <span class="emphasis"><em>/* lusol */</em></span>

<span class="strong"><strong>#define</strong></span> DIM 10
<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>EDGES</strong></span> (DIM*DIM/4)
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;A, DIM, DIM, EDGES + DIM);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; DIM; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, i, i, <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 3));
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; EDGES; i++) {
        long int from = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, DIM - 1);
        long int to = <span class="strong"><strong>RNG_INTEGER</strong></span>(0, DIM - 1);
        igraph_real_t value = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 5);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;A, from, to, value);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;A, &amp;B);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;A);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dupl" title="5.6.2. igraph_sparsemat_dupl — Removes duplicate elements from a sparse matrix.">igraph_sparsemat_dupl</a></strong></span>(&amp;B);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;b, DIM);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; DIM; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(b)[i] = <span class="strong"><strong>RNG_INTEGER</strong></span>(1, 10);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;x, DIM);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_lusol" title="5.7.8. igraph_sparsemat_lusol — Solves a linear system via LU decomposition.">igraph_sparsemat_lusol</a></strong></span>(&amp;B, &amp;b, &amp;x, <span class="emphasis"><em>/*order=*/</em></span> 0, <span class="emphasis"><em>/*tol=*/</em></span> 1e-10);

    <span class="strong"><strong>if</strong></span> (! <span class="strong"><strong>check_solution</strong></span>(&amp;B, &amp;x, &amp;b)) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;b);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;x);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;B);

<span class="strong"><strong>#undef</strong></span> DIM
<span class="strong"><strong>#undef</strong></span> EDGES

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.6.2.7.4"></a><p class="title"><b>Example 7.8.  File <code class="code">examples/simple/igraph_sparsemat6.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2010-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {
    igraph_matrix_t mat, mat2, mat3;
    igraph_sparsemat_t spmat, spmat2;
    int i;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);

<span class="strong"><strong>#define</strong></span> NROW 10
<span class="strong"><strong>#define</strong></span> NCOL 7
<span class="strong"><strong>#define</strong></span> NUM_NONZEROS 15

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat, NROW, NCOL);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; NUM_NONZEROS; i++) {
        int r = <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_get_integer" title="4.1. igraph_rng_get_integer — Generate an integer random number from an interval.">igraph_rng_get_integer</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 0, NROW - 1);
        int c = <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_get_integer" title="4.1. igraph_rng_get_integer — Generate an integer random number from an interval.">igraph_rng_get_integer</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 0, NCOL - 1);
        igraph_real_t val = <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_get_integer" title="4.1. igraph_rng_get_integer — Generate an integer random number from an interval.">igraph_rng_get_integer</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 1, 10);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(mat, r, c) = val;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_as_sparsemat" title="5.9.3. igraph_matrix_as_sparsemat — Converts a dense matrix to a sparse matrix.">igraph_matrix_as_sparsemat</a></strong></span>(&amp;spmat, &amp;mat, <span class="emphasis"><em>/*tol=*/</em></span> 1e-14);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.9.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;mat2, &amp;spmat);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_all_e" title="3.8.1. igraph_matrix_all_e — Are all elements equal?">igraph_matrix_all_e</a></strong></span>(&amp;mat, &amp;mat2)) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;spmat, &amp;spmat2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat3, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.9.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;mat3, &amp;spmat2);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_all_e" title="3.8.1. igraph_matrix_all_e — Are all elements equal?">igraph_matrix_all_e</a></strong></span>(&amp;mat, &amp;mat3)) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat3);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat2);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.6.2.7.5"></a><p class="title"><b>Example 7.9.  File <code class="code">examples/simple/igraph_sparsemat7.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2010-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

<span class="strong"><strong>#define</strong></span> DIM1 10
<span class="strong"><strong>#define</strong></span> DIM2 5

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>INT</strong></span>(a) (<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_get_integer" title="4.1. igraph_rng_get_integer — Generate an integer random number from an interval.">igraph_rng_get_integer</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 0, (a)))

int <span class="strong"><strong>main</strong></span>() {
    igraph_matrix_t mat;
    igraph_sparsemat_t spmat, spmat2;
    int i;
    igraph_real_t m1, m2;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;spmat, DIM1, DIM2, 20);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, 1, 2, -1.0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, 3, 2, 10.0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, <span class="strong"><strong>INT</strong></span>(DIM1 - 1), <span class="strong"><strong>INT</strong></span>(DIM2 - 1), 1.0);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, 1, 2, -1.0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, 3, 2, 10.0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;spmat, &amp;spmat2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.9.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;mat, &amp;spmat2);
    m1 = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_min" title="5.3.8. igraph_sparsemat_min — Minimum of a sparse matrix.">igraph_sparsemat_min</a></strong></span>(&amp;spmat2);
    m2 = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_min" title="3.10.1. igraph_matrix_min — Smallest element of a matrix.">igraph_matrix_min</a></strong></span>(&amp;mat);
    <span class="strong"><strong>if</strong></span> (m1 != m2) {
        <span class="strong"><strong>printf</strong></span>("%f %f\n", m1, m2);
        <span class="strong"><strong>return</strong></span> 1;
    }
    m1 = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_max" title="5.3.9. igraph_sparsemat_max — Maximum of a sparse matrix.">igraph_sparsemat_max</a></strong></span>(&amp;spmat2);
    m2 = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_max" title="3.10.2. igraph_matrix_max — Largest element of a matrix.">igraph_matrix_max</a></strong></span>(&amp;mat);
    <span class="strong"><strong>if</strong></span> (m1 != m2) {
        <span class="strong"><strong>printf</strong></span>("%f %f\n", m1, m2);
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_minmax" title="5.3.10. igraph_sparsemat_minmax — Minimum and maximum of a sparse matrix.">igraph_sparsemat_minmax</a></strong></span>(&amp;spmat2, &amp;m1, &amp;m2);
    <span class="strong"><strong>if</strong></span> (m1 != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_min" title="3.10.1. igraph_matrix_min — Smallest element of a matrix.">igraph_matrix_min</a></strong></span>(&amp;mat)) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong>if</strong></span> (m2 != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_max" title="3.10.2. igraph_matrix_max — Largest element of a matrix.">igraph_matrix_max</a></strong></span>(&amp;mat)) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat2);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.6.2.7.6"></a><p class="title"><b>Example 7.10.  File <code class="code">examples/simple/igraph_sparsemat8.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2010-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

<span class="strong"><strong>#define</strong></span> DIM1 10
<span class="strong"><strong>#define</strong></span> DIM2 5

<span class="strong"><strong>#define</strong></span> <span class="strong"><strong>INT</strong></span>(a) (<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_get_integer" title="4.1. igraph_rng_get_integer — Generate an integer random number from an interval.">igraph_rng_get_integer</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 0, (a)))

int <span class="strong"><strong>main</strong></span>() {
    igraph_matrix_t mat, mat2;
    igraph_sparsemat_t spmat, spmat2;
    int i, j, nz1, nz2;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> sums1, sums2;


    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Set the seed of a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);

    <span class="emphasis"><em>/* COPY */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;spmat, DIM1, DIM2, 20);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, <span class="strong"><strong>INT</strong></span>(DIM1 - 1), <span class="strong"><strong>INT</strong></span>(DIM2 - 1), 1.0);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_copy" title="5.2.2. igraph_sparsemat_copy — Copies a sparse matrix.">igraph_sparsemat_copy</a></strong></span>(&amp;spmat2, &amp;spmat);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.9.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;mat, &amp;spmat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.9.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;mat2, &amp;spmat2);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_all_e" title="3.8.1. igraph_matrix_all_e — Are all elements equal?">igraph_matrix_all_e</a></strong></span>(&amp;mat, &amp;mat2)) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat2);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;spmat, &amp;spmat2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_copy" title="5.2.2. igraph_sparsemat_copy — Copies a sparse matrix.">igraph_sparsemat_copy</a></strong></span>(&amp;spmat, &amp;spmat2);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.9.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;mat2, &amp;spmat);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_all_e" title="3.8.1. igraph_matrix_all_e — Are all elements equal?">igraph_matrix_all_e</a></strong></span>(&amp;mat, &amp;mat2)) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat2);

    <span class="emphasis"><em>/* COLSUMS, ROWSUMS */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;spmat, DIM1, DIM2, 20);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, <span class="strong"><strong>INT</strong></span>(DIM1 - 1), <span class="strong"><strong>INT</strong></span>(DIM2 - 1), 1.0);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;spmat, &amp;spmat2);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.9.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;mat, &amp;spmat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;sums1, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;sums2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_colsums" title="5.3.14. igraph_sparsemat_colsums — Column-wise sums.">igraph_sparsemat_colsums</a></strong></span>(&amp;spmat, &amp;sums1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_colsum" title="3.7.10. igraph_matrix_colsum — Columnwise sum.">igraph_matrix_colsum</a></strong></span>(&amp;mat, &amp;sums2);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_all_e" title="2.9.1. igraph_vector_all_e — Are all elements equal?">igraph_vector_all_e</a></strong></span>(&amp;sums1, &amp;sums2)) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_colsums" title="5.3.14. igraph_sparsemat_colsums — Column-wise sums.">igraph_sparsemat_colsums</a></strong></span>(&amp;spmat2, &amp;sums1);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_all_e" title="2.9.1. igraph_vector_all_e — Are all elements equal?">igraph_vector_all_e</a></strong></span>(&amp;sums1, &amp;sums2)) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_rowsums" title="5.3.13. igraph_sparsemat_rowsums — Row-wise sums.">igraph_sparsemat_rowsums</a></strong></span>(&amp;spmat, &amp;sums1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_rowsum" title="3.7.9. igraph_matrix_rowsum — Rowwise sum.">igraph_matrix_rowsum</a></strong></span>(&amp;mat, &amp;sums2);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_all_e" title="2.9.1. igraph_vector_all_e — Are all elements equal?">igraph_vector_all_e</a></strong></span>(&amp;sums1, &amp;sums2)) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_rowsums" title="5.3.13. igraph_sparsemat_rowsums — Row-wise sums.">igraph_sparsemat_rowsums</a></strong></span>(&amp;spmat2, &amp;sums1);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_all_e" title="2.9.1. igraph_vector_all_e — Are all elements equal?">igraph_vector_all_e</a></strong></span>(&amp;sums1, &amp;sums2)) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;sums1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;sums2);

    <span class="emphasis"><em>/* COUNT_NONZERO, COUNT_NONZEROTOL */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;spmat, DIM1, DIM2, 20);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, 1, 2, 1.0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, 1, 2, 1.0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, 1, 3, 1e-12);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, <span class="strong"><strong>INT</strong></span>(DIM1 - 1), <span class="strong"><strong>INT</strong></span>(DIM2 - 1), 1.0);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;spmat, &amp;spmat2);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.9.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;mat, &amp;spmat2);

    nz1 = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_count_nonzero" title="5.3.11. igraph_sparsemat_count_nonzero — Counts nonzero elements of a sparse matrix.">igraph_sparsemat_count_nonzero</a></strong></span>(&amp;spmat2);
    <span class="strong"><strong>for</strong></span> (nz2 = 0, i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(&amp;mat); i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(&amp;mat); j++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(mat, i, j) != 0) {
                nz2++;
            }
        }
    }
    <span class="strong"><strong>if</strong></span> (nz1 != nz2) {
        <span class="strong"><strong>printf</strong></span>("%i %i\n", nz1, nz2);
        <span class="strong"><strong>return</strong></span> 7;
    }

    nz1 = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_count_nonzerotol" title="5.3.12. igraph_sparsemat_count_nonzerotol — Counts nonzero elements of a sparse matrix, ignoring elements close to zero.">igraph_sparsemat_count_nonzerotol</a></strong></span>(&amp;spmat2, 1e-10);
    <span class="strong"><strong>for</strong></span> (nz2 = 0, i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_nrow" title="3.11.5. igraph_matrix_nrow — The number of rows in a matrix.">igraph_matrix_nrow</a></strong></span>(&amp;mat); i++) {
        <span class="strong"><strong>for</strong></span> (j = 0; j &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_ncol" title="3.11.6. igraph_matrix_ncol — The number of columns in a matrix.">igraph_matrix_ncol</a></strong></span>(&amp;mat); j++) {
            <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(mat, i, j)) &gt;= 1e-10) {
                nz2++;
            }
        }
    }
    <span class="strong"><strong>if</strong></span> (nz1 != nz2) {
        <span class="strong"><strong>printf</strong></span>("%i %i\n", nz1, nz2);
        <span class="strong"><strong>return</strong></span> 8;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat2);

    <span class="emphasis"><em>/* SCALE */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;spmat, DIM1, DIM2, 20);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, <span class="strong"><strong>INT</strong></span>(DIM1 - 1), <span class="strong"><strong>INT</strong></span>(DIM2 - 1), 1.0);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;spmat, &amp;spmat2);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_scale" title="5.4.5. igraph_sparsemat_scale — Scales a sparse matrix.">igraph_sparsemat_scale</a></strong></span>(&amp;spmat, 2.0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_scale" title="5.4.5. igraph_sparsemat_scale — Scales a sparse matrix.">igraph_sparsemat_scale</a></strong></span>(&amp;spmat2, 2.0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.9.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;mat, &amp;spmat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.9.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;mat2, &amp;spmat2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_scale" title="3.7.2. igraph_matrix_scale — Multiplies each element of the matrix by a constant.">igraph_matrix_scale</a></strong></span>(&amp;mat, 1.0 / 2.0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_scale" title="3.7.2. igraph_matrix_scale — Multiplies each element of the matrix by a constant.">igraph_matrix_scale</a></strong></span>(&amp;mat2, 1.0 / 2.0);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_all_e" title="3.8.1. igraph_matrix_all_e — Are all elements equal?">igraph_matrix_all_e</a></strong></span>(&amp;mat, &amp;mat2)) {
        <span class="strong"><strong>return</strong></span> 9;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat2);

    <span class="emphasis"><em>/* ADDROWS, ADDCOLS */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format.">igraph_sparsemat_init</a></strong></span>(&amp;spmat, DIM1, DIM2, 20);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix.">igraph_sparsemat_entry</a></strong></span>(&amp;spmat, <span class="strong"><strong>INT</strong></span>(DIM1 - 1), <span class="strong"><strong>INT</strong></span>(DIM2 - 1), 1.0);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format.">igraph_sparsemat_compress</a></strong></span>(&amp;spmat, &amp;spmat2);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_add_rows" title="5.4.11. igraph_sparsemat_add_rows — Adds rows to a sparse matrix.">igraph_sparsemat_add_rows</a></strong></span>(&amp;spmat, 3);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_add_cols" title="5.4.12. igraph_sparsemat_add_cols — Adds columns to a sparse matrix.">igraph_sparsemat_add_cols</a></strong></span>(&amp;spmat, 2);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_add_rows" title="5.4.11. igraph_sparsemat_add_rows — Adds rows to a sparse matrix.">igraph_sparsemat_add_rows</a></strong></span>(&amp;spmat2, 3);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_add_cols" title="5.4.12. igraph_sparsemat_add_cols — Adds columns to a sparse matrix.">igraph_sparsemat_add_cols</a></strong></span>(&amp;spmat2, 2);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.9.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;mat, &amp;spmat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat2, 0, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_as_matrix" title="5.9.4. igraph_sparsemat_as_matrix — Converts a sparse matrix to a dense matrix.">igraph_sparsemat_as_matrix</a></strong></span>(&amp;mat2, &amp;spmat2);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_all_e" title="3.8.1. igraph_matrix_all_e — Are all elements equal?">igraph_matrix_all_e</a></strong></span>(&amp;mat, &amp;mat2)) {
        <span class="strong"><strong>return</strong></span> 10;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix.">igraph_sparsemat_destroy</a></strong></span>(&amp;spmat2);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="creating-sparse-matrix-objects"></a>5.2. Creating sparse matrix objects</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_init">5.2.1. <code class="function">igraph_sparsemat_init</code> —  Initializes a sparse matrix, in triplet format.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_copy">5.2.2. <code class="function">igraph_sparsemat_copy</code> —  Copies a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_realloc">5.2.3. <code class="function">igraph_sparsemat_realloc</code> —  Allocates more (or less) memory for a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_destroy">5.2.4. <code class="function">igraph_sparsemat_destroy</code> —  Deallocates memory used by a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_eye">5.2.5. <code class="function">igraph_sparsemat_eye</code> —  Creates a sparse identity matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_diag">5.2.6. <code class="function">igraph_sparsemat_diag</code> —  Creates a sparse diagonal matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_view">5.2.7. <code class="function">igraph_sparsemat_view</code> —  Initialize a sparse matrix and set all parameters.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_init"></a>5.2.1. <code class="function">igraph_sparsemat_init</code> —  Initializes a sparse matrix, in triplet format.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.3.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_init(igraph_sparsemat_t *A, int rows, int cols, int nzmax);
</pre></div>
<p>
</p>
<p>



This is the most common way to create a sparse matrix, together
with the <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix."><code class="function">igraph_sparsemat_entry()</code></a> function, which can be used to
add the non-zero elements one by one. Once done, the user can call
<a class="link" href="igraph-Data-structures.html#igraph_sparsemat_compress" title="5.6.1. igraph_sparsemat_compress — Converts a sparse matrix to column-compressed format."><code class="function">igraph_sparsemat_compress()</code></a> to convert the matrix to
column-compressed, to allow computations with it.

</p>
<p>The user must call <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix."><code class="function">igraph_sparsemat_destroy()</code></a> on
the matrix to deallocate the memory, once the matrix is no more
needed.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  Pointer to a not yet initialized sparse matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rows</code></em>:</span></p></td>
<td><p>
  The number of rows in the matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cols</code></em>:</span></p></td>
<td><p>
  The number of columns.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nzmax</code></em>:</span></p></td>
<td><p>
  The maximum number of non-zero elements in the
   matrix. It is not compulsory to get this right, but it is
   useful for the allocation of the proper amount of memory.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_copy"></a>5.2.2. <code class="function">igraph_sparsemat_copy</code> —  Copies a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.3.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_copy(igraph_sparsemat_t *to,
                          const igraph_sparsemat_t *from);
</pre></div>
<p>
</p>
<p>



Create a sparse matrix object, by copying another one. The source
matrix can be either in triplet or column-compressed format.

</p>
<p>
Exactly the same amount of memory will be allocated to the
copy matrix, as it is currently for the original one.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized sparse matrix, the copy will
   be created here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The sparse matrix to copy.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n+nzmax), the number of columns plus the maximum
number of non-zero elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_realloc"></a>5.2.3. <code class="function">igraph_sparsemat_realloc</code> —  Allocates more (or less) memory for a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.3.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_realloc(igraph_sparsemat_t *A, int nzmax);
</pre></div>
<p>
</p>
<p>



Sparse matrices automatically allocate more memory, as needed. To
control memory allocation, the user can call this function, to
allocate memory for a given number of non-zero elements.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The sparse matrix, it can be in triplet or
   column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nzmax</code></em>:</span></p></td>
<td><p>
  The new maximum number of non-zero elements.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_destroy"></a>5.2.4. <code class="function">igraph_sparsemat_destroy</code> —  Deallocates memory used by a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.3.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_sparsemat_destroy(igraph_sparsemat_t *A);
</pre></div>
<p>
</p>
<p>



One destroyed, the sparse matrix must be initialized again, before
calling any other operation on it.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The sparse matrix to destroy.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_eye"></a>5.2.5. <code class="function">igraph_sparsemat_eye</code> —  Creates a sparse identity matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.3.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_eye(igraph_sparsemat_t *A, int n, int nzmax,
                         igraph_real_t value,
                         igraph_bool_t compress);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  An uninitialized sparse matrix, the result is stored
  here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of rows and number of columns in the matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nzmax</code></em>:</span></p></td>
<td><p>
  The maximum number of non-zero elements, this
  essentially gives the amount of memory that will be allocated for
  matrix elements.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  The value to store in the diagonal.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>compress</code></em>:</span></p></td>
<td><p>
  Whether to create a column-compressed matrix. If
  false, then a triplet matrix is created.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_diag"></a>5.2.6. <code class="function">igraph_sparsemat_diag</code> —  Creates a sparse diagonal matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.3.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_diag(igraph_sparsemat_t *A, int nzmax,
                          const igraph_vector_t *values,
                          igraph_bool_t compress);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  An uninitialized sparse matrix, the result is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nzmax</code></em>:</span></p></td>
<td><p>
  The maximum number of non-zero elements, this
  essentially gives the amount of memory that will be allocated for
  matrix elements.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>values</code></em>:</span></p></td>
<td><p>
  The values to store in the diagonal, the size of the
   matrix defined by the length of this vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>compress</code></em>:</span></p></td>
<td><p>
  Whether to create a column-compressed matrix. If
  false, then a triplet matrix is created.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the length of the diagonal vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_view"></a>5.2.7. <code class="function">igraph_sparsemat_view</code> —  Initialize a sparse matrix and set all parameters.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.3.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_view(igraph_sparsemat_t *A, int nzmax, int m, int n,
                          int *p, int *i, double *x, int nz);
</pre></div>
<p>
</p>
<p>



This function can be used to temporarily handle existing sparse matrix data,
usually created by another software library, as an <code class="constant">igraph_sparsemat_t</code> object,
and thus avoid unnecessary copying. It supports data stored in either the
compressed sparse column format, or the <code class="literal">(i, j, x)</code> triplet format
where <code class="constant">i</code> and <code class="constant">j</code> are the matrix indices of a non-zero element, and <code class="constant">x</code>
is its value.

</p>
<p>
The compressed sparse column (or row) format is commonly used to represent
sparse matrix data. It consists of three vectors, the <em class="parameter"><code>p</code></em> column pointers, the
<em class="parameter"><code>i</code></em> row indices, and the <em class="parameter"><code>x</code></em> values. <code class="literal">p[k]</code> is the number
of non-zero entires in matrix columns <code class="literal">k-1</code> and lower.
<code class="literal">p[0]</code> is always zero and <code class="literal">p[n]</code> is always the total
number of non-zero entires in the matrix. <code class="literal">i[l]</code> is the row index
of the <code class="constant">l-th</code> stored element, while <code class="literal">x[l]</code> is its value.
If a matrix element with indices <code class="literal">(j, k)</code> is explicitly stored,
it must be located between positions <code class="literal">p[k]</code> and <code class="literal">p[k+1] - 1</code>
(inclusive) in the <em class="parameter"><code>i</code></em> and <em class="parameter"><code>x</code></em> vectors.

</p>
<p>
Do not call <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_destroy" title="5.2.4. igraph_sparsemat_destroy — Deallocates memory used by a sparse matrix."><code class="function">igraph_sparsemat_destroy()</code></a> on a sparse matrix created with
this function. Instead, <a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions."><code class="function">igraph_free()</code></a> must be called on the <code class="constant">cs</code>
field of <em class="parameter"><code>A</code></em> to free the storage allocated by this function.

</p>
<p>
Warning: Matrices created with this function must not be used with functions
that may reallocate the underlying storage, such as <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_entry" title="5.4.1. igraph_sparsemat_entry — Adds an element to a sparse matrix."><code class="function">igraph_sparsemat_entry()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The non-initialized sparse matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nzmax</code></em>:</span></p></td>
<td><p>
  The maximum number of entries, typically the actual number of entries.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The number of matrix rows.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of matrix columns.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  For a compressed matrix, this is the column pointer vector, and
         must be of size <code class="literal">n+1</code>. For a triplet format matrix, it
         is a vector of column indices and must be of size <em class="parameter"><code>nzmax</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>i</code></em>:</span></p></td>
<td><p>
  The row vector. This should contain the row indices of the
         elements in <em class="parameter"><code>x</code></em>. It must be of size <em class="parameter"><code>nzmax</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x</code></em>:</span></p></td>
<td><p>
  The values of the non-zero elements of the sparse matrix.
         It must be of size <em class="parameter"><code>nzmax</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nz</code></em>:</span></p></td>
<td><p>
  For a compressed matrix, is must be -1. For a triplet format
          matrix, is must contain the number of entries.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="query-properties-of-a-sparse-matrix"></a>5.3. Query properties of a sparse matrix</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_index">5.3.1. <code class="function">igraph_sparsemat_index</code> —  Extracts a submatrix or a single element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_nrow">5.3.2. <code class="function">igraph_sparsemat_nrow</code> —  Number of rows.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_ncol">5.3.3. <code class="function">igraph_sparsemat_ncol</code> —  Number of columns.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_type">5.3.4. <code class="function">igraph_sparsemat_type</code> —  Type of a sparse matrix (triplet or column-compressed).</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_is_triplet">5.3.5. <code class="function">igraph_sparsemat_is_triplet</code> —  Is this sparse matrix in triplet format?</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_is_cc">5.3.6. <code class="function">igraph_sparsemat_is_cc</code> —  Is this sparse matrix in column-compressed format?</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_getelements_sorted">5.3.7. <code class="function">igraph_sparsemat_getelements_sorted</code> —  Returns the sorted elements of a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_min">5.3.8. <code class="function">igraph_sparsemat_min</code> —  Minimum of a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_max">5.3.9. <code class="function">igraph_sparsemat_max</code> —  Maximum of a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_minmax">5.3.10. <code class="function">igraph_sparsemat_minmax</code> —  Minimum and maximum of a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_count_nonzero">5.3.11. <code class="function">igraph_sparsemat_count_nonzero</code> —  Counts nonzero elements of a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_count_nonzerotol">5.3.12. <code class="function">igraph_sparsemat_count_nonzerotol</code> —  Counts nonzero elements of a sparse matrix, ignoring elements close to zero.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_rowsums">5.3.13. <code class="function">igraph_sparsemat_rowsums</code> —  Row-wise sums.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_colsums">5.3.14. <code class="function">igraph_sparsemat_colsums</code> —  Column-wise sums.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_nonzero_storage">5.3.15. <code class="function">igraph_sparsemat_nonzero_storage</code> —  Returns number of stored entries of a sparse matrix.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_index"></a>5.3.1. <code class="function">igraph_sparsemat_index</code> —  Extracts a submatrix or a single element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_index(const igraph_sparsemat_t *A,
                           const igraph_vector_int_t *p,
                           const igraph_vector_int_t *q,
                           igraph_sparsemat_t *res,
                           igraph_real_t *constres);
</pre></div>
<p>
</p>
<p>



This function indexes into a sparse matrix.
It serves two purposes. First, it can extract
submatrices from a sparse matrix. Second, as a special case, it can
extract a single element from a sparse matrix.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, it must be in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  An integer vector, or a null pointer. The selected row
   index or indices. A null pointer selects all rows.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  An integer vector, or a null pointer. The selected column
   index or indices. A null pointer selects all columns.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized sparse matrix, or a null
   pointer. If not a null pointer, then the selected submatrix is
   stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>constres</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable or a null pointer. If
   not a null pointer, then the first non-zero element in the
   selected submatrix is stored here, if there is one. Otherwise
   zero is stored here. This behavior is handy if one
   wants to select a single entry from the matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_nrow"></a>5.3.2. <code class="function">igraph_sparsemat_nrow</code> —  Number of rows.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_sparsemat_nrow(const igraph_sparsemat_t *A);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in triplet or column-compressed format.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of rows in the <em class="parameter"><code>A</code></em> matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_ncol"></a>5.3.3. <code class="function">igraph_sparsemat_ncol</code> —  Number of columns.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_sparsemat_ncol(const igraph_sparsemat_t *A);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in triplet or column-compressed format.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of columns in the <em class="parameter"><code>A</code></em> matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_type"></a>5.3.4. <code class="function">igraph_sparsemat_type</code> —  Type of a sparse matrix (triplet or column-compressed).</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_sparsemat_type_t igraph_sparsemat_type(const igraph_sparsemat_t *A);
</pre></div>
<p>
</p>
<p>



Gives whether a sparse matrix is stored in the triplet format or in
column-compressed format.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Either <code class="constant">IGRAPH_SPARSEMAT_CC</code> or <code class="constant">IGRAPH_SPARSEMAT_TRIPLET</code>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_is_triplet"></a>5.3.5. <code class="function">igraph_sparsemat_is_triplet</code> —  Is this sparse matrix in triplet format?</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_sparsemat_is_triplet(const igraph_sparsemat_t *A);
</pre></div>
<p>
</p>
<p>



Decides whether a sparse matrix is in triplet format.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  One if the input matrix is in triplet format, zero
otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_is_cc"></a>5.3.6. <code class="function">igraph_sparsemat_is_cc</code> —  Is this sparse matrix in column-compressed format?</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_sparsemat_is_cc(const igraph_sparsemat_t *A);
</pre></div>
<p>
</p>
<p>



Decides whether a sparse matrix is in column-compressed format.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  One if the input matrix is in column-compressed format, zero
otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_getelements_sorted"></a>5.3.7. <code class="function">igraph_sparsemat_getelements_sorted</code> —  Returns the sorted elements of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_getelements_sorted(const igraph_sparsemat_t *A,
                                        igraph_vector_int_t *i,
                                        igraph_vector_int_t *j,
                                        igraph_vector_t *x);
</pre></div>
<p>
</p>
<p>



This function will sort a sparse matrix and return the elements in
3 vectors. Two vectors will indicate where the elements are located,
and one will give the elements.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  A sparse matrix in either triplet or compressed form.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>i</code></em>:</span></p></td>
<td><p>
  An initialized int vector. This will store the rows of the
         returned elements.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>j</code></em>:</span></p></td>
<td><p>
  An initialized int vector. For a triplet matrix this will
         store the columns of the returned elements. For a compressed
         matrix, if the column index is <code class="constant">k</code>, then <code class="literal">j[k]</code>
         is the index in <em class="parameter"><code>x</code></em> of the start of the <code class="constant">k-th</code> column, and
         the last element of <code class="constant">j</code> is the total number of elements.
         The total number of elements in the <code class="constant">k-th</code> column is
         therefore <code class="literal">j[k+1] - j[k]</code>. For example, if there
         is one element in the first column, and five in the second,
         <code class="constant">j</code> will be set to <code class="literal">{0, 1, 6}</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x</code></em>:</span></p></td>
<td><p>
  An initialized vector. The elements will be placed here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of stored elements in the sparse matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_min"></a>5.3.8. <code class="function">igraph_sparsemat_min</code> —  Minimum of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_sparsemat_min(igraph_sparsemat_t *A);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, column-compressed.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The minimum in the input matrix, or <code class="constant">IGRAPH_POSINFINITY</code>
   if the matrix has zero elements.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_max"></a>5.3.9. <code class="function">igraph_sparsemat_max</code> —  Maximum of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_sparsemat_max(igraph_sparsemat_t *A);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, column-compressed.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The maximum in the input matrix, or <code class="constant">IGRAPH_NEGINFINITY</code>
   if the matrix has zero elements.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_minmax"></a>5.3.10. <code class="function">igraph_sparsemat_minmax</code> —  Minimum and maximum of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_minmax(igraph_sparsemat_t *A,
                            igraph_real_t *min, igraph_real_t *max);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, column-compressed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>min</code></em>:</span></p></td>
<td><p>
  The minimum in the input matrix is stored here, or <code class="constant">IGRAPH_POSINFINITY</code> if the matrix has zero elements.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>max</code></em>:</span></p></td>
<td><p>
  The maximum in the input matrix is stored here, or <code class="constant">IGRAPH_NEGINFINITY</code> if the matrix has zero elements.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_count_nonzero"></a>5.3.11. <code class="function">igraph_sparsemat_count_nonzero</code> —  Counts nonzero elements of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_sparsemat_count_nonzero(igraph_sparsemat_t *A);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, column-compressed.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_count_nonzerotol"></a>5.3.12. <code class="function">igraph_sparsemat_count_nonzerotol</code> —  Counts nonzero elements of a sparse matrix, ignoring elements close to zero.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.13.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_sparsemat_count_nonzerotol(igraph_sparsemat_t *A,
        igraph_real_t tol);
</pre></div>
<p>
</p>
<p>



Count the number of matrix entries that are closer to zero than <em class="parameter"><code>tol</code></em>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>The</code></em>:</span></p></td>
<td><p>
  input matrix, column-compressed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>Real</code></em>:</span></p></td>
<td><p>
  scalar, the tolerance.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_rowsums"></a>5.3.13. <code class="function">igraph_sparsemat_rowsums</code> —  Row-wise sums.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.14.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_rowsums(const igraph_sparsemat_t *A,
                             igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in triplet or column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the result is stored here. It
   will be resized as needed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nz), the number of non-zero elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_colsums"></a>5.3.14. <code class="function">igraph_sparsemat_colsums</code> —  Column-wise sums.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.15.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_colsums(const igraph_sparsemat_t *A,
                             igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in triplet or column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the result is stored here. It
   will be resized as needed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nz) for triplet matrices, O(nz+n) for
column-compressed ones, nz is the number of non-zero elements, n is
the number of columns.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_nonzero_storage"></a>5.3.15. <code class="function">igraph_sparsemat_nonzero_storage</code> —  Returns number of stored entries of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.4.16.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_nonzero_storage(const igraph_sparsemat_t *A);
</pre></div>
<p>
</p>
<p>



This function will return the number of stored entries of a sparse
matrix. These entries can be zero, and multiple entries can be
at the same position. Use <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dupl" title="5.6.2. igraph_sparsemat_dupl — Removes duplicate elements from a sparse matrix."><code class="function">igraph_sparsemat_dupl()</code></a> to sum
duplicate entries, and <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dropzeros" title="5.4.3. igraph_sparsemat_dropzeros — Drops the zero elements from a sparse matrix."><code class="function">igraph_sparsemat_dropzeros()</code></a> to remove
zeros.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  A sparse matrix in either triplet or compressed form.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Number of stored entries.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="operations-on-sparse-matrices"></a>5.4. Operations on sparse matrices</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_entry">5.4.1. <code class="function">igraph_sparsemat_entry</code> —  Adds an element to a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_fkeep">5.4.2. <code class="function">igraph_sparsemat_fkeep</code> —  Filters the elements of a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_dropzeros">5.4.3. <code class="function">igraph_sparsemat_dropzeros</code> —  Drops the zero elements from a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_droptol">5.4.4. <code class="function">igraph_sparsemat_droptol</code> —  Drops the almost zero elements from a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_scale">5.4.5. <code class="function">igraph_sparsemat_scale</code> —  Scales a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_permute">5.4.6. <code class="function">igraph_sparsemat_permute</code> —  Permutes the rows and columns of a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_transpose">5.4.7. <code class="function">igraph_sparsemat_transpose</code> —  Transposes a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_add">5.4.8. <code class="function">igraph_sparsemat_add</code> —  Sum of two sparse matrices.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_multiply">5.4.9. <code class="function">igraph_sparsemat_multiply</code> —  Matrix multiplication.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_gaxpy">5.4.10. <code class="function">igraph_sparsemat_gaxpy</code> —  Matrix-vector product, added to another vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_add_rows">5.4.11. <code class="function">igraph_sparsemat_add_rows</code> —  Adds rows to a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_add_cols">5.4.12. <code class="function">igraph_sparsemat_add_cols</code> —  Adds columns to a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_resize">5.4.13. <code class="function">igraph_sparsemat_resize</code> —  Resizes a sparse matrix.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_entry"></a>5.4.1. <code class="function">igraph_sparsemat_entry</code> —  Adds an element to a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_entry(igraph_sparsemat_t *A, int row, int col,
                           igraph_real_t elem);
</pre></div>
<p>
</p>
<p>



This function can be used to add the entries to a sparse matrix,
after initializing it with <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_init" title="5.2.1. igraph_sparsemat_init — Initializes a sparse matrix, in triplet format."><code class="function">igraph_sparsemat_init()</code></a>. If you add
multiple entries in the same position, they will all be saved, and
the resulting value is the sum of all entries in that position.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, it must be in triplet format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>row</code></em>:</span></p></td>
<td><p>
  The row index of the entry to add.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>col</code></em>:</span></p></td>
<td><p>
  The column index of the entry to add.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>elem</code></em>:</span></p></td>
<td><p>
  The value of the entry.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1) on average.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_fkeep"></a>5.4.2. <code class="function">igraph_sparsemat_fkeep</code> —  Filters the elements of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_fkeep(
    igraph_sparsemat_t *A,
    igraph_integer_t (*fkeep)(igraph_integer_t, igraph_integer_t, igraph_real_t, void*),
    void *other
);
</pre></div>
<p>
</p>
<p>



This function can be used to filter the (non-zero) elements of a
sparse matrix. For all entries, it calls the supplied function and
depending on the return values either keeps, or deleted the element
from the matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>fkeep</code></em>:</span></p></td>
<td><p>
  The filter function. It must take four arguments: the
   first is an <code class="constant">int</code>, the row index of the entry, the second is
   another <code class="constant">int</code>, the column index. The third is <code class="constant">igraph_real_t</code>,
   the value of the entry. The fourth element is a <code class="constant">void</code> pointer,
   the <em class="parameter"><code>other</code></em> argument is passed here. The function must return
   an <code class="constant">int</code>. If this is zero, then the entry is deleted, otherwise
   it is kept.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>other</code></em>:</span></p></td>
<td><p>
  A <code class="constant">void</code> pointer that is passed to the filtering
function.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_dropzeros"></a>5.4.3. <code class="function">igraph_sparsemat_dropzeros</code> —  Drops the zero elements from a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_dropzeros(igraph_sparsemat_t *A);
</pre></div>
<p>
</p>
<p>



As a result of matrix operations, some of the entries in a sparse
matrix might be zero. This function removes these entries.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, it must be in column-compressed format.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_droptol"></a>5.4.4. <code class="function">igraph_sparsemat_droptol</code> —  Drops the almost zero elements from a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_droptol(igraph_sparsemat_t *A, igraph_real_t tol);
</pre></div>
<p>
</p>
<p>



This function is similar to <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_dropzeros" title="5.4.3. igraph_sparsemat_dropzeros — Drops the zero elements from a sparse matrix."><code class="function">igraph_sparsemat_dropzeros()</code></a>, but it
also drops entries that are closer to zero than the given tolerance
threshold.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, it must be in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>tol</code></em>:</span></p></td>
<td><p>
  Real number, giving the tolerance threshold.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_scale"></a>5.4.5. <code class="function">igraph_sparsemat_scale</code> —  Scales a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_scale(igraph_sparsemat_t *A, igraph_real_t by);
</pre></div>
<p>
</p>
<p>



Multiplies all elements of a sparse matrix, by the given scalar.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>by</code></em>:</span></p></td>
<td><p>
  The scaling factor.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nz), the number of non-zero elements in the
matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_permute"></a>5.4.6. <code class="function">igraph_sparsemat_permute</code> —  Permutes the rows and columns of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_permute(const igraph_sparsemat_t *A,
                             const igraph_vector_int_t *p,
                             const igraph_vector_int_t *q,
                             igraph_sparsemat_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, it must be in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  Integer vector, giving the permutation of the rows.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  Integer vector, the permutation of the columns.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized sparse matrix, the result is
  stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(m+n+nz), the number of rows plus the number of
columns plus the number of non-zero elements in the matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_transpose"></a>5.4.7. <code class="function">igraph_sparsemat_transpose</code> —  Transposes a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_transpose(const igraph_sparsemat_t *A,
                               igraph_sparsemat_t *res,
                               int values);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, column-compressed or triple format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized sparse matrix, the result is
   stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>values</code></em>:</span></p></td>
<td><p>
  If this is non-zero, the matrix transpose is
   calculated the normal way. If it is zero, then only the pattern
   of the input matrix is stored in the result, the values are not.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_add"></a>5.4.8. <code class="function">igraph_sparsemat_add</code> —  Sum of two sparse matrices.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_add(const igraph_sparsemat_t *A,
                         const igraph_sparsemat_t *B,
                         igraph_real_t alpha,
                         igraph_real_t beta,
                         igraph_sparsemat_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The first input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>B</code></em>:</span></p></td>
<td><p>
  The second input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>alpha</code></em>:</span></p></td>
<td><p>
  Real scalar, <em class="parameter"><code>A</code></em> is multiplied by <em class="parameter"><code>alpha</code></em> before the
   addition.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>beta</code></em>:</span></p></td>
<td><p>
  Real scalar, <em class="parameter"><code>B</code></em> is multiplied by <em class="parameter"><code>beta</code></em> before the
   addition.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized sparse matrix, the result
   is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_multiply"></a>5.4.9. <code class="function">igraph_sparsemat_multiply</code> —  Matrix multiplication.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_multiply(const igraph_sparsemat_t *A,
                              const igraph_sparsemat_t *B,
                              igraph_sparsemat_t *res);
</pre></div>
<p>
</p>
<p>



Multiplies two sparse matrices.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The first input matrix (left hand side), in
  column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>B</code></em>:</span></p></td>
<td><p>
  The second input matrix (right hand side), in
  column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized sparse matrix, the result is
  stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_gaxpy"></a>5.4.10. <code class="function">igraph_sparsemat_gaxpy</code> —  Matrix-vector product, added to another vector.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_gaxpy(const igraph_sparsemat_t *A,
                           const igraph_vector_t *x,
                           igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x</code></em>:</span></p></td>
<td><p>
  The input vector, its size must match the number of
   columns in <em class="parameter"><code>A</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  This vector is added to the matrix-vector product
   and it is overwritten by the result.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_add_rows"></a>5.4.11. <code class="function">igraph_sparsemat_add_rows</code> —  Adds rows to a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_add_rows(igraph_sparsemat_t *A, long int n);
</pre></div>
<p>
</p>
<p>



The current matrix elements are retained and all elements in the
new rows are zero.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in triplet or column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of rows to add.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_add_cols"></a>5.4.12. <code class="function">igraph_sparsemat_add_cols</code> —  Adds columns to a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.13.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_add_cols(igraph_sparsemat_t *A, long int n);
</pre></div>
<p>
</p>
<p>



The current matrix elements are retained, and all elements in the
new columns are zero.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in triplet or column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of columns to add.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_resize"></a>5.4.13. <code class="function">igraph_sparsemat_resize</code> —  Resizes a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.5.14.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_resize(igraph_sparsemat_t *A, long int nrow,
                            long int ncol, int nzmax);
</pre></div>
<p>
</p>
<p>



This function resizes a sparse matrix. The resized sparse matrix
will be empty.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The initialized sparse matrix to resize.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nrow</code></em>:</span></p></td>
<td><p>
  The new number of rows.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>ncol</code></em>:</span></p></td>
<td><p>
  The new number of columns.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nzmax</code></em>:</span></p></td>
<td><p>
  The new maximum number of elements.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nzmax), the maximum number of non-zero elements.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="operations-on_sparse_matrix_iterators"></a>5.5. Operations on sparse matrix iterators</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_iterator_init">5.5.1. <code class="function">igraph_sparsemat_iterator_init</code> —  Initialize a sparse matrix iterator.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_iterator_reset">5.5.2. <code class="function">igraph_sparsemat_iterator_reset</code> —  Reset a sparse matrix iterator to the first element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_iterator_end">5.5.3. <code class="function">igraph_sparsemat_iterator_end</code> —  Query if the iterator is past the last element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_iterator_row">5.5.4. <code class="function">igraph_sparsemat_iterator_row</code> —  Return the row of the iterator.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_iterator_col">5.5.5. <code class="function">igraph_sparsemat_iterator_col</code> —  Return the column of the iterator.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_iterator_get">5.5.6. <code class="function">igraph_sparsemat_iterator_get</code> —  Return the element at the current iterator position.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_iterator_next">5.5.7. <code class="function">igraph_sparsemat_iterator_next</code> —  Let a sparse matrix iterator go to the next element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_iterator_idx">5.5.8. <code class="function">igraph_sparsemat_iterator_idx</code> —  Returns the element vector index of a sparse matrix iterator.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_iterator_init"></a>5.5.1. <code class="function">igraph_sparsemat_iterator_init</code> —  Initialize a sparse matrix iterator.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.6.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_iterator_init(igraph_sparsemat_iterator_t *it,
                                   igraph_sparsemat_t *sparsemat);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>it</code></em>:</span></p></td>
<td><p>
  A pointer to an uninitialized sparse matrix iterator.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>sparsemat</code></em>:</span></p></td>
<td><p>
  Pointer to the sparse matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code. This will always return <code class="constant">IGRAPH_SUCCESS</code>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of columns of the sparse matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_iterator_reset"></a>5.5.2. <code class="function">igraph_sparsemat_iterator_reset</code> —  Reset a sparse matrix iterator to the first element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.6.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_iterator_reset(igraph_sparsemat_iterator_t *it);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>it</code></em>:</span></p></td>
<td><p>
  A pointer to the sparse matrix iterator.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code. This will always return <code class="constant">IGRAPH_SUCCESS</code>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of columns of the sparse matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_iterator_end"></a>5.5.3. <code class="function">igraph_sparsemat_iterator_end</code> —  Query if the iterator is past the last element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.6.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t
igraph_sparsemat_iterator_end(const igraph_sparsemat_iterator_t *it);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>it</code></em>:</span></p></td>
<td><p>
  A pointer to the sparse matrix iterator.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  true if the iterator is past the last element, false if it
        points to an element in a sparse matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_iterator_row"></a>5.5.4. <code class="function">igraph_sparsemat_iterator_row</code> —  Return the row of the iterator.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.6.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_iterator_row(const igraph_sparsemat_iterator_t *it);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>it</code></em>:</span></p></td>
<td><p>
  A pointer to the sparse matrix iterator.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The row of the element at the current iterator position.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_iterator_col"></a>5.5.5. <code class="function">igraph_sparsemat_iterator_col</code> —  Return the column of the iterator.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.6.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_iterator_col(const igraph_sparsemat_iterator_t *it);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>it</code></em>:</span></p></td>
<td><p>
  A pointer to the sparse matrix iterator.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The column of the element at the current iterator position.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_iterator_get"></a>5.5.6. <code class="function">igraph_sparsemat_iterator_get</code> —  Return the element at the current iterator position.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.6.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t
igraph_sparsemat_iterator_get(const igraph_sparsemat_iterator_t *it);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>it</code></em>:</span></p></td>
<td><p>
  A pointer to the sparse matrix iterator.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The value of the element at the current iterator position.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_iterator_next"></a>5.5.7. <code class="function">igraph_sparsemat_iterator_next</code> —  Let a sparse matrix iterator go to the next element.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.6.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_iterator_next(igraph_sparsemat_iterator_t *it);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>it</code></em>:</span></p></td>
<td><p>
  A pointer to the sparse matrix iterator.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The position of the iterator in the element vector.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of columns of the sparse matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_iterator_idx"></a>5.5.8. <code class="function">igraph_sparsemat_iterator_idx</code> —  Returns the element vector index of a sparse matrix iterator.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.6.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_iterator_idx(const igraph_sparsemat_iterator_t *it);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>it</code></em>:</span></p></td>
<td><p>
  A pointer to the sparse matrix iterator.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The position of the iterator in the element vector.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="operations-that-change-the-internal-representation"></a>5.6. Operations that change the internal representation</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_compress">5.6.1. <code class="function">igraph_sparsemat_compress</code> —  Converts a sparse matrix to column-compressed format.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_dupl">5.6.2. <code class="function">igraph_sparsemat_dupl</code> —  Removes duplicate elements from a sparse matrix.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_compress"></a>5.6.1. <code class="function">igraph_sparsemat_compress</code> —  Converts a sparse matrix to column-compressed format.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.7.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_compress(const igraph_sparsemat_t *A,
                              igraph_sparsemat_t *res);
</pre></div>
<p>
</p>
<p>



Converts a sparse matrix from triplet format to column-compressed format.
Almost all sparse matrix operations require that the matrix is in
column-compressed format.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, it must be in triplet format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized sparse matrix object, the
   compressed version of <em class="parameter"><code>A</code></em> is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nz) where <code class="constant">nz</code> is the number of non-zero elements.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_dupl"></a>5.6.2. <code class="function">igraph_sparsemat_dupl</code> —  Removes duplicate elements from a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.7.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_dupl(igraph_sparsemat_t *A);
</pre></div>
<p>
</p>
<p>



It is possible that a column-compressed sparse matrix stores a
single matrix entry in multiple pieces. The entry is then the sum
of all its pieces. (Some functions create matrices like this.) This
function eliminates the multiple pieces.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="decompositions-and-solving-linear-systems"></a>5.7. Decompositions and solving linear systems</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_symblu">5.7.1. <code class="function">igraph_sparsemat_symblu</code> —  Symbolic LU decomposition.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_symbqr">5.7.2. <code class="function">igraph_sparsemat_symbqr</code> —  Symbolic QR decomposition.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_lsolve">5.7.3. <code class="function">igraph_sparsemat_lsolve</code> —  Solves a lower-triangular linear system.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_ltsolve">5.7.4. <code class="function">igraph_sparsemat_ltsolve</code> —  Solves an upper-triangular linear system.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_usolve">5.7.5. <code class="function">igraph_sparsemat_usolve</code> —  Solves an upper-triangular linear system.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_utsolve">5.7.6. <code class="function">igraph_sparsemat_utsolve</code> —  Solves a lower-triangular linear system.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_cholsol">5.7.7. <code class="function">igraph_sparsemat_cholsol</code> —  Solves a symmetric linear system via Cholesky decomposition.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_lusol">5.7.8. <code class="function">igraph_sparsemat_lusol</code> —  Solves a linear system via LU decomposition.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_lu">5.7.9. <code class="function">igraph_sparsemat_lu</code> —  LU decomposition of a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_qr">5.7.10. <code class="function">igraph_sparsemat_qr</code> —  QR decomposition of a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_luresol">5.7.11. <code class="function">igraph_sparsemat_luresol</code> —  Solves a linear system using a precomputed LU decomposition.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_qrresol">5.7.12. <code class="function">igraph_sparsemat_qrresol</code> —  Solves a linear system using a precomputed QR decomposition.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_symbolic_destroy">5.7.13. <code class="function">igraph_sparsemat_symbolic_destroy</code> —  Deallocates memory after a symbolic decomposition.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_numeric_destroy">5.7.14. <code class="function">igraph_sparsemat_numeric_destroy</code> —  Deallocates memory after a numeric decomposition.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_symblu"></a>5.7.1. <code class="function">igraph_sparsemat_symblu</code> —  Symbolic LU decomposition.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_symblu(long int order, const igraph_sparsemat_t *A,
                            igraph_sparsemat_symbolic_t *dis);
</pre></div>
<p>
</p>
<p>



LU decomposition of sparse matrices involves two steps, the first
is calling this function, and then <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_lu" title="5.7.9. igraph_sparsemat_lu — LU decomposition of a sparse matrix."><code class="function">igraph_sparsemat_lu()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>order</code></em>:</span></p></td>
<td><p>
  The ordering to use: 0 means natural ordering, 1 means
  minimum degree ordering of A+A', 2 is minimum degree ordering of
  A'A after removing the dense rows from A, and 3 is the minimum
  degree ordering of A'A.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>dis</code></em>:</span></p></td>
<td><p>
  The result of the symbolic analysis is stored here. Once
   not needed anymore, it must be destroyed by calling <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_symbolic_destroy" title="5.7.13. igraph_sparsemat_symbolic_destroy — Deallocates memory after a symbolic decomposition."><code class="function">igraph_sparsemat_symbolic_destroy()</code></a>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_symbqr"></a>5.7.2. <code class="function">igraph_sparsemat_symbqr</code> —  Symbolic QR decomposition.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_symbqr(long int order, const igraph_sparsemat_t *A,
                            igraph_sparsemat_symbolic_t *dis);
</pre></div>
<p>
</p>
<p>



QR decomposition of sparse matrices involves two steps, the first
is calling this function, and then <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_qr" title="5.7.10. igraph_sparsemat_qr — QR decomposition of a sparse matrix."><code class="function">igraph_sparsemat_qr()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>order</code></em>:</span></p></td>
<td><p>
  The ordering to use: 0 means natural ordering, 1 means
  minimum degree ordering of A+A', 2 is minimum degree ordering of
  A'A after removing the dense rows from A, and 3 is the minimum
  degree ordering of A'A.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>dis</code></em>:</span></p></td>
<td><p>
  The result of the symbolic analysis is stored here. Once
   not needed anymore, it must be destroyed by calling <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_symbolic_destroy" title="5.7.13. igraph_sparsemat_symbolic_destroy — Deallocates memory after a symbolic decomposition."><code class="function">igraph_sparsemat_symbolic_destroy()</code></a>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_lsolve"></a>5.7.3. <code class="function">igraph_sparsemat_lsolve</code> —  Solves a lower-triangular linear system.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_lsolve(const igraph_sparsemat_t *L,
                            const igraph_vector_t *b,
                            igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>



Solve the Lx=b linear equation system, where the L coefficient
matrix is square and lower-triangular, with a zero-free diagonal.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>L</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>b</code></em>:</span></p></td>
<td><p>
  The right hand side of the linear system.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_ltsolve"></a>5.7.4. <code class="function">igraph_sparsemat_ltsolve</code> —  Solves an upper-triangular linear system.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_ltsolve(const igraph_sparsemat_t *L,
                             const igraph_vector_t *b,
                             igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>



Solve the L'x=b linear equation system, where the L
matrix is square and lower-triangular, with a zero-free diagonal.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>L</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>b</code></em>:</span></p></td>
<td><p>
  The right hand side of the linear system.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_usolve"></a>5.7.5. <code class="function">igraph_sparsemat_usolve</code> —  Solves an upper-triangular linear system.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_usolve(const igraph_sparsemat_t *U,
                            const igraph_vector_t *b,
                            igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>



Solves the Ux=b upper triangular system.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>U</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>b</code></em>:</span></p></td>
<td><p>
  The right hand side of the linear system.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_utsolve"></a>5.7.6. <code class="function">igraph_sparsemat_utsolve</code> —  Solves a lower-triangular linear system.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_utsolve(const igraph_sparsemat_t *U,
                             const igraph_vector_t *b,
                             igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>



This is the same as <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_usolve" title="5.7.5. igraph_sparsemat_usolve — Solves an upper-triangular linear system."><code class="function">igraph_sparsemat_usolve()</code></a>, but U'x=b is
solved, where the apostrophe denotes the transpose.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>U</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>b</code></em>:</span></p></td>
<td><p>
  The right hand side of the linear system.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the result is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_cholsol"></a>5.7.7. <code class="function">igraph_sparsemat_cholsol</code> —  Solves a symmetric linear system via Cholesky decomposition.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_cholsol(const igraph_sparsemat_t *A,
                             const igraph_vector_t *b,
                             igraph_vector_t *res,
                             int order);
</pre></div>
<p>
</p>
<p>



Solve Ax=b, where A is a symmetric positive definite matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The right hand side.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>order</code></em>:</span></p></td>
<td><p>
  An integer giving the ordering method to use for the
   factorization. Zero is the natural ordering; if it is one, then
   the fill-reducing minimum-degree ordering of A+A' is used.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_lusol"></a>5.7.8. <code class="function">igraph_sparsemat_lusol</code> —  Solves a linear system via LU decomposition.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_lusol(const igraph_sparsemat_t *A,
                           const igraph_vector_t *b,
                           igraph_vector_t *res,
                           int order,
                           igraph_real_t tol);
</pre></div>
<p>
</p>
<p>



Solve Ax=b, via LU factorization of A.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>b</code></em>:</span></p></td>
<td><p>
  The right hand side of the equation.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>order</code></em>:</span></p></td>
<td><p>
  The ordering method to use, zero means the natural
   ordering, one means the fill-reducing minimum-degree ordering of
   A+A', two means the ordering of A'*A, after removing the dense
   rows from A. Three means the ordering of A'*A.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>tol</code></em>:</span></p></td>
<td><p>
  Real number, the tolerance limit to use for the numeric
   LU factorization.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_lu"></a>5.7.9. <code class="function">igraph_sparsemat_lu</code> —  LU decomposition of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_lu(const igraph_sparsemat_t *A,
                        const igraph_sparsemat_symbolic_t *dis,
                        igraph_sparsemat_numeric_t *din, double tol);
</pre></div>
<p>
</p>
<p>



Performs numeric sparse LU decomposition of a matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>dis</code></em>:</span></p></td>
<td><p>
  The symbolic analysis for LU decomposition, coming from
   a call to the <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_symblu" title="5.7.1. igraph_sparsemat_symblu — Symbolic LU decomposition."><code class="function">igraph_sparsemat_symblu()</code></a> function.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>din</code></em>:</span></p></td>
<td><p>
  The numeric decomposition, the result is stored here. It
   can be used to solve linear systems with changing right hand
   side vectors, by calling <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_luresol" title="5.7.11. igraph_sparsemat_luresol — Solves a linear system using a precomputed LU decomposition."><code class="function">igraph_sparsemat_luresol()</code></a>. Once
   not needed any more, it must be destroyed by calling <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_symbolic_destroy" title="5.7.13. igraph_sparsemat_symbolic_destroy — Deallocates memory after a symbolic decomposition."><code class="function">igraph_sparsemat_symbolic_destroy()</code></a> on it.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>tol</code></em>:</span></p></td>
<td><p>
  The tolerance for the numeric LU decomposition.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_qr"></a>5.7.10. <code class="function">igraph_sparsemat_qr</code> —  QR decomposition of a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_qr(const igraph_sparsemat_t *A,
                        const igraph_sparsemat_symbolic_t *dis,
                        igraph_sparsemat_numeric_t *din);
</pre></div>
<p>
</p>
<p>



Numeric QR decomposition of a sparse matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>dis</code></em>:</span></p></td>
<td><p>
  The result of the symbolic QR analysis, from the
   function <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_symbqr" title="5.7.2. igraph_sparsemat_symbqr — Symbolic QR decomposition."><code class="function">igraph_sparsemat_symbqr()</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>din</code></em>:</span></p></td>
<td><p>
  The result of the decomposition is stored here, it can
   be used to solve many linear systems with the same coefficient
   matrix and changing right hand sides, using the <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_qrresol" title="5.7.12. igraph_sparsemat_qrresol — Solves a linear system using a precomputed QR decomposition."><code class="function">igraph_sparsemat_qrresol()</code></a> function. Once not needed any more,
   one should call <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_numeric_destroy" title="5.7.14. igraph_sparsemat_numeric_destroy — Deallocates memory after a numeric decomposition."><code class="function">igraph_sparsemat_numeric_destroy()</code></a> on it to
   free the allocated memory.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_luresol"></a>5.7.11. <code class="function">igraph_sparsemat_luresol</code> —  Solves a linear system using a precomputed LU decomposition.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_luresol(const igraph_sparsemat_symbolic_t *dis,
                             const igraph_sparsemat_numeric_t *din,
                             const igraph_vector_t *b,
                             igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>



Uses the LU decomposition of a matrix to solve linear systems.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>dis</code></em>:</span></p></td>
<td><p>
  The symbolic analysis of the coefficient matrix, the
   result of <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_symblu" title="5.7.1. igraph_sparsemat_symblu — Symbolic LU decomposition."><code class="function">igraph_sparsemat_symblu()</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>din</code></em>:</span></p></td>
<td><p>
  The LU decomposition, the result of a call to <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_lu" title="5.7.9. igraph_sparsemat_lu — LU decomposition of a sparse matrix."><code class="function">igraph_sparsemat_lu()</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>b</code></em>:</span></p></td>
<td><p>
  A vector that defines the right hand side of the linear
   equation system.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the solution of the linear system
   is stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_qrresol"></a>5.7.12. <code class="function">igraph_sparsemat_qrresol</code> —  Solves a linear system using a precomputed QR decomposition.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.13.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_qrresol(const igraph_sparsemat_symbolic_t *dis,
                             const igraph_sparsemat_numeric_t *din,
                             const igraph_vector_t *b,
                             igraph_vector_t *res);
</pre></div>
<p>
</p>
<p>



Solves a linear system using a QR decomposition of its coefficient
matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>dis</code></em>:</span></p></td>
<td><p>
  Symbolic analysis of the coefficient matrix, the result
   of <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_symbqr" title="5.7.2. igraph_sparsemat_symbqr — Symbolic QR decomposition."><code class="function">igraph_sparsemat_symbqr()</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>din</code></em>:</span></p></td>
<td><p>
  The QR decomposition of the coefficient matrix, the
   result of <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_qr" title="5.7.10. igraph_sparsemat_qr — QR decomposition of a sparse matrix."><code class="function">igraph_sparsemat_qr()</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>b</code></em>:</span></p></td>
<td><p>
  Vector, giving the right hand side of the linear equation
   system.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An initialized vector, the solution is stored here. It
   is resized as needed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_symbolic_destroy"></a>5.7.13. <code class="function">igraph_sparsemat_symbolic_destroy</code> —  Deallocates memory after a symbolic decomposition.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.14.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_sparsemat_symbolic_destroy(igraph_sparsemat_symbolic_t *dis);
</pre></div>
<p>
</p>
<p>



Frees the memory allocated by <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_symbqr" title="5.7.2. igraph_sparsemat_symbqr — Symbolic QR decomposition."><code class="function">igraph_sparsemat_symbqr()</code></a> or
<a class="link" href="igraph-Data-structures.html#igraph_sparsemat_symblu" title="5.7.1. igraph_sparsemat_symblu — Symbolic LU decomposition."><code class="function">igraph_sparsemat_symblu()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>dis</code></em>:</span></p></td>
<td><p>
  The symbolic analysis.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_numeric_destroy"></a>5.7.14. <code class="function">igraph_sparsemat_numeric_destroy</code> —  Deallocates memory after a numeric decomposition.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.8.15.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_sparsemat_numeric_destroy(igraph_sparsemat_numeric_t *din);
</pre></div>
<p>
</p>
<p>



Frees the memoty allocated by <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_qr" title="5.7.10. igraph_sparsemat_qr — QR decomposition of a sparse matrix."><code class="function">igraph_sparsemat_qr()</code></a> or <a class="link" href="igraph-Data-structures.html#igraph_sparsemat_lu" title="5.7.9. igraph_sparsemat_lu — LU decomposition of a sparse matrix."><code class="function">igraph_sparsemat_lu()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>din</code></em>:</span></p></td>
<td><p>
  The LU or QR decomposition.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="eigenvalues-and-eigenvectors"></a>5.8. Eigenvalues and eigenvectors</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_arpack_rssolve">5.8.1. <code class="function">igraph_sparsemat_arpack_rssolve</code> —  Eigenvalues and eigenvectors of a symmetric sparse matrix via ARPACK.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_arpack_rnsolve">5.8.2. <code class="function">igraph_sparsemat_arpack_rnsolve</code> —  Eigenvalues and eigenvectors of a nonsymmetric sparse matrix via ARPACK.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_arpack_rssolve"></a>5.8.1. <code class="function">igraph_sparsemat_arpack_rssolve</code> —  Eigenvalues and eigenvectors of a symmetric sparse matrix via ARPACK.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.9.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_arpack_rssolve(const igraph_sparsemat_t *A,
                                    igraph_arpack_options_t *options,
                                    igraph_arpack_storage_t *storage,
                                    igraph_vector_t *values,
                                    igraph_matrix_t *vectors,
                                    igraph_sparsemat_solve_t solvemethod);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>The</code></em>:</span></p></td>
<td><p>
  input matrix, must be column-compressed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  It is passed to <a class="link" href="igraph-Arpack.html#igraph_arpack_rssolve" title="3.2.1. igraph_arpack_rssolve — ARPACK solver for symmetric matrices"><code class="function">igraph_arpack_rssolve()</code></a>. See
   <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a> for the details. If <code class="constant">mode</code> is 1,
   then ARPACK uses regular mode, if <code class="constant">mode</code> is 3, then shift and
   invert mode is used and the <code class="constant">sigma</code> structure member defines
   the shift.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>storage</code></em>:</span></p></td>
<td><p>
  Storage for ARPACK. See <a class="link" href="igraph-Arpack.html#igraph_arpack_rssolve" title="3.2.1. igraph_arpack_rssolve — ARPACK solver for symmetric matrices"><code class="function">igraph_arpack_rssolve()</code></a> and <a class="link" href="igraph-Arpack.html#igraph_arpack_storage_t" title="3.1.2. igraph_arpack_storage_t — Storage for ARPACK"><code class="function">igraph_arpack_storage_t</code></a> for
   details.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>values</code></em>:</span></p></td>
<td><p>
  An initialized vector or a null pointer, the
   eigenvalues are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vectors</code></em>:</span></p></td>
<td><p>
  An initialised matrix, or a null pointer, the
   eigenvectors are stored here, in the columns.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>solvemethod</code></em>:</span></p></td>
<td>
<p>
  The method to solve the linear system, if <code class="constant">mode</code> is 3, i.e. the shift and invert mode is used.
   Possible values:
   </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_SPARSEMAT_SOLVE_LU</code></span></p></td>
<td><p>

          The linear system is solved using LU decomposition.
     
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_SPARSEMAT_SOLVE_QR</code></span></p></td>
<td><p>

          The linear system is solved using QR decomposition.
   
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_arpack_rnsolve"></a>5.8.2. <code class="function">igraph_sparsemat_arpack_rnsolve</code> —  Eigenvalues and eigenvectors of a nonsymmetric sparse matrix via ARPACK.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.9.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_arpack_rnsolve(const igraph_sparsemat_t *A,
                                    igraph_arpack_options_t *options,
                                    igraph_arpack_storage_t *storage,
                                    igraph_matrix_t *values,
                                    igraph_matrix_t *vectors);
</pre></div>
<p>
</p>
<p>



Eigenvalues and/or eigenvectors of a nonsymmetric sparse matrix.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in column-compressed mode.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>options</code></em>:</span></p></td>
<td><p>
  ARPACK options, it is passed to <a class="link" href="igraph-Arpack.html#igraph_arpack_rnsolve" title="3.2.2. igraph_arpack_rnsolve — ARPACK solver for non-symmetric matrices"><code class="function">igraph_arpack_rnsolve()</code></a>. See also <a class="link" href="igraph-Arpack.html#igraph_arpack_options_t" title="3.1.1. igraph_arpack_options_t — Options for ARPACK"><code class="function">igraph_arpack_options_t</code></a>
   for details.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>storage</code></em>:</span></p></td>
<td><p>
  Storage for ARPACK, this is passed to <a class="link" href="igraph-Arpack.html#igraph_arpack_rnsolve" title="3.2.2. igraph_arpack_rnsolve — ARPACK solver for non-symmetric matrices"><code class="function">igraph_arpack_rnsolve()</code></a>. See <a class="link" href="igraph-Arpack.html#igraph_arpack_storage_t" title="3.1.2. igraph_arpack_storage_t — Storage for ARPACK"><code class="function">igraph_arpack_storage_t</code></a> for
   details.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>values</code></em>:</span></p></td>
<td><p>
  An initialized matrix, or a null pointer. If not a
   null pointer, then the eigenvalues are stored here, the first
   column is the real part, the second column is the imaginary
   part.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vectors</code></em>:</span></p></td>
<td><p>
  An initialized matrix, or a null pointer. If not a
   null pointer, then the eigenvectors are stored here, please see
   <a class="link" href="igraph-Arpack.html#igraph_arpack_rnsolve" title="3.2.2. igraph_arpack_rnsolve — ARPACK solver for non-symmetric matrices"><code class="function">igraph_arpack_rnsolve()</code></a> for the format.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="conversion-to-other-data-types"></a>5.9. Conversion to other data types</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat">5.9.1. <code class="function">igraph_sparsemat</code> —  Creates an igraph graph from a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_get_sparsemat">5.9.2. <code class="function">igraph_get_sparsemat</code> —  Converts an igraph graph to a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_matrix_as_sparsemat">5.9.3. <code class="function">igraph_matrix_as_sparsemat</code> —  Converts a dense matrix to a sparse matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_as_matrix">5.9.4. <code class="function">igraph_sparsemat_as_matrix</code> —  Converts a sparse matrix to a dense matrix.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat"></a>5.9.1. <code class="function">igraph_sparsemat</code> —  Creates an igraph graph from a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.10.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat(igraph_t *graph, const igraph_sparsemat_t *A,
                     igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



One edge is created for each non-zero entry in the matrix. If you
have a symmetric matrix, and want to create an undirected graph,
then delete the entries in the upper diagonal first, or call <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.5. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a> on the result graph to eliminate the multiple
edges.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized igraph_t object, the
   graphs is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, in triplet or column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean scalar, whether to create a directed
   graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_get_sparsemat"></a>5.9.2. <code class="function">igraph_get_sparsemat</code> —  Converts an igraph graph to a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.10.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_get_sparsemat(const igraph_t *graph, igraph_sparsemat_t *res);
</pre></div>
<p>
</p>
<p>



If the graph is undirected, then a symmetric matrix is created.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized sparse matrix. The result
   will be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_matrix_as_sparsemat"></a>5.9.3. <code class="function">igraph_matrix_as_sparsemat</code> —  Converts a dense matrix to a sparse matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.10.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_matrix_as_sparsemat(igraph_sparsemat_t *res,
                               const igraph_matrix_t *mat,
                               igraph_real_t tol);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  An uninitialized sparse matrix, the result is stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mat</code></em>:</span></p></td>
<td><p>
  The dense input matrix.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>tol</code></em>:</span></p></td>
<td><p>
  Real scalar, the tolerance. Values closer than <em class="parameter"><code>tol</code></em> to
   zero are considered as zero, and will not be included in the
   sparse matrix.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements in the dense
matrix.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_as_matrix"></a>5.9.4. <code class="function">igraph_sparsemat_as_matrix</code> —  Converts a sparse matrix to a dense matrix.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.10.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_as_matrix(igraph_matrix_t *res,
                               const igraph_sparsemat_t *spmat);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized matrix, the result is stored
   here. It will be resized to the required size.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>spmat</code></em>:</span></p></td>
<td><p>
  The input sparse matrix, in triplet or
   column-compressed format.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(mn), the number of elements in the dense
matrix.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="writing-to-a-file-or-to-the-screen"></a>5.10. Writing to a file, or to the screen</h3></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Data-structures.html#igraph_sparsemat_print">5.10.1. <code class="function">igraph_sparsemat_print</code> —  Prints a sparse matrix to a file.</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_sparsemat_print"></a>5.10.1. <code class="function">igraph_sparsemat_print</code> —  Prints a sparse matrix to a file.</h4></div></div></div>
<a class="indexterm" name="id-1.8.6.11.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_sparsemat_print(const igraph_sparsemat_t *A,
                           FILE *outstream);
</pre></div>
<p>
</p>
<p>



Only the non-zero entries are printed. This function serves more as
a debugging utility, as currently there is no function that could
read back the printed matrix from the file.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The input matrix, triplet or column-compressed format.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>outstream</code></em>:</span></p></td>
<td><p>
  The stream to print it to.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(nz) for triplet matrices, O(n+nz) for
column-compressed matrices. nz is the number of non-zero elements,
n is the number columns in the matrix.
 
</p>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="igraph-Stacks"></a>6. Stacks</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_stack_init">6.1. <code class="function">igraph_stack_init</code> —  Initializes a stack.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_stack_destroy">6.2. <code class="function">igraph_stack_destroy</code> —  Destroys a stack object.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_stack_reserve">6.3. <code class="function">igraph_stack_reserve</code> —  Reserve memory.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_stack_empty">6.4. <code class="function">igraph_stack_empty</code> —  Decides whether a stack object is empty.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_stack_size">6.5. <code class="function">igraph_stack_size</code> —  Returns the number of elements in a stack.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_stack_clear">6.6. <code class="function">igraph_stack_clear</code> —  Removes all elements from a stack.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_stack_push">6.7. <code class="function">igraph_stack_push</code> —  Places an element on the top of a stack.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_stack_pop">6.8. <code class="function">igraph_stack_pop</code> —  Removes and returns an element from the top of a stack.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_stack_top">6.9. <code class="function">igraph_stack_top</code> —  Query top element.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_stack_init"></a>6.1. <code class="function">igraph_stack_init</code> —  Initializes a stack.</h3></div></div></div>
<a class="indexterm" name="id-1.8.7.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_stack_init(igraph_stack_t* s, long int size);
</pre></div>
<p>
</p>
<p>




The initialized stack is always empty.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>s</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized stack.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>size</code></em>:</span></p></td>
<td><p>
  The number of elements to allocate memory for.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(<em class="parameter"><code>size</code></em>).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_stack_destroy"></a>6.2. <code class="function">igraph_stack_destroy</code> —  Destroys a stack object.</h3></div></div></div>
<a class="indexterm" name="id-1.8.7.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_stack_destroy(igraph_stack_t* s);
</pre></div>
<p>
</p>
<p>




Deallocate the memory used for a stack.
It is possible to reinitialize a destroyed stack again by
<a class="link" href="igraph-Data-structures.html#igraph_stack_init" title="6.1. igraph_stack_init — Initializes a stack."><code class="function">igraph_stack_init()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>s</code></em>:</span></p></td>
<td><p>
  The stack to destroy.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_stack_reserve"></a>6.3. <code class="function">igraph_stack_reserve</code> —  Reserve memory.</h3></div></div></div>
<a class="indexterm" name="id-1.8.7.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_stack_reserve(igraph_stack_t* s, long int size);
</pre></div>
<p>
</p>
<p>




Reserve memory for future use. The actual size of the stack is
unchanged.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>s</code></em>:</span></p></td>
<td><p>
  The stack object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>size</code></em>:</span></p></td>
<td><p>
  The number of elements to reserve memory for. If it is
    not bigger than the current size then nothing happens.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: should be around O(n), the new allocated size of
the stack.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_stack_empty"></a>6.4. <code class="function">igraph_stack_empty</code> —  Decides whether a stack object is empty.</h3></div></div></div>
<a class="indexterm" name="id-1.8.7.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_stack_empty(igraph_stack_t* s);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>s</code></em>:</span></p></td>
<td><p>
  The stack object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Boolean, <code class="constant">TRUE</code> if the stack is empty, <code class="constant">FALSE</code>
otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_stack_size"></a>6.5. <code class="function">igraph_stack_size</code> —  Returns the number of elements in a stack.</h3></div></div></div>
<a class="indexterm" name="id-1.8.7.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_stack_size(const igraph_stack_t* s);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>s</code></em>:</span></p></td>
<td><p>
  The stack object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of elements in the stack.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_stack_clear"></a>6.6. <code class="function">igraph_stack_clear</code> —  Removes all elements from a stack.</h3></div></div></div>
<a class="indexterm" name="id-1.8.7.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_stack_clear(igraph_stack_t* s);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>s</code></em>:</span></p></td>
<td><p>
  The stack object.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_stack_push"></a>6.7. <code class="function">igraph_stack_push</code> —  Places an element on the top of a stack.</h3></div></div></div>
<a class="indexterm" name="id-1.8.7.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_stack_push(igraph_stack_t* s, igraph_real_t elem);
</pre></div>
<p>
</p>
<p>




The capacity of the stack is increased, if needed.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>s</code></em>:</span></p></td>
<td><p>
  The stack object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>elem</code></em>:</span></p></td>
<td><p>
  The element to push.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1) is no reallocation is needed, O(n)
otherwise, but it is ensured that n push operations are performed
in O(n) time.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_stack_pop"></a>6.8. <code class="function">igraph_stack_pop</code> —  Removes and returns an element from the top of a stack.</h3></div></div></div>
<a class="indexterm" name="id-1.8.7.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_stack_pop(igraph_stack_t* s);
</pre></div>
<p>
</p>
<p>




The stack must contain at least one element, call <a class="link" href="igraph-Data-structures.html#igraph_stack_empty" title="6.4. igraph_stack_empty — Decides whether a stack object is empty."><code class="function">igraph_stack_empty()</code></a> to make sure of this.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>s</code></em>:</span></p></td>
<td><p>
  The stack object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The removed top element.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_stack_top"></a>6.9. <code class="function">igraph_stack_top</code> —  Query top element.</h3></div></div></div>
<a class="indexterm" name="id-1.8.7.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_stack_top(const igraph_stack_t* s);
</pre></div>
<p>
</p>
<p>




Returns the top element of the stack, without removing it.
The stack must be non-empty.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>s</code></em>:</span></p></td>
<td><p>
  The stack.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The top element.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="igraph-Dqueues"></a>7. Double-ended queues</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_dqueue_init">7.1. <code class="function">igraph_dqueue_init</code> —  Initialize a double ended queue (deque).</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_dqueue_destroy">7.2. <code class="function">igraph_dqueue_destroy</code> —  Destroy a double ended queue.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_dqueue_empty">7.3. <code class="function">igraph_dqueue_empty</code> —  Decide whether the queue is empty.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_dqueue_full">7.4. <code class="function">igraph_dqueue_full</code> —  Check whether the queue is full.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_dqueue_clear">7.5. <code class="function">igraph_dqueue_clear</code> —  Remove all elements from the queue.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_dqueue_size">7.6. <code class="function">igraph_dqueue_size</code> —  Number of elements in the queue.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_dqueue_head">7.7. <code class="function">igraph_dqueue_head</code> —  Head of the queue.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_dqueue_back">7.8. <code class="function">igraph_dqueue_back</code> —  Tail of the queue.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_dqueue_pop">7.9. <code class="function">igraph_dqueue_pop</code> —  Remove the head.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_dqueue_pop_back">7.10. <code class="function">igraph_dqueue_pop_back</code> —  Remove the tail</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_dqueue_push">7.11. <code class="function">igraph_dqueue_push</code> —  Appends an element.</a></span></dt>
</dl></div>
<p>
This is the classic data type of the double ended queue. Most of
the time it is used if a First-In-First-Out (FIFO) behavior is
needed. See the operations below.
</p>
<p>
</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.8.3.1"></a><p class="title"><b>Example 7.11.  File <code class="code">examples/simple/dqueue.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_dqueue_t q;
    int i;

    <span class="emphasis"><em>/* igraph_dqueue_init, igraph_dqueue_destroy, igraph_dqueue_empty */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_init" title="7.1. igraph_dqueue_init — Initialize a double ended queue (deque).">igraph_dqueue_init</a></strong></span>(&amp;q, 5);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_empty" title="7.3. igraph_dqueue_empty — Decide whether the queue is empty.">igraph_dqueue_empty</a></strong></span>(&amp;q)) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_destroy" title="7.2. igraph_dqueue_destroy — Destroy a double ended queue.">igraph_dqueue_destroy</a></strong></span>(&amp;q);

    <span class="emphasis"><em>/* igraph_dqueue_push, igraph_dqueue_pop */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_init" title="7.1. igraph_dqueue_init — Initialize a double ended queue (deque).">igraph_dqueue_init</a></strong></span>(&amp;q, 4);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_push" title="7.11. igraph_dqueue_push — Appends an element.">igraph_dqueue_push</a></strong></span>(&amp;q, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_push" title="7.11. igraph_dqueue_push — Appends an element.">igraph_dqueue_push</a></strong></span>(&amp;q, 2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_push" title="7.11. igraph_dqueue_push — Appends an element.">igraph_dqueue_push</a></strong></span>(&amp;q, 3);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_push" title="7.11. igraph_dqueue_push — Appends an element.">igraph_dqueue_push</a></strong></span>(&amp;q, 4);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_pop" title="7.9. igraph_dqueue_pop — Remove the head.">igraph_dqueue_pop</a></strong></span>(&amp;q) != 1) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_pop" title="7.9. igraph_dqueue_pop — Remove the head.">igraph_dqueue_pop</a></strong></span>(&amp;q) != 2) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_pop" title="7.9. igraph_dqueue_pop — Remove the head.">igraph_dqueue_pop</a></strong></span>(&amp;q) != 3) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_pop" title="7.9. igraph_dqueue_pop — Remove the head.">igraph_dqueue_pop</a></strong></span>(&amp;q) != 4) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_destroy" title="7.2. igraph_dqueue_destroy — Destroy a double ended queue.">igraph_dqueue_destroy</a></strong></span>(&amp;q);

    <span class="emphasis"><em>/* igraph_dqueue_clear, igraph_dqueue_size */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_init" title="7.1. igraph_dqueue_init — Initialize a double ended queue (deque).">igraph_dqueue_init</a></strong></span>(&amp;q, 0);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_size" title="7.6. igraph_dqueue_size — Number of elements in the queue.">igraph_dqueue_size</a></strong></span>(&amp;q) != 0) {
        <span class="strong"><strong>return</strong></span> 6;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_clear" title="7.5. igraph_dqueue_clear — Remove all elements from the queue.">igraph_dqueue_clear</a></strong></span>(&amp;q);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_size" title="7.6. igraph_dqueue_size — Number of elements in the queue.">igraph_dqueue_size</a></strong></span>(&amp;q) != 0) {
        <span class="strong"><strong>return</strong></span> 7;
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_push" title="7.11. igraph_dqueue_push — Appends an element.">igraph_dqueue_push</a></strong></span>(&amp;q, i);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_clear" title="7.5. igraph_dqueue_clear — Remove all elements from the queue.">igraph_dqueue_clear</a></strong></span>(&amp;q);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_size" title="7.6. igraph_dqueue_size — Number of elements in the queue.">igraph_dqueue_size</a></strong></span>(&amp;q) != 0) {
        <span class="strong"><strong>return</strong></span> 8;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_destroy" title="7.2. igraph_dqueue_destroy — Destroy a double ended queue.">igraph_dqueue_destroy</a></strong></span>(&amp;q);

    <span class="emphasis"><em>/* </em></span><span class="strong"><strong>TODO:</strong></span><span class="emphasis"><em> igraph_dqueue_full */</em></span>

    <span class="emphasis"><em>/* igraph_dqueue_head, igraph_dqueue_back, igraph_dqueue_pop_back */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_init" title="7.1. igraph_dqueue_init — Initialize a double ended queue (deque).">igraph_dqueue_init</a></strong></span>(&amp;q, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_push" title="7.11. igraph_dqueue_push — Appends an element.">igraph_dqueue_push</a></strong></span>(&amp;q, i);
    }
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 10; i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_head" title="7.7. igraph_dqueue_head — Head of the queue.">igraph_dqueue_head</a></strong></span>(&amp;q) != 0) {
            <span class="strong"><strong>return</strong></span> 9;
        }
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_back" title="7.8. igraph_dqueue_back — Tail of the queue.">igraph_dqueue_back</a></strong></span>(&amp;q) != 9 - i) {
            <span class="strong"><strong>return</strong></span> 10;
        }
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_pop_back" title="7.10. igraph_dqueue_pop_back — Remove the tail">igraph_dqueue_pop_back</a></strong></span>(&amp;q) != 9 - i) {
            <span class="strong"><strong>return</strong></span> 11;
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_destroy" title="7.2. igraph_dqueue_destroy — Destroy a double ended queue.">igraph_dqueue_destroy</a></strong></span>(&amp;q);

    <span class="emphasis"><em>/* print */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_init" title="7.1. igraph_dqueue_init — Initialize a double ended queue (deque).">igraph_dqueue_init</a></strong></span>(&amp;q, 4);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_push" title="7.11. igraph_dqueue_push — Appends an element.">igraph_dqueue_push</a></strong></span>(&amp;q, 1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_push" title="7.11. igraph_dqueue_push — Appends an element.">igraph_dqueue_push</a></strong></span>(&amp;q, 2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_push" title="7.11. igraph_dqueue_push — Appends an element.">igraph_dqueue_push</a></strong></span>(&amp;q, 3);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_push" title="7.11. igraph_dqueue_push — Appends an element.">igraph_dqueue_push</a></strong></span>(&amp;q, 4);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_pop" title="7.9. igraph_dqueue_pop — Remove the head.">igraph_dqueue_pop</a></strong></span>(&amp;q);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_pop" title="7.9. igraph_dqueue_pop — Remove the head.">igraph_dqueue_pop</a></strong></span>(&amp;q);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_push" title="7.11. igraph_dqueue_push — Appends an element.">igraph_dqueue_push</a></strong></span>(&amp;q, 5);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_push" title="7.11. igraph_dqueue_push — Appends an element.">igraph_dqueue_push</a></strong></span>(&amp;q, 6);
    <span class="strong"><strong>igraph_dqueue_print</strong></span>(&amp;q);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_clear" title="7.5. igraph_dqueue_clear — Remove all elements from the queue.">igraph_dqueue_clear</a></strong></span>(&amp;q);
    <span class="strong"><strong>igraph_dqueue_print</strong></span>(&amp;q);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_dqueue_destroy" title="7.2. igraph_dqueue_destroy — Destroy a double ended queue.">igraph_dqueue_destroy</a></strong></span>(&amp;q);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>IGRAPH_FINALLY_STACK_SIZE</strong></span>() != 0) {
        <span class="strong"><strong>return</strong></span> 12;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dqueue_init"></a>7.1. <code class="function">igraph_dqueue_init</code> —  Initialize a double ended queue (deque).</h3></div></div></div>
<a class="indexterm" name="id-1.8.8.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_dqueue_init(igraph_dqueue_t* q, long int size);
</pre></div>
<p>
</p>
<p>




The queue will be always empty.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized deque.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>size</code></em>:</span></p></td>
<td><p>
  How many elements to allocate memory for.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(<em class="parameter"><code>size</code></em>).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dqueue_destroy"></a>7.2. <code class="function">igraph_dqueue_destroy</code> —  Destroy a double ended queue.</h3></div></div></div>
<a class="indexterm" name="id-1.8.8.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_dqueue_destroy(igraph_dqueue_t* q);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  The queue to destroy</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dqueue_empty"></a>7.3. <code class="function">igraph_dqueue_empty</code> —  Decide whether the queue is empty.</h3></div></div></div>
<a class="indexterm" name="id-1.8.8.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_dqueue_empty(const igraph_dqueue_t* q);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  The queue.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Boolean, <code class="constant">TRUE</code> if <em class="parameter"><code>q</code></em> contains at least one element, <code class="constant">FALSE</code> otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dqueue_full"></a>7.4. <code class="function">igraph_dqueue_full</code> —  Check whether the queue is full.</h3></div></div></div>
<a class="indexterm" name="id-1.8.8.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_dqueue_full(igraph_dqueue_t* q);
</pre></div>
<p>
</p>
<p>




If a queue is full the next igraph_dqueue_push() operation will allocate
more memory.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  The queue.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <code class="constant">TRUE</code> if <em class="parameter"><code>q</code></em> is full, <code class="constant">FALSE</code> otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complecity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dqueue_clear"></a>7.5. <code class="function">igraph_dqueue_clear</code> —  Remove all elements from the queue.</h3></div></div></div>
<a class="indexterm" name="id-1.8.8.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_dqueue_clear(igraph_dqueue_t* q);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  The queue</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dqueue_size"></a>7.6. <code class="function">igraph_dqueue_size</code> —  Number of elements in the queue.</h3></div></div></div>
<a class="indexterm" name="id-1.8.8.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_dqueue_size(const igraph_dqueue_t* q);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  The queue.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Integer, the number of elements currently in the queue.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dqueue_head"></a>7.7. <code class="function">igraph_dqueue_head</code> —  Head of the queue.</h3></div></div></div>
<a class="indexterm" name="id-1.8.8.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_dqueue_head(const igraph_dqueue_t* q);
</pre></div>
<p>
</p>
<p>




The queue must contain at least one element.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  The queue.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The first element in the queue.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dqueue_back"></a>7.8. <code class="function">igraph_dqueue_back</code> —  Tail of the queue.</h3></div></div></div>
<a class="indexterm" name="id-1.8.8.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_dqueue_back(const igraph_dqueue_t* q);
</pre></div>
<p>
</p>
<p>




The queue must contain at least one element.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  The queue.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The last element in the queue.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dqueue_pop"></a>7.9. <code class="function">igraph_dqueue_pop</code> —  Remove the head.</h3></div></div></div>
<a class="indexterm" name="id-1.8.8.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_dqueue_pop(igraph_dqueue_t* q);
</pre></div>
<p>
</p>
<p>




Removes and returns the first element in the queue. The queue must
be non-empty.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  The input queue.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The first element in the queue.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dqueue_pop_back"></a>7.10. <code class="function">igraph_dqueue_pop_back</code> —  Remove the tail</h3></div></div></div>
<a class="indexterm" name="id-1.8.8.13.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_dqueue_pop_back(igraph_dqueue_t* q);
</pre></div>
<p>
</p>
<p>




Removes and returns the last element in the queue. The queue must
be non-empty.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  The queue.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The last element in the queue.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dqueue_push"></a>7.11. <code class="function">igraph_dqueue_push</code> —  Appends an element.</h3></div></div></div>
<a class="indexterm" name="id-1.8.8.14.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_dqueue_push(igraph_dqueue_t* q, igraph_real_t elem);
</pre></div>
<p>
</p>
<p>




Append an element to the end of the queue.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>q</code></em>:</span></p></td>
<td><p>
  The queue.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>elem</code></em>:</span></p></td>
<td><p>
  The element to append.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1) if no memory allocation is needed, O(n), the
number of elements in the queue otherwise. But not that by
allocating always twice as much memory as the current size of the
queue we ensure that n push operations can always be done in at
most O(n) time. (Assuming memory allocation is at most linear.)
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="igraph-Heaps"></a>8. Maximum and minimum heaps</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_heap_init">8.1. <code class="function">igraph_heap_init</code> —  Initializes an empty heap object.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_heap_init_array">8.2. <code class="function">igraph_heap_init_array</code> —  Build a heap from an array.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_heap_destroy">8.3. <code class="function">igraph_heap_destroy</code> —  Destroys an initialized heap object.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_heap_empty">8.4. <code class="function">igraph_heap_empty</code> —  Decides whether a heap object is empty.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_heap_push">8.5. <code class="function">igraph_heap_push</code> —  Add an element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_heap_top">8.6. <code class="function">igraph_heap_top</code> —  Top element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_heap_delete_top">8.7. <code class="function">igraph_heap_delete_top</code> —  Return and removes the top element</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_heap_size">8.8. <code class="function">igraph_heap_size</code> —  Number of elements</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_heap_reserve">8.9. <code class="function">igraph_heap_reserve</code> —  Allocate more memory</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_heap_init"></a>8.1. <code class="function">igraph_heap_init</code> —  Initializes an empty heap object.</h3></div></div></div>
<a class="indexterm" name="id-1.8.9.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_heap_init(igraph_heap_t* h, long int alloc_size);
</pre></div>
<p>
</p>
<p>




Creates an empty heap, but allocates size for some elements.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>h</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized heap object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>alloc_size</code></em>:</span></p></td>
<td><p>
  Number of elements to allocate memory for.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(<em class="parameter"><code>alloc_size</code></em>), assuming memory allocation is a
linear operation.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_heap_init_array"></a>8.2. <code class="function">igraph_heap_init_array</code> —  Build a heap from an array.</h3></div></div></div>
<a class="indexterm" name="id-1.8.9.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_heap_init_array(igraph_heap_t *h, igraph_real_t* data, long int len);
</pre></div>
<p>
</p>
<p>




Initializes a heap object from an array, the heap is also
built of course (constructor).
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>h</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized heap object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>data</code></em>:</span></p></td>
<td><p>
  Pointer to an array of base data type.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>len</code></em>:</span></p></td>
<td><p>
  The length of the array at <em class="parameter"><code>data</code></em>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of elements in the heap.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_heap_destroy"></a>8.3. <code class="function">igraph_heap_destroy</code> —  Destroys an initialized heap object.</h3></div></div></div>
<a class="indexterm" name="id-1.8.9.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_heap_destroy(igraph_heap_t* h);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>h</code></em>:</span></p></td>
<td><p>
  The heap object.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_heap_empty"></a>8.4. <code class="function">igraph_heap_empty</code> —  Decides whether a heap object is empty.</h3></div></div></div>
<a class="indexterm" name="id-1.8.9.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_bool_t igraph_heap_empty(igraph_heap_t* h);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>h</code></em>:</span></p></td>
<td><p>
  The heap object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <code class="constant">TRUE</code> if the heap is empty, <code class="constant">FALSE</code> otherwise.
  </p></td>
</tr></tbody>
</table></div>
<p>

TIme complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_heap_push"></a>8.5. <code class="function">igraph_heap_push</code> —  Add an element.</h3></div></div></div>
<a class="indexterm" name="id-1.8.9.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_heap_push(igraph_heap_t* h, igraph_real_t elem);
</pre></div>
<p>
</p>
<p>




Adds an element to the heap.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>h</code></em>:</span></p></td>
<td><p>
  The heap object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>elem</code></em>:</span></p></td>
<td><p>
  The element to add.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(log n), n is the number of elements in the
heap if no reallocation is needed, O(n) otherwise. It is ensured
that n push operations are performed in O(n log n) time.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_heap_top"></a>8.6. <code class="function">igraph_heap_top</code> —  Top element.</h3></div></div></div>
<a class="indexterm" name="id-1.8.9.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_heap_top(igraph_heap_t* h);
</pre></div>
<p>
</p>
<p>




For maximum heaps this is the largest, for minimum heaps the
smallest element of the heap.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>h</code></em>:</span></p></td>
<td><p>
  The heap object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The top element.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_heap_delete_top"></a>8.7. <code class="function">igraph_heap_delete_top</code> —  Return and removes the top element</h3></div></div></div>
<a class="indexterm" name="id-1.8.9.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_heap_delete_top(igraph_heap_t* h);
</pre></div>
<p>
</p>
<p>




Removes and returns the top element of the heap. For maximum heaps
this is the largest, for minimum heaps the smallest element.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>h</code></em>:</span></p></td>
<td><p>
  The heap object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The top element.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(log n), n is the number of elements in the
heap.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_heap_size"></a>8.8. <code class="function">igraph_heap_size</code> —  Number of elements</h3></div></div></div>
<a class="indexterm" name="id-1.8.9.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_heap_size(igraph_heap_t* h);
</pre></div>
<p>
</p>
<p>




Gives the number of elements in a heap.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>h</code></em>:</span></p></td>
<td><p>
  The heap object.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of elements in the heap.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_heap_reserve"></a>8.9. <code class="function">igraph_heap_reserve</code> —  Allocate more memory</h3></div></div></div>
<a class="indexterm" name="id-1.8.9.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_heap_reserve(igraph_heap_t* h, long int size);
</pre></div>
<p>
</p>
<p>




Allocates memory for future use. The size of the heap is
unchanged. If the heap is larger than the <em class="parameter"><code>size</code></em> parameter then
nothing happens.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>h</code></em>:</span></p></td>
<td><p>
  The heap object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>size</code></em>:</span></p></td>
<td><p>
  The number of elements to allocate memory for.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(<em class="parameter"><code>size</code></em>) if <em class="parameter"><code>size</code></em> is larger than the current
number of elements. O(1) otherwise.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="igraph-Strvector"></a>9. String vectors</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_strvector_init">9.1. <code class="function">igraph_strvector_init</code> —  Initialize</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_strvector_copy">9.2. <code class="function">igraph_strvector_copy</code> —  Initialization by copying.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_strvector_destroy">9.3. <code class="function">igraph_strvector_destroy</code> —  Free allocated memory</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#STR">9.4. <code class="function">STR</code> — Indexing string vectors</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_strvector_get">9.5. <code class="function">igraph_strvector_get</code> —  Indexing</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_strvector_set">9.6. <code class="function">igraph_strvector_set</code> —  Set an element</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_strvector_set2">9.7. <code class="function">igraph_strvector_set2</code> —  Sets an element.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_strvector_remove">9.8. <code class="function">igraph_strvector_remove</code> —  Removes a single element from a string vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_strvector_append">9.9. <code class="function">igraph_strvector_append</code> — Concatenate two string vectors.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_strvector_clear">9.10. <code class="function">igraph_strvector_clear</code> — Remove all elements</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_strvector_resize">9.11. <code class="function">igraph_strvector_resize</code> —  Resize</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_strvector_size">9.12. <code class="function">igraph_strvector_size</code> —  Gives the size of a string vector.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_strvector_add">9.13. <code class="function">igraph_strvector_add</code> —  Adds an element to the back of a string vector.</a></span></dt>
</dl></div>
<p>The <span class="type">igraph_strvector_t</span> type is a vector of strings.
The current implementation is very simple and not too efficient. It
works fine for not too many strings, e.g. the list of attribute
names is returned in a string vector by <a class="link" href="igraph-Attributes.html#igraph_cattribute_list" title="3.1.1. igraph_cattribute_list — List all attributes"><code class="function">igraph_cattribute_list()</code></a>. Do not expect great performance from this
type.</p>
<p>
</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.10.3.1"></a><p class="title"><b>Example 7.12.  File <code class="code">examples/simple/igraph_strvector.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

void <span class="strong"><strong>strvector_print</strong></span>(<span class="strong"><strong>const</strong></span> igraph_strvector_t *sv) {
    long int i, s = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_size" title="9.12. igraph_strvector_size — Gives the size of a string vector.">igraph_strvector_size</a></strong></span>(sv);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; s; i++) {
        <span class="strong"><strong>printf</strong></span>("---%s---\n", <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#STR" title="9.4. STR — Indexing string vectors">STR</a></strong></span>(*sv, i));
    }
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_strvector_t sv1, sv2;
    char *str1;
    int i;

    <span class="emphasis"><em>/* igraph_strvector_init, igraph_strvector_destroy */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_init" title="9.1. igraph_strvector_init — Initialize">igraph_strvector_init</a></strong></span>(&amp;sv1, 10);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_destroy" title="9.3. igraph_strvector_destroy — Free allocated memory">igraph_strvector_destroy</a></strong></span>(&amp;sv1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_init" title="9.1. igraph_strvector_init — Initialize">igraph_strvector_init</a></strong></span>(&amp;sv1, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_destroy" title="9.3. igraph_strvector_destroy — Free allocated memory">igraph_strvector_destroy</a></strong></span>(&amp;sv1);

    <span class="emphasis"><em>/* igraph_strvector_get, igraph_strvector_set */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_init" title="9.1. igraph_strvector_init — Initialize">igraph_strvector_init</a></strong></span>(&amp;sv1, 5);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_size" title="9.12. igraph_strvector_size — Gives the size of a string vector.">igraph_strvector_size</a></strong></span>(&amp;sv1); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_get" title="9.5. igraph_strvector_get — Indexing">igraph_strvector_get</a></strong></span>(&amp;sv1, i, &amp;str1);
        <span class="strong"><strong>printf</strong></span>("---%s---\n", str1);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 0, "zero");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 1, "one");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 2, "two");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 3, "three");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 4, "four");
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_size" title="9.12. igraph_strvector_size — Gives the size of a string vector.">igraph_strvector_size</a></strong></span>(&amp;sv1); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_get" title="9.5. igraph_strvector_get — Indexing">igraph_strvector_get</a></strong></span>(&amp;sv1, i, &amp;str1);
        <span class="strong"><strong>printf</strong></span>("---%s---\n", str1);
    }

    <span class="emphasis"><em>/* igraph_strvector_remove_section, igraph_strvector_remove,</em></span>
<span class="emphasis"><em>       igraph_strvector_resize, igraph_strvector_size */</em></span>
    <span class="strong"><strong>igraph_strvector_remove_section</strong></span>(&amp;sv1, 0, 5);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_size" title="9.12. igraph_strvector_size — Gives the size of a string vector.">igraph_strvector_size</a></strong></span>(&amp;sv1) != 0) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_resize" title="9.11. igraph_strvector_resize — Resize">igraph_strvector_resize</a></strong></span>(&amp;sv1, 10);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 0, "zero");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 1, "one");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 2, "two");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 3, "three");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 4, "four");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_resize" title="9.11. igraph_strvector_resize — Resize">igraph_strvector_resize</a></strong></span>(&amp;sv1, 5);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_size" title="9.12. igraph_strvector_size — Gives the size of a string vector.">igraph_strvector_size</a></strong></span>(&amp;sv1); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_get" title="9.5. igraph_strvector_get — Indexing">igraph_strvector_get</a></strong></span>(&amp;sv1, i, &amp;str1);
        <span class="strong"><strong>printf</strong></span>("---%s---\n", str1);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_resize" title="9.11. igraph_strvector_resize — Resize">igraph_strvector_resize</a></strong></span>(&amp;sv1, 0);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_size" title="9.12. igraph_strvector_size — Gives the size of a string vector.">igraph_strvector_size</a></strong></span>(&amp;sv1) != 0) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_resize" title="9.11. igraph_strvector_resize — Resize">igraph_strvector_resize</a></strong></span>(&amp;sv1, 10);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 0, "zero");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 1, "one");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 2, "two");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 3, "three");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 4, "four");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_resize" title="9.11. igraph_strvector_resize — Resize">igraph_strvector_resize</a></strong></span>(&amp;sv1, 5);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_size" title="9.12. igraph_strvector_size — Gives the size of a string vector.">igraph_strvector_size</a></strong></span>(&amp;sv1); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_get" title="9.5. igraph_strvector_get — Indexing">igraph_strvector_get</a></strong></span>(&amp;sv1, i, &amp;str1);
        <span class="strong"><strong>printf</strong></span>("---%s---\n", str1);
    }

    <span class="emphasis"><em>/* igraph_strvector_move_interval */</em></span>
    <span class="strong"><strong>igraph_strvector_move_interval</strong></span>(&amp;sv1, 3, 5, 0);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_size" title="9.12. igraph_strvector_size — Gives the size of a string vector.">igraph_strvector_size</a></strong></span>(&amp;sv1); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_get" title="9.5. igraph_strvector_get — Indexing">igraph_strvector_get</a></strong></span>(&amp;sv1, i, &amp;str1);
        <span class="strong"><strong>printf</strong></span>("---%s---\n", str1);
    }

    <span class="emphasis"><em>/* igraph_strvector_copy */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_copy" title="9.2. igraph_strvector_copy — Initialization by copying.">igraph_strvector_copy</a></strong></span>(&amp;sv2, &amp;sv1);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_size" title="9.12. igraph_strvector_size — Gives the size of a string vector.">igraph_strvector_size</a></strong></span>(&amp;sv2); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_get" title="9.5. igraph_strvector_get — Indexing">igraph_strvector_get</a></strong></span>(&amp;sv2, i, &amp;str1);
        <span class="strong"><strong>printf</strong></span>("---%s---\n", str1);
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_resize" title="9.11. igraph_strvector_resize — Resize">igraph_strvector_resize</a></strong></span>(&amp;sv1, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_destroy" title="9.3. igraph_strvector_destroy — Free allocated memory">igraph_strvector_destroy</a></strong></span>(&amp;sv2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_copy" title="9.2. igraph_strvector_copy — Initialization by copying.">igraph_strvector_copy</a></strong></span>(&amp;sv2, &amp;sv1);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_size" title="9.12. igraph_strvector_size — Gives the size of a string vector.">igraph_strvector_size</a></strong></span>(&amp;sv2) != 0) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_destroy" title="9.3. igraph_strvector_destroy — Free allocated memory">igraph_strvector_destroy</a></strong></span>(&amp;sv2);

    <span class="emphasis"><em>/* igraph_strvector_add */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_add" title="9.13. igraph_strvector_add — Adds an element to the back of a string vector.">igraph_strvector_add</a></strong></span>(&amp;sv1, "zeroth");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_add" title="9.13. igraph_strvector_add — Adds an element to the back of a string vector.">igraph_strvector_add</a></strong></span>(&amp;sv1, "first");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_add" title="9.13. igraph_strvector_add — Adds an element to the back of a string vector.">igraph_strvector_add</a></strong></span>(&amp;sv1, "second");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_add" title="9.13. igraph_strvector_add — Adds an element to the back of a string vector.">igraph_strvector_add</a></strong></span>(&amp;sv1, "third");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_add" title="9.13. igraph_strvector_add — Adds an element to the back of a string vector.">igraph_strvector_add</a></strong></span>(&amp;sv1, "fourth");
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_size" title="9.12. igraph_strvector_size — Gives the size of a string vector.">igraph_strvector_size</a></strong></span>(&amp;sv1); i++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_get" title="9.5. igraph_strvector_get — Indexing">igraph_strvector_get</a></strong></span>(&amp;sv1, i, &amp;str1);
        <span class="strong"><strong>printf</strong></span>("---%s---\n", str1);
    }

    <span class="emphasis"><em>/* </em></span><span class="strong"><strong>TODO:</strong></span><span class="emphasis"><em> igraph_strvector_permdelete */</em></span>
    <span class="emphasis"><em>/* </em></span><span class="strong"><strong>TODO:</strong></span><span class="emphasis"><em> igraph_strvector_remove_negidx */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_destroy" title="9.3. igraph_strvector_destroy — Free allocated memory">igraph_strvector_destroy</a></strong></span>(&amp;sv1);

    <span class="emphasis"><em>/* append */</em></span>
    <span class="strong"><strong>printf</strong></span>("---\n");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_init" title="9.1. igraph_strvector_init — Initialize">igraph_strvector_init</a></strong></span>(&amp;sv1, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_init" title="9.1. igraph_strvector_init — Initialize">igraph_strvector_init</a></strong></span>(&amp;sv2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_append" title="9.9. igraph_strvector_append — Concatenate two string vectors.">igraph_strvector_append</a></strong></span>(&amp;sv1, &amp;sv2);
    <span class="strong"><strong>strvector_print</strong></span>(&amp;sv1);
    <span class="strong"><strong>printf</strong></span>("---\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_resize" title="9.11. igraph_strvector_resize — Resize">igraph_strvector_resize</a></strong></span>(&amp;sv1, 3);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_append" title="9.9. igraph_strvector_append — Concatenate two string vectors.">igraph_strvector_append</a></strong></span>(&amp;sv1, &amp;sv2);
    <span class="strong"><strong>strvector_print</strong></span>(&amp;sv1);
    <span class="strong"><strong>printf</strong></span>("---\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_append" title="9.9. igraph_strvector_append — Concatenate two string vectors.">igraph_strvector_append</a></strong></span>(&amp;sv2, &amp;sv1);
    <span class="strong"><strong>strvector_print</strong></span>(&amp;sv2);
    <span class="strong"><strong>printf</strong></span>("---\n");

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 0, "0");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 1, "1");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 2, "2");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv2, 0, "3");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv2, 1, "4");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv2, 2, "5");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_append" title="9.9. igraph_strvector_append — Concatenate two string vectors.">igraph_strvector_append</a></strong></span>(&amp;sv1, &amp;sv2);
    <span class="strong"><strong>strvector_print</strong></span>(&amp;sv1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_destroy" title="9.3. igraph_strvector_destroy — Free allocated memory">igraph_strvector_destroy</a></strong></span>(&amp;sv1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_destroy" title="9.3. igraph_strvector_destroy — Free allocated memory">igraph_strvector_destroy</a></strong></span>(&amp;sv2);

    <span class="emphasis"><em>/* clear */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_init" title="9.1. igraph_strvector_init — Initialize">igraph_strvector_init</a></strong></span>(&amp;sv1, 3);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 0, "0");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 1, "1");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 2, "2");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_clear" title="9.10. igraph_strvector_clear — Remove all elements">igraph_strvector_clear</a></strong></span>(&amp;sv1);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_size" title="9.12. igraph_strvector_size — Gives the size of a string vector.">igraph_strvector_size</a></strong></span>(&amp;sv1) != 0) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_resize" title="9.11. igraph_strvector_resize — Resize">igraph_strvector_resize</a></strong></span>(&amp;sv1, 4);
    <span class="strong"><strong>strvector_print</strong></span>(&amp;sv1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 0, "one");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 2, "two");
    <span class="strong"><strong>strvector_print</strong></span>(&amp;sv1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_destroy" title="9.3. igraph_strvector_destroy — Free allocated memory">igraph_strvector_destroy</a></strong></span>(&amp;sv1);

    <span class="emphasis"><em>/* STR */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_init" title="9.1. igraph_strvector_init — Initialize">igraph_strvector_init</a></strong></span>(&amp;sv1, 5);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 0, "one");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 1, "two");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 2, "three");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 3, "four");
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element">igraph_strvector_set</a></strong></span>(&amp;sv1, 4, "five");
    <span class="strong"><strong>strvector_print</strong></span>(&amp;sv1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_strvector_destroy" title="9.3. igraph_strvector_destroy — Free allocated memory">igraph_strvector_destroy</a></strong></span>(&amp;sv1);

    <span class="strong"><strong>if</strong></span> (!IGRAPH_FINALLY_STACK_EMPTY) {
        <span class="strong"><strong>return</strong></span> 4;
    }

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strvector_init"></a>9.1. <code class="function">igraph_strvector_init</code> —  Initialize</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_strvector_init(igraph_strvector_t *sv, long int len);
</pre></div>
<p>
</p>
<p>




Reserves memory for the string vector, a string vector must be
first initialized before calling other functions on it.
All elements of the string vector are set to the empty string.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>sv</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized string vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>len</code></em>:</span></p></td>
<td><p>
  The (initial) length of the string vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(<em class="parameter"><code>len</code></em>).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strvector_copy"></a>9.2. <code class="function">igraph_strvector_copy</code> —  Initialization by copying.</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_strvector_copy(igraph_strvector_t *to,
                          const igraph_strvector_t *from);
</pre></div>
<p>
</p>
<p>




Initializes a string vector by copying another string vector.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized string vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The other string vector, to be copied.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(l), the total length of the strings in <em class="parameter"><code>from</code></em>.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strvector_destroy"></a>9.3. <code class="function">igraph_strvector_destroy</code> —  Free allocated memory</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_strvector_destroy(igraph_strvector_t *sv);
</pre></div>
<p>
</p>
<p>




Destroy a string vector. It may be reinitialized with <a class="link" href="igraph-Data-structures.html#igraph_strvector_init" title="9.1. igraph_strvector_init — Initialize"><code class="function">igraph_strvector_init()</code></a> later.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>sv</code></em>:</span></p></td>
<td><p>
  The string vector.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(l), the total length of the strings, maybe less
depending on the memory manager.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="STR"></a>9.4. <code class="function">STR</code> — Indexing string vectors</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.7.2"></a><p>
</p>
<pre class="programlisting">
#define STR(sv,i)
</pre>
<p>
</p>
<p>


This is a macro which allows to query the elements of a string vector in
simpler way than <a class="link" href="igraph-Data-structures.html#igraph_strvector_get" title="9.5. igraph_strvector_get — Indexing"><code class="function">igraph_strvector_get()</code></a>. Note this macro cannot be
used to set an element, for that use <a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element"><code class="function">igraph_strvector_set()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>sv</code></em>:</span></p></td>
<td><p>
  The string vector
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>i</code></em>:</span></p></td>
<td><p>
  The the index of the element.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The element at position <em class="parameter"><code>i</code></em>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strvector_get"></a>9.5. <code class="function">igraph_strvector_get</code> —  Indexing</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_strvector_get(const igraph_strvector_t *sv, long int idx,
                          char **value);
</pre></div>
<p>
</p>
<p>




Query an element of a string vector. See also the <a class="link" href="igraph-Data-structures.html#STR" title="9.4. STR — Indexing string vectors"><code class="function">STR</code></a> macro
for an easier way.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>sv</code></em>:</span></p></td>
<td><p>
  The input string vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>idx</code></em>:</span></p></td>
<td><p>
  The index of the element to query.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>Pointer</code></em>:</span></p></td>
<td><p>
  to a <span class="type">char*</span>, the address of the string
  is stored here.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strvector_set"></a>9.6. <code class="function">igraph_strvector_set</code> —  Set an element</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_strvector_set(igraph_strvector_t *sv, long int idx,
                         const char *value);
</pre></div>
<p>
</p>
<p>




The provided <em class="parameter"><code>value</code></em> is copied into the <em class="parameter"><code>idx</code></em> position in the
string vector.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>sv</code></em>:</span></p></td>
<td><p>
  The string vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>idx</code></em>:</span></p></td>
<td><p>
  The position to set.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  The new value.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(l), the length of the new string. Maybe more,
depending on the memory management, if reallocation is needed.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strvector_set2"></a>9.7. <code class="function">igraph_strvector_set2</code> —  Sets an element.</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_strvector_set2(igraph_strvector_t *sv, long int idx,
                          const char *value, int len);
</pre></div>
<p>
</p>
<p>




This is almost the same as <a class="link" href="igraph-Data-structures.html#igraph_strvector_set" title="9.6. igraph_strvector_set — Set an element"><code class="function">igraph_strvector_set</code></a>, but the new
value is not a zero terminated string, but its length is given.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>sv</code></em>:</span></p></td>
<td><p>
  The string vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>idx</code></em>:</span></p></td>
<td><p>
  The position to set.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  The new value.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>len</code></em>:</span></p></td>
<td><p>
  The length of the new value.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(l), the length of the new string. Maybe more,
depending on the memory management, if reallocation is needed.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strvector_remove"></a>9.8. <code class="function">igraph_strvector_remove</code> —  Removes a single element from a string vector.</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_strvector_remove(igraph_strvector_t *v, long int elem);
</pre></div>
<p>
</p>
<p>




The string will be one shorter.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The string vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>elem</code></em>:</span></p></td>
<td><p>
  The index of the element to remove.</p></td>
</tr>
</tbody>
</table></div>
<p>


Time complexity: O(n), the length of the string.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strvector_append"></a>9.9. <code class="function">igraph_strvector_append</code> — Concatenate two string vectors.</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_strvector_append(igraph_strvector_t *to,
                            const igraph_strvector_t *from);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>to</code></em>:</span></p></td>
<td><p>
  The first string vector, the result is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>from</code></em>:</span></p></td>
<td><p>
  The second string vector, it is kept unchanged.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n+l2), n is the number of strings in the new
string vector, l2 is the total length of strings in the <em class="parameter"><code>from</code></em>
string vector.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strvector_clear"></a>9.10. <code class="function">igraph_strvector_clear</code> — Remove all elements</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.13.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_strvector_clear(igraph_strvector_t *sv);
</pre></div>
<p>
</p>
<p>



After this operation the string vector will be empty.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>sv</code></em>:</span></p></td>
<td><p>
  The string vector.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(l), the total length of strings, maybe less,
depending on the memory manager.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strvector_resize"></a>9.11. <code class="function">igraph_strvector_resize</code> —  Resize</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.14.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_strvector_resize(igraph_strvector_t* v, long int newsize);
</pre></div>
<p>
</p>
<p>




If the new size is bigger then empty strings are added, if it is
smaller then the unneeded elements are removed.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The string vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>newsize</code></em>:</span></p></td>
<td><p>
  The new size.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n), the number of strings if the vector is made
bigger, O(l), the total length of the deleted strings if it is made
smaller, maybe less, depending on memory management.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strvector_size"></a>9.12. <code class="function">igraph_strvector_size</code> —  Gives the size of a string vector.</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.15.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_strvector_size(const igraph_strvector_t *sv);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>sv</code></em>:</span></p></td>
<td><p>
  The string vector.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The length of the string vector.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_strvector_add"></a>9.13. <code class="function">igraph_strvector_add</code> —  Adds an element to the back of a string vector.</h3></div></div></div>
<a class="indexterm" name="id-1.8.10.16.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_strvector_add(igraph_strvector_t *v, const char *value);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>v</code></em>:</span></p></td>
<td><p>
  The string vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  The string to add, it will be copied.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n+l), n is the total number of strings, l is the
length of the new string.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="igraph-Adjlists"></a>10. Adjacency lists</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#adjacent-vertices">10.1. Adjacent vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#incident-edges">10.2. Incident edges</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#lazy-adjacency-list">10.3. Lazy adjacency list for vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#lazy-incidence-list">10.4. Lazy incidence list for edges</a></span></dt>
</dl></div>
<p>Sometimes it is easier to work with a graph which is in
adjacency list format: a list of vectors; each vector contains the
neighbor vertices or incident edges of a given vertex. Typically,
this representation is good if we need to iterate over the neighbors
of all vertices many times. E.g. when finding the shortest paths
between all pairs of vertices or calculating closeness centrality
for all the vertices.</p>
<p>The <span class="type">igraph_adjlist_t</span> stores the adjacency lists
of a graph. After creation it is independent of the original graph,
it can be modified freely with the usual vector operations, the
graph is not affected. E.g. the adjacency list can be used to
rewire the edges of a graph efficiently. If one used the
straightforward <a class="link" href="igraph-Basic.html#igraph_delete_edges" title="3.3.4. igraph_delete_edges — Removes edges from a graph."><code class="function">igraph_delete_edges()</code></a> and <a class="link" href="igraph-Basic.html#igraph_add_edges" title="3.3.2. igraph_add_edges — Adds edges to a graph object."><code class="function">igraph_add_edges()</code></a> combination for this that needs O(|V|+|E|) time
for every single deletion and insertion operation, it is thus very
slow if many edges are rewired. Extracting the graph into an
adjacency list, do all the rewiring operations on the vectors of
the adjacency list and then creating a new graph needs (depending
on how exactly the rewiring is done) typically O(|V|+|E|) time for
the whole rewiring process.</p>
<p>Lazy adjacency lists are a bit different. When creating a
lazy adjacency list, the neighbors of the vertices are not queried,
only some memory is allocated for the vectors. When <a class="link" href="igraph-Data-structures.html#igraph_lazy_adjlist_get" title="10.3.3. igraph_lazy_adjlist_get — Query neighbor vertices."><code class="function">igraph_lazy_adjlist_get()</code></a> is called for vertex v the first time,
the neighbors of v are queried and stored in a vector of the
adjacency list, so they don't need to be queried again. Lazy
adjacency lists are handy if you have an at least linear operation
(because initialization is generally linear in terms of the number of
vertices), but you don't know how many vertices you will visit
during the computation.
</p>
<p>
</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.8.11.5.1"></a><p class="title"><b>Example 7.13.  File <code class="code">examples/simple/adjlist.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2008-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g, g2;
    igraph_adjlist_t adjlist;
    igraph_bool_t iso;

    <span class="emphasis"><em>/* Create a directed out-tree, convert it into an adjacency list</em></span>
<span class="emphasis"><em>     * representation, then reconstruct the graph from the tree and check</em></span>
<span class="emphasis"><em>     * whether the two are isomorphic (they should be) */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_tree" title="1.9. igraph_tree — Creates a tree in which almost all vertices have the same number of children.">igraph_tree</a></strong></span>(&amp;g, 42, 3, IGRAPH_TREE_OUT);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_adjlist_init" title="10.1.1. igraph_adjlist_init — Constructs an adjacency list of vertices from a given graph.">igraph_adjlist_init</a></strong></span>(&amp;g, &amp;adjlist, IGRAPH_OUT, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE);
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_adjlist" title="1.5. igraph_adjlist — Creates a graph from an adjacency list.">igraph_adjlist</a></strong></span>(&amp;g2, &amp;adjlist, IGRAPH_OUT, <span class="emphasis"><em>/* duplicate = */</em></span> 0);
    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic" title="1.1. igraph_isomorphic — Decides whether two graphs are isomorphic">igraph_isomorphic</a></strong></span>(&amp;g, &amp;g2, &amp;iso);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_adjlist_destroy" title="10.1.4. igraph_adjlist_destroy — Deallocates an adjacency list.">igraph_adjlist_destroy</a></strong></span>(&amp;adjlist);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g2);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="adjacent-vertices"></a>10.1. Adjacent vertices</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_adjlist_init">10.1.1. <code class="function">igraph_adjlist_init</code> —  Constructs an adjacency list of vertices from a given graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_adjlist_init_empty">10.1.2. <code class="function">igraph_adjlist_init_empty</code> —  Initializes an empty adjacency list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_adjlist_init_complementer">10.1.3. <code class="function">igraph_adjlist_init_complementer</code> —  Adjacency lists for the complementer graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_adjlist_destroy">10.1.4. <code class="function">igraph_adjlist_destroy</code> —  Deallocates an adjacency list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_adjlist_get">10.1.5. <code class="function">igraph_adjlist_get</code> —  Query a vector in an adjacency list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_adjlist_size">10.1.6. <code class="function">igraph_adjlist_size</code> —  Returns the number of vertices in an adjacency list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_adjlist_clear">10.1.7. <code class="function">igraph_adjlist_clear</code> — Removes all edges from an adjacency list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_adjlist_sort">10.1.8. <code class="function">igraph_adjlist_sort</code> —  Sorts each vector in an adjacency list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_adjlist_simplify">10.1.9. <code class="function">igraph_adjlist_simplify</code> —  Simplifies an adjacency list.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_adjlist_init"></a>10.1.1. <code class="function">igraph_adjlist_init</code> —  Constructs an adjacency list of vertices from a given graph.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.6.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_adjlist_init(const igraph_t *graph, igraph_adjlist_t *al,
                        igraph_neimode_t mode, igraph_loops_t loops,
                        igraph_multiple_t multiple);
</pre></div>
<p>
</p>
<p>



Creates a list of vectors containing the neighbors of all vertices
in a graph. The adjacency list is independent of the graph after
creation, e.g. the graph can be destroyed and modified, the
adjacency list contains the state of the graph at the time of its
initialization.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized <span class="type">igraph_adjlist_t</span> object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant specifying whether outgoing
  (<code class="literal">IGRAPH_OUT</code>), incoming (<code class="literal">IGRAPH_IN</code>),
  or both (<code class="literal">IGRAPH_ALL</code>) types of neighbors to include
  in the adjacency list. It is ignored for undirected networks.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Specifies how to treat loop edges. <code class="literal">IGRAPH_NO_LOOPS</code>
  removes loop edges from the adjacency list. <code class="literal">IGRAPH_LOOPS_ONCE</code>
  makes each loop edge appear only once in the adjacency list of the
  corresponding vertex. <code class="literal">IGRAPH_LOOPS_TWICE</code> makes loop edges
  appear <span class="emphasis"><em>twice</em></span> in the adjacency list of the corresponding vertex,
  but only if the graph is undirected or <code class="literal">mode</code> is set to
  <code class="literal">IGRAPH_ALL</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiple</code></em>:</span></p></td>
<td><p>
  Specifies how to treat multiple (parallel) edges.
  <code class="literal">IGRAPH_NO_MULTIPLE</code> collapses parallel edges into a single one;
  <code class="literal">IGRAPH_MULTIPLE</code> keeps the multiplicities of parallel edges
  so the same vertex will appear as many times in the adjacency list of
  another vertex as the number of parallel edges going between the two
  vertices.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_adjlist_init_empty"></a>10.1.2. <code class="function">igraph_adjlist_init_empty</code> —  Initializes an empty adjacency list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.6.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_adjlist_init_empty(igraph_adjlist_t *al, igraph_integer_t no_of_nodes);
</pre></div>
<p>
</p>
<p>



Creates a list of vectors, one for each vertex. This is useful when you
are <span class="emphasis"><em>constructing</em></span> a graph using an adjacency list representation as
it does not require your graph to exist yet.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>no_of_nodes</code></em>:</span></p></td>
<td><p>
  The number of vertices
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized <span class="type">igraph_adjlist_t</span> object.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|), linear in the number of vertices.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_adjlist_init_complementer"></a>10.1.3. <code class="function">igraph_adjlist_init_complementer</code> —  Adjacency lists for the complementer graph.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.6.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_adjlist_init_complementer(const igraph_t *graph,
                                     igraph_adjlist_t *al,
                                     igraph_neimode_t mode,
                                     igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>



This function creates adjacency lists for the complementer
of the input graph. In the complementer graph all edges are present
which are not present in the original graph. Multiple edges in the
input graph are ignored.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  Pointer to a not yet initialized adjacency list.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant specifying whether outgoing
  (<code class="literal">IGRAPH_OUT</code>), incoming (<code class="literal">IGRAPH_IN</code>),
  or both (<code class="literal">IGRAPH_ALL</code>) types of neighbors (in the
  complementer graph) to include in the adjacency list. It is
  ignored for undirected networks.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to consider loop edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^2+|E|), quadratic in the number of vertices.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_adjlist_destroy"></a>10.1.4. <code class="function">igraph_adjlist_destroy</code> —  Deallocates an adjacency list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.6.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_adjlist_destroy(igraph_adjlist_t *al);
</pre></div>
<p>
</p>
<p>



Free all memory allocated for an adjacency list.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  The adjacency list to destroy.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: depends on memory management.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_adjlist_get"></a>10.1.5. <code class="function">igraph_adjlist_get</code> —  Query a vector in an adjacency list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.6.6.2"></a><p>
</p>
<pre class="programlisting">
#define igraph_adjlist_get(al,no)
</pre>
<p>
</p>
<p>


Returns a pointer to an <span class="type">igraph_vector_int_t</span> object from an
adjacency list. The vector can be modified as desired.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  The adjacency list object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no</code></em>:</span></p></td>
<td><p>
  The vertex whose adjacent vertices will be returned.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Pointer to the <span class="type">igraph_vector_int_t</span> object.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_adjlist_size"></a>10.1.6. <code class="function">igraph_adjlist_size</code> —  Returns the number of vertices in an adjacency list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.6.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_integer_t igraph_adjlist_size(const igraph_adjlist_t *al);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  The adjacency list.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of vertices in the adjacency list.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_adjlist_clear"></a>10.1.7. <code class="function">igraph_adjlist_clear</code> — Removes all edges from an adjacency list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.6.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_adjlist_clear(igraph_adjlist_t *al);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  The adjacency list.
Time complexity: depends on memory management, typically O(n), where n is
the total number of elements in the adjacency list.</p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_adjlist_sort"></a>10.1.8. <code class="function">igraph_adjlist_sort</code> —  Sorts each vector in an adjacency list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.6.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_adjlist_sort(igraph_adjlist_t *al);
</pre></div>
<p>
</p>
<p>



Sorts every vector of the adjacency list.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  The adjacency list.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: O(n log n), n is the total number of elements in
the adjacency list.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_adjlist_simplify"></a>10.1.9. <code class="function">igraph_adjlist_simplify</code> —  Simplifies an adjacency list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.6.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_adjlist_simplify(igraph_adjlist_t *al);
</pre></div>
<p>
</p>
<p>



Simplifies an adjacency list, i.e. removes loop and multiple edges.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  The adjacency list.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of edges and
vertices.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="incident-edges"></a>10.2. Incident edges</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_inclist_init">10.2.1. <code class="function">igraph_inclist_init</code> —  Initializes an incidence list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_inclist_destroy">10.2.2. <code class="function">igraph_inclist_destroy</code> —  Frees all memory allocated for an incidence list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_inclist_get">10.2.3. <code class="function">igraph_inclist_get</code> —  Query a vector in an incidence list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_inclist_size">10.2.4. <code class="function">igraph_inclist_size</code> —  Returns the number of vertices in an incidence list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_inclist_clear">10.2.5. <code class="function">igraph_inclist_clear</code> —  Removes all edges from an incidence list.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_inclist_init"></a>10.2.1. <code class="function">igraph_inclist_init</code> —  Initializes an incidence list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.7.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_inclist_init(const igraph_t *graph,
                        igraph_inclist_t *il,
                        igraph_neimode_t mode,
                        igraph_loops_t loops);
</pre></div>
<p>
</p>
<p>



Creates a list of vectors containing the incident edges for all
vertices. The incidence list is independent of the graph after
creation, subsequent changes of the graph object do not update the
incidence list, and changes to the incidence list do not update the
graph.

</p>
<p>
When <em class="parameter"><code>mode</code></em> is <code class="constant">IGRAPH_IN</code> or <code class="constant">IGRAPH_OUT</code>, each edge ID will appear
in the incidence list <span class="emphasis"><em>once.</em></span> When <em class="parameter"><code>mode</code></em> is <code class="constant">IGRAPH_ALL</code>, each edge ID
will appear in the incidence list <span class="emphasis"><em>twice,</em></span> once for the source vertex
and once for the target edge. It also means that the edge IDs of loop edges
may potentially appear <span class="emphasis"><em>twice</em></span> for the <span class="emphasis"><em>same</em></span> vertex. Use the <em class="parameter"><code>loops</code></em>
argument to control whether this will be the case (<code class="constant">IGRAPH_LOOPS_TWICE</code> )
or not (<code class="constant">IGRAPH_LOOPS_ONCE</code> or <code class="constant">IGRAPH_NO_LOOPS</code>).

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>il</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized incidence list.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant specifying whether incoming edges
  (<code class="literal">IGRAPH_IN</code>), outgoing edges (<code class="literal">IGRAPH_OUT</code>) or
  both (<code class="literal">IGRAPH_ALL</code>) to include in the incidence lists
  of directed graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Specifies how to treat loop edges. <code class="literal">IGRAPH_NO_LOOPS</code>
  removes loop edges from the incidence list. <code class="literal">IGRAPH_LOOPS_ONCE</code>
  makes each loop edge appear only once in the incidence list of the
  corresponding vertex. <code class="literal">IGRAPH_LOOPS_TWICE</code> makes loop edges
  appear <span class="emphasis"><em>twice</em></span> in the incidence list of the corresponding vertex,
  but only if the graph is undirected or <code class="literal">mode</code> is set to
  <code class="literal">IGRAPH_ALL</code>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_inclist_destroy"></a>10.2.2. <code class="function">igraph_inclist_destroy</code> —  Frees all memory allocated for an incidence list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.7.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_inclist_destroy(igraph_inclist_t *il);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>eal</code></em>:</span></p></td>
<td><p>
  The incidence list to destroy.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: depends on memory management.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_inclist_get"></a>10.2.3. <code class="function">igraph_inclist_get</code> —  Query a vector in an incidence list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.7.4.2"></a><p>
</p>
<pre class="programlisting">
#define igraph_inclist_get(il,no)
</pre>
<p>
</p>
<p>


Returns a pointer to an <span class="type">igraph_vector_int_t</span> object from an
incidence list containing edge ids. The vector can be modified,
resized, etc. as desired.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>il</code></em>:</span></p></td>
<td><p>
  Pointer to the incidence list.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no</code></em>:</span></p></td>
<td><p>
  The vertex for which the incident edges are returned.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Pointer to an <span class="type">igraph_vector_int_t</span> object.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_inclist_size"></a>10.2.4. <code class="function">igraph_inclist_size</code> —  Returns the number of vertices in an incidence list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.7.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_integer_t igraph_inclist_size(const igraph_inclist_t *il);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>il</code></em>:</span></p></td>
<td><p>
  The incidence list.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of vertices in the incidence list.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_inclist_clear"></a>10.2.5. <code class="function">igraph_inclist_clear</code> —  Removes all edges from an incidence list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.7.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_inclist_clear(igraph_inclist_t *il);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>il</code></em>:</span></p></td>
<td><p>
  The incidence list.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: depends on memory management, typically O(n), where n is
the total number of elements in the incidence list.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="lazy-adjacency-list"></a>10.3. Lazy adjacency list for vertices</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_lazy_adjlist_init">10.3.1. <code class="function">igraph_lazy_adjlist_init</code> —  Initialized a lazy adjacency list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_lazy_adjlist_destroy">10.3.2. <code class="function">igraph_lazy_adjlist_destroy</code> —  Deallocate a lazt adjacency list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_lazy_adjlist_get">10.3.3. <code class="function">igraph_lazy_adjlist_get</code> —  Query neighbor vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_lazy_adjlist_size">10.3.4. <code class="function">igraph_lazy_adjlist_size</code> —  Returns the number of vertices in a lazy adjacency list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_lazy_adjlist_clear">10.3.5. <code class="function">igraph_lazy_adjlist_clear</code> —  Removes all edges from a lazy adjacency list.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_lazy_adjlist_init"></a>10.3.1. <code class="function">igraph_lazy_adjlist_init</code> —  Initialized a lazy adjacency list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.8.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_lazy_adjlist_init(const igraph_t *graph,
                             igraph_lazy_adjlist_t *al,
                             igraph_neimode_t mode,
                             igraph_loops_t loops,
                             igraph_multiple_t multiple);
</pre></div>
<p>
</p>
<p>



Create a lazy adjacency list for vertices. This function only
allocates some memory for storing the vectors of an adjacency list,
but the neighbor vertices are not queried, only at the <a class="link" href="igraph-Data-structures.html#igraph_lazy_adjlist_get" title="10.3.3. igraph_lazy_adjlist_get — Query neighbor vertices."><code class="function">igraph_lazy_adjlist_get()</code></a> calls.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized adjacency list object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant, it gives whether incoming edges
  (<code class="literal">IGRAPH_IN</code>), outgoing edges
  (<code class="literal">IGRPAH_OUT</code>) or both types of edges
  (<code class="literal">IGRAPH_ALL</code>) are considered. It is ignored for
  undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>simplify</code></em>:</span></p></td>
<td><p>
  Constant, it gives whether to simplify the vectors
  in the adjacency list (<code class="literal">IGRAPH_SIMPLIFY</code>) or not
  (<code class="literal">IGRAPH_DONT_SIMPLIFY</code>).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|), the number of vertices, possibly, but
depends on the underlying memory management too.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_lazy_adjlist_destroy"></a>10.3.2. <code class="function">igraph_lazy_adjlist_destroy</code> —  Deallocate a lazt adjacency list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.8.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_lazy_adjlist_destroy(igraph_lazy_adjlist_t *al);
</pre></div>
<p>
</p>
<p>



Free all allocated memory for a lazy adjacency list.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  The adjacency list to deallocate.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: depends on the memory management.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_lazy_adjlist_get"></a>10.3.3. <code class="function">igraph_lazy_adjlist_get</code> —  Query neighbor vertices.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.8.4.2"></a><p>
</p>
<pre class="programlisting">
#define igraph_lazy_adjlist_get(al,no)
</pre>
<p>
</p>
<p>


If the function is called for the first time for a vertex then the
result is stored in the adjacency list and no further query
operations are needed when the neighbors of the same vertex are
queried again.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  The lazy adjacency list.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no</code></em>:</span></p></td>
<td><p>
  The vertex ID to query.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Pointer to a vector. It is allowed to modify it and
  modification does not affect the original graph.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(d), the number of neighbor vertices for the
first time, O(1) for subsequent calls.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_lazy_adjlist_size"></a>10.3.4. <code class="function">igraph_lazy_adjlist_size</code> —  Returns the number of vertices in a lazy adjacency list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.8.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_integer_t igraph_lazy_adjlist_size(const igraph_lazy_adjlist_t *al);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  The lazy adjacency list.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of vertices in the lazy adjacency list.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_lazy_adjlist_clear"></a>10.3.5. <code class="function">igraph_lazy_adjlist_clear</code> —  Removes all edges from a lazy adjacency list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.8.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_lazy_adjlist_clear(igraph_lazy_adjlist_t *al);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  The lazy adjacency list.
Time complexity: depends on memory management, typically O(n), where n is
the total number of elements in the adjacency list.</p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="lazy-incidence-list"></a>10.4. Lazy incidence list for edges</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_lazy_inclist_init">10.4.1. <code class="function">igraph_lazy_inclist_init</code> —  Initializes a lazy incidence list of edges.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_lazy_inclist_destroy">10.4.2. <code class="function">igraph_lazy_inclist_destroy</code> —  Deallocates a lazy incidence list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_lazy_inclist_get">10.4.3. <code class="function">igraph_lazy_inclist_get</code> —  Query incident edges.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_lazy_inclist_size">10.4.4. <code class="function">igraph_lazy_inclist_size</code> —  Returns the number of vertices in a lazy incidence list.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_lazy_inclist_clear">10.4.5. <code class="function">igraph_lazy_inclist_clear</code> —  Removes all edges from a lazy incidence list.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_lazy_inclist_init"></a>10.4.1. <code class="function">igraph_lazy_inclist_init</code> —  Initializes a lazy incidence list of edges.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.9.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_lazy_inclist_init(const igraph_t *graph,
                             igraph_lazy_inclist_t *il,
                             igraph_neimode_t mode,
                             igraph_loops_t loops);
</pre></div>
<p>
</p>
<p>



Create a lazy incidence list for edges. This function only
allocates some memory for storing the vectors of an incidence list,
but the incident edges are not queried, only when <a class="link" href="igraph-Data-structures.html#igraph_lazy_inclist_get" title="10.4.3. igraph_lazy_inclist_get — Query incident edges."><code class="function">igraph_lazy_inclist_get()</code></a> is called.

</p>
<p>
When <em class="parameter"><code>mode</code></em> is <code class="constant">IGRAPH_IN</code> or <code class="constant">IGRAPH_OUT</code>, each edge ID will appear
in the incidence list <span class="emphasis"><em>once.</em></span> When <em class="parameter"><code>mode</code></em> is <code class="constant">IGRAPH_ALL</code>, each edge ID
will appear in the incidence list <span class="emphasis"><em>twice,</em></span> once for the source vertex
and once for the target edge. It also means that the edge IDs of loop edges
will appear <span class="emphasis"><em>twice</em></span> for the <span class="emphasis"><em>same</em></span> vertex.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized incidence list.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant, it gives whether incoming edges
  (<code class="literal">IGRAPH_IN</code>), outgoing edges
  (<code class="literal">IGRAPH_OUT</code>) or both types of edges
  (<code class="literal">IGRAPH_ALL</code>) are considered. It is ignored for
  undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Specifies how to treat loop edges. <code class="literal">IGRAPH_NO_LOOPS</code>
  removes loop edges from the incidence list. <code class="literal">IGRAPH_LOOPS_ONCE</code>
  makes each loop edge appear only once in the incidence list of the
  corresponding vertex. <code class="literal">IGRAPH_LOOPS_TWICE</code> makes loop edges
  appear <span class="emphasis"><em>twice</em></span> in the incidence list of the corresponding vertex,
  but only if the graph is undirected or <code class="literal">mode</code> is set to
  <code class="literal">IGRAPH_ALL</code>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|), the number of vertices, possibly. But it
also depends on the underlying memory management.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_lazy_inclist_destroy"></a>10.4.2. <code class="function">igraph_lazy_inclist_destroy</code> —  Deallocates a lazy incidence list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.9.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_lazy_inclist_destroy(igraph_lazy_inclist_t *il);
</pre></div>
<p>
</p>
<p>



Frees all allocated memory for a lazy incidence list.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  The incidence list to deallocate.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: depends on memory management.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_lazy_inclist_get"></a>10.4.3. <code class="function">igraph_lazy_inclist_get</code> —  Query incident edges.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.9.4.2"></a><p>
</p>
<pre class="programlisting">
#define igraph_lazy_inclist_get(al,no)
</pre>
<p>
</p>
<p>


If the function is called for the first time for a vertex, then the
result is stored in the incidence list and no further query
operations are needed when the incident edges of the same vertex are
queried again.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>al</code></em>:</span></p></td>
<td><p>
  The lazy incidence list object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no</code></em>:</span></p></td>
<td><p>
  The vertex id to query.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Pointer to a vector. It is allowed to modify it and
  modification does not affect the original graph.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(d), the number of incident edges for the first
time, O(1) for subsequent calls with the same <em class="parameter"><code>no</code></em> argument.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_lazy_inclist_size"></a>10.4.4. <code class="function">igraph_lazy_inclist_size</code> —  Returns the number of vertices in a lazy incidence list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.9.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_integer_t igraph_lazy_inclist_size(const igraph_lazy_inclist_t *il);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>il</code></em>:</span></p></td>
<td><p>
  The lazy incidence list.
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of vertices in the lazy incidence list.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="igraph_lazy_inclist_clear"></a>10.4.5. <code class="function">igraph_lazy_inclist_clear</code> —  Removes all edges from a lazy incidence list.</h4></div></div></div>
<a class="indexterm" name="id-1.8.11.9.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_lazy_inclist_clear(igraph_lazy_inclist_t *il);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>il</code></em>:</span></p></td>
<td><p>
  The lazy incidence list.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: depends on memory management, typically O(n), where n is
the total number of elements in the incidence list.
 
</p>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="igraph-Partial-prefix-sum-trees"></a>11. Partial prefix sum trees</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_psumtree_init">11.1. <code class="function">igraph_psumtree_init</code> —  Initializes a partial prefix sum tree.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_psumtree_destroy">11.2. <code class="function">igraph_psumtree_destroy</code> —  Destroys a partial prefix sum tree.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_psumtree_size">11.3. <code class="function">igraph_psumtree_size</code> —  Returns the size of the tree.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_psumtree_get">11.4. <code class="function">igraph_psumtree_get</code> —  Retrieves the value corresponding to an item in the tree.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_psumtree_sum">11.5. <code class="function">igraph_psumtree_sum</code> —  Returns the sum of the values of the leaves in the tree.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_psumtree_search">11.6. <code class="function">igraph_psumtree_search</code> —  Finds an item in the tree, given a value.</a></span></dt>
<dt><span class="section"><a href="igraph-Data-structures.html#igraph_psumtree_update">11.7. <code class="function">igraph_psumtree_update</code> —  Updates the value associated to an item in the tree.</a></span></dt>
</dl></div>
<p>The <span class="type">igraph_psumtree_t</span> data type represents a partial prefix sum
tree. A partial prefix sum tree is a data structure that can be used to draw
samples from a discrete probability distribution with dynamic probabilities
that are updated frequently. This is achieved by creating a binary tree where
the leaves are the items. Each leaf contains the probability corresponding to
the items. Intermediate nodes of the tree always contain the sum of its two
children. When the value of a leaf node is updated, the values of its
ancestors are also updated accordingly.</p>
<p>Samples can be drawn from the probability distribution represented by
the tree by generating a uniform random number between 0 (inclusive) and the
value of the root of the tree (exclusive), and then following the branches
of the tree as follows. In each step, the value in the current node is
compared with the generated number. If the value in the node is larger,
the left branch of the tree is taken; otherwise the generated number is
decreased by the value in the node and the right branch of the tree is
taken, until a leaf node is reached.</p>
<p>Note that the sampling process works only if all the values in the tree
are non-negative. This is enforced by the object; in particular, trying to
set a negative value for an item will produce an igraph error.</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_psumtree_init"></a>11.1. <code class="function">igraph_psumtree_init</code> —  Initializes a partial prefix sum tree.</h3></div></div></div>
<a class="indexterm" name="id-1.8.12.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_psumtree_init(igraph_psumtree_t *t, long int size);
</pre></div>
<p>
</p>
<p>




</p>
<p>
The tree is initialized with a fixed number of elements. After initialization,
the value corresponding to each element is zero.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>t</code></em>:</span></p></td>
<td><p>
  The tree to initialize
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>size</code></em>:</span></p></td>
<td><p>
  The number of elements in the tree
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, typically <code class="constant">IGRAPH_ENOMEM</code> if there is not enough memory
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n) for a tree containing n elements
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_psumtree_destroy"></a>11.2. <code class="function">igraph_psumtree_destroy</code> —  Destroys a partial prefix sum tree.</h3></div></div></div>
<a class="indexterm" name="id-1.8.12.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
void igraph_psumtree_destroy(igraph_psumtree_t *t);
</pre></div>
<p>
</p>
<p>




</p>
<p>
All partial prefix sum trees initialized by <a class="link" href="igraph-Data-structures.html#igraph_psumtree_init" title="11.1. igraph_psumtree_init — Initializes a partial prefix sum tree."><code class="function">igraph_psumtree_init()</code></a>
should be properly destroyed by this function. A destroyed tree needs to be
reinitialized by <a class="link" href="igraph-Data-structures.html#igraph_psumtree_init" title="11.1. igraph_psumtree_init — Initializes a partial prefix sum tree."><code class="function">igraph_psumtree_init()</code></a> if you want to use it again.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>t</code></em>:</span></p></td>
<td><p>
  Pointer to the (previously initialized) tree to destroy.</p></td>
</tr></tbody>
</table></div>
<p>


Time complexity: operating system dependent.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_psumtree_size"></a>11.3. <code class="function">igraph_psumtree_size</code> —  Returns the size of the tree.</h3></div></div></div>
<a class="indexterm" name="id-1.8.12.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
long int igraph_psumtree_size(const igraph_psumtree_t *t);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>t</code></em>:</span></p></td>
<td><p>
  The tree object
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The number of discrete items in the tree.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_psumtree_get"></a>11.4. <code class="function">igraph_psumtree_get</code> —  Retrieves the value corresponding to an item in the tree.</h3></div></div></div>
<a class="indexterm" name="id-1.8.12.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_psumtree_get(const igraph_psumtree_t *t, long int idx);
</pre></div>
<p>
</p>
<p>




</p>
<p>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>t</code></em>:</span></p></td>
<td><p>
  The tree to query.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>idx</code></em>:</span></p></td>
<td><p>
  The index of the item whose value is to be retrieved.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The value corresponding to the item with the given index.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1)
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_psumtree_sum"></a>11.5. <code class="function">igraph_psumtree_sum</code> —  Returns the sum of the values of the leaves in the tree.</h3></div></div></div>
<a class="indexterm" name="id-1.8.12.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_real_t igraph_psumtree_sum(const igraph_psumtree_t *t);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code>t</code></em>:</span></p></td>
<td><p>
  The tree object
</p></td>
</tr></tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  The sum of the values of the leaves in the tree.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(1).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_psumtree_search"></a>11.6. <code class="function">igraph_psumtree_search</code> —  Finds an item in the tree, given a value.</h3></div></div></div>
<a class="indexterm" name="id-1.8.12.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_psumtree_search(const igraph_psumtree_t *t, long int *idx,
                           igraph_real_t search);
</pre></div>
<p>
</p>
<p>




This function finds the item with the lowest index where it holds that the
sum of all the items with a <span class="emphasis"><em>lower</em></span> index is less than or equal to the given
value and that the sum of all the items with a lower index plus the item
itself is larger than the given value.

</p>
<p>
If you think about the partial prefix sum tree as a tool to sample from a
discrete probability distribution, then calling this function repeatedly
with uniformly distributed random numbers in the range 0 (inclusive) to the
sum of all values in the tree (exclusive) will sample the items in the tree
with a probability that is proportional to their associated values.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>t</code></em>:</span></p></td>
<td><p>
  The tree to query.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>idx</code></em>:</span></p></td>
<td><p>
  The index of the item is returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>search</code></em>:</span></p></td>
<td><p>
  The value to use for the search. Must be in the interval
       <code class="literal">[0, sum)</code>, where <code class="constant">sum</code> is the sum of all elements
       (leaves) in the tree.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code; currently the search always succeeds.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(log n), where n is the number of items in the tree.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_psumtree_update"></a>11.7. <code class="function">igraph_psumtree_update</code> —  Updates the value associated to an item in the tree.</h3></div></div></div>
<a class="indexterm" name="id-1.8.12.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_psumtree_update(igraph_psumtree_t *t, long int idx,
                           igraph_real_t new_value);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>t</code></em>:</span></p></td>
<td><p>
  The tree to query.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>idx</code></em>:</span></p></td>
<td><p>
  The index of the item to update.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>new_value</code></em>:</span></p></td>
<td><p>
  The new value of the item.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, <code class="constant">IGRAPH_EINVAL</code> if the new value is negative or NaN,
        <code class="constant">IGRAPH_SUCCESS</code> if the operation was successful.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(log n), where n is the number of items in the tree.
 
</p>
</div>
</div>
</div>
<table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Memory.html"><b>← Chapter 6. Memory (de)allocation</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Random.html"><b>Chapter 8. Random numbers →</b></a></td>
</tr></table>


      </div>
    </div>
  </div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	      &copy; 2003 &ndash; 2025 The igraph core team.
        &bull; Code licensed under <a href="http://www.gnu.org/licenses/gpl-2.0.html"> GNU GPL 2</a> or later,
        documentation under <a href="http://www.gnu.org/copyleft/fdl.html">GNU FDL</a>.
      </p>
      <p class="social">
        <a href="https://twitter.com/igraph2"><i class="fa-brands fa-twitter"></i></a>
        <a rel="me" href="https://fosstodon.org/@igraph"><i class="fa-brands fa-mastodon"></i></a>
        <a href="https://discord.gg/cSyHDPJWDD"><i class="fa-brands fa-discord"></i></a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'c', 'html/');
    </script>





    
  </body>
</html>
