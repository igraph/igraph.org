




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>igraph Reference Manual</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-1392972-5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-1392972-5');
    </script>

    <link href="/css/manual.css" rel="stylesheet">
<script async src="https://cse.google.com/cse.js?cx=003494361702844740117:dlnifinshhm"></script>

  </head>

  <body class="cc">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/c">igraph library</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            master
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="/r">igraph R package</a>
              <a class="dropdown-item" href="/python">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">igraph Reference Manual</h1>
        <p class="lead">For using the igraph C library</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container search-box-container">
  <div class="row">
    <div class="col-md-12 d-flex flex-row align-items-middle">
      <div class="search-label">Search the manual:</div>
	  <div style="flex: 1; margin: -1em 0 -1em 0"><div class="gcse-search" data-personalizedAds="false"></div></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="bs-docs-section">
        
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navigation-header mb-4" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-light" href="igraph-Foreign.html"><i class="fa fa-chevron-left"></i>
              Previous
            </a><a accesskey="h" class="btn btn-light" href="index.html"><i class="fa fa-home"></i>
              Home
            </a><a accesskey="n" class="btn btn-light" href="igraph-Separators.html"><i class="fa fa-chevron-right"></i>
              Next
            </a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Flows"></a>Chapter 22. Maximum flows, minimum cuts and related measures</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Flows.html#maximum-flows">1. Maximum flows</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#cuts-and-minimum-cuts">2. Cuts and minimum cuts</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#connectivity">3. Connectivity</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#edge-and-vertex-disjoint-paths">4. Edge- and vertex-disjoint paths</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#graph-adhesion-and-cohesion">5. Graph adhesion and cohesion</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#cohesive-blocks">6. Cohesive blocks</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="maximum-flows"></a>1. Maximum flows</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Flows.html#igraph_maxflow">1.1. <code class="function">igraph_maxflow</code> — Maximum network flow between a pair of vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_maxflow_value">1.2. <code class="function">igraph_maxflow_value</code> —  Maximum flow in a network with the push/relabel algorithm</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_dominator_tree">1.3. <code class="function">igraph_dominator_tree</code> — Calculates the dominator tree of a flowgraph</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_maxflow_stats_t">1.4. <code class="function">igraph_maxflow_stats_t</code> — A simple data type to return some statistics from the</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_maxflow"></a>1.1. <code class="function">igraph_maxflow</code> — Maximum network flow between a pair of vertices</h3></div></div></div>
<a class="indexterm" name="id-1.23.2.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_maxflow(const igraph_t *graph, igraph_real_t *value,
                   igraph_vector_t *flow, igraph_vector_t *cut,
                   igraph_vector_t *partition, igraph_vector_t *partition2,
                   igraph_integer_t source, igraph_integer_t target,
                   const igraph_vector_t *capacity,
                   igraph_maxflow_stats_t *stats);
</pre></div>
<p>
</p>
<p>



</p>
<p>This function implements the Goldberg-Tarjan algorithm for
calculating value of the maximum flow in a directed or undirected
graph. The algorithm was given in Andrew V. Goldberg, Robert
E. Tarjan: A New Approach to the Maximum-Flow Problem, Journal of
the ACM, 35(4), 921-940, 1988. </p>
<p> The input of the function is a graph, a vector
of real numbers giving the capacity of the edges and two vertices
of the graph, the source and the target. A flow is a function
assigning positive real numbers to the edges and satisfying two
requirements: (1) the flow value is less than the capacity of the
edge and (2) at each vertex except the source and the target, the
incoming flow (i.e. the sum of the flow on the incoming edges) is
the same as the outgoing flow (i.e. the sum of the flow on the
outgoing edges). The value of the flow is the incoming flow at the
target vertex. The maximum flow is the flow with the maximum
value.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, either directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the value of the maximum
       will be placed here, unless it is a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>flow</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then it must be a pointer to an
       initialized vector. The vector will be resized, and the flow
       on each edge will be placed in it, in the order of the edge
       ids. For undirected graphs this argument is bit trickier,
       since for these the flow direction is not predetermined by
       the edge direction. For these graphs the elements of the
       <em class="parameter"><code>flow</code></em> vector can be negative, this means that the flow
       goes from the bigger vertex id to the smaller one. Positive
       values mean that the flow goes from the smaller vertex id to
       the bigger one.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cut</code></em>:</span></p></td>
<td><p>
  A null pointer or a pointer to an initialized vector.
       If not a null pointer, then the minimum cut corresponding to
       the maximum flow is stored here, i.e. all edge ids that are
       part of the minimum cut are stored in the vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>partition</code></em>:</span></p></td>
<td><p>
  A null pointer or a pointer to an initialized
       vector. If not a null pointer, then the first partition of
       the minimum cut that corresponds to the maximum flow will be
       placed here. The first partition is always the one that
       contains the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>partition2</code></em>:</span></p></td>
<td><p>
  A null pointer or a pointer to an initialized
       vector. If not a null pointer, then the second partition of
       the minimum cut that corresponds to the maximum flow will be
       placed here. The second partition is always the one that
       contains the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>source</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>capacity</code></em>:</span></p></td>
<td><p>
  Vector containing the capacity of the edges. If NULL, then
       every edge is considered to have capacity 1.0.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>stats</code></em>:</span></p></td>
<td><p>
  Counts of the number of different operations
       preformed by the algorithm are stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^3). In practice it is much faster, but i
cannot prove a better lower bound for the data structure i've
used. In fact, this implementation runs much faster than the
<code class="constant">hi_pr</code> implementation discussed in
B. V. Cherkassky and A. V. Goldberg: On implementing the
push-relabel method for the maximum flow problem, (Algorithmica,
19:390--410, 1997) on all the graph classes i've tried.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_mincut_value" title="2.6. igraph_mincut_value — The minimum edge cut in a graph"><code class="function">igraph_mincut_value()</code></a>, <a class="link" href="igraph-Flows.html#igraph_edge_connectivity" title="3.2. igraph_edge_connectivity — The minimum edge connectivity in a graph."><code class="function">igraph_edge_connectivity()</code></a>,
<a class="link" href="igraph-Flows.html#igraph_vertex_connectivity" title="3.4. igraph_vertex_connectivity — The vertex connectivity of a graph"><code class="function">igraph_vertex_connectivity()</code></a> for
properties based on the maximum flow.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.23.2.2.12.1"></a><p class="title"><b>Example 22.1.  File <code class="code">examples/simple/flow.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t flow;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> capacity;
    igraph_integer_t source, target;
    FILE *infile;
    <a class="link" href="igraph-Flows.html#igraph_maxflow_stats_t" title="1.4. igraph_maxflow_stats_t — A simple data type to return some statistics from the">igraph_maxflow_stats_t</a> stats;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;capacity, 0);

    <span class="emphasis"><em>/***************/</em></span>
    infile = <span class="strong"><strong>fopen</strong></span>("ak-4102.max", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_dimacs" title="1.7. igraph_read_graph_dimacs — Read a graph in DIMACS format.">igraph_read_graph_dimacs</a></strong></span>(&amp;g, infile, 0, 0, &amp;source, &amp;target, &amp;capacity,
                             IGRAPH_DIRECTED);
    <span class="strong"><strong>fclose</strong></span>(infile);

    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm">igraph_maxflow_value</a></strong></span>(&amp;g, &amp;flow, source, target, &amp;capacity, &amp;stats);

    <span class="strong"><strong>if</strong></span> (flow != 8207) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="emphasis"><em>/***************/</em></span>

    <span class="emphasis"><em>/*   /\***************\/ */</em></span>
    <span class="emphasis"><em>/*   infile=fopen("ak-8198.max", "r"); */</em></span>
    <span class="emphasis"><em>/*   igraph_read_graph_dimacs(&amp;g, infile, 0, 0, &amp;source, &amp;target, &amp;capacity, */</em></span>
    <span class="emphasis"><em>/*             IGRAPH_DIRECTED); */</em></span>
    <span class="emphasis"><em>/*   fclose(infile); */</em></span>

    <span class="emphasis"><em>/*   t=timer(); */</em></span>
    <span class="emphasis"><em>/*   igraph_maxflow_value(&amp;g, &amp;flow, source, target, &amp;capacity, &amp;stats); */</em></span>
    <span class="emphasis"><em>/*   t=timer()-t; */</em></span>
    <span class="emphasis"><em>/*   printf("8198: %g (time %.10f)\n", flow, t); */</em></span>
    <span class="emphasis"><em>/*   igraph_destroy(&amp;g); */</em></span>
    <span class="emphasis"><em>/*   /\***************\/ */</em></span>

    <span class="emphasis"><em>/*   /\***************\/ */</em></span>
    <span class="emphasis"><em>/*   infile=fopen("ak-16390.max", "r"); */</em></span>
    <span class="emphasis"><em>/*   igraph_read_graph_dimacs(&amp;g, infile, 0, 0, &amp;source, &amp;target, &amp;capacity, */</em></span>
    <span class="emphasis"><em>/*             IGRAPH_DIRECTED); */</em></span>
    <span class="emphasis"><em>/*   fclose(infile); */</em></span>

    <span class="emphasis"><em>/*   t=timer(); */</em></span>
    <span class="emphasis"><em>/*   igraph_maxflow_value(&amp;g, &amp;flow, source, target, &amp;capacity, &amp;stats); */</em></span>
    <span class="emphasis"><em>/*   t=timer()-t; */</em></span>
    <span class="emphasis"><em>/*   printf("16390: %g (time %.10f)\n", flow, t); */</em></span>
    <span class="emphasis"><em>/*   igraph_destroy(&amp;g); */</em></span>
    <span class="emphasis"><em>/*   /\***************\/ */</em></span>

    <span class="emphasis"><em>/*   /\***************\/ */</em></span>
    <span class="emphasis"><em>/*   infile=fopen("ak-32774.max", "r"); */</em></span>
    <span class="emphasis"><em>/*   igraph_read_graph_dimacs(&amp;g, infile, 0, 0, &amp;source, &amp;target, &amp;capacity, */</em></span>
    <span class="emphasis"><em>/*             IGRAPH_DIRECTED); */</em></span>
    <span class="emphasis"><em>/*   fclose(infile); */</em></span>

    <span class="emphasis"><em>/*   t=timer(); */</em></span>
    <span class="emphasis"><em>/*   igraph_maxflow_value(&amp;g, &amp;flow, source, target, &amp;capacity, &amp;stats); */</em></span>
    <span class="emphasis"><em>/*   t=timer()-t; */</em></span>
    <span class="emphasis"><em>/*   printf("32774: %g (time %.10f)\n", flow, t); */</em></span>
    <span class="emphasis"><em>/*   igraph_destroy(&amp;g); */</em></span>
    <span class="emphasis"><em>/*   /\***************\/ */</em></span>

    <span class="emphasis"><em>/*   /\***************\/ */</em></span>
    <span class="emphasis"><em>/*   infile=fopen("ak-65542.max", "r"); */</em></span>
    <span class="emphasis"><em>/*   igraph_read_graph_dimacs(&amp;g, infile, 0, 0, &amp;source, &amp;target, &amp;capacity, */</em></span>
    <span class="emphasis"><em>/*             IGRAPH_DIRECTED); */</em></span>
    <span class="emphasis"><em>/*   fclose(infile); */</em></span>

    <span class="emphasis"><em>/*   t=timer(); */</em></span>
    <span class="emphasis"><em>/*   igraph_maxflow_value(&amp;g, &amp;flow, source, target, &amp;capacity, &amp;stats); */</em></span>
    <span class="emphasis"><em>/*   t=timer()-t; */</em></span>
    <span class="emphasis"><em>/*   printf("65542: %g (time %.10f)\n", flow, t); */</em></span>
    <span class="emphasis"><em>/*   igraph_destroy(&amp;g); */</em></span>
    <span class="emphasis"><em>/*   /\***************\/ */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;capacity);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.23.2.2.12.2"></a><p class="title"><b>Example 22.2.  File <code class="code">examples/simple/flow2.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2006-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>check_flow</strong></span>(int errorinc,
               <span class="strong"><strong>const</strong></span> igraph_t *graph, igraph_real_t flow_value,
               <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *flow, <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *cut,
               <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *partition,
               <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *partition2,
               long int source, long int target,
               <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *capacity,
               igraph_bool_t print) {

    long int i, n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="3.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(graph), m = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="3.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(graph);
    long int nc = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(cut);
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> inedges, outedges;
    igraph_bool_t directed = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="3.2.13. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(graph);
    igraph_real_t cutsize;
    igraph_t graph_copy;
    igraph_matrix_t sp;

    <span class="strong"><strong>if</strong></span> (print) {
        <span class="strong"><strong>printf</strong></span>("flow value: %g\n", (double) flow_value);
        <span class="strong"><strong>printf</strong></span>("flow: ");
        <span class="strong"><strong>igraph_vector_print</strong></span>(flow);
        <span class="strong"><strong>printf</strong></span>("first partition:  ");
        <span class="strong"><strong>igraph_vector_print</strong></span>(partition);
        <span class="strong"><strong>printf</strong></span>("second partition: ");
        <span class="strong"><strong>igraph_vector_print</strong></span>(partition2);
        <span class="strong"><strong>printf</strong></span>("edges in the cut: ");
        <span class="strong"><strong>for</strong></span> (i = 0; i &lt; nc; i++) {
            long int edge = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*cut)[i];
            long int from = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="3.2.5. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(graph, edge);
            long int to  = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="3.2.6. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>  (graph, edge);
            <span class="strong"><strong>if</strong></span> (!directed &amp;&amp; from &gt; to) {
                igraph_integer_t tmp = from;
                from = to;
                to = tmp;
            }
            <span class="strong"><strong>printf</strong></span>("%li-%li (%g), ", from, to, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*capacity)[edge]);
        }
        <span class="strong"><strong>printf</strong></span>("\n");
    }
    <span class="strong"><strong>fflush</strong></span>(stdout);

    <span class="emphasis"><em>/* Always less than the capacity */</em></span>
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; m; i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*flow)[i] &gt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*capacity)[i]) {
            <span class="strong"><strong>return</strong></span> errorinc + 3;
        }
    }

    <span class="emphasis"><em>/* What comes in goes out, but only in directed graphs,</em></span>
<span class="emphasis"><em>       there is no in and out in undirected ones...</em></span>
<span class="emphasis"><em>     */</em></span>
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="3.2.13. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(graph)) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;inedges, 0);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;outedges, 0);

        <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
            long int n1, n2, j;
            igraph_real_t in_flow = 0.0, out_flow = 0.0;
            <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_incident" title="3.2.12. igraph_incident — Gives the incident edges of a vertex.">igraph_incident</a></strong></span>(graph, &amp;inedges,  i, IGRAPH_IN);
            <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_incident" title="3.2.12. igraph_incident — Gives the incident edges of a vertex.">igraph_incident</a></strong></span>(graph, &amp;outedges, i, IGRAPH_OUT);
            n1 = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;inedges);
            n2 = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;outedges);
            <span class="strong"><strong>for</strong></span> (j = 0; j &lt; n1; j++) {
                long int e = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(inedges)[j];
                in_flow += <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*flow)[e];
            }
            <span class="strong"><strong>for</strong></span> (j = 0; j &lt; n2; j++) {
                long int e = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(outedges)[j];
                out_flow += <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*flow)[e];
            }
            <span class="strong"><strong>if</strong></span> (i == source) {
                <span class="strong"><strong>if</strong></span> (in_flow &gt; 0) {
                    <span class="strong"><strong>return</strong></span> errorinc + 4;
                }
                <span class="strong"><strong>if</strong></span> (out_flow != flow_value) {
                    <span class="strong"><strong>return</strong></span> errorinc + 5;
                }
            } <span class="strong"><strong>else</strong></span> <span class="strong"><strong>if</strong></span> (i == target) {
                <span class="strong"><strong>if</strong></span> (out_flow &gt; 0) {
                    <span class="strong"><strong>return</strong></span> errorinc + 6;
                }
                <span class="strong"><strong>if</strong></span> (in_flow != flow_value) {
                    <span class="strong"><strong>return</strong></span> errorinc + 7;
                }

            } <span class="strong"><strong>else</strong></span> {
                <span class="strong"><strong>if</strong></span> (in_flow != out_flow) {
                    <span class="strong"><strong>return</strong></span> errorinc + 8;
                }
            }
        }

        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;inedges);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;outedges);
    }

    <span class="emphasis"><em>/* Check the minimum cut size*/</em></span>
    <span class="strong"><strong>for</strong></span> (i = 0, cutsize = 0.0; i &lt; nc; i++) {
        long int edge = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*cut)[i];
        cutsize += <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*capacity)[edge];
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong>fabs</strong></span>(cutsize - flow_value) &gt; 1e-14) {
        <span class="strong"><strong>return</strong></span> errorinc + 9;
    }

    <span class="emphasis"><em>/* Check that the cut indeed cuts */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_copy" title="3.1.3. igraph_copy — Creates an exact (deep) copy of a graph.">igraph_copy</a></strong></span>(&amp;graph_copy, graph);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_delete_edges" title="3.3.4. igraph_delete_edges — Removes edges from a graph.">igraph_delete_edges</a></strong></span>(&amp;graph_copy, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_vector" title="7.4. igraph_ess_vector — Immediate vector view edge selector.">igraph_ess_vector</a></strong></span>(cut));
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;sp, 1, 1);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_shortest_paths" title="2.1. igraph_shortest_paths — The length of the shortest paths between vertices.">igraph_shortest_paths</a></strong></span>(&amp;graph_copy, &amp;sp, <span class="emphasis"><em>/*from=*/</em></span> <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_1" title="4.3. igraph_vss_1 — Vertex set with a single vertex (immediate version).">igraph_vss_1</a></strong></span>(source),
                          <span class="emphasis"><em>/*to=*/</em></span> <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_1" title="4.3. igraph_vss_1 — Vertex set with a single vertex (immediate version).">igraph_vss_1</a></strong></span>(target), IGRAPH_OUT);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.5.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(sp, 0, 0) != IGRAPH_INFINITY) {
        <span class="strong"><strong>return</strong></span> errorinc + 10;
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.3. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;sp);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph_copy);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_real_t flow_value;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> cut;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> capacity;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> partition, partition2;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> flow;
    long int i, n;
    igraph_integer_t source, target;
    FILE *infile;
    igraph_real_t flow_value2 = 0.0;
    int check;
    <a class="link" href="igraph-Flows.html#igraph_maxflow_stats_t" title="1.4. igraph_maxflow_stats_t — A simple data type to return some statistics from the">igraph_maxflow_stats_t</a> stats;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;capacity, 0);

    <span class="emphasis"><em>/***************/</em></span>
    infile = <span class="strong"><strong>fopen</strong></span>("ak-4102.max", "r");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_read_graph_dimacs" title="1.7. igraph_read_graph_dimacs — Read a graph in DIMACS format.">igraph_read_graph_dimacs</a></strong></span>(&amp;g, infile, 0, 0, &amp;source, &amp;target, &amp;capacity,
                             IGRAPH_DIRECTED);
    <span class="strong"><strong>fclose</strong></span>(infile);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;cut, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;partition, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;partition2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;flow, 0);

    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_maxflow" title="1.1. igraph_maxflow — Maximum network flow between a pair of vertices">igraph_maxflow</a></strong></span>(&amp;g, &amp;flow_value, &amp;flow, &amp;cut, &amp;partition,
                   &amp;partition2, source, target, &amp;capacity, &amp;stats);

    <span class="strong"><strong>if</strong></span> (flow_value != 8207) {
        <span class="strong"><strong>return</strong></span> 1;
    }

    n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(&amp;cut);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        long int e = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(cut)[i];
        flow_value2 += <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(capacity)[e];
    }
    <span class="strong"><strong>if</strong></span> (flow_value != flow_value2) {
        <span class="strong"><strong>return</strong></span> 2;
    }

    <span class="emphasis"><em>/* Check the flow */</em></span>
    <span class="strong"><strong>if</strong></span> ( (check = <span class="strong"><strong>check_flow</strong></span>(0, &amp;g, flow_value, &amp;flow, &amp;cut, &amp;partition,
                             &amp;partition2, source, target, &amp;capacity,
                             <span class="emphasis"><em>/*print=*/</em></span> 0))) {
        <span class="strong"><strong>return</strong></span> check;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;capacity);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;cut);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;partition);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;partition2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;flow);

    <span class="emphasis"><em>/* ------------------------------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 4, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 1, 2, 1, 3, 2, 3, -1);
    <span class="strong"><strong>igraph_vector_init_int_end</strong></span>(&amp;capacity, -1, 4, 2, 10, 2, 2, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;cut, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;partition, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;partition2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;flow, 0);

    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_maxflow" title="1.1. igraph_maxflow — Maximum network flow between a pair of vertices">igraph_maxflow</a></strong></span>(&amp;g, &amp;flow_value, &amp;flow, &amp;cut, &amp;partition, &amp;partition2,
                   <span class="emphasis"><em>/*source=*/</em></span> 0, <span class="emphasis"><em>/*target=*/</em></span> 3, &amp;capacity, &amp;stats);

    <span class="strong"><strong>if</strong></span> ( (check = <span class="strong"><strong>check_flow</strong></span>(20, &amp;g, flow_value, &amp;flow, &amp;cut, &amp;partition,
                             &amp;partition2, 0, 3, &amp;capacity,
                             <span class="emphasis"><em>/*print=*/</em></span> 1))) {
        <span class="strong"><strong>return</strong></span> check;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;cut);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;partition2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;partition);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;capacity);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;flow);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* ------------------------------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 6, IGRAPH_DIRECTED,
                 0, 1, 1, 2, 2, 3, 0, 5, 5, 4, 4, 3, 3, 0, -1);
    <span class="strong"><strong>igraph_vector_init_int_end</strong></span>(&amp;capacity, -1, 3, 1, 2, 10, 1, 3, 2, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;cut, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;partition, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;partition2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;flow, 0);

    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_maxflow" title="1.1. igraph_maxflow — Maximum network flow between a pair of vertices">igraph_maxflow</a></strong></span>(&amp;g, &amp;flow_value, &amp;flow, &amp;cut, &amp;partition, &amp;partition2,
                   <span class="emphasis"><em>/*source=*/</em></span> 0, <span class="emphasis"><em>/*target=*/</em></span> 2, &amp;capacity, &amp;stats);

    <span class="strong"><strong>if</strong></span> ( (check = <span class="strong"><strong>check_flow</strong></span>(40, &amp;g, flow_value, &amp;flow, &amp;cut, &amp;partition,
                             &amp;partition2, 0, 2, &amp;capacity,
                             <span class="emphasis"><em>/*print=*/</em></span> 1))) {
        <span class="strong"><strong>return</strong></span> check;
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;cut);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;partition2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;partition);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;capacity);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;flow);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_maxflow_value"></a>1.2. <code class="function">igraph_maxflow_value</code> —  Maximum flow in a network with the push/relabel algorithm</h3></div></div></div>
<a class="indexterm" name="id-1.23.2.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_maxflow_value(const igraph_t *graph, igraph_real_t *value,
                         igraph_integer_t source, igraph_integer_t target,
                         const igraph_vector_t *capacity,
                         igraph_maxflow_stats_t *stats);
</pre></div>
<p>
</p>
<p>



</p>
<p>This function implements the Goldberg-Tarjan algorithm for
calculating value of the maximum flow in a directed or undirected
graph. The algorithm was given in Andrew V. Goldberg, Robert
E. Tarjan: A New Approach to the Maximum-Flow Problem, Journal of
the ACM, 35(4), 921-940, 1988. </p>
<p> The input of the function is a graph, a vector
of real numbers giving the capacity of the edges and two vertices
of the graph, the source and the target. A flow is a function
assigning positive real numbers to the edges and satisfying two
requirements: (1) the flow value is less than the capacity of the
edge and (2) at each vertex except the source and the target, the
incoming flow (i.e. the sum of the flow on the incoming edges) is
the same as the outgoing flow (i.e. the sum of the flow on the
outgoing edges). The value of the flow is the incoming flow at the
target vertex. The maximum flow is the flow with the maximum
value. </p>
<p> According to a theorem by Ford and Fulkerson
(L. R. Ford Jr. and D. R. Fulkerson. Maximal flow through a
network. Canadian J. Math., 8:399-404, 1956.) the maximum flow
between two vertices is the same as the
minimum cut between them (also called the minimum s-t cut). So <a class="link" href="igraph-Flows.html#igraph_st_mincut_value" title="2.2. igraph_st_mincut_value — The minimum s-t cut in a graph"><code class="function">igraph_st_mincut_value()</code></a> gives the same result in all cases as <code class="constant">igraph_maxflow_value</code>().</p>
<p> Note that the value of the maximum flow is the same as the
minimum cut in the graph.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, either directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the result will be placed here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>source</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>capacity</code></em>:</span></p></td>
<td><p>
  Vector containing the capacity of the edges. If NULL, then
       every edge is considered to have capacity 1.0.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>stats</code></em>:</span></p></td>
<td><p>
  Counts of the number of different operations
       preformed by the algorithm are stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^3).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_maxflow" title="1.1. igraph_maxflow — Maximum network flow between a pair of vertices"><code class="function">igraph_maxflow()</code></a> to calculate the actual flow.
<a class="link" href="igraph-Flows.html#igraph_mincut_value" title="2.6. igraph_mincut_value — The minimum edge cut in a graph"><code class="function">igraph_mincut_value()</code></a>, <a class="link" href="igraph-Flows.html#igraph_edge_connectivity" title="3.2. igraph_edge_connectivity — The minimum edge connectivity in a graph."><code class="function">igraph_edge_connectivity()</code></a>,
<a class="link" href="igraph-Flows.html#igraph_vertex_connectivity" title="3.4. igraph_vertex_connectivity — The vertex connectivity of a graph"><code class="function">igraph_vertex_connectivity()</code></a> for
properties based on the maximum flow.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dominator_tree"></a>1.3. <code class="function">igraph_dominator_tree</code> — Calculates the dominator tree of a flowgraph</h3></div></div></div>
<a class="indexterm" name="id-1.23.2.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_dominator_tree(const igraph_t *graph,
                          igraph_integer_t root,
                          igraph_vector_t *dom,
                          igraph_t *domtree,
                          igraph_vector_t *leftout,
                          igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



A flowgraph is a directed graph with a distinguished start (or
root) vertex r, such that for any vertex v, there is a path from r
to v. A vertex v dominates another vertex w (not equal to v), if
every path from r to w contains v. Vertex v is the immediate
dominator or w, v=idom(w), if v dominates w and every other
dominator of w dominates v. The edges {(idom(w), w)| w is not r}
form a directed tree, rooted at r, called the dominator tree of the
graph. Vertex v dominates vertex w if and only if v is an ancestor
of w in the dominator tree.

</p>
<p>This function implements the Lengauer-Tarjan algorithm
to construct the dominator tree of a directed graph. For details
please see Thomas Lengauer, Robert Endre Tarjan: A fast algorithm
for finding dominators in a flowgraph, ACM Transactions on
Programming Languages and Systems (TOPLAS) I/1, 121--141, 1979.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  A directed graph. If it is not a flowgraph, and it
       contains some vertices not reachable from the root vertex,
       then these vertices will be collected in the <code class="constant">leftout</code>
       vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>root</code></em>:</span></p></td>
<td><p>
  The id of the root (or source) vertex, this will be the
       root of the tree.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>dom</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector or a null pointer. If
       not a null pointer, then the immediate dominator of each
       vertex will be stored here. For vertices that are not
       reachable from the root, NaN is stored here. For
       the root vertex itself, -1 is added.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>domtree</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized igraph_t, or NULL. If
       not a null pointer, then the dominator tree is returned
       here. The graph contains the vertices that are unreachable
       from the root (if any), these will be isolates.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>leftout</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector object, or NULL. If
       not NULL, then the ids of the vertices that are unreachable
       from the root vertex (and thus not part of the dominator
       tree) are stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Constant, must be <code class="constant">IGRAPH_IN</code> or <code class="constant">IGRAPH_OUT</code>. If it
       is <code class="constant">IGRAPH_IN</code>, then all directions are considered as
       opposite to the original one in the input graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: very close to O(|E|+|V|), linear in the number of
edges and vertices. More precisely, it is O(|V|+|E|alpha(|E|,|V|)),
where alpha(|E|,|V|) is a functional inverse of Ackermann's
function.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.23.2.4.9.1"></a><p class="title"><b>Example 22.3.  File <code class="code">examples/simple/dominator_tree.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2010-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g, domtree;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> dom, leftout;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;dom, 0);
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 13, IGRAPH_DIRECTED,
                 0, 1, 0, 7, 0, 10,
                 1, 2, 1, 5,
                 2, 3,
                 3, 4,
                 4, 3, 4, 0,
                 5, 3, 5, 6,
                 6, 3,
                 7, 8, 7, 10, 7, 11,
                 8, 9,
                 9, 4, 9, 8,
                 10, 11,
                 11, 12,
                 12, 9,
                 -1);

    <span class="emphasis"><em>/* Check NULL vector arguments */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_dominator_tree" title="1.3. igraph_dominator_tree — Calculates the dominator tree of a flowgraph">igraph_dominator_tree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*root=*/</em></span> 0, <span class="emphasis"><em>/*dom=*/</em></span> 0, <span class="emphasis"><em>/*domtree=*/</em></span> 0,
                          <span class="emphasis"><em>/*leftout=*/</em></span> 0, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);

    <span class="emphasis"><em>/* Proper calculation */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_dominator_tree" title="1.3. igraph_dominator_tree — Calculates the dominator tree of a flowgraph">igraph_dominator_tree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*root=*/</em></span> 0, &amp;dom, <span class="emphasis"><em>/*domtree=*/</em></span> 0,
                          <span class="emphasis"><em>/*leftout=*/</em></span> 0, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;dom);

    <span class="emphasis"><em>/* Tree calculation */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_dominator_tree" title="1.3. igraph_dominator_tree — Calculates the dominator tree of a flowgraph">igraph_dominator_tree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*root=*/</em></span> 0, <span class="emphasis"><em>/*dom=*/</em></span> 0, <span class="emphasis"><em>/*domtree=*/</em></span> &amp;domtree,
                          <span class="emphasis"><em>/*leftout=*/</em></span> 0, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;domtree, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;dom);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;domtree);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* -------------------------------------------------------------------*/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;dom, 0);
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 13, IGRAPH_DIRECTED,
                 1, 0, 2, 0, 3, 0,
                 4, 1,
                 1, 2, 4, 2, 5, 2,
                 6, 3, 7, 3,
                 12, 4,
                 8, 5,
                 9, 6,
                 9, 7, 10, 7,
                 5, 8, 11, 8,
                 11, 9,
                 9, 10,
                 9, 11, 0, 11,
                 8, 12,
                 -1);

    <span class="emphasis"><em>/* Check NULL vector arguments */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_dominator_tree" title="1.3. igraph_dominator_tree — Calculates the dominator tree of a flowgraph">igraph_dominator_tree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*root=*/</em></span> 0, <span class="emphasis"><em>/*dom=*/</em></span> 0, <span class="emphasis"><em>/*domtree=*/</em></span> 0,
                          <span class="emphasis"><em>/*leftout=*/</em></span> 0, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_IN);

    <span class="emphasis"><em>/* Proper calculation */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_dominator_tree" title="1.3. igraph_dominator_tree — Calculates the dominator tree of a flowgraph">igraph_dominator_tree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*root=*/</em></span> 0, &amp;dom, <span class="emphasis"><em>/*domtree=*/</em></span> 0,
                          <span class="emphasis"><em>/*leftout=*/</em></span> 0, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_IN);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;dom);

    <span class="emphasis"><em>/* Tree calculation */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_dominator_tree" title="1.3. igraph_dominator_tree — Calculates the dominator tree of a flowgraph">igraph_dominator_tree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*root=*/</em></span> 0, <span class="emphasis"><em>/*dom=*/</em></span> 0, <span class="emphasis"><em>/*domtree=*/</em></span> &amp;domtree,
                          <span class="emphasis"><em>/*leftout=*/</em></span> 0, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_IN);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;domtree, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;dom);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;domtree);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* -------------------------------------------------------------------*/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;dom, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;leftout, 0);

    <span class="emphasis"><em>/* Check a graph with more components */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 20, IGRAPH_DIRECTED,
                 0, 1, 0, 2, 0, 3,
                 1, 4,
                 2, 1, 2, 4, 2, 8,
                 3, 9, 3, 10,
                 4, 15,
                 8, 11,
                 9, 12,
                 10, 12, 10, 13,
                 11, 8, 11, 14,
                 12, 14,
                 13, 12,
                 14, 12, 14, 0,
                 15, 11,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_dominator_tree" title="1.3. igraph_dominator_tree — Calculates the dominator tree of a flowgraph">igraph_dominator_tree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*root=*/</em></span> 0, &amp;dom, &amp;domtree,
                          &amp;leftout, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_OUT);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;dom);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;leftout);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;domtree, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;dom);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;leftout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;domtree);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* -------------------------------------------------------------------*/</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;dom, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;leftout, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 10, IGRAPH_DIRECTED,
                 0, 9,
                 1, 0, 1, 2,
                 2, 3, 2, 7,
                 3, 1,
                 4, 1, 4, 3,
                 5, 2, 5, 3, 5, 4, 5, 8,
                 6, 5, 6, 9,
                 8, 7,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_dominator_tree" title="1.3. igraph_dominator_tree — Calculates the dominator tree of a flowgraph">igraph_dominator_tree</a></strong></span>(&amp;g, <span class="emphasis"><em>/*root=*/</em></span> 9, &amp;dom, &amp;domtree,
                          &amp;leftout, <span class="emphasis"><em>/*mode=*/</em></span> IGRAPH_IN);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;dom);
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;leftout);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;domtree, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;dom);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;leftout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;domtree);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_maxflow_stats_t"></a>1.4. <code class="function">igraph_maxflow_stats_t</code> — A simple data type to return some statistics from the</h3></div></div></div>
<a class="indexterm" name="id-1.23.2.5.2"></a><pre class="programlisting">
typedef struct {
    int nopush, norelabel, nogap, nogapnodes, nobfs;
</pre>
<p>

push-relabel maximum flow solver.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>nopush</code></em>:</span></p></td>
<td><p>
  The number of push operations performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>norelabel</code></em>:</span></p></td>
<td><p>
  The number of relabel operarions performed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nogap</code></em>:</span></p></td>
<td><p>
  The number of times the gap heuristics was used.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nogapnodes</code></em>:</span></p></td>
<td><p>
  The total number of vertices that were
       omitted form further calculations because of the gap
       heuristics.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nobfs</code></em>:</span></p></td>
<td><p>
  The number of times the reverse BFS was run to
       assign good values to the height function. This includes
       an initial run before the whole algorithm, so it is always
       at least one.
 </p></td>
</tr>
</tbody>
</table></div>
<p>

</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="cuts-and-minimum-cuts"></a>2. Cuts and minimum cuts</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Flows.html#igraph_st_mincut">2.1. <code class="function">igraph_st_mincut</code> — Minimum cut between a source and a target vertex</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_st_mincut_value">2.2. <code class="function">igraph_st_mincut_value</code> —  The minimum s-t cut in a graph</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_all_st_cuts">2.3. <code class="function">igraph_all_st_cuts</code> — List all edge-cuts between two vertices in a directed graph</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_all_st_mincuts">2.4. <code class="function">igraph_all_st_mincuts</code> — All minimum s-t cuts of a directed graph</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_mincut">2.5. <code class="function">igraph_mincut</code> —  Calculates the minimum cut in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_mincut_value">2.6. <code class="function">igraph_mincut_value</code> —  The minimum edge cut in a graph</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_gomory_hu_tree">2.7. <code class="function">igraph_gomory_hu_tree</code> —  Gomory-Hu tree of a graph.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_st_mincut"></a>2.1. <code class="function">igraph_st_mincut</code> — Minimum cut between a source and a target vertex</h3></div></div></div>
<a class="indexterm" name="id-1.23.3.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_st_mincut(const igraph_t *graph, igraph_real_t *value,
                     igraph_vector_t *cut, igraph_vector_t *partition,
                     igraph_vector_t *partition2,
                     igraph_integer_t source, igraph_integer_t target,
                     const igraph_vector_t *capacity);
</pre></div>
<p>
</p>
<p>



Finds the edge set that has the smallest total capacity among all
edge sets that disconnect the source and target vertices.

</p>
<p>The calculation is performed using maximum flow
techniques, by calling <a class="link" href="igraph-Flows.html#igraph_maxflow" title="1.1. igraph_maxflow — Maximum network flow between a pair of vertices"><code class="function">igraph_maxflow()</code></a>.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the value of the cut is
       stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cut</code></em>:</span></p></td>
<td><p>
  Pointer to a real vector, the edge ids that are included
       in the cut are stored here. This argument is ignored if it
       is a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>partition</code></em>:</span></p></td>
<td><p>
  Pointer to a real vector, the vertex ids of the
       vertices in the first partition of the cut are stored
       here. The first partition is always the one that contains the
       source vertex. This argument is ignored if it is a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>partition2</code></em>:</span></p></td>
<td><p>
  Pointer to a real vector, the vertex ids of the
       vertices in the second partition of the cut are stored here.
       The second partition is always the one that contains the
       target vertex. This argument is ignored if it is a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>source</code></em>:</span></p></td>
<td><p>
  Integer, the id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  Integer, the id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>capacity</code></em>:</span></p></td>
<td><p>
  Vector containing the capacity of the edges. If a
       null pointer, then every edge is considered to have capacity
       1.0.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_maxflow" title="1.1. igraph_maxflow — Maximum network flow between a pair of vertices"><code class="function">igraph_maxflow()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: see <a class="link" href="igraph-Flows.html#igraph_maxflow" title="1.1. igraph_maxflow — Maximum network flow between a pair of vertices"><code class="function">igraph_maxflow()</code></a>.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_st_mincut_value"></a>2.2. <code class="function">igraph_st_mincut_value</code> —  The minimum s-t cut in a graph</h3></div></div></div>
<a class="indexterm" name="id-1.23.3.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_st_mincut_value(const igraph_t *graph, igraph_real_t *value,
                           igraph_integer_t source, igraph_integer_t target,
                           const igraph_vector_t *capacity);
</pre></div>
<p>
</p>
<p>



</p>
<p> The minimum s-t cut in a weighted (=valued) graph is the
total minimum edge weight needed to remove from the graph to
eliminate all paths from a given vertex (<code class="constant">source</code>) to
another vertex (<code class="constant">target</code>). Directed paths are considered in
directed graphs, and undirected paths in undirected graphs.  </p>
<p> The minimum s-t cut between two vertices is known to be same
as the maximum flow between these two vertices. So this function
calls <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a> to do the calculation.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result will be stored
       here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>source</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>capacity</code></em>:</span></p></td>
<td><p>
  Pointer to the capacity vector, it should contain
       non-negative numbers and its length should be the same the
       the number of edges in the graph. It can be a null pointer, then
       every edge has unit capacity.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^3), see also the discussion for <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>, |V| is the number of vertices.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_all_st_cuts"></a>2.3. <code class="function">igraph_all_st_cuts</code> — List all edge-cuts between two vertices in a directed graph</h3></div></div></div>
<a class="indexterm" name="id-1.23.3.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_all_st_cuts(const igraph_t *graph,
                       igraph_vector_ptr_t *cuts,
                       igraph_vector_ptr_t *partition1s,
                       igraph_integer_t source,
                       igraph_integer_t target);
</pre></div>
<p>
</p>
<p>



This function lists all edge-cuts between a source and a target
vertex. Every cut is listed exactly once. The implemented algorithm
is described in JS Provan and DR Shier: A Paradigm for listing
(s,t)-cuts in graphs, Algorithmica 15, 351--372, 1996.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, is must be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cuts</code></em>:</span></p></td>
<td><p>
  An initialized pointer vector, the cuts are stored
       here. It is a list of pointers to igraph_vector_t
       objects. Each vector will contain the ids of the edges in
       the cut. This argument is ignored if it is a null pointer.
       To free all memory allocated for <code class="constant">cuts</code>, you need call
       <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a> and then <a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions."><code class="function">igraph_free()</code></a> on
       each element, before destroying the pointer vector itself.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>partition1s</code></em>:</span></p></td>
<td><p>
  An initialized pointer vector, the list of
       vertex sets, generating the actual edge cuts, are stored
       here. Each vector contains a set of vertex ids. If X is such
       a set, then all edges going from X to the complement of X
       form an (s,t) edge-cut in the graph. This argument is
       ignored if it is a null pointer.
       To free all memory allocated for <code class="constant">partition1s</code>, you need call
       <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a> and then <a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions."><code class="function">igraph_free()</code></a> on
       each element, before destroying the pointer vector itself.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>source</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n(|V|+|E|)), where |V| is the number of
vertices, |E| is the number of edges, and n is the number of cuts.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_all_st_mincuts"></a>2.4. <code class="function">igraph_all_st_mincuts</code> — All minimum s-t cuts of a directed graph</h3></div></div></div>
<a class="indexterm" name="id-1.23.3.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_all_st_mincuts(const igraph_t *graph, igraph_real_t *value,
                          igraph_vector_ptr_t *cuts,
                          igraph_vector_ptr_t *partition1s,
                          igraph_integer_t source,
                          igraph_integer_t target,
                          const igraph_vector_t *capacity);
</pre></div>
<p>
</p>
<p>



This function lists all edge cuts between two vertices, in a directed graph,
with minimum total capacity. Possibly, multiple cuts may have the same total
capacity, although there is often only one minimum cut in weighted graphs.
It is recommended to supply integer-values capacities. Otherwise, not all
minimum cuts may be detected because of numerical roundoff errors.
The implemented algorithm is described in JS Provan and DR
Shier: A Paradigm for listing (s,t)-cuts in graphs, Algorithmica 15,
351--372, 1996.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it must be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  Pointer to a real number, the value of the minimum cut
       is stored here, unless it is a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cuts</code></em>:</span></p></td>
<td><p>
  An initialized pointer vector, the cuts are stored
       here. It is a list of pointers to igraph_vector_t
       objects. Each vector will contain the ids of the edges in
       the cut. This argument is ignored if it is a null pointer.
       To free all memory allocated for <code class="constant">cuts</code>, you need call
       <a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object."><code class="function">igraph_vector_destroy()</code></a> and then <a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions."><code class="function">igraph_free()</code></a> on
       each element, before destroying the pointer vector itself.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>partition1s</code></em>:</span></p></td>
<td><p>
  An initialized pointer vector, the list of
       vertex sets, generating the actual edge cuts, are stored
       here. Each vector contains a set of vertex ids. If X is such
       a set, then all edges going from X to the complement of X
       form an (s,t) edge-cut in the graph. This argument is
       ignored if it is a null pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>source</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>capacity</code></em>:</span></p></td>
<td><p>
  Vector of edge capacities. All capacities must be
       strictly positive. If this is a null pointer, then all edges
       are assumed to have capacity one.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n(|V|+|E|))+O(F), where |V| is the number of
vertices, |E| is the number of edges, and n is the number of cuts;
O(F) is the time complexity of the maximum flow algorithm, see <a class="link" href="igraph-Flows.html#igraph_maxflow" title="1.1. igraph_maxflow — Maximum network flow between a pair of vertices"><code class="function">igraph_maxflow()</code></a>.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.23.3.5.8.2"></a><p class="title"><b>Example 22.4.  File <code class="code">examples/simple/igraph_all_st_mincuts.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2010-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>print_and_destroy</strong></span>(igraph_t *g,
                      igraph_real_t value,
                      igraph_vector_ptr_t *partitions,
                      igraph_vector_ptr_t *cuts) {
    long int i, e, m, n = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(partitions);
    <span class="strong"><strong>printf</strong></span>("Found %li cuts, value: %g\n", n, value);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; n; i++) {
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *vec = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*partitions)[i];
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *vec2 = cuts ? <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*cuts)[i] : 0;
        <span class="strong"><strong>printf</strong></span>("Partition %li: ", i);
        <span class="strong"><strong>igraph_vector_print</strong></span>(vec);
        <span class="strong"><strong>if</strong></span> (vec2) {
            <span class="strong"><strong>printf</strong></span>("Cut %li:\n", i);
            m = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(vec2);
            <span class="strong"><strong>for</strong></span> (e = 0; e &lt; m; e++) {
                igraph_integer_t from, to;
                <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_edge" title="3.2.3. igraph_edge — Gives the head and tail vertices of an edge.">igraph_edge</a></strong></span>(g, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*vec2)[e], &amp;from, &amp;to);
                <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="3.2.13. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(g)) {
                    <span class="strong"><strong>printf</strong></span>("  %" IGRAPH_PRId " -&gt; %" IGRAPH_PRId "\n", from, to);
                } <span class="strong"><strong>else</strong></span> {
                    <span class="strong"><strong>printf</strong></span>("  %" IGRAPH_PRId " -- %" IGRAPH_PRId "\n", from, to);
                }
            }
        }

        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(vec);
        <span class="strong"><strong>if</strong></span> (vec2) {
            <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(vec2);
        }
        <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions.">igraph_free</a></strong></span>(vec);
        <span class="strong"><strong>if</strong></span> (vec2) {
            <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions.">igraph_free</a></strong></span>(vec2);
        }
    }
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(partitions);
    <span class="strong"><strong>if</strong></span> (cuts) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(cuts);
    }
    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    igraph_vector_ptr_t partitions;
    igraph_vector_ptr_t cuts;
    igraph_real_t value;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 5, IGRAPH_DIRECTED,
                 0, 1, 1, 2, 2, 3, 3, 4,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;partitions, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;cuts, 0);
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_all_st_mincuts" title="2.4. igraph_all_st_mincuts — All minimum s-t cuts of a directed graph">igraph_all_st_mincuts</a></strong></span>(&amp;g, &amp;value, &amp;cuts, &amp;partitions,
                          <span class="emphasis"><em>/*source=*/</em></span> 0, <span class="emphasis"><em>/*target=*/</em></span> 4,
                          <span class="emphasis"><em>/*capacity=*/</em></span> 0);

    <span class="strong"><strong>print_and_destroy</strong></span>(&amp;g, value, &amp;partitions, &amp;cuts);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 6, IGRAPH_DIRECTED, 0, 1, 1, 2, 1, 3, 2, 4, 3, 4, 4, 5, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;partitions, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;cuts, 0);
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_all_st_mincuts" title="2.4. igraph_all_st_mincuts — All minimum s-t cuts of a directed graph">igraph_all_st_mincuts</a></strong></span>(&amp;g, &amp;value, &amp;cuts, &amp;partitions,
                          <span class="emphasis"><em>/*source=*/</em></span> 0, <span class="emphasis"><em>/*target=*/</em></span> 5, <span class="emphasis"><em>/*capacity=*/</em></span> 0);

    <span class="strong"><strong>print_and_destroy</strong></span>(&amp;g, value, &amp;partitions, &amp;cuts);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 6, IGRAPH_DIRECTED, 0, 1, 1, 2, 1, 3, 2, 4, 3, 4, 4, 5, -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;partitions, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;cuts, 0);
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_all_st_mincuts" title="2.4. igraph_all_st_mincuts — All minimum s-t cuts of a directed graph">igraph_all_st_mincuts</a></strong></span>(&amp;g, &amp;value, &amp;cuts, &amp;partitions,
                          <span class="emphasis"><em>/*source=*/</em></span> 0, <span class="emphasis"><em>/*target=*/</em></span> 4, <span class="emphasis"><em>/*capacity=*/</em></span> 0);

    <span class="strong"><strong>print_and_destroy</strong></span>(&amp;g, value, &amp;partitions, &amp;cuts);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 9, IGRAPH_DIRECTED, 0, 1, 0, 2, 1, 3, 2, 3,
                 1, 4, 4, 2, 1, 5, 5, 2, 1, 6, 6, 2, 1, 7, 7, 2, 1, 8, 8, 2,
                 -1);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;partitions, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;cuts, 0);
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_all_st_mincuts" title="2.4. igraph_all_st_mincuts — All minimum s-t cuts of a directed graph">igraph_all_st_mincuts</a></strong></span>(&amp;g, &amp;value, &amp;cuts, &amp;partitions,
                          <span class="emphasis"><em>/*source=*/</em></span> 0, <span class="emphasis"><em>/*target=*/</em></span> 3, <span class="emphasis"><em>/*capacity=*/</em></span> 0);

    <span class="strong"><strong>print_and_destroy</strong></span>(&amp;g, value, &amp;partitions, &amp;cuts);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 4, IGRAPH_DIRECTED,
                 1, 0, 2, 0, 2, 1, 3, 2,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;partitions, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;cuts, 0);
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_all_st_mincuts" title="2.4. igraph_all_st_mincuts — All minimum s-t cuts of a directed graph">igraph_all_st_mincuts</a></strong></span>(&amp;g, &amp;value, &amp;cuts, &amp;partitions,
                          <span class="emphasis"><em>/*source=*/</em></span> 2, <span class="emphasis"><em>/*target=*/</em></span> 0, <span class="emphasis"><em>/*capacity=*/</em></span> 0);

    <span class="strong"><strong>print_and_destroy</strong></span>(&amp;g, value, &amp;partitions, &amp;cuts);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 4, IGRAPH_DIRECTED,
                 1, 0, 2, 0, 2, 1, 2, 3,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;partitions, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;cuts, 0);
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_all_st_mincuts" title="2.4. igraph_all_st_mincuts — All minimum s-t cuts of a directed graph">igraph_all_st_mincuts</a></strong></span>(&amp;g, &amp;value, &amp;cuts, &amp;partitions,
                          <span class="emphasis"><em>/*source=*/</em></span> 2, <span class="emphasis"><em>/*target=*/</em></span> 0, <span class="emphasis"><em>/*capacity=*/</em></span> 0);

    <span class="strong"><strong>print_and_destroy</strong></span>(&amp;g, value, &amp;partitions, &amp;cuts);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* ---------------------------------------------------------------- */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 9, IGRAPH_DIRECTED,
                 0, 4,  0, 7,  1, 6,  2, 1,  3, 8,  4, 0,  4, 2,
                 4, 5,  5, 0,  5, 3,  6, 7,  7, 8,
                 -1);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;partitions, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;cuts, 0);
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_all_st_mincuts" title="2.4. igraph_all_st_mincuts — All minimum s-t cuts of a directed graph">igraph_all_st_mincuts</a></strong></span>(&amp;g, &amp;value, &amp;cuts, &amp;partitions,
                          <span class="emphasis"><em>/*source=*/</em></span> 0, <span class="emphasis"><em>/*target=*/</em></span> 8, <span class="emphasis"><em>/*capacity=*/</em></span> 0);

    <span class="strong"><strong>print_and_destroy</strong></span>(&amp;g, value, &amp;partitions, &amp;cuts);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_mincut"></a>2.5. <code class="function">igraph_mincut</code> —  Calculates the minimum cut in a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.23.3.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_mincut(const igraph_t *graph,
                  igraph_real_t *value,
                  igraph_vector_t *partition,
                  igraph_vector_t *partition2,
                  igraph_vector_t *cut,
                  const igraph_vector_t *capacity);
</pre></div>
<p>
</p>
<p>



This function calculates the minimum cut in a graph.
The minimum cut is the minimum set of edges which needs to be
removed to disconnect the graph. The minimum is calculated using
the weights (<em class="parameter"><code>capacity</code></em>) of the edges, so the cut with the minimum
total capacity is calculated.

</p>
<p> For directed graphs an implementation based on
calculating 2|V|-2 maximum flows is used.
For undirected graphs we use the Stoer-Wagner
algorithm, as described in M. Stoer and F. Wagner: A simple min-cut
algorithm, Journal of the ACM, 44 585-591, 1997.

</p>
<p>
The first implementation of the actual cut calculation for
undirected graphs was made by Gregory Benison, thanks Greg.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>value</code></em>:</span></p></td>
<td><p>
  Pointer to a float, the value of the cut will be
   stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>partition</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the ids
   of the vertices in the first partition after separating the
   graph will be stored here. The vector will be resized as
   needed. This argument is ignored if it is a NULL pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>partition2</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector the ids
   of the vertices in the second partition will be stored here.
   The vector will be resized as needed. This argument is ignored
   if it is a NULL pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cut</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the ids of the edges
   in the cut will be stored here. This argument is ignored if it
   is a NULL pointer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>capacity</code></em>:</span></p></td>
<td><p>
  A numeric vector giving the capacities of the
   edges. If a null pointer then all edges have unit capacity.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_mincut_value" title="2.6. igraph_mincut_value — The minimum edge cut in a graph"><code class="function">igraph_mincut_value()</code></a>, a simpler interface for calculating
the value of the cut only.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: for directed graphs it is O(|V|^4), but see the
remarks at <a class="link" href="igraph-Flows.html#igraph_maxflow" title="1.1. igraph_maxflow — Maximum network flow between a pair of vertices"><code class="function">igraph_maxflow()</code></a>. For undirected graphs it is
O(|V||E|+|V|^2 log|V|). |V| and |E| are the number of vertices and
edges respectively.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.23.3.6.12.2"></a><p class="title"><b>Example 22.5.  File <code class="code">examples/simple/igraph_mincut.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2007-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard st, Cambridge MA, 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>print_mincut</strong></span>(<span class="strong"><strong>const</strong></span> igraph_t *graph, igraph_real_t value,
                 <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *partition,
                 <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *partition2,
                 <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *cut,
                 <span class="strong"><strong>const</strong></span> <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *capacity) {

    long int i, nc = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_size" title="2.11.2. igraph_vector_size — Returns the size (=length) of the vector.">igraph_vector_size</a></strong></span>(cut);
    igraph_bool_t directed = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="3.2.13. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(graph);

    <span class="strong"><strong>printf</strong></span>("mincut value: %g\n", (double) value);
    <span class="strong"><strong>printf</strong></span>("first partition:  ");
    <span class="strong"><strong>igraph_vector_print</strong></span>(partition);
    <span class="strong"><strong>printf</strong></span>("second partition: ");
    <span class="strong"><strong>igraph_vector_print</strong></span>(partition2);
    <span class="strong"><strong>printf</strong></span>("edges in the cut: ");
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; nc; i++) {
        long int edge = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*cut)[i];
        long int from = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="3.2.5. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(graph, edge);
        long int to  = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="3.2.6. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>  (graph, edge);
        <span class="strong"><strong>if</strong></span> (!directed &amp;&amp; from &gt; to) {
            igraph_integer_t tmp = from;
            from = to;
            to = tmp;
        }
        <span class="strong"><strong>printf</strong></span>("%li-%li (%g), ", from, to, <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(*capacity)[edge]);
    }
    <span class="strong"><strong>printf</strong></span>("\n");

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights, partition, partition2, cut;
    igraph_real_t value;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;partition, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;partition2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;cut, 0);

    <span class="emphasis"><em>/* -------------------------------------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_UNDIRECTED,
                 0, 1, 0, 4, 1, 2, 1, 4, 1, 5, 2, 3, 2, 6, 3, 6, 3, 7, 4, 5, 5, 6, 6, 7,
                 -1);
    <span class="strong"><strong>igraph_vector_init_int_end</strong></span>(&amp;weights, -1, 2, 3, 3, 2, 2, 4, 2, 2, 2, 3, 1, 3, -1);

    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_mincut" title="2.5. igraph_mincut — Calculates the minimum cut in a graph.">igraph_mincut</a></strong></span>(&amp;g, &amp;value, &amp;partition, &amp;partition2, &amp;cut, &amp;weights);
    <span class="strong"><strong>print_mincut</strong></span>(&amp;g, value, &amp;partition, &amp;partition2, &amp;cut, &amp;weights);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* -------------------------------------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 6, IGRAPH_DIRECTED,
                 0, 1, 1, 2, 2, 3, 0, 5, 5, 4, 4, 3, 3, 0, -1);
    <span class="strong"><strong>igraph_vector_init_int_end</strong></span>(&amp;weights, -1, 3, 1, 2, 10, 1, 3, 2, -1);

    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_mincut" title="2.5. igraph_mincut — Calculates the minimum cut in a graph.">igraph_mincut</a></strong></span>(&amp;g, &amp;value, &amp;partition, &amp;partition2, &amp;cut, &amp;weights);
    <span class="strong"><strong>print_mincut</strong></span>(&amp;g, value, &amp;partition, &amp;partition2, &amp;cut, &amp;weights);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* -------------------------------------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 5, IGRAPH_DIRECTED,
                 4, 3, 3, 2, 2, 1, 1, 0,
                 -1);
    <span class="strong"><strong>igraph_vector_init_int_end</strong></span>(&amp;weights, -1, 1, 1, 1, 1, -1);
    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_mincut" title="2.5. igraph_mincut — Calculates the minimum cut in a graph.">igraph_mincut</a></strong></span>(&amp;g, &amp;value, &amp;partition, &amp;partition2, &amp;cut, &amp;weights);
    <span class="strong"><strong>print_mincut</strong></span>(&amp;g, value, &amp;partition, &amp;partition2, &amp;cut, &amp;weights);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* -------------------------------------------- */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;cut);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;partition2);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;partition);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_mincut_value"></a>2.6. <code class="function">igraph_mincut_value</code> —  The minimum edge cut in a graph</h3></div></div></div>
<a class="indexterm" name="id-1.23.3.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_mincut_value(const igraph_t *graph, igraph_real_t *res,
                        const igraph_vector_t *capacity);
</pre></div>
<p>
</p>
<p>



</p>
<p> The minimum edge cut in a graph is the total minimum
weight of the edges needed to remove from the graph to make the
graph <span class="emphasis"><em>not</em></span> strongly connected. (If the original graph is not
strongly connected then this is zero.) Note that in undirected
graphs strong connectedness is the same as weak connectedness. </p>
<p> The minimum cut can be calculated with maximum flow
techniques, although the current implementation does this only for
directed graphs and a separate non-flow based implementation is
used for undirected graphs. See Mechthild Stoer and Frank Wagner: A
simple min-cut algorithm, Journal of the ACM 44 585--591, 1997.
For directed graphs
the maximum flow is calculated between a fixed vertex and all the
other vertices in the graph and this is done in both
directions. Then the minimum is taken to get the minimum cut.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to a real variable, the result will be stored
   here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>capacity</code></em>:</span></p></td>
<td><p>
  Pointer to the capacity vector, it should contain
   the same number of non-negative numbers as the number of edges in
   the graph. If a null pointer then all edges will have unit capacity.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_mincut" title="2.5. igraph_mincut — Calculates the minimum cut in a graph."><code class="function">igraph_mincut()</code></a>, <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>, <a class="link" href="igraph-Flows.html#igraph_st_mincut_value" title="2.2. igraph_st_mincut_value — The minimum s-t cut in a graph"><code class="function">igraph_st_mincut_value()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(log(|V|)*|V|^2) for undirected graphs and
O(|V|^4) for directed graphs, but see also the discussion at the
documentation of <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_gomory_hu_tree"></a>2.7. <code class="function">igraph_gomory_hu_tree</code> —  Gomory-Hu tree of a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.23.3.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_gomory_hu_tree(const igraph_t *graph, igraph_t *tree,
                          igraph_vector_t *flows, const igraph_vector_t *capacity);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The Gomory-Hu tree is a concise representation of the value of all the
maximum flows (or minimum cuts) in a graph. The vertices of the tree
correspond exactly to the vertices of the original graph in the same order.
Edges of the Gomory-Hu tree are annotated by flow values.  The value of
the maximum flow (or minimum cut) between an arbitrary (u,v) vertex
pair in the original graph is then given by the minimum flow value (i.e.
edge annotation) along the shortest path between u and v in the
Gomory-Hu tree.

</p>
<p>This implementation uses Gusfield's algorithm to construct the
Gomory-Hu tree. See the following paper for more details:

</p>
<p>
Gusfield D: Very simple methods for all pairs network flow analysis. SIAM J
Comput 19(1):143-155, 1990.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>tree</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph; the result will be
             stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>flows</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized vector; the flow values
             corresponding to each edge in the Gomory-Hu tree will
             be returned here. You may pass a NULL pointer here if you are
             not interested in the flow values.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>capacity</code></em>:</span></p></td>
<td><p>
  Vector containing the capacity of the edges. If NULL, then
       every edge is considered to have capacity 1.0.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^4) since it performs a max-flow calculation
between vertex zero and every other vertex and max-flow is
O(|V|^3).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_maxflow" title="1.1. igraph_maxflow — Maximum network flow between a pair of vertices"><code class="function">igraph_maxflow()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="connectivity"></a>3. Connectivity</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Flows.html#igraph_st_edge_connectivity">3.1. <code class="function">igraph_st_edge_connectivity</code> —  Edge connectivity of a pair of vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_edge_connectivity">3.2. <code class="function">igraph_edge_connectivity</code> —  The minimum edge connectivity in a graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_st_vertex_connectivity">3.3. <code class="function">igraph_st_vertex_connectivity</code> —  The vertex connectivity of a pair of vertices</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_vertex_connectivity">3.4. <code class="function">igraph_vertex_connectivity</code> — The vertex connectivity of a graph</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_st_edge_connectivity"></a>3.1. <code class="function">igraph_st_edge_connectivity</code> —  Edge connectivity of a pair of vertices</h3></div></div></div>
<a class="indexterm" name="id-1.23.4.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_st_edge_connectivity(const igraph_t *graph, igraph_integer_t *res,
                                igraph_integer_t source,
                                igraph_integer_t target);
</pre></div>
<p>
</p>
<p>



</p>
<p> The edge connectivity of two vertices (<code class="constant">source</code> and
<code class="constant">target</code>) in a graph is the minimum number of edges that
have to be deleted from the graph to eliminate all paths from <code class="constant">source</code> to <code class="constant">target</code>.</p>
<p>This function uses the maximum flow algorithm to calculate
the edge connectivity.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, it has to be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>source</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^3).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>, <a class="link" href="igraph-Flows.html#igraph_edge_connectivity" title="3.2. igraph_edge_connectivity — The minimum edge connectivity in a graph."><code class="function">igraph_edge_connectivity()</code></a>,
<a class="link" href="igraph-Flows.html#igraph_st_vertex_connectivity" title="3.3. igraph_st_vertex_connectivity — The vertex connectivity of a pair of vertices"><code class="function">igraph_st_vertex_connectivity()</code></a>, <a class="link" href="igraph-Flows.html#igraph_vertex_connectivity" title="3.4. igraph_vertex_connectivity — The vertex connectivity of a graph"><code class="function">igraph_vertex_connectivity()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_edge_connectivity"></a>3.2. <code class="function">igraph_edge_connectivity</code> —  The minimum edge connectivity in a graph.</h3></div></div></div>
<a class="indexterm" name="id-1.23.4.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_edge_connectivity(const igraph_t *graph, igraph_integer_t *res,
                             igraph_bool_t checks);
</pre></div>
<p>
</p>
<p>



</p>
<p> This is the minimum of the edge connectivity over all
pairs of vertices in the graph. </p>
<p>
The edge connectivity of a graph is the same as group adhesion as
defined in Douglas R. White and Frank Harary: The cohesiveness of
blocks in social networks: node connectivity and conditional
density, Sociological Methodology 31:305--359, 2001.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>checks</code></em>:</span></p></td>
<td><p>
  Logical constant. Whether to check that the graph is
   connected and also the degree of the vertices. If the graph is
   not (strongly) connected then the connectivity is obviously zero. Otherwise
   if the minimum degree is one then the edge connectivity is also
   one. It is a good idea to perform these checks, as they can be
   done quickly compared to the connectivity calculation itself.
   They were suggested by Peter McMahan, thanks Peter.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(log(|V|)*|V|^2) for undirected graphs and
O(|V|^4) for directed graphs, but see also the discussion at the
documentation of <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_st_edge_connectivity" title="3.1. igraph_st_edge_connectivity — Edge connectivity of a pair of vertices"><code class="function">igraph_st_edge_connectivity()</code></a>, <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>,
<a class="link" href="igraph-Flows.html#igraph_vertex_connectivity" title="3.4. igraph_vertex_connectivity — The vertex connectivity of a graph"><code class="function">igraph_vertex_connectivity()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_st_vertex_connectivity"></a>3.3. <code class="function">igraph_st_vertex_connectivity</code> —  The vertex connectivity of a pair of vertices</h3></div></div></div>
<a class="indexterm" name="id-1.23.4.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_st_vertex_connectivity(const igraph_t *graph,
                                  igraph_integer_t *res,
                                  igraph_integer_t source,
                                  igraph_integer_t target,
                                  igraph_vconn_nei_t neighbors);
</pre></div>
<p>
</p>
<p>



</p>
<p>The vertex connectivity of two vertices (<code class="constant">source</code> and
<code class="constant">target</code>) is the minimum number of vertices that have to be
deleted to eliminate all paths from <code class="constant">source</code> to <code class="constant">target</code>. Directed paths are considered in directed graphs.</p>
<p>The vertex connectivity of a pair is the same as the number
of different (i.e. node-independent) paths from source to
target.</p>
<p>The current implementation uses maximum flow calculations to
obtain the result.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>source</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>neighbors</code></em>:</span></p></td>
<td><p>
  A constant giving what to do if the two vertices
    are connected. Possible values:
    <code class="constant">IGRAPH_VCONN_NEI_ERROR</code>, stop with an error message,
    <code class="constant">IGRAPH_VCONN_NEGATIVE</code>, return -1.
    <code class="constant">IGRAPH_VCONN_NUMBER_OF_NODES</code>, return the number of nodes.
    <code class="constant">IGRAPH_VCONN_IGNORE</code>, ignore the fact that the two vertices
       are connected and calculate the number of vertices needed
       to eliminate all paths except for the trivial (direct) paths
       between <em class="parameter"><code>source</code></em> and <em class="parameter"><code>vertex</code></em>. TODO: what about neighbors?
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^3), but see the discussion at <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_vertex_connectivity" title="3.4. igraph_vertex_connectivity — The vertex connectivity of a graph"><code class="function">igraph_vertex_connectivity()</code></a>,
<a class="link" href="igraph-Flows.html#igraph_edge_connectivity" title="3.2. igraph_edge_connectivity — The minimum edge connectivity in a graph."><code class="function">igraph_edge_connectivity()</code></a>,
<a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_vertex_connectivity"></a>3.4. <code class="function">igraph_vertex_connectivity</code> — The vertex connectivity of a graph</h3></div></div></div>
<a class="indexterm" name="id-1.23.4.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vertex_connectivity(const igraph_t *graph, igraph_integer_t *res,
                               igraph_bool_t checks);
</pre></div>
<p>
</p>
<p>



</p>
<p> The vertex connectivity of a graph is the minimum
vertex connectivity along each pairs of vertices in the graph.
</p>
<p> The vertex connectivity of a graph is the same as group
cohesion as defined in Douglas R. White and Frank Harary: The
cohesiveness of blocks in social networks: node connectivity and
conditional density, Sociological Methodology 31:305--359, 2001.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>checks</code></em>:</span></p></td>
<td><p>
  Logical constant. Whether to check that the graph is
   connected and also the degree of the vertices. If the graph is
   not (strongly) connected then the connectivity is obviously zero. Otherwise
   if the minimum degree is one then the vertex connectivity is also
   one. It is a good idea to perform these checks, as they can be
   done quickly compared to the connectivity calculation itself.
   They were suggested by Peter McMahan, thanks Peter.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^5).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_st_vertex_connectivity" title="3.3. igraph_st_vertex_connectivity — The vertex connectivity of a pair of vertices"><code class="function">igraph_st_vertex_connectivity()</code></a>, <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>,
and <a class="link" href="igraph-Flows.html#igraph_edge_connectivity" title="3.2. igraph_edge_connectivity — The minimum edge connectivity in a graph."><code class="function">igraph_edge_connectivity()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="edge-and-vertex-disjoint-paths"></a>4. Edge- and vertex-disjoint paths</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Flows.html#igraph_edge_disjoint_paths">4.1. <code class="function">igraph_edge_disjoint_paths</code> —  The maximum number of edge-disjoint paths between two vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_vertex_disjoint_paths">4.2. <code class="function">igraph_vertex_disjoint_paths</code> —  Maximum number of vertex-disjoint paths between two vertices.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_edge_disjoint_paths"></a>4.1. <code class="function">igraph_edge_disjoint_paths</code> —  The maximum number of edge-disjoint paths between two vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.23.5.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_edge_disjoint_paths(const igraph_t *graph, igraph_integer_t *res,
                               igraph_integer_t source,
                               igraph_integer_t target);
</pre></div>
<p>
</p>
<p>



</p>
<p> A set of paths between two vertices is called
edge-disjoint if they do not share any edges. The maximum number of
edge-disjoint paths are calculated by this function using maximum
flow techniques. Directed paths are considered in directed
graphs. </p>
<p> Note that the number of disjoint paths is the same as the
edge connectivity of the two vertices using uniform edge weights.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, can be directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an integer variable, the result will be
       stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>source</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^3), but see the discussion at <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_vertex_disjoint_paths" title="4.2. igraph_vertex_disjoint_paths — Maximum number of vertex-disjoint paths between two vertices."><code class="function">igraph_vertex_disjoint_paths()</code></a>, <a class="link" href="igraph-Flows.html#igraph_st_edge_connectivity" title="3.1. igraph_st_edge_connectivity — Edge connectivity of a pair of vertices"><code class="function">igraph_st_edge_connectivity()</code></a>, <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_vertex_disjoint_paths"></a>4.2. <code class="function">igraph_vertex_disjoint_paths</code> —  Maximum number of vertex-disjoint paths between two vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.23.5.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_vertex_disjoint_paths(const igraph_t *graph, igraph_integer_t *res,
                                 igraph_integer_t source,
                                 igraph_integer_t target);
</pre></div>
<p>
</p>
<p>



</p>
<p> A set of paths between two vertices is called
vertex-disjoint if they share no vertices. The calculation is
performed by using maximum flow techniques. </p>
<p> Note that the number of vertex-disjoint paths is the same as
the vertex connectivity of the two vertices in most cases (if the
two vertices are not connected by an edge).
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an integer variable, the result will be
       stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>source</code></em>:</span></p></td>
<td><p>
  The id of the source vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>target</code></em>:</span></p></td>
<td><p>
  The id of the target vertex.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^3).

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_edge_disjoint_paths" title="4.1. igraph_edge_disjoint_paths — The maximum number of edge-disjoint paths between two vertices."><code class="function">igraph_edge_disjoint_paths()</code></a>, <a class="link" href="igraph-Flows.html#igraph_vertex_connectivity" title="3.4. igraph_vertex_connectivity — The vertex connectivity of a graph"><code class="function">igraph_vertex_connectivity()</code></a>, <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="graph-adhesion-and-cohesion"></a>5. Graph adhesion and cohesion</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Flows.html#igraph_adhesion">5.1. <code class="function">igraph_adhesion</code> —  Graph adhesion, this is (almost) the same as edge connectivity.</a></span></dt>
<dt><span class="section"><a href="igraph-Flows.html#igraph_cohesion">5.2. <code class="function">igraph_cohesion</code> —  Graph cohesion, this is the same as vertex connectivity.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_adhesion"></a>5.1. <code class="function">igraph_adhesion</code> —  Graph adhesion, this is (almost) the same as edge connectivity.</h3></div></div></div>
<a class="indexterm" name="id-1.23.6.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_adhesion(const igraph_t *graph, igraph_integer_t *res,
                    igraph_bool_t checks);
</pre></div>
<p>
</p>
<p>



</p>
<p> This quantity is defined by White and Harary in
The cohesiveness of blocks in social networks: node connectivity and
conditional density, (Sociological Methodology 31:305--359, 2001)
and basically it is the edge connectivity of the graph
with uniform edge weights.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, either directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an integer, the result will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>checks</code></em>:</span></p></td>
<td><p>
  Logical constant. Whether to check that the graph is
   connected and also the degree of the vertices. If the graph is
   not (strongly) connected then the adhesion is obviously zero. Otherwise
   if the minimum degree is one then the adhesion is also
   one. It is a good idea to perform these checks, as they can be
   done quickly compared to the edge connectivity calculation itself.
   They were suggested by Peter McMahan, thanks Peter.
* </p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(log(|V|)*|V|^2) for undirected graphs and
O(|V|^4) for directed graphs, but see also the discussion at the
documentation of <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_cohesion" title="5.2. igraph_cohesion — Graph cohesion, this is the same as vertex connectivity."><code class="function">igraph_cohesion()</code></a>, <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>, <a class="link" href="igraph-Flows.html#igraph_edge_connectivity" title="3.2. igraph_edge_connectivity — The minimum edge connectivity in a graph."><code class="function">igraph_edge_connectivity()</code></a>, <a class="link" href="igraph-Flows.html#igraph_mincut_value" title="2.6. igraph_mincut_value — The minimum edge cut in a graph"><code class="function">igraph_mincut_value()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_cohesion"></a>5.2. <code class="function">igraph_cohesion</code> —  Graph cohesion, this is the same as vertex connectivity.</h3></div></div></div>
<a class="indexterm" name="id-1.23.6.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_cohesion(const igraph_t *graph, igraph_integer_t *res,
                    igraph_bool_t checks);
</pre></div>
<p>
</p>
<p>



</p>
<p> This quantity was defined by White and Harary in <span class="quote">“<span class="quote">The
cohesiveness of blocks in social networks: node connectivity and
conditional density</span>”</span>, (Sociological Methodology 31:305--359, 2001)
and it is the same as the vertex connectivity of a
graph.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>res</code></em>:</span></p></td>
<td><p>
  Pointer to an integer variable, the result will be
       stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>checks</code></em>:</span></p></td>
<td><p>
  Logical constant. Whether to check that the graph is
   connected and also the degree of the vertices. If the graph is
   not (strongly) connected then the cohesion is obviously zero. Otherwise
   if the minimum degree is one then the cohesion is also
   one. It is a good idea to perform these checks, as they can be
   done quickly compared to the vertex connectivity calculation itself.
   They were suggested by Peter McMahan, thanks Peter.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^4), |V| is the number of vertices. In
practice it is more like O(|V|^2), see <a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Flows.html#igraph_vertex_connectivity" title="3.4. igraph_vertex_connectivity — The vertex connectivity of a graph"><code class="function">igraph_vertex_connectivity()</code></a>, <a class="link" href="igraph-Flows.html#igraph_adhesion" title="5.1. igraph_adhesion — Graph adhesion, this is (almost) the same as edge connectivity."><code class="function">igraph_adhesion()</code></a>,
<a class="link" href="igraph-Flows.html#igraph_maxflow_value" title="1.2. igraph_maxflow_value — Maximum flow in a network with the push/relabel algorithm"><code class="function">igraph_maxflow_value()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="cohesive-blocks"></a>6. Cohesive blocks</h2></div></div></div>
<div class="toc"><dl class="toc"><dt><span class="section"><a href="igraph-Flows.html#igraph_cohesive_blocks">6.1. <code class="function">igraph_cohesive_blocks</code> — Identifies the hierarchical cohesive block structure of a graph</a></span></dt></dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_cohesive_blocks"></a>6.1. <code class="function">igraph_cohesive_blocks</code> — Identifies the hierarchical cohesive block structure of a graph</h3></div></div></div>
<a class="indexterm" name="id-1.23.7.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
int igraph_cohesive_blocks(const igraph_t *graph,
                           igraph_vector_ptr_t *blocks,
                           igraph_vector_t *cohesion,
                           igraph_vector_t *parent,
                           igraph_t *block_tree);
</pre></div>
<p>
</p>
<p>



Cohesive blocking is a method of determining hierarchical subsets of
graph vertices based on their structural cohesion (or vertex
connectivity). For a given graph G, a subset of its vertices
S is said to be maximally k-cohesive if there is
no superset of S with vertex connectivity greater than or equal to k.
Cohesive blocking is a process through which, given a
k-cohesive set of vertices, maximally l-cohesive subsets are
recursively identified with l&gt;k. Thus a hiearchy of vertex subsets
is found, whith the entire graph G at its root. See the following
reference for details: J. Moody and D. R. White. Structural
cohesion and embeddedness: A hierarchical concept of social
groups. American Sociological Review, 68(1):103--127, Feb 2003.

</p>
<p>This function implements cohesive blocking and
calculates the complete cohesive block hierarchy of a graph.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph. It must be undirected and simple. See
   <a class="link" href="igraph-Structural.html#igraph_is_simple" title="16.1. igraph_is_simple — Decides whether the input graph is a simple graph."><code class="function">igraph_is_simple()</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>blocks</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then it must be an initialized
   vector of pointers and the cohesive blocks are stored here.
   Each block is encoded with a numeric vector, that contains the
   vertex ids of the block.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>cohesion</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then it must be an initialized
   vector and the cohesion of the blocks is stored here, in the same
   order as the blocks in the <em class="parameter"><code>blocks</code></em> pointer vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>parent</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then it must be an initialized
   vector and the block hierarchy is stored here. For each block, the
   id (i.e. the position in the <em class="parameter"><code>blocks</code></em> pointer vector) of its
   parent block is stored. For the top block in the hierarchy,
   -1 is stored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>block_tree</code></em>:</span></p></td>
<td><p>
  If not a null pointer, then it must be a pointer
   to an uninitialized graph, and the block hierarchy is stored
   here as an igraph graph. The vertex ids correspond to the order
   of the blocks in the <em class="parameter"><code>blocks</code></em> vector.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.23.7.2.9.1"></a><p class="title"><b>Example 22.6.  File <code class="code">examples/simple/cohesive_blocks.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="emphasis"><em>/* -*- mode: C -*-  */</em></span>
<span class="emphasis"><em>/*</em></span>
<span class="emphasis"><em>   IGraph library.</em></span>
<span class="emphasis"><em>   Copyright (C) 2010-2012  Gabor Csardi </em></span>&lt;csardi.gabor@gmail.com&gt;
<span class="emphasis"><em>   334 Harvard street, Cambridge, MA 02139 USA</em></span>

<span class="emphasis"><em>   This program is free software; you can redistribute it and/or modify</em></span>
<span class="emphasis"><em>   it under the terms of the GNU General Public License as published by</em></span>
<span class="emphasis"><em>   the Free Software Foundation; either version 2 of the License, or</em></span>
<span class="emphasis"><em>   (at your option) any later version.</em></span>

<span class="emphasis"><em>   This program is distributed in the hope that it will be useful,</em></span>
<span class="emphasis"><em>   but WITHOUT ANY WARRANTY; without even the implied warranty of</em></span>
<span class="emphasis"><em>   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</em></span>
<span class="emphasis"><em>   GNU General Public License for more details.</em></span>

<span class="emphasis"><em>   You should have received a copy of the GNU General Public License</em></span>
<span class="emphasis"><em>   along with this program; if not, write to the Free Software</em></span>
<span class="emphasis"><em>   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</em></span>
<span class="emphasis"><em>   02110-1301 USA</em></span>

<span class="emphasis"><em>*/</em></span>

<span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>doit</strong></span>(igraph_t *g) {

    igraph_vector_ptr_t blocks;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> cohesion;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> parent;
    igraph_t block_tree;
    long int i;

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_init" title="2.16.1. igraph_vector_ptr_init — Initialize a pointer vector (constructor).">igraph_vector_ptr_init</a></strong></span>(&amp;blocks, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;cohesion, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;parent, 0);

    <span class="strong"><strong><a class="link" href="igraph-Flows.html#igraph_cohesive_blocks" title="6.1. igraph_cohesive_blocks — Identifies the hierarchical cohesive block structure of a graph">igraph_cohesive_blocks</a></strong></span>(g, &amp;blocks, &amp;cohesion, &amp;parent,
                           &amp;block_tree);

    <span class="strong"><strong>printf</strong></span>("Blocks:\n");
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_size" title="2.16.6. igraph_vector_ptr_size — Gives the number of elements in the pointer vector.">igraph_vector_ptr_size</a></strong></span>(&amp;blocks); i++) {
        <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> *sg = <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(blocks)[i];
        <span class="strong"><strong>printf</strong></span>("  ");
        <span class="strong"><strong>igraph_vector_print</strong></span>(sg);
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(sg);
        <span class="strong"><strong><a class="link" href="igraph-Memory.html#igraph_free" title="2. igraph_free — Deallocate memory that was allocated by igraph functions.">igraph_free</a></strong></span>(sg);
    }
    <span class="strong"><strong>printf</strong></span>("Cohesion:\n  ");
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;cohesion);
    <span class="strong"><strong>printf</strong></span>("Parents:\n  ");
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;parent);
    <span class="strong"><strong>printf</strong></span>("Block graph:\n");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;block_tree, stdout);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_ptr_destroy" title="2.16.3. igraph_vector_ptr_destroy — Destroys a pointer vector.">igraph_vector_ptr_destroy</a></strong></span>(&amp;blocks);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;cohesion);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;parent);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;block_tree);

    <span class="strong"><strong>return</strong></span> 0;
}

int <span class="strong"><strong>main</strong></span>() {

    igraph_t g;
    int ret;

    <span class="emphasis"><em>/* --------------------------------------------------------*/</em></span>
    <span class="emphasis"><em>/* The graph from the Moody-White paper                    */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 23, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 0, 3, 0, 4, 0, 5,
                 1, 2, 1, 3, 1, 4, 1, 6,
                 2, 3, 2, 5, 2, 6,
                 3, 4, 3, 5, 3, 6,
                 4, 5, 4, 6, 4, 20,
                 5, 6,
                 6, 7, 6, 10, 6, 13, 6, 18,
                 7, 8, 7, 10, 7, 13,
                 8, 9,
                 9, 11, 9, 12,
                 10, 11, 10, 13,
                 11, 15,
                 12, 15,
                 13, 14,
                 14, 15,
                 16, 17, 16, 18, 16, 19,
                 17, 19, 17, 20,
                 18, 19, 18, 21, 18, 22,
                 19, 20,
                 20, 21, 20, 22,
                 21, 22,
                 -1);

    <span class="strong"><strong>if</strong></span> ( (ret = <span class="strong"><strong>doit</strong></span>(&amp;g)) ) {
        <span class="strong"><strong>return</strong></span> ret;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>printf</strong></span>("--\n");

    <span class="emphasis"><em>/* --------------------------------------------------------*/</em></span>
    <span class="emphasis"><em>/* A tricky graph, where the separators themselves         */</em></span>
    <span class="emphasis"><em>/* form a block. But recently we don't include this        */</em></span>
    <span class="emphasis"><em>/* block in the results.                                   */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 8, IGRAPH_UNDIRECTED,
                 0, 1, 0, 4, 0, 5, 1, 2, 1, 4, 1, 5, 1, 6, 2, 3, 2, 5, 2, 6, 2, 7,
                 3, 6, 3, 7, 4, 5, 5, 6, 6, 7,
                 -1);

    <span class="strong"><strong>if</strong></span> ( (ret = <span class="strong"><strong>doit</strong></span>(&amp;g)) ) {
        <span class="strong"><strong>return</strong></span> ret;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>printf</strong></span>("--\n");

    <span class="emphasis"><em>/* --------------------------------------------------------*/</em></span>
    <span class="emphasis"><em>/* The science camp graph from </em></span>http://intersci.ss.uci.edu/<span class="emphasis"><em> */</em></span>
    <span class="emphasis"><em>/* wiki/index.php/Cohesive_blocking                        */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 18, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 0, 3,
                 1, 2, 1, 3, 1, 16, 1, 17,
                 2, 3,
                 3, 17,
                 4, 5, 4, 6, 4, 7, 4, 8,
                 5, 6, 5, 7,
                 6, 7, 6, 8,
                 7, 8, 7, 16,
                 8, 9, 8, 10,
                 9, 11, 9, 12, 9, 13, 9, 14,
                 10, 11, 10, 12, 10, 13,
                 11, 14,
                 12, 13, 12, 14, 12, 15,
                 15, 16, 15, 17,
                 16, 17,
                 -1);

    <span class="strong"><strong>if</strong></span> ( (ret = <span class="strong"><strong>doit</strong></span>(&amp;g)) ) {
        <span class="strong"><strong>return</strong></span> ret;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>printf</strong></span>("--\n");

    <span class="emphasis"><em>/* --------------------------------------------------------*/</em></span>
    <span class="emphasis"><em>/* Zachary karate-club                                     */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 34, IGRAPH_UNDIRECTED,
                 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8, 0, 10, 0, 11, 0, 12, 0, 13,
                 0, 17, 0, 19, 0, 21, 0, 31,
                 1, 2, 1, 3, 1, 7, 1, 13, 1, 17, 1, 19, 1, 21, 1, 30,
                 2, 3, 2, 7, 2, 27, 2, 28, 2, 32, 2, 9, 2, 8, 2, 13,
                 3, 7, 3, 12, 3, 13,
                 4, 6, 4, 10,
                 5, 6, 5, 10, 5, 16,
                 6, 16,
                 8, 30, 8, 32, 8, 33,
                 9, 33,
                 13, 33,
                 14, 32, 14, 33,
                 15, 32, 15, 33,
                 18, 32, 18, 33,
                 19, 33,
                 20, 32, 20, 33,
                 22, 32, 22, 33,
                 23, 25, 23, 27, 23, 32, 23, 33, 23, 29,
                 24, 25, 24, 27, 24, 31,
                 25, 31,
                 26, 29, 26, 33,
                 27, 33,
                 28, 31, 28, 33,
                 29, 32, 29, 33,
                 30, 32, 30, 33,
                 31, 32, 31, 33,
                 32, 33,
                 -1);

    <span class="strong"><strong>if</strong></span> ( (ret = <span class="strong"><strong>doit</strong></span>(&amp;g)) ) {
        <span class="strong"><strong>return</strong></span> ret;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="3.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>printf</strong></span>("--\n");

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
</div>
</div>
<table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Foreign.html"><b>← Chapter 21. Reading and writing graphs from and to files</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Separators.html"><b>Chapter 23. Vertex separators →</b></a></td>
</tr></table>


      </div>
    </div>
  </div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
      &copy; 2003 &ndash; 2020 The igraph core team.
            &bull; Code licensed under 
            <a href="http://www.gnu.org/licenses/gpl-2.0.html">
            GNU GPL 2</a> or later, documentation under 
            <a href="http://www.gnu.org/copyleft/fdl.html">
              GNU FDL.</a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'c', 'html/');
    </script>





    
  </body>
</html>
