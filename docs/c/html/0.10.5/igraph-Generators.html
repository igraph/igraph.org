




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>igraph Reference Manual</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/fontawesome.min.css" integrity="sha384-QYIZto+st3yW+o8+5OHfT6S482Zsvz2WfOzpFSXMF9zqeLcFV0/wlZpMtyFcZALm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/solid.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/brands.min.css">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DY4MJME11Z"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-DY4MJME11Z');
	</script>

    <link href="/css/manual.css" rel="stylesheet">
<script async src="https://cse.google.com/cse.js?cx=003494361702844740117:dlnifinshhm"></script>

  </head>

  <body class="cc">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/c">igraph library</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            0.10.5
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="https://r.igraph.org">igraph R package</a>
              <a class="dropdown-item" href="https://python.igraph.org">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa-brands fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa-solid fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa-solid fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa-solid fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa-brands fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">igraph Reference Manual</h1>
        <p class="lead">For using the igraph C library</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container search-box-container">
  <div class="row">
    <div class="col-md-12 d-flex flex-row align-items-middle">
      <div class="search-label">Search the manual:</div>
	  <div style="flex: 1; margin: -1em 0 -1em 0"><div class="gcse-search" data-personalizedAds="false"></div></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <div class="bs-docs-section">
        
<div class="navigation-header mb-4" width="100%" summary="Navigation header"><div class="btn-group">
<a accesskey="p" class="btn btn-light" href="igraph-Random.html"><i class="fa fa-chevron-left"></i>
              Previous
            </a><a accesskey="h" class="btn btn-light" href="index.html"><i class="fa fa-home"></i>
              Home
            </a><a accesskey="n" class="btn btn-light" href="igraph-Spatial-Games.html"><i class="fa fa-chevron-right"></i>
              Next
            </a>
</div></div>
<div class="chapter">
<div class="titlepage"><div><div><h1 class="title">
<a name="igraph-Generators"></a>Chapter 9. Graph generators</h1></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Generators.html#deterministic-graph-generators">1. Deterministic graph generators</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#games-randomized-graph-generators">2. Games: Randomized graph generators</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#deprecated-graph-generators">3. Deprecated functions</a></span></dt>
</dl></div>
<p>Graph generators create graphs.</p>
<p>Almost all functions which create graph objects are documented
here. The exceptions are <a class="link" href="igraph-Operators.html#igraph_induced_subgraph" title="3.4. igraph_induced_subgraph — Creates a subgraph induced by the specified vertices."><code class="function">igraph_induced_subgraph()</code></a> and alike, these
create graphs based on another graph.</p>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="deterministic-graph-generators"></a>1. Deterministic graph generators</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Generators.html#igraph_create">1.1. <code class="function">igraph_create</code> —  Creates a graph with the specified edges.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_small">1.2. <code class="function">igraph_small</code> —  Shorthand to create a small graph, giving the edges as arguments.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_adjacency">1.3. <code class="function">igraph_adjacency</code> —  Creates a graph from an adjacency matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_weighted_adjacency">1.4. <code class="function">igraph_weighted_adjacency</code> —  Creates a graph from a weighted adjacency matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_sparse_adjacency">1.5. <code class="function">igraph_sparse_adjacency</code> —  Creates a graph from a sparse adjacency matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_sparse_weighted_adjacency">1.6. <code class="function">igraph_sparse_weighted_adjacency</code> —  Creates a graph from a weighted sparse adjacency matrix.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_adjlist">1.7. <code class="function">igraph_adjlist</code> —  Creates a graph from an adjacency list.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_star">1.8. <code class="function">igraph_star</code> —  Creates a <span class="emphasis"><em>star</em></span> graph, every vertex connects only to the center.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_wheel">1.9. <code class="function">igraph_wheel</code> —  Creates a <span class="emphasis"><em>wheel</em></span> graph, a union of a star and a cycle graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_square_lattice">1.10. <code class="function">igraph_square_lattice</code> —  Arbitrary dimensional square lattices.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_triangular_lattice">1.11. <code class="function">igraph_triangular_lattice</code> —  A triangular lattice with the given shape.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_hexagonal_lattice">1.12. <code class="function">igraph_hexagonal_lattice</code> —  A hexagonal lattice with the given shape.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_ring">1.13. <code class="function">igraph_ring</code> —  Creates a <span class="emphasis"><em>cycle</em></span> graph or a <span class="emphasis"><em>path</em></span> graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_kary_tree">1.14. <code class="function">igraph_kary_tree</code> —  Creates a k-ary tree in which almost all vertices have k children.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_symmetric_tree">1.15. <code class="function">igraph_symmetric_tree</code> —  Creates a symmetric tree with the specified number of branches at each level.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_regular_tree">1.16. <code class="function">igraph_regular_tree</code> —  Creates a regular tree.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_full">1.17. <code class="function">igraph_full</code> —  Creates a full graph (directed or undirected, with or without loops).</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_full_citation">1.18. <code class="function">igraph_full_citation</code> —  Creates a full citation graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_full_multipartite">1.19. <code class="function">igraph_full_multipartite</code> —  Create a full multipartite graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_turan">1.20. <code class="function">igraph_turan</code> —  Create a Turán graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_realize_degree_sequence">1.21. <code class="function">igraph_realize_degree_sequence</code> —  Generates a graph with the given degree sequence.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_famous">1.22. <code class="function">igraph_famous</code> —  Create a famous graph by simply providing its name.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_lcf">1.23. <code class="function">igraph_lcf</code> —  Creates a graph from LCF notation.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_lcf_vector">1.24. <code class="function">igraph_lcf_vector</code> —  Creates a graph from LCF notation.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_from_prufer">1.25. <code class="function">igraph_from_prufer</code> —  Generates a tree from a Prüfer sequence.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_atlas">1.26. <code class="function">igraph_atlas</code> —  Create a small graph from the <span class="quote">“<span class="quote">Graph Atlas</span>”</span>.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_de_bruijn">1.27. <code class="function">igraph_de_bruijn</code> —  Generate a de Bruijn graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_kautz">1.28. <code class="function">igraph_kautz</code> —  Generate a Kautz graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_circulant">1.29. <code class="function">igraph_circulant</code> —  Creates a circulant graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_generalized_petersen">1.30. <code class="function">igraph_generalized_petersen</code> —  Creates a Generalized Petersen graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_extended_chordal_ring">1.31. <code class="function">igraph_extended_chordal_ring</code> —  Create an extended chordal ring.</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_create"></a>1.1. <code class="function">igraph_create</code> —  Creates a graph with the specified edges.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_create(igraph_t *graph, const igraph_vector_int_t *edges,
                  igraph_integer_t n, igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  An uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges</code></em>:</span></p></td>
<td><p>
  The edges to add, the first two elements are the first
       edge, etc.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph, if smaller or equal
       to the highest vertex ID in the <em class="parameter"><code>edges</code></em> vector it
       will be increased automatically. So it is safe to give 0
       here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to create a directed graph or
       not. If yes, then the first edge points from the first
       vertex ID in <em class="parameter"><code>edges</code></em> to the second, etc.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVEVECTOR</code>: invalid edges
        vector (odd number of vertices).
        <code class="constant">IGRAPH_EINVVID</code>: invalid (negative)
        vertex ID.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|),
|V| is the number of vertices,
|E| the number of edges in the
graph.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.2.8.1"></a><p class="title"><b>Example 9.1.  File <code class="code">examples/simple/igraph_create.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {

    igraph_t g;
    igraph_vector_int_t v1, v2;

    <span class="emphasis"><em>/* simple use */</em></span>
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;v1, 8);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v1)[0] = 0;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v1)[1] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v1)[2] = 1;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v1)[3] = 2;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v1)[4] = 2;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v1)[5] = 3;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v1)[6] = 2;
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v1)[7] = 2;
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_create" title="1.1. igraph_create — Creates a graph with the specified edges.">igraph_create</a></strong></span>(&amp;g, &amp;v1, 0, 0);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) != 4) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;v2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_edgelist" title="26.10. igraph_get_edgelist — The list of edges in a graph.">igraph_get_edgelist</a></strong></span>(&amp;g, &amp;v2, 0);
    <span class="strong"><strong>igraph_vector_int_sort</strong></span>(&amp;v1);
    <span class="strong"><strong>igraph_vector_int_sort</strong></span>(&amp;v2);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>igraph_vector_int_all_e</strong></span>(&amp;v1, &amp;v2)) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* higher number of vertices */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_create" title="1.1. igraph_create — Creates a graph with the specified edges.">igraph_create</a></strong></span>(&amp;g, &amp;v1, 10, 0);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) != 10) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_edgelist" title="26.10. igraph_get_edgelist — The list of edges in a graph.">igraph_get_edgelist</a></strong></span>(&amp;g, &amp;v2, 0);
    <span class="strong"><strong>igraph_vector_int_sort</strong></span>(&amp;v1);
    <span class="strong"><strong>igraph_vector_int_sort</strong></span>(&amp;v2);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong>igraph_vector_int_all_e</strong></span>(&amp;v1, &amp;v2)) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;v1);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;v2);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_small"></a>1.2. <code class="function">igraph_small</code> —  Shorthand to create a small graph, giving the edges as arguments.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_small(igraph_t *graph, igraph_integer_t n, igraph_bool_t directed,
                            int first, ...);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This function is handy when a relatively small graph needs to be created.
Instead of giving the edges as a vector, they are given simply as
arguments and a <code class="literal">-1</code> needs to be given after the last meaningful
edge argument.

</p>
<p>Note that only graphs which have vertex IDs smaller than
the largest value representable by the <span class="type">int</span> type can be created this way.
If you give larger values then the result is undefined.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object. The result
       will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph; a non-negative integer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td>
<p>
  Logical constant; gives whether the graph should be
       directed. Supported values are:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_DIRECTED</code></span></p></td>
<td><p>

         The graph to be created will be <span class="emphasis"><em>directed.</em></span>
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_UNDIRECTED</code></span></p></td>
<td><p>

         The graph to be created will be <span class="emphasis"><em>undirected.</em></span>
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>...</code></em>:</span></p></td>
<td><p>
  The additional arguments giving the edges of the
       graph. Don't forget to supply an additional <code class="literal">-1</code> after the last
       (meaningful) argument. The <em class="parameter"><code>first</code></em> parameter is present for
       technical reasons and represents the first variadic argument.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges in the graph to create.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.3.10.1"></a><p class="title"><b>Example 9.2.  File <code class="code">examples/simple/igraph_small.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {

    igraph_t g;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_small" title="1.2. igraph_small — Shorthand to create a small graph, giving the edges as arguments.">igraph_small</a></strong></span>(&amp;g, 0, IGRAPH_DIRECTED, 0, 1, 1, 2, 2, 3, 3, 4, 6, 1, -1);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;g, stdout);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_adjacency"></a>1.3. <code class="function">igraph_adjacency</code> —  Creates a graph from an adjacency matrix.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_adjacency(
    igraph_t *graph, const igraph_matrix_t *adjmatrix, igraph_adjacency_t mode,
    igraph_loops_t loops
);
</pre></div>
<p>
</p>
<p>




The order of the vertices in the matrix is preserved, i.e. the vertex
corresponding to the first row/column will be vertex with id 0, the
next row is for vertex 1, etc.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>adjmatrix</code></em>:</span></p></td>
<td><p>
  The adjacency matrix. How it is interpreted
       depends on the <em class="parameter"><code>mode</code></em> argument.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  Constant to specify how the given matrix is interpreted
       as an adjacency matrix. Possible values (A(i,j) is the element in
       row i and column j in the adjacency matrix <em class="parameter"><code>adjmatrix</code></em>):
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_DIRECTED</code></span></p></td>
<td><p>

         the graph will be directed and
         an element gives the number of edges between two vertices.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_UNDIRECTED</code></span></p></td>
<td><p>

         this is the same as <code class="constant">IGRAPH_ADJ_MAX</code>,
         for convenience.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_MAX</code></span></p></td>
<td><p>

         undirected graph will be created
         and the number of edges between vertices
         i and
         j is
         max(A(i,j), A(j,i)).
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_MIN</code></span></p></td>
<td><p>

         undirected graph will be created
         with min(A(i,j), A(j,i))
         edges between vertices
         i and
         j.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_PLUS</code></span></p></td>
<td><p>

         undirected graph will be created
         with A(i,j)+A(j,i) edges
         between vertices
         i and
         j.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_UPPER</code></span></p></td>
<td><p>

         undirected graph will be created,
         only the upper right triangle (including the diagonal) is
         used for the number of edges.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_LOWER</code></span></p></td>
<td><p>

         undirected graph will be created,
         only the lower left triangle (including the diagonal) is
         used for creating the edges.
      
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td>
<p>
  Constant to specify how the diagonal of the matrix should be
       treated when creating loop edges.
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_NO_LOOPS</code></span></p></td>
<td><p>

         Ignore the diagonal of the input matrix and do not create loops.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LOOPS_ONCE</code></span></p></td>
<td><p>

         Treat the diagonal entries as the number of loop edges incident on
         the corresponding vertex.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LOOPS_TWICE</code></span></p></td>
<td><p>

         Treat the diagonal entries as <span class="emphasis"><em>twice</em></span> the number of loop edges
         incident on the corresponding vertex. Odd numbers in the diagonal
         will return an error code.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code,
        <code class="constant">IGRAPH_NONSQUARE</code>: non-square matrix.
        <code class="constant">IGRAPH_EINVAL</code>: Negative entry was found in adjacency matrix, or an
        odd number was found in the diagonal with <code class="constant">IGRAPH_LOOPS_TWICE</code>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||V|),
|V| is the number of vertices in the graph.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.4.8.1"></a><p class="title"><b>Example 9.3.  File <code class="code">examples/simple/igraph_adjacency.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_weighted_adjacency"></a>1.4. <code class="function">igraph_weighted_adjacency</code> —  Creates a graph from a weighted adjacency matrix.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_weighted_adjacency(
    igraph_t *graph, const igraph_matrix_t *adjmatrix, igraph_adjacency_t mode,
    igraph_vector_t *weights, igraph_loops_t loops
);
</pre></div>
<p>
</p>
<p>




The order of the vertices in the matrix is preserved, i.e. the vertex
corresponding to the first row/column will be vertex with id 0, the
next row is for vertex 1, etc.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>adjmatrix</code></em>:</span></p></td>
<td><p>
  The weighted adjacency matrix. How it is interpreted
       depends on the <em class="parameter"><code>mode</code></em> argument. The common feature is that
       edges with zero weights are considered nonexistent (however,
       negative weights are permitted).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  Constant to specify how the given matrix is interpreted
       as an adjacency matrix. Possible values
       (A(i,j)
       is the element in row i and column
       j in the adjacency matrix
       <em class="parameter"><code>adjmatrix</code></em>):
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_DIRECTED</code></span></p></td>
<td><p>

         the graph will be directed and
         an element gives the weight of the edge between two vertices.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_UNDIRECTED</code></span></p></td>
<td><p>

         this is the same as <code class="constant">IGRAPH_ADJ_MAX</code>,
         for convenience.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_MAX</code></span></p></td>
<td><p>

         undirected graph will be created
         and the weight of the edge between vertices
         i and
         j is
         max(A(i,j), A(j,i)).
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_MIN</code></span></p></td>
<td><p>

         undirected graph will be created
         with edge weight min(A(i,j), A(j,i))
         between vertices
         i and
         j.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_PLUS</code></span></p></td>
<td><p>

         undirected graph will be created
         with edge weight A(i,j)+A(j,i)
         between vertices
         i and
         j.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_UPPER</code></span></p></td>
<td><p>

         undirected graph will be created,
         only the upper right triangle (including the diagonal) is
         used for the edge weights.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ADJ_LOWER</code></span></p></td>
<td><p>

         undirected graph will be created,
         only the lower left triangle (including the diagonal) is
         used for the edge weights.
      
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>weights</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector, the weights will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td>
<p>
  Constant to specify how the diagonal of the matrix should be
       treated when creating loop edges.
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_NO_LOOPS</code></span></p></td>
<td><p>

         Ignore the diagonal of the input matrix and do not create loops.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LOOPS_ONCE</code></span></p></td>
<td><p>

         Treat the diagonal entries as the weight of the loop edge incident
         on the corresponding vertex.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LOOPS_TWICE</code></span></p></td>
<td><p>

         Treat the diagonal entries as <span class="emphasis"><em>twice</em></span> the weight of the loop edge
         incident on the corresponding vertex.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code,
        <code class="constant">IGRAPH_NONSQUARE</code>: non-square matrix.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||V|),
|V| is the number of vertices in the graph.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.5.8.1"></a><p class="title"><b>Example 9.4.  File <code class="code">examples/simple/igraph_weighted_adjacency.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdarg.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {
    igraph_matrix_t mat;
    igraph_t g;
    int m[4][4] = { { 0, 1, 2, 0 }, { 2, 0, 0, 1 }, { 0, 0, 1, 0 }, { 0, 1, 0, 0 } };
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_vector_int_t el;
    igraph_integer_t i, j, n;
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;el, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, 0);

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_init" title="3.2.1. igraph_matrix_init — Initializes a matrix.">igraph_matrix_init</a></strong></span>(&amp;mat, 4, 4);
    <span class="strong"><strong>for</strong></span> (i = 0; i &lt; 4; i++) <span class="strong"><strong>for</strong></span> (j = 0; j &lt; 4; j++) {
        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#MATRIX" title="3.4.1. MATRIX — Accessing an element of a matrix.">MATRIX</a></strong></span>(mat, i, j) = m[i][j];
    }

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_weighted_adjacency" title="1.4. igraph_weighted_adjacency — Creates a graph from a weighted adjacency matrix.">igraph_weighted_adjacency</a></strong></span>(&amp;g, &amp;mat, IGRAPH_ADJ_DIRECTED, &amp;weights, IGRAPH_LOOPS_ONCE);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_edgelist" title="26.10. igraph_get_edgelist — The list of edges in a graph.">igraph_get_edgelist</a></strong></span>(&amp;g, &amp;el, 0);
    n = <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g);

    <span class="strong"><strong>for</strong></span> (i = 0, j = 0; i &lt; n; i++, j += 2) {
        <span class="strong"><strong>printf</strong></span>("%" IGRAPH_PRId " --&gt; %" IGRAPH_PRId ": %g\n",
               <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(el)[j], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(el)[j + 1], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(weights)[i]);
    }

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_matrix_destroy" title="3.2.4. igraph_matrix_destroy — Destroys a matrix object.">igraph_matrix_destroy</a></strong></span>(&amp;mat);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;el);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_sparse_adjacency"></a>1.5. <code class="function">igraph_sparse_adjacency</code> —  Creates a graph from a sparse adjacency matrix.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_sparse_adjacency(igraph_t *graph, igraph_sparsemat_t *adjmatrix,
        igraph_adjacency_t mode, igraph_loops_t loops);
</pre></div>
<p>
</p>
<p>




This has the same functionality as <a class="link" href="igraph-Generators.html#igraph_adjacency" title="1.3. igraph_adjacency — Creates a graph from an adjacency matrix."><code class="function">igraph_adjacency()</code></a>, but uses
a column-compressed adjacency matrix.

Time complexity: O(|E|),
where |E| is the number of edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_sparse_weighted_adjacency"></a>1.6. <code class="function">igraph_sparse_weighted_adjacency</code> —  Creates a graph from a weighted sparse adjacency matrix.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_sparse_weighted_adjacency(
    igraph_t *graph, igraph_sparsemat_t *adjmatrix, igraph_adjacency_t mode,
    igraph_vector_t *weights, igraph_loops_t loops
);
</pre></div>
<p>
</p>
<p>




This has the same functionality as <a class="link" href="igraph-Generators.html#igraph_weighted_adjacency" title="1.4. igraph_weighted_adjacency — Creates a graph from a weighted adjacency matrix."><code class="function">igraph_weighted_adjacency()</code></a>, but uses
a column-compressed adjacency matrix.

Time complexity: O(|E|),
where |E| is the number of edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_adjlist"></a>1.7. <code class="function">igraph_adjlist</code> —  Creates a graph from an adjacency list.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_adjlist(igraph_t *graph, const igraph_adjlist_t *adjlist,
                   igraph_neimode_t mode, igraph_bool_t duplicate);
</pre></div>
<p>
</p>
<p>



An adjacency list is a list of vectors, containing the neighbors
of all vertices. For operations that involve many changes to the
graph structure, it is recommended that you convert the graph into
an adjacency list via <a class="link" href="igraph-Data-structures.html#igraph_adjlist_init" title="10.1.1. igraph_adjlist_init — Constructs an adjacency list of vertices from a given graph."><code class="function">igraph_adjlist_init()</code></a>, perform the
modifications (these are cheap for an adjacency list) and then
recreate the igraph graph via this function.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>adjlist</code></em>:</span></p></td>
<td><p>
  The adjacency list.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  Whether or not to create a directed graph. <code class="constant">IGRAPH_ALL</code>
            means an undirected graph, <code class="constant">IGRAPH_OUT</code> means a
            directed graph from an out-adjacency list (i.e. each
            list contains the successors of the corresponding
            vertices), <code class="constant">IGRAPH_IN</code> means a directed graph from an
            in-adjacency list
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>duplicate</code></em>:</span></p></td>
<td><p>
  Logical, for undirected graphs this specified
       whether each edge is included twice, in the vectors of
       both adjacent vertices. If this is false (0), then it is
       assumed that every edge is included only once. This argument
       is ignored for directed graphs.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Data-structures.html#igraph_adjlist_init" title="10.1.1. igraph_adjlist_init — Constructs an adjacency list of vertices from a given graph."><code class="function">igraph_adjlist_init()</code></a> for the opposite operation.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|).

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_star"></a>1.8. <code class="function">igraph_star</code> —  Creates a <span class="emphasis"><em>star</em></span> graph, every vertex connects only to the center.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_star(igraph_t *graph, igraph_integer_t n, igraph_star_mode_t mode,
                igraph_integer_t center);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, this will
       be the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Integer constant, the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  Constant, gives the type of the star graph to
       create. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_STAR_OUT</code></span></p></td>
<td><p>

         directed star graph, edges point
         <span class="emphasis"><em>from</em></span> the center to the other vertices.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_STAR_IN</code></span></p></td>
<td><p>

         directed star graph, edges point
         <span class="emphasis"><em>to</em></span> the center from the other vertices.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_STAR_MUTUAL</code></span></p></td>
<td><p>

         directed star graph with mutual edges.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_STAR_UNDIRECTED</code></span></p></td>
<td><p>

         an undirected star graph is
         created.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>center</code></em>:</span></p></td>
<td><p>
  Id of the vertex which will be the center of the
         graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid number of vertices.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

          invalid center vertex.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|), the
number of vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_square_lattice" title="1.10. igraph_square_lattice — Arbitrary dimensional square lattices."><code class="function">igraph_square_lattice()</code></a>, <a class="link" href="igraph-Generators.html#igraph_ring" title="1.13. igraph_ring — Creates a cycle graph or a path graph."><code class="function">igraph_ring()</code></a>, <a class="link" href="igraph-Generators.html#igraph_kary_tree" title="1.14. igraph_kary_tree — Creates a k-ary tree in which almost all vertices have k children."><code class="function">igraph_kary_tree()</code></a>
for creating other regular structures.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.9.10.1"></a><p class="title"><b>Example 9.5.  File <code class="code">examples/simple/igraph_star.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {
    igraph_t graph;

    <span class="emphasis"><em>/* Create an undirected 6-star, with the 0th node as the centre. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center.">igraph_star</a></strong></span>(&amp;graph, 7, IGRAPH_STAR_UNDIRECTED, 0);

    <span class="emphasis"><em>/* Output the edge list of the graph. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;graph, stdout);

    <span class="emphasis"><em>/* Destroy the graph when we are done using it. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_wheel"></a>1.9. <code class="function">igraph_wheel</code> —  Creates a <span class="emphasis"><em>wheel</em></span> graph, a union of a star and a cycle graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_wheel(igraph_t *graph, igraph_integer_t n, igraph_wheel_mode_t mode,
                igraph_integer_t center);
</pre></div>
<p>
</p>
<p>




A wheel graph on <em class="parameter"><code>n</code></em> vertices can be thought of as a wheel with
<code class="literal">n - 1</code> spokes. The cycle graph part makes up the rim,
while the star graph part adds the spokes.

</p>
<p>
Note that the two and three-vertex wheel graphs are non-simple:
The two-vertex wheel graph contains a self-loop, while the three-vertex
wheel graph contains parallel edges (a 1-cycle and a 2-cycle, respectively).

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, this will
       be the result.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Integer constant, the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  Constant, gives the type of the star graph to
       create. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_WHEEL_OUT</code></span></p></td>
<td><p>

         directed wheel graph, edges point
         <span class="emphasis"><em>from</em></span> the center to the other vertices.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_WHEEL_IN</code></span></p></td>
<td><p>

         directed wheel graph, edges point
         <span class="emphasis"><em>to</em></span> the center from the other vertices.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_WHEEL_MUTUAL</code></span></p></td>
<td><p>

         directed wheel graph with mutual edges.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_WHEEL_UNDIRECTED</code></span></p></td>
<td><p>

         an undirected wheel graph is
         created.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>center</code></em>:</span></p></td>
<td><p>
  Id of the vertex which will be the center of the
         graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVVID</code></span></p></td>
<td><p>

          invalid number of vertices.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

          invalid center vertex.
        
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

          invalid mode argument.
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|), the
number of vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_square_lattice" title="1.10. igraph_square_lattice — Arbitrary dimensional square lattices."><code class="function">igraph_square_lattice()</code></a>, <a class="link" href="igraph-Generators.html#igraph_ring" title="1.13. igraph_ring — Creates a cycle graph or a path graph."><code class="function">igraph_ring()</code></a>, <a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center."><code class="function">igraph_star()</code></a>,
<a class="link" href="igraph-Generators.html#igraph_kary_tree" title="1.14. igraph_kary_tree — Creates a k-ary tree in which almost all vertices have k children."><code class="function">igraph_kary_tree()</code></a> for creating other regular structures.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_square_lattice"></a>1.10. <code class="function">igraph_square_lattice</code> —  Arbitrary dimensional square lattices.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_square_lattice(
    igraph_t *graph, const igraph_vector_int_t *dimvector, igraph_integer_t nei,
    igraph_bool_t directed, igraph_bool_t mutual, const igraph_vector_bool_t *periodic
);
</pre></div>
<p>
</p>
<p>




Creates d-dimensional square lattices of the given size. Optionally,
the lattice can be made periodic, and the neighbors within a given
graph distance can be connected.

</p>
<p>
In the zero-dimensional case, the singleton graph is returned.

</p>
<p>
The vertices of the resulting graph are ordered such that the
index of the vertex at position <code class="literal">(i_1, i_2, i_3, ..., i_d)</code>
in a lattice of size <code class="literal">(n_1, n_2, ..., n_d)</code> will be
<code class="literal">i_1 + n_1 * i_2 + n_1 * n_2 * i_3 + ...</code>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  An uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>dimvector</code></em>:</span></p></td>
<td><p>
  Vector giving the sizes of the lattice in each of
       its dimensions. The dimension of the lattice will be the
       same as the length of this vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nei</code></em>:</span></p></td>
<td><p>
  Integer value giving the distance (number of steps)
       within which two vertices will be connected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to create a directed graph.
       If the <code class="constant">mutual</code> and <code class="constant">circular</code> arguments are not set to true,
       edges will be directed from lower-index vertices towards
       higher-index ones.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mutual</code></em>:</span></p></td>
<td><p>
  Boolean, if the graph is directed this gives whether
       to create all connections as mutual.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>periodic</code></em>:</span></p></td>
<td><p>
  Boolean vector, defines whether the generated lattice is
       periodic along each dimension. The length of this vector must match
       the length of <em class="parameter"><code>dimvector</code></em>. This parameter may also be <code class="constant">NULL</code>, which
       implies that the lattice will not be periodic.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid (negative) dimension vector or mismatch
        between the length of the dimension vector and the periodicity vector.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: If <em class="parameter"><code>nei</code></em> is less than two then it is O(|V|+|E|) (as
far as I remember), |V| and |E| are the number of vertices
and edges in the generated graph. Otherwise it is O(|V|*d^k+|E|), d
is the average degree of the graph, k is the <em class="parameter"><code>nei</code></em> argument.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_triangular_lattice"></a>1.11. <code class="function">igraph_triangular_lattice</code> —  A triangular lattice with the given shape.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_triangular_lattice(
    igraph_t *graph, const igraph_vector_int_t *dims, igraph_bool_t directed,
    igraph_bool_t mutual);
</pre></div>
<p>
</p>
<p>



</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>This function is experimental and its signature is not considered final yet.
We reserve the right to change the function signature without changing the
major version of igraph. Use it at your own risk.</p>
</div>
<p>Creates a triangular lattice whose vertices have the form (i, j) for non-negative integers i and j
and (i, j) is generally connected with (i + 1, j), (i, j + 1), and (i - 1, j + 1).
The function constructs a planar dual of the graph constructed by <a class="link" href="igraph-Generators.html#igraph_hexagonal_lattice" title="1.12. igraph_hexagonal_lattice — A hexagonal lattice with the given shape."><code class="function">igraph_hexagonal_lattice()</code></a>.
In particular, there a one-to-one correspondence between the vertices in the constructed graph
and the cycles of length 6 in the graph constructed by <a class="link" href="igraph-Generators.html#igraph_hexagonal_lattice" title="1.12. igraph_hexagonal_lattice — A hexagonal lattice with the given shape."><code class="function">igraph_hexagonal_lattice()</code></a>
with the same <em class="parameter"><code>dims</code></em> parameter.

</p>
<p>
The vertices of the resulting graph are ordered lexicographically with the 2nd coordinate being
more significant, e.g., (i, j) &lt; (i + 1, j) and (i + 1, j) &lt; (i, j + 1)

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  An uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>dims</code></em>:</span></p></td>
<td><p>
  Integer vector, defines the shape of the lattice. (Below the "edge length"s are in terms of graph theoretical path lengths.)
       If <em class="parameter"><code>dims</code></em> is of length 1, the resulting lattice has a triangular shape
       where each side of the triangle contains <code class="literal">dims[0]</code> vertices.
       If <em class="parameter"><code>dims</code></em> is of length 2, the resulting lattice has a
       "quasi rectangular" shape with the sides containing <code class="literal">dims[0]</code> and
       <code class="literal">dims[1]</code> vertices, respectively.
       If <em class="parameter"><code>dims</code></em> is of length 3, the resulting lattice has a hexagonal shape
       where the sides of the hexagon contain <code class="literal">dims[0]</code>, <code class="literal">dims[1]</code> and
       <code class="literal">dims[2]</code> vertices.
       All coordinates must be non-negative.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to create a directed graph.
       If the <code class="constant">mutual</code> argument is not set to true,
       edges will be directed from lower-index vertices towards
       higher-index ones.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mutual</code></em>:</span></p></td>
<td><p>
  Boolean, if the graph is directed this gives whether
       to create all connections as mutual.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: The size of <em class="parameter"><code>dims</code></em> must be either 1, 2, or 3 with all the components
        at least 1.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_hexagonal_lattice" title="1.12. igraph_hexagonal_lattice — A hexagonal lattice with the given shape."><code class="function">igraph_hexagonal_lattice()</code></a> for creating a triangular lattice.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity:  O(|V|), where |V| is the number of vertices in the generated graph.

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_hexagonal_lattice"></a>1.12. <code class="function">igraph_hexagonal_lattice</code> —  A hexagonal lattice with the given shape.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.13.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_hexagonal_lattice(
    igraph_t *graph, const igraph_vector_int_t *dims, igraph_bool_t directed,
    igraph_bool_t mutual
);
</pre></div>
<p>
</p>
<p>



</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>This function is experimental and its signature is not considered final yet.
We reserve the right to change the function signature without changing the
major version of igraph. Use it at your own risk.</p>
</div>
<p>Creates a hexagonal lattice whose vertices have the form (i, j) for non-negative integers i and j
and (i, j) is generally connected with (i + 1, j), and if i is odd also with (i - 1, j + 1).
The function constructs a planar dual of the graph constructed by <a class="link" href="igraph-Generators.html#igraph_triangular_lattice" title="1.11. igraph_triangular_lattice — A triangular lattice with the given shape."><code class="function">igraph_triangular_lattice()</code></a>.
In particular, there a one-to-one correspondence between the cycles of length 6 in the constructed graph
and the vertices of the graph constructed by <a class="link" href="igraph-Generators.html#igraph_triangular_lattice" title="1.11. igraph_triangular_lattice — A triangular lattice with the given shape."><code class="function">igraph_triangular_lattice()</code></a> function
with the same <em class="parameter"><code>dims</code></em> parameter.

</p>
<p>
The vertices of the resulting graph are ordered lexicographically with the 2nd coordinate being
more significant, e.g., (i, j) &lt; (i + 1, j) and (i + 1, j) &lt; (i, j + 1)

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  An uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>dims</code></em>:</span></p></td>
<td><p>
  Integer vector, defines the shape of the lattice. (Below the "edge length"s are in terms of graph theoretical path lengths.)
       If <em class="parameter"><code>dims</code></em> is of length 1, the resulting lattice has a triangular shape
       where each side of the triangle contains <code class="literal">dims[0]</code> vertices.
       If <em class="parameter"><code>dims</code></em> is of length 2, the resulting lattice has a
       "quasi rectangular" shape with the sides containing <code class="literal">dims[0]</code> and
       <code class="literal">dims[1]</code> vertices, respectively.
       If <em class="parameter"><code>dims</code></em> is of length 3, the resulting lattice has a hexagonal shape
       where the sides of the hexagon contain <code class="literal">dims[0]</code>, <code class="literal">dims[1]</code> and
       <code class="literal">dims[2]</code> vertices.
       All coordinates must be non-negative.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to create a directed graph.
       If the <code class="constant">mutual</code> argument is not set to true,
       edges will be directed from lower-index vertices towards
       higher-index ones.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mutual</code></em>:</span></p></td>
<td><p>
  Boolean, if the graph is directed this gives whether
       to create all connections as mutual.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: The size of <em class="parameter"><code>dims</code></em> must be either 1, 2, or 3 with all the components
        at least 1.

  </p></td>
</tr></tbody>
</table></div>
<p></p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_triangular_lattice" title="1.11. igraph_triangular_lattice — A triangular lattice with the given shape."><code class="function">igraph_triangular_lattice()</code></a> for creating a triangular lattice.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity:  O(|V|), where |V| is the number of vertices in the generated graph.

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_ring"></a>1.13. <code class="function">igraph_ring</code> —  Creates a <span class="emphasis"><em>cycle</em></span> graph or a <span class="emphasis"><em>path</em></span> graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.14.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_ring(igraph_t *graph, igraph_integer_t n, igraph_bool_t directed,
                igraph_bool_t mutual, igraph_bool_t circular);
</pre></div>
<p>
</p>
<p>




A circular ring on <code class="constant">n</code> vertices is commonly known in graph
theory as the cycle graph, and often denoted by <code class="literal">C_n</code>.
Removing a single edge from the cycle graph <code class="literal">C_n</code> results
in the path graph <code class="literal">P_n</code>. This function can generate both.

</p>
<p>
When <em class="parameter"><code>n</code></em> is 1 or 2, the result may not be a simple graph:
the one-cycle contains a self-loop and the undirected or reciprocally
connected directed two-cycle contains parallel edges.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, whether to create a directed graph.
       All edges will be oriented in the same direction along
       the cycle or path.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mutual</code></em>:</span></p></td>
<td><p>
  Logical, whether to create mutual edges in directed
       graphs. It is ignored for undirected graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>circular</code></em>:</span></p></td>
<td><p>
  Logical, whether to create a closed ring (a cycle)
       or an open path.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid number of vertices.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|), the number of vertices in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_lattice" title="3.2. igraph_lattice — Arbitrary dimensional square lattices (deprecated)."><code class="function">igraph_lattice()</code></a> for generating more general lattices.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.14.11.1"></a><p class="title"><b>Example 9.6.  File <code class="code">examples/simple/igraph_ring.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {
    igraph_t graph;

    <span class="emphasis"><em>/* Create a directed path graph on 10 vertices. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.13. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;graph, 10, IGRAPH_DIRECTED, <span class="emphasis"><em>/* mutual= */</em></span> 0, <span class="emphasis"><em>/* circular= */</em></span> 0);

    <span class="emphasis"><em>/* Output the edge list of the graph. */</em></span>
    <span class="strong"><strong>printf</strong></span>("10-path graph:\n");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;graph, stdout);

    <span class="emphasis"><em>/* Destroy the graph. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="emphasis"><em>/* Create a 4-cycle graph. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_ring" title="1.13. igraph_ring — Creates a cycle graph or a path graph.">igraph_ring</a></strong></span>(&amp;graph, 4, IGRAPH_UNDIRECTED, <span class="emphasis"><em>/* mutual= */</em></span> 0, <span class="emphasis"><em>/* circular= */</em></span> 1);

    <span class="emphasis"><em>/* Output the edge list of the graph. */</em></span>
    <span class="strong"><strong>printf</strong></span>("\n4-cycle graph:\n");
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;graph, stdout);

    <span class="emphasis"><em>/* Destroy the graph. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_kary_tree"></a>1.14. <code class="function">igraph_kary_tree</code> —  Creates a k-ary tree in which almost all vertices have k children.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.15.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_kary_tree(igraph_t *graph, igraph_integer_t n, igraph_integer_t children,
                igraph_tree_mode_t type);
</pre></div>
<p>
</p>
<p>




To obtain a completely symmetric tree with <code class="constant">l</code> layers, where each
vertex has precisely <em class="parameter"><code>children</code></em> descendants, use
<code class="literal">n = (children^(l+1) - 1) / (children - 1)</code>.
Such trees are often called <code class="literal">k</code>-ary trees, where <code class="constant">k</code> refers
to the number of children.

</p>
<p>
Note that for <code class="literal">n=0</code>, the null graph is returned,
which is not considered to be a tree by <a class="link" href="igraph-Structural.html#igraph_is_tree" title="15.5. igraph_is_tree — Decides whether the graph is a tree."><code class="function">igraph_is_tree()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Integer, the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>children</code></em>:</span></p></td>
<td><p>
  Integer, the number of children of a vertex in the
       tree.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type</code></em>:</span></p></td>
<td>
<p>
  Constant, gives whether to create a directed tree, and
       if this is the case, also its orientation. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TREE_OUT</code></span></p></td>
<td><p>

         directed tree, the edges point
         from the parents to their children.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TREE_IN</code></span></p></td>
<td><p>

         directed tree, the edges point from
         the children to their parents.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TREE_UNDIRECTED</code></span></p></td>
<td><p>

         undirected tree.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid number of vertices.
        <code class="constant">IGRAPH_INVMODE</code>: invalid mode argument.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the
number of vertices plus the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_lattice" title="3.2. igraph_lattice — Arbitrary dimensional square lattices (deprecated)."><code class="function">igraph_lattice()</code></a>, <a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center."><code class="function">igraph_star()</code></a> for creating other regular
structures; <a class="link" href="igraph-Generators.html#igraph_from_prufer" title="1.25. igraph_from_prufer — Generates a tree from a Prüfer sequence."><code class="function">igraph_from_prufer()</code></a> for creating arbitrary trees;
<a class="link" href="igraph-Generators.html#igraph_tree_game" title="2.29. igraph_tree_game — Generates a random tree with the given number of nodes."><code class="function">igraph_tree_game()</code></a> for uniform random sampling of trees.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.15.11.1"></a><p class="title"><b>Example 9.7.  File <code class="code">examples/simple/igraph_kary_tree.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {
    igraph_t graph;
    igraph_bool_t res;

    <span class="emphasis"><em>/* Create a directed binary tree on 15 nodes,</em></span>
<span class="emphasis"><em>       with edges pointing towards the root. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_kary_tree" title="1.14. igraph_kary_tree — Creates a k-ary tree in which almost all vertices have k children.">igraph_kary_tree</a></strong></span>(&amp;graph, 15, 2, IGRAPH_TREE_IN);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_tree" title="15.5. igraph_is_tree — Decides whether the graph is a tree.">igraph_is_tree</a></strong></span>(&amp;graph, &amp;res, NULL, IGRAPH_IN);
    <span class="strong"><strong>printf</strong></span>("Is it an in-tree? %s\n", res ? "Yes" : "No");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_tree" title="15.5. igraph_is_tree — Decides whether the graph is a tree.">igraph_is_tree</a></strong></span>(&amp;graph, &amp;res, NULL, IGRAPH_OUT);
    <span class="strong"><strong>printf</strong></span>("Is it an out-tree? %s\n", res ? "Yes" : "No");

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_symmetric_tree"></a>1.15. <code class="function">igraph_symmetric_tree</code> —  Creates a symmetric tree with the specified number of branches at each level.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.16.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_symmetric_tree(igraph_t *graph, const igraph_vector_int_t *branches,
                igraph_tree_mode_t type);
</pre></div>
<p>
</p>
<p>




This function creates a tree in which all vertices at distance <code class="constant">d</code> from the
root have <em class="parameter"><code>branching_counts</code></em>[d] children.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>branches</code></em>:</span></p></td>
<td><p>
  Vector detailing the number of branches at each level.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type</code></em>:</span></p></td>
<td>
<p>
  Constant, gives whether to create a directed tree, and
       if this is the case, also its orientation. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TREE_OUT</code></span></p></td>
<td><p>

         directed tree, the edges point
         from the parents to their children.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TREE_IN</code></span></p></td>
<td><p>

         directed tree, the edges point from
         the children to their parents.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TREE_UNDIRECTED</code></span></p></td>
<td><p>

         undirected tree.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_INVMODE</code>: invalid mode argument.
        <code class="constant">IGRAPH_EINVAL</code>: invalid number of children.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the
number of vertices plus the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_kary_tree" title="1.14. igraph_kary_tree — Creates a k-ary tree in which almost all vertices have k children."><code class="function">igraph_kary_tree()</code></a>, <a class="link" href="igraph-Generators.html#igraph_regular_tree" title="1.16. igraph_regular_tree — Creates a regular tree."><code class="function">igraph_regular_tree()</code></a> and <a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center."><code class="function">igraph_star()</code></a>
for creating other regular tree structures;
<a class="link" href="igraph-Generators.html#igraph_from_prufer" title="1.25. igraph_from_prufer — Generates a tree from a Prüfer sequence."><code class="function">igraph_from_prufer()</code></a> for creating arbitrary trees;
<a class="link" href="igraph-Generators.html#igraph_tree_game" title="2.29. igraph_tree_game — Generates a random tree with the given number of nodes."><code class="function">igraph_tree_game()</code></a> for uniform random sampling of trees.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.16.10.1"></a><p class="title"><b>Example 9.8.  File <code class="code">examples/simple/igraph_symmetric_tree.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {

    igraph_t graph;
    igraph_bool_t res;
    igraph_vector_int_t v;
    <span class="strong"><strong>igraph_vector_int_init_int</strong></span>(&amp;v, 3, 3, 4, 5);

    <span class="emphasis"><em>/* Create a directed symmetric tree with 2 levels -</em></span>
<span class="emphasis"><em>       3 children in first and 4 children in second level,</em></span>
<span class="emphasis"><em>       5 children in third level</em></span>
<span class="emphasis"><em>       with edges pointing towards the root. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_symmetric_tree" title="1.15. igraph_symmetric_tree — Creates a symmetric tree with the specified number of branches at each level.">igraph_symmetric_tree</a></strong></span>(&amp;graph, &amp;v, IGRAPH_TREE_IN);

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_tree" title="15.5. igraph_is_tree — Decides whether the graph is a tree.">igraph_is_tree</a></strong></span>(&amp;graph, &amp;res, NULL, IGRAPH_IN);
    <span class="strong"><strong>printf</strong></span>("Is it an in-tree? %s\n", res ? "Yes" : "No");

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_tree" title="15.5. igraph_is_tree — Decides whether the graph is a tree.">igraph_is_tree</a></strong></span>(&amp;graph, &amp;res, NULL, IGRAPH_OUT);
    <span class="strong"><strong>printf</strong></span>("Is it an out-tree? %s\n", res ? "Yes" : "No");

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;v);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_regular_tree"></a>1.16. <code class="function">igraph_regular_tree</code> —  Creates a regular tree.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.17.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_regular_tree(igraph_t *graph, igraph_integer_t h, igraph_integer_t k, igraph_tree_mode_t type);
</pre></div>
<p>
</p>
<p>



All vertices of a regular tree, except its leaves, have the same total degree <em class="parameter"><code>k</code></em>.
This is different from a k-ary tree (<a class="link" href="igraph-Generators.html#igraph_kary_tree" title="1.14. igraph_kary_tree — Creates a k-ary tree in which almost all vertices have k children."><code class="function">igraph_kary_tree()</code></a>), where all
vertices have the same number of children, thus the degre of the root is
one less than the degree of the other internal vertices. Regular trees
are also referred to as Bethe lattices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>h</code></em>:</span></p></td>
<td><p>
  The height of the tree, i.e. the distance between the root and the leaves.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>k</code></em>:</span></p></td>
<td><p>
  The degree of the regular tree.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type</code></em>:</span></p></td>
<td>
<p>
  Constant, gives whether to create a directed tree, and
       if this is the case, also its orientation. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TREE_OUT</code></span></p></td>
<td><p>

         directed tree, the edges point
         from the parents to their children.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TREE_IN</code></span></p></td>
<td><p>

         directed tree, the edges point from
         the children to their parents.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_TREE_UNDIRECTED</code></span></p></td>
<td><p>

         undirected tree.
       
</p></td>
</tr>
</tbody>
</table></div>
</td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the
number of vertices plus the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_kary_tree" title="1.14. igraph_kary_tree — Creates a k-ary tree in which almost all vertices have k children."><code class="function">igraph_kary_tree()</code></a> to create k-ary tree where each vertex has the same
number of children, i.e. out-degree, instead of the same total degree.
<a class="link" href="igraph-Generators.html#igraph_symmetric_tree" title="1.15. igraph_symmetric_tree — Creates a symmetric tree with the specified number of branches at each level."><code class="function">igraph_symmetric_tree()</code></a> to use a different number of children at each level.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.17.10.1"></a><p class="title"><b>Example 9.9.  File <code class="code">examples/simple/igraph_regular_tree.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {
    igraph_t tree;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> eccentricity;
    igraph_bool_t is_tree;

    <span class="emphasis"><em>/* Create a Bethe lattice with 5 levels, i.e. height 4. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_regular_tree" title="1.16. igraph_regular_tree — Creates a regular tree.">igraph_regular_tree</a></strong></span>(&amp;tree, 4, 3, IGRAPH_TREE_UNDIRECTED);

    <span class="emphasis"><em>/* Bethe lattices are trees. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_tree" title="15.5. igraph_is_tree — Decides whether the graph is a tree.">igraph_is_tree</a></strong></span>(&amp;tree, &amp;is_tree, NULL, IGRAPH_ALL);
    <span class="strong"><strong>printf</strong></span>("Is it a tree? %s\n", is_tree ? "Yes." : "No.");

    <span class="emphasis"><em>/* Compute and print eccentricities. The root is the most central. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;eccentricity, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_eccentricity" title="3.26. igraph_eccentricity — Eccentricity of some vertices.">igraph_eccentricity</a></strong></span>(&amp;tree, &amp;eccentricity, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL);
    <span class="strong"><strong>printf</strong></span>("Vertex eccentricities:\n");
    <span class="strong"><strong>igraph_vector_print</strong></span>(&amp;eccentricity);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;eccentricity);

    <span class="emphasis"><em>/* Clean up. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;tree);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_full"></a>1.17. <code class="function">igraph_full</code> —  Creates a full graph (directed or undirected, with or without loops).</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.18.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_full(igraph_t *graph, igraph_integer_t n, igraph_bool_t directed,
                igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




</p>
<p>
In a full graph every possible edge is present, every vertex is
connected to every other vertex. A full graph in <code class="constant">igraph</code> should be
distinguished from the concept of complete graphs as used in graph theory.
If n is a positive integer, then the complete graph K_n on n vertices is
the undirected simple graph with the following property. For any distinct
pair (u,v) of vertices in K_n, uv (or equivalently vu) is an edge of K_n.
In <code class="constant">igraph</code>, a full graph on n vertices can be K_n, a directed version of
K_n, or K_n with at least one loop edge. In any case, if F is a full graph
on n vertices as generated by <code class="constant">igraph</code>, then K_n is a subgraph of the
undirected version of F.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Integer, the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, whether to create a directed graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Logical, whether to include self-edges (loops).
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid number of vertices.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|),
|V| is the number of vertices,
|E| the number of edges in the
graph. Of course this is the same as
O(|E|)=O(|V||V|)
here.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_square_lattice" title="1.10. igraph_square_lattice — Arbitrary dimensional square lattices."><code class="function">igraph_square_lattice()</code></a>, <a class="link" href="igraph-Generators.html#igraph_star" title="1.8. igraph_star — Creates a star graph, every vertex connects only to the center."><code class="function">igraph_star()</code></a>, <a class="link" href="igraph-Generators.html#igraph_kary_tree" title="1.14. igraph_kary_tree — Creates a k-ary tree in which almost all vertices have k children."><code class="function">igraph_kary_tree()</code></a>
for creating other regular structures.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.18.11.1"></a><p class="title"><b>Example 9.10.  File <code class="code">examples/simple/igraph_full.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {
    igraph_t graph;
    igraph_integer_t n_vertices = 10;

    <span class="emphasis"><em>/* Create an undirected complete graph. */</em></span>
    <span class="emphasis"><em>/* Use IGRAPH_UNDIRECTED and IGRAPH_NO_LOOPS instead of 1/TRUE and 0/FALSE for better readability. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.17. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;graph, n_vertices, IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS);
    <span class="strong"><strong>printf</strong></span>("The undirected complete graph on %" IGRAPH_PRId " vertices has %" IGRAPH_PRId " edges.\n",
          <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;graph), <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;graph));

    <span class="emphasis"><em>/* Remember to destroy the object at the end. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="emphasis"><em>/* Create a directed complete graph. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.17. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;graph, n_vertices, IGRAPH_DIRECTED, IGRAPH_NO_LOOPS);
    <span class="strong"><strong>printf</strong></span>("The directed complete graph on %" IGRAPH_PRId " vertices has %" IGRAPH_PRId " edges.\n",
          <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;graph), <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;graph));

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="emphasis"><em>/* Create an undirected complete graph with self-loops. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.17. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;graph, n_vertices, IGRAPH_UNDIRECTED, IGRAPH_LOOPS);
    <span class="strong"><strong>printf</strong></span>("The undirected complete graph on %" IGRAPH_PRId " vertices with self-loops has %" IGRAPH_PRId " edges.\n",
          <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;graph), <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;graph));

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="emphasis"><em>/* Create a directed graph with self-loops. */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_full" title="1.17. igraph_full — Creates a full graph (directed or undirected, with or without loops).">igraph_full</a></strong></span>(&amp;graph, n_vertices, IGRAPH_DIRECTED, IGRAPH_LOOPS);
    <span class="strong"><strong>printf</strong></span>("The directed complete graph on %" IGRAPH_PRId " vertices with self-loops has %" IGRAPH_PRId " edges.\n",
          <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;graph), <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;graph));

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;

}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_full_citation"></a>1.18. <code class="function">igraph_full_citation</code> —  Creates a full citation graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.19.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_full_citation(igraph_t *graph, igraph_integer_t n,
                         igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



This is a directed graph, where every <code class="literal">i-&gt;j</code> edge is
present if and only if <code class="literal">j&lt;i</code>.
If the <code class="constant">directed</code> argument is zero then an undirected graph is
created, and it is just a full graph.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the result
   is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Whether to created a directed graph. If zero an
   undirected graph is created.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|^2), as we have many edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_full_multipartite"></a>1.19. <code class="function">igraph_full_multipartite</code> —  Create a full multipartite graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.20.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_full_multipartite(igraph_t *graph,
                          igraph_vector_int_t *types,
                          const igraph_vector_int_t *n,
                          igraph_bool_t directed,
                          igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



A multipartite graph contains two or more types of vertices and connections
are only possible between two vertices of different types. This function
creates a complete multipartite graph.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an igraph_t object, the graph will be
  created here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Pointer to an integer vector. If not a null pointer,
  the type of each vertex will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Pointer to an integer vector, the number of vertices
  of each type.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to create a directed graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td><p>
  A constant that gives the type of connections for
  directed graphs. If <code class="constant">IGRAPH_OUT</code>, then edges point from vertices
  of low-index vertices to high-index vertices; if <code class="constant">IGRAPH_IN</code>, then the opposite direction is realized; if <code class="constant">IGRAPH_ALL</code>, then mutual edges will be created.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Bipartite.html#igraph_full_bipartite" title="2.2. igraph_full_bipartite — Create a full bipartite network."><code class="function">igraph_full_bipartite()</code></a> for full bipartite graphs.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_turan"></a>1.20. <code class="function">igraph_turan</code> —  Create a Turán graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.21.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_turan(igraph_t *graph,
                            igraph_vector_int_t *types,
                            igraph_integer_t n,
                            igraph_integer_t r);
</pre></div>
<p>
</p>
<p>



Turán graphs are complete multipartite graphs with the property
that the sizes of the partitions are as close to equal as possible.

This function generates undirected graphs. The null graph is
returned when the number of vertices is zero. A complete graph is
returned if the number of partitions is greater than the number of
vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an igraph_t object, the graph will be
  created here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Pointer to an integer vector. If not a null pointer,
  the type (partition index) of each vertex will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Integer, the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>r</code></em>:</span></p></td>
<td><p>
  Integer, the number of partitions of the graph, must be
  positive.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices and
edges.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_full_multipartite" title="1.19. igraph_full_multipartite — Create a full multipartite graph."><code class="function">igraph_full_multipartite()</code></a> for full multipartite graphs.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_realize_degree_sequence"></a>1.21. <code class="function">igraph_realize_degree_sequence</code> —  Generates a graph with the given degree sequence.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.22.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_realize_degree_sequence(
        igraph_t *graph,
        const igraph_vector_int_t *outdeg, const igraph_vector_int_t *indeg,
        igraph_edge_type_sw_t allowed_edge_types,
        igraph_realize_degseq_t method);
</pre></div>
<p>
</p>
<p>




This function generates an undirected graph that realizes a given degree sequence,
or a directed graph that realized a given pair of out- and in-degree sequences.

</p>
<p>
Simple undirected graphs are constructed using the Havel-Hakimi algorithm
(undirected case), or the analogous Kleitman-Wang algorithm (directed case).
These algorithms work by choosing an arbitrary vertex and connecting all its stubs
to other vertices of highest degree.  In the directed case, the "highest" (in, out) degree
pairs are determined based on lexicographic ordering. This step is repeated until all degrees
have been connected up.

</p>
<p>
Loopless multigraphs are generated using an analogous algorithm: an arbitrary vertex is chosen,
and it is connected with a single connection to a highest remaining degee vertex. If self-loops
are also allowed, the same algorithm is used, but if a non-zero vertex remains at the end of the
procedure, the graph is completed by adding self-loops to it. Thus, the result will contain at most
one vertex with self-loops.

</p>
<p>
The <code class="constant">method</code> parameter controls the order in which the vertices to be connected are chosen.

</p>
<p>
References:

</p>
<p>
V. Havel,
Poznámka o existenci konečných grafů (A remark on the existence of finite graphs),
Časopis pro pěstování matematiky 80, 477-480 (1955).
<a class="ulink" href="http://eudml.org/doc/19050" target="_top">http://eudml.org/doc/19050</a>

</p>
<p>
S. L. Hakimi,
On Realizability of a Set of Integers as Degrees of the Vertices of a Linear Graph,
Journal of the SIAM 10, 3 (1962).
<a class="ulink" href="https://www.jstor.org/stable/2098770" target="_top">https://www.jstor.org/stable/2098770</a>

</p>
<p>
D. J. Kleitman and D. L. Wang,
Algorithms for Constructing Graphs and Digraphs with Given Valences and Factors,
Discrete Mathematics 6, 1 (1973).
<a class="ulink" href="https://doi.org/10.1016/0012-365X%2873%2990037-X" target="_top">https://doi.org/10.1016/0012-365X%2873%2990037-X</a>

</p>
<p>
Sz. Horvát and C. D. Modes,
Connectedness matters: construction and exact random sampling of connected networks (2021).
<a class="ulink" href="https://doi.org/10.1088/2632-072X/abced5" target="_top">https://doi.org/10.1088/2632-072X/abced5</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>outdeg</code></em>:</span></p></td>
<td><p>
  The degree sequence of an undirected graph
       (if <em class="parameter"><code>indeg</code></em> is NULL), or the out-degree sequence of
       a directed graph (if <em class="parameter"><code>indeg</code></em> is given).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>indeg</code></em>:</span></p></td>
<td><p>
  The in-degree sequence of a directed graph.
       Pass <code class="constant">NULL</code> to generate an undirected graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>allowed_edge_types</code></em>:</span></p></td>
<td>
<p>
  The types of edges to allow in the graph. For directed graphs,
       only <code class="constant">IGRAPH_SIMPLE_SW</code> is implemented at this moment. For undirected
       graphs, the following values are valid:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_SIMPLE_SW</code></span></p></td>
<td><p>

         simple graphs (i.e. no self-loops or multi-edges allowed).
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LOOPS_SW</code></span></p></td>
<td><p>

         single self-loops are allowed, but not multi-edges; currently not implemented.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_MULTI_SW</code></span></p></td>
<td><p>

         multi-edges are allowed, but not self-loops.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_LOOPS_SW | IGRAPH_MULTI_SW</code></span></p></td>
<td><p>

         both self-loops and multi-edges are allowed.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>method</code></em>:</span></p></td>
<td>
<p>
  The method to generate the graph. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_REALIZE_DEGSEQ_SMALLEST</code></span></p></td>
<td><p>

         The vertex with smallest remaining degree is selected first. The result is usually
         a graph with high negative degree assortativity. In the undirected case, this method
         is guaranteed to generate a connected graph, regardless of whether multi-edges are allowed,
         provided that a connected realization exists (see Horvát and Modes, 2021, as well as
         <a class="ulink" href="http://szhorvat.net/pelican/hh-connected-graphs.html" target="_top">http://szhorvat.net/pelican/hh-connected-graphs.html</a>).
         In the directed case it tends to generate weakly connected graphs, but this is not
         guaranteed.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_REALIZE_DEGSEQ_LARGEST</code></span></p></td>
<td><p>

         The vertex with the largest remaining degree is selected first. The result
         is usually a graph with high positive degree assortativity, and is often disconnected.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_REALIZE_DEGSEQ_INDEX</code></span></p></td>
<td><p>

         The vertices are selected in order of their index (i.e. their position in the degree vector).
         Note that sorting the degree vector and using the <code class="constant">INDEX</code> method is not equivalent
         to the <code class="constant">SMALLEST</code> method above, as <code class="constant">SMALLEST</code> uses the smallest <span class="emphasis"><em>remaining</em></span>
         degree for selecting vertices, not the smallest <span class="emphasis"><em>initial</em></span> degree.
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
         </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_UNIMPLEMENTED</code></span></p></td>
<td><p>

          The requested method is not implemented.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

          There is not enough memory to perform the operation.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

          Invalid method parameter, or invalid in- and/or out-degree vectors.
          The degree vectors should be non-negative, the length
          and sum of <em class="parameter"><code>outdeg</code></em> and <em class="parameter"><code>indeg</code></em> should match for directed graphs.
         
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_is_graphical" title="9.1. igraph_is_graphical — Is there a graph with the given degree sequence?"><code class="function">igraph_is_graphical()</code></a> to test graphicality without generating a graph;
     <a class="link" href="igraph-Generators.html#igraph_degree_sequence_game" title="2.8. igraph_degree_sequence_game — Generates a random graph with a given degree sequence."><code class="function">igraph_degree_sequence_game()</code></a> to generate random graphs with a given degree sequence;
     <a class="link" href="igraph-Generators.html#igraph_k_regular_game" title="2.9. igraph_k_regular_game — Generates a random graph where each vertex has the same degree."><code class="function">igraph_k_regular_game()</code></a> to generate random regular graphs;
     <a class="link" href="igraph-Generators.html#igraph_rewire" title="2.13. igraph_rewire — Randomly rewires a graph while preserving its degree sequence."><code class="function">igraph_rewire()</code></a> to randomly rewire the edges of a graph while preserving its degree sequence.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.22.18.1"></a><p class="title"><b>Example 9.11.  File <code class="code">examples/simple/igraph_realize_degree_sequence.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>(void){
    igraph_t g1, g2, g3;
    igraph_integer_t nodes = 500, A = 0, power = 1, m = 1;
    igraph_real_t assortativity;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Seeds a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);
    <span class="strong"><strong>printf</strong></span>("Demonstration of difference in assortativities of graphs with the same degree sequence but different linkages:\n\nInitial graph based on the Barabasi-Albert model with %" IGRAPH_PRId " nodes.\n", nodes);

    <span class="emphasis"><em>/* Graph 1 generated by a randomized graph generator */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model.">igraph_barabasi_game</a></strong></span>(&amp;g1, nodes, power, m, NULL, <span class="emphasis"><em>/* outpref */</em></span> 0, A, IGRAPH_UNDIRECTED, IGRAPH_BARABASI_PSUMTREE, <span class="emphasis"><em>/* start from */</em></span> NULL);

    igraph_vector_int_t degree;
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;degree, nodes);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g1, &amp;degree, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_ALL, IGRAPH_NO_LOOPS);

    <span class="emphasis"><em>/* Measuring assortativity of the first graph */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="20.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree.">igraph_assortativity_degree</a></strong></span>(&amp;g1, &amp;assortativity, IGRAPH_UNDIRECTED);
    <span class="strong"><strong>printf</strong></span>("Assortativity of initial graph = %g\n\n", assortativity);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g1);

    <span class="emphasis"><em>/* Graph 2 (with the same degree sequence) generated by selecting vertices with the smallest degree first */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_realize_degree_sequence" title="1.21. igraph_realize_degree_sequence — Generates a graph with the given degree sequence.">igraph_realize_degree_sequence</a></strong></span>(&amp;g2, &amp;degree, NULL, IGRAPH_SIMPLE_SW, IGRAPH_REALIZE_DEGSEQ_SMALLEST);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="20.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree.">igraph_assortativity_degree</a></strong></span>(&amp;g2, &amp;assortativity, IGRAPH_UNDIRECTED);
    <span class="strong"><strong>printf</strong></span>("Assortativity after choosing vertices with the smallest degrees first = %g\n\n", assortativity);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g2);

    <span class="emphasis"><em>/* Graph 3 (with the same degree sequence) generated by selecting vertices with the largest degree first */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_realize_degree_sequence" title="1.21. igraph_realize_degree_sequence — Generates a graph with the given degree sequence.">igraph_realize_degree_sequence</a></strong></span>(&amp;g3, &amp;degree, NULL, IGRAPH_SIMPLE_SW, IGRAPH_REALIZE_DEGSEQ_LARGEST);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_assortativity_degree" title="20.3. igraph_assortativity_degree — Assortativity of a graph based on vertex degree.">igraph_assortativity_degree</a></strong></span>(&amp;g3, &amp;assortativity, IGRAPH_UNDIRECTED);
    <span class="strong"><strong>printf</strong></span>("Assortativity after choosing vertices with the largest degrees first = %g\n", assortativity);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g3);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;degree);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_famous"></a>1.22. <code class="function">igraph_famous</code> —  Create a famous graph by simply providing its name.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.23.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_famous(igraph_t *graph, const char *name);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The name of the graph can be simply supplied as a string.
Note that this function creates graphs which don't take any parameters,
there are separate functions for graphs with parameters, e.g. <a class="link" href="igraph-Generators.html#igraph_full" title="1.17. igraph_full — Creates a full graph (directed or undirected, with or without loops)."><code class="function">igraph_full()</code></a> for creating a full graph.

</p>
<p>
The following graphs are supported:
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">Bull</code></span></p></td>
<td><p>

          The bull graph, 5 vertices, 5 edges, resembles the
          head of a bull if drawn properly.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Chvatal</code></span></p></td>
<td><p>

          This is the smallest triangle-free graph that is
          both 4-chromatic and 4-regular. According to the Grunbaum
          conjecture there exists an m-regular, m-chromatic graph
          with n vertices for every m&gt;1 and n&gt;2. The Chvatal graph
          is an example for m=4 and n=12. It has 24 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Coxeter</code></span></p></td>
<td><p>

          A non-Hamiltonian cubic symmetric graph with 28
          vertices and 42 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Cubical</code></span></p></td>
<td><p>

          The Platonic graph of the cube. A convex regular
          polyhedron with 8 vertices and 12 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Diamond</code></span></p></td>
<td><p>

          A graph with 4 vertices and 5 edges, resembles a
          schematic diamond if drawn properly.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Dodecahedral, Dodecahedron</code></span></p></td>
<td><p>

          Another Platonic solid
          with 20 vertices and 30 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Folkman</code></span></p></td>
<td><p>

          The semisymmetric graph with minimum number of
          vertices, 20 and 40 edges. A semisymmetric graph is
          regular, edge transitive and not vertex transitive.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Franklin</code></span></p></td>
<td><p>

          This is a graph whose embedding to the Klein
          bottle can be colored with six colors, it is a
          counterexample to the necessity of the Heawood
          conjecture on a Klein bottle. It has 12 vertices and 18
          edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Frucht</code></span></p></td>
<td><p>

          The Frucht Graph is the smallest cubical graph
          whose automorphism group consists only of the identity
          element. It has 12 vertices and 18 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Grotzsch</code></span></p></td>
<td><p>

          The Grötzsch graph is a triangle-free graph with
          11 vertices, 20 edges, and chromatic number 4. It is named after
          German mathematician Herbert Grötzsch, and its existence
          demonstrates that the assumption of planarity is necessary in
          Grötzsch's theorem that every triangle-free planar
          graph is 3-colorable.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Heawood</code></span></p></td>
<td><p>

          The Heawood graph is an undirected graph with 14
          vertices and 21 edges. The graph is cubic, and all cycles in the
          graph have six or more edges. Every smaller cubic graph has shorter
          cycles, so this graph is the 6-cage, the smallest cubic graph of
          girth 6.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Herschel</code></span></p></td>
<td><p>

          The Herschel graph is the smallest
          nonhamiltonian polyhedral graph. It is the
          unique such graph on 11 nodes, and has 18 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">House</code></span></p></td>
<td><p>

          The house graph is a 5-vertex, 6-edge graph, the
          schematic draw of a house if drawn properly, basically a
          triangle on top of a square.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">HouseX</code></span></p></td>
<td><p>

          The same as the house graph with an X in the square. 5
          vertices and 8 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Icosahedral, Icosahedron</code></span></p></td>
<td><p>

          A Platonic solid with 12
          vertices and 30 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Krackhardt_Kite</code></span></p></td>
<td><p>

          A social network with 10 vertices and 18 edges.
          Krackhardt, D. Assessing the Political Landscape:
          Structure, Cognition, and Power in Organizations.
          Admin. Sci. Quart. 35, 342-369, 1990.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Levi</code></span></p></td>
<td><p>

          The graph is a 4-arc transitive cubic graph, it has
          30 vertices and 45 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">McGee</code></span></p></td>
<td><p>

          The McGee graph is the unique 3-regular 7-cage
          graph, it has 24 vertices and 36 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Meredith</code></span></p></td>
<td><p>

          The Meredith graph is a quartic graph on 70
          nodes and 140 edges that is a counterexample to the conjecture that
          every 4-regular 4-connected graph is Hamiltonian.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Noperfectmatching</code></span></p></td>
<td><p>

          A connected graph with 16 vertices and
          27 edges containing no perfect matching. A matching in a graph
          is a set of pairwise non-incident edges; that is, no two edges
          share a common vertex. A perfect matching is a matching
          which covers all vertices of the graph.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Nonline</code></span></p></td>
<td><p>

          A graph whose connected components are the 9
          graphs whose presence as a vertex-induced subgraph in a
          graph makes a nonline graph. It has 50 vertices and 72 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Octahedral, Octahedron</code></span></p></td>
<td><p>

          Platonic solid with 6
          vertices and 12 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Petersen</code></span></p></td>
<td><p>

          A 3-regular graph with 10 vertices and 15 edges. It is
          the smallest hypohamiltonian graph, i.e. it is
          non-hamiltonian but removing any single vertex from it makes it
          Hamiltonian.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Robertson</code></span></p></td>
<td><p>

          The unique (4,5)-cage graph, i.e. a 4-regular
          graph of girth 5. It has 19 vertices and 38 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Smallestcyclicgroup</code></span></p></td>
<td><p>

          A smallest nontrivial graph
          whose automorphism group is cyclic. It has 9 vertices and
          15 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Tetrahedral, Tetrahedron</code></span></p></td>
<td><p>

          Platonic solid with 4
          vertices and 6 edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Thomassen</code></span></p></td>
<td><p>

          The smallest hypotraceable graph,
          on 34 vertices and 52 edges. A hypotracable graph does
          not contain a Hamiltonian path but after removing any
          single vertex from it the remainder always contains a
          Hamiltonian path. A graph containing a Hamiltonian path
          is called traceable.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Tutte</code></span></p></td>
<td><p>

          Tait's Hamiltonian graph conjecture states that
          every 3-connected 3-regular planar graph is Hamiltonian.
          This graph is a counterexample. It has 46 vertices and 69
          edges.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Uniquely3colorable</code></span></p></td>
<td><p>

          Returns a 12-vertex, triangle-free
          graph with chromatic number 3 that is uniquely
          3-colorable.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Walther</code></span></p></td>
<td><p>

          An identity graph with 25 vertices and 31
          edges. An identity graph has a single graph automorphism,
          the trivial one.
  
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">Zachary</code></span></p></td>
<td><p>

          Social network of friendships between 34 members of a
          karate club at a US university in the 1970s. See
          W. W. Zachary, An information flow model for conflict and
          fission in small groups, Journal of Anthropological
          Research 33, 452-473 (1977).

</p></td>
</tr>
</tbody>
</table></div>
<p>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>name</code></em>:</span></p></td>
<td><p>
  Character constant, the name of the graph to be
    created, it is case insensitive.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code, <code class="constant">IGRAPH_EINVAL</code> if there is no graph with the
    given name.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Other functions for creating graph structures:
<a class="link" href="igraph-Generators.html#igraph_ring" title="1.13. igraph_ring — Creates a cycle graph or a path graph."><code class="function">igraph_ring()</code></a>, <a class="link" href="igraph-Generators.html#igraph_kary_tree" title="1.14. igraph_kary_tree — Creates a k-ary tree in which almost all vertices have k children."><code class="function">igraph_kary_tree()</code></a>, <a class="link" href="igraph-Generators.html#igraph_square_lattice" title="1.10. igraph_square_lattice — Arbitrary dimensional square lattices."><code class="function">igraph_square_lattice()</code></a>,
<a class="link" href="igraph-Generators.html#igraph_full" title="1.17. igraph_full — Creates a full graph (directed or undirected, with or without loops)."><code class="function">igraph_full()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_lcf"></a>1.23. <code class="function">igraph_lcf</code> —  Creates a graph from LCF notation.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.24.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_lcf(igraph_t *graph, igraph_integer_t n, ...);
</pre></div>
<p>
</p>
<p>



</p>
<p>
LCF is short for Lederberg-Coxeter-Frucht, it is a concise notation for
3-regular Hamiltonian graphs. It consists of three parameters: the
number of vertices in the graph, a list of shifts giving additional
edges to a cycle backbone, and another integer giving how many times
the shifts should be performed. See
<a class="ulink" href="http://mathworld.wolfram.com/LCFNotation.html" target="_top">http://mathworld.wolfram.com/LCFNotation.html</a> for details.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Integer, the number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>...</code></em>:</span></p></td>
<td><p>
  The shifts and the number of repeats for the shifts,
       plus an additional 0 to mark the end of the arguments.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  See <a class="link" href="igraph-Generators.html#igraph_lcf_vector" title="1.24. igraph_lcf_vector — Creates a graph from LCF notation."><code class="function">igraph_lcf_vector()</code></a> for a similar function using a
vector_t instead of the variable length argument list.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.24.11.1"></a><p class="title"><b>Example 9.12.  File <code class="code">examples/simple/igraph_lcf.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {

    igraph_t g, g2;
    igraph_bool_t iso;

    <span class="emphasis"><em>// Franklin graph</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_lcf" title="1.23. igraph_lcf — Creates a graph from LCF notation.">igraph_lcf</a></strong></span>(&amp;g, 12, 5, -5, 6, 0);
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_famous" title="1.22. igraph_famous — Create a famous graph by simply providing its name.">igraph_famous</a></strong></span>(&amp;g2, "franklin");

    <span class="strong"><strong><a class="link" href="igraph-Isomorphism.html#igraph_isomorphic_vf2" title="3.1. igraph_isomorphic_vf2 — Isomorphism via VF2.">igraph_isomorphic_vf2</a></strong></span>(&amp;g, &amp;g2,
                          <span class="emphasis"><em>/*vertex.color1=*/</em></span> 0, <span class="emphasis"><em>/*vertex.color2=*/</em></span> 0,
                          <span class="emphasis"><em>/*edge.color1=*/</em></span> 0, <span class="emphasis"><em>/*edge.color2=*/</em></span> 0,
                          &amp;iso, 0, 0, 0, 0, 0);
    <span class="strong"><strong>if</strong></span> (!iso) {
        <span class="strong"><strong>printf</strong></span>("Failure: Franklin\n");
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g2);

    <span class="emphasis"><em>// [3, -2]^4, n=8</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_lcf" title="1.23. igraph_lcf — Creates a graph from LCF notation.">igraph_lcf</a></strong></span>(&amp;g, 8, 3, -2, 4, 0);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g) != 16) {
        <span class="strong"><strong>printf</strong></span>("Failure: [3, -2]^4, n=8\n");
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>// [2, -2]^2, n=2</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_lcf" title="1.23. igraph_lcf — Creates a graph from LCF notation.">igraph_lcf</a></strong></span>(&amp;g, 2, 2, -2, 2, 0);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g) != 1) {
        <span class="strong"><strong>printf</strong></span>("Failure: [2, -2]^2, n=2\n");
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>// [2]^2, n=2</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_lcf" title="1.23. igraph_lcf — Creates a graph from LCF notation.">igraph_lcf</a></strong></span>(&amp;g, 2, 2, 2, 0);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g) != 1) {
        <span class="strong"><strong>printf</strong></span>("Failure: [2]^2, n=2\n");
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>// Regression test for bug #996</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_lcf" title="1.23. igraph_lcf — Creates a graph from LCF notation.">igraph_lcf</a></strong></span>(&amp;g, 0, 0);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) != 0 || <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g) != 0) {
        <span class="strong"><strong>printf</strong></span>("Failure: regression test for #996\n");
        <span class="strong"><strong>return</strong></span> 1;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_lcf_vector"></a>1.24. <code class="function">igraph_lcf_vector</code> —  Creates a graph from LCF notation.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.25.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_lcf_vector(igraph_t *graph, igraph_integer_t n,
                      const igraph_vector_int_t *shifts,
                      igraph_integer_t repeats);
</pre></div>
<p>
</p>
<p>



This function is essentially the same as <a class="link" href="igraph-Generators.html#igraph_lcf" title="1.23. igraph_lcf — Creates a graph from LCF notation."><code class="function">igraph_lcf()</code></a>, only
the way for giving the arguments is different. See <a class="link" href="igraph-Generators.html#igraph_lcf" title="1.23. igraph_lcf — Creates a graph from LCF notation."><code class="function">igraph_lcf()</code></a> for details.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Integer constant giving the number of vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>shifts</code></em>:</span></p></td>
<td><p>
  A vector giving the shifts.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>repeats</code></em>:</span></p></td>
<td><p>
  An integer constant giving the number of repeats
       for the shifts.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_lcf" title="1.23. igraph_lcf — Creates a graph from LCF notation."><code class="function">igraph_lcf()</code></a>, <a class="link" href="igraph-Generators.html#igraph_extended_chordal_ring" title="1.31. igraph_extended_chordal_ring — Create an extended chordal ring."><code class="function">igraph_extended_chordal_ring()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), linear in the number of vertices plus
the number of edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_from_prufer"></a>1.25. <code class="function">igraph_from_prufer</code> —  Generates a tree from a Prüfer sequence.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.26.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_from_prufer(igraph_t *graph, const igraph_vector_int_t *prufer);
</pre></div>
<p>
</p>
<p>




A Prüfer sequence is a unique sequence of integers associated
with a labelled tree. A tree on n vertices can be represented by a
sequence of n-2 integers, each between 0 and n-1 (inclusive).

The algorithm used by this function is based on
Paulius Micikevičius, Saverio Caminiti, Narsingh Deo:
Linear-time Algorithms for Encoding Trees as Sequences of Node Labels

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>prufer</code></em>:</span></p></td>
<td><p>
  The Prüfer sequence
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
         </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

            there is not enough memory to perform the operation.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

            invalid Prüfer sequence given
         
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Structural.html#igraph_to_prufer" title="15.7. igraph_to_prufer — Converts a tree to its Prüfer sequence."><code class="function">igraph_to_prufer()</code></a>, <a class="link" href="igraph-Generators.html#igraph_kary_tree" title="1.14. igraph_kary_tree — Creates a k-ary tree in which almost all vertices have k children."><code class="function">igraph_kary_tree()</code></a>, <a class="link" href="igraph-Generators.html#igraph_tree_game" title="2.29. igraph_tree_game — Generates a random tree with the given number of nodes."><code class="function">igraph_tree_game()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_atlas"></a>1.26. <code class="function">igraph_atlas</code> —  Create a small graph from the <span class="quote">“<span class="quote">Graph Atlas</span>”</span>.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.27.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_atlas(igraph_t *graph, igraph_integer_t number);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The number of the graph is given as a parameter.
The graphs are listed: </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>
in increasing order of number of nodes;
     
</p></li>
<li class="listitem"><p>
for a fixed number of nodes, in increasing order of the
          number of edges;
     
</p></li>
<li class="listitem"><p>
for fixed numbers of nodes and edges, in increasing
          order of the degree sequence, for example 111223 &lt; 112222;
     
</p></li>
<li class="listitem"><p>
for fixed degree sequence, in increasing number of
          automorphisms.
     
</p></li>
</ol></div>
<p>

</p>
<p>
The data was converted from the NetworkX software package,
see <a class="ulink" href="http://networkx.github.io" target="_top">http://networkx.github.io</a> .

</p>
<p>
See <span class="emphasis"><em> An Atlas of Graphs </em></span> by Ronald C. Read and Robin J. Wilson,
Oxford University Press, 1998.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>number</code></em>:</span></p></td>
<td><p>
  The number of the graph to generate.</p></td>
</tr>
</tbody>
</table></div>
<p>


Added in version 0.2.</p>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number of
edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.4.27.10.1"></a><p class="title"><b>Example 9.13.  File <code class="code">examples/simple/igraph_atlas.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {

    igraph_t g;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_atlas" title="1.26. igraph_atlas — Create a small graph from the “Graph Atlas”.">igraph_atlas</a></strong></span>(&amp;g, 45);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;g, stdout);
    <span class="strong"><strong>printf</strong></span>("\n");
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_atlas" title="1.26. igraph_atlas — Create a small graph from the “Graph Atlas”.">igraph_atlas</a></strong></span>(&amp;g, 0);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;g, stdout);
    <span class="strong"><strong>printf</strong></span>("\n");
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_atlas" title="1.26. igraph_atlas — Create a small graph from the “Graph Atlas”.">igraph_atlas</a></strong></span>(&amp;g, 1252);
    <span class="strong"><strong><a class="link" href="igraph-Foreign.html#igraph_write_graph_edgelist" title="1.2. igraph_write_graph_edgelist — Writes the edge list of a graph to a file.">igraph_write_graph_edgelist</a></strong></span>(&amp;g, stdout);
    <span class="strong"><strong>printf</strong></span>("\n");
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_de_bruijn"></a>1.27. <code class="function">igraph_de_bruijn</code> —  Generate a de Bruijn graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.28.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_de_bruijn(igraph_t *graph, igraph_integer_t m, igraph_integer_t n);
</pre></div>
<p>
</p>
<p>



A de Bruijn graph represents relationships between strings. An alphabet
of <code class="constant">m</code> letters are used and strings of length <code class="constant">n</code> are considered.
A vertex corresponds to every possible string and there is a directed edge
from vertex <code class="constant">v</code> to vertex <code class="constant">w</code> if the string of <code class="constant">v</code> can be transformed into
the string of <code class="constant">w</code> by removing its first letter and appending a letter to it.

</p>
<p>
Please note that the graph will have <code class="constant">m</code> to the power <code class="constant">n</code> vertices and
even more edges, so probably you don't want to supply too big numbers for
<code class="constant">m</code> and <code class="constant">n</code>.

</p>
<p>
De Bruijn graphs have some interesting properties, please see another source,
e.g. Wikipedia for details.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the result will be
       stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Integer, the number of letters in the alphabet.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Integer, the length of the strings.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_kautz" title="1.28. igraph_kautz — Generate a Kautz graph."><code class="function">igraph_kautz()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number of edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_kautz"></a>1.28. <code class="function">igraph_kautz</code> —  Generate a Kautz graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.29.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_kautz(igraph_t *graph, igraph_integer_t m, igraph_integer_t n);
</pre></div>
<p>
</p>
<p>



A Kautz graph is a labeled graph, vertices are labeled by strings
of length <code class="constant">n</code>+1 above an alphabet with <code class="constant">m</code>+1 letters, with
the restriction that every two consecutive letters in the string
must be different. There is a directed edge from a vertex <code class="constant">v</code> to
another vertex <code class="constant">w</code> if it is possible to transform the string of
<code class="constant">v</code> into the string of <code class="constant">w</code> by removing the first letter and
appending a letter to it. For string length 1 the new letter
cannot equal the old letter, so there are no loops.

</p>
<p>
Kautz graphs have some interesting properties, see e.g. Wikipedia
for details.

</p>
<p>
Vincent Matossian wrote the first version of this function in R,
thanks.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the result
will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Integer, <code class="constant">m</code>+1 is the number of letters in the alphabet.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Integer, <code class="constant">n</code>+1 is the length of the strings.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_de_bruijn" title="1.27. igraph_de_bruijn — Generate a de Bruijn graph."><code class="function">igraph_de_bruijn()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|* [(m+1)/m]^n +|E|), in practice it is more
like O(|V|+|E|). |V| is the number of vertices, |E| is the number
of edges and <code class="constant">m</code> and <code class="constant">n</code> are the corresponding arguments.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_circulant"></a>1.29. <code class="function">igraph_circulant</code> —  Creates a circulant graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.30.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_circulant(igraph_t *graph, igraph_integer_t n, const igraph_vector_int_t *shifts, igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



A circulant graph <code class="literal">G(n, shifts)</code> consists of <em class="parameter"><code>n</code></em> vertices <code class="literal">v_0</code>, ...,
<code class="literal">v_(n-1)</code> such that for each <code class="constant">s_i</code> in the list of offsets <em class="parameter"><code>shifts</code></em>, <code class="constant">v_j</code> is
connected to <code class="literal">v_((j + s_i) mod n)</code> for all j.

</p>
<p>
The function can generate either directed or undirected graphs. It does not generate
multi-edges or self-loops.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the result will
  be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Integer, the number of vertices in the circulant graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>shifts</code></em>:</span></p></td>
<td><p>
  Integer vector, a list of the offsets within the circulant graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to create a directed graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_ring" title="1.13. igraph_ring — Creates a cycle graph or a path graph."><code class="function">igraph_ring()</code></a>, <a class="link" href="igraph-Generators.html#igraph_generalized_petersen" title="1.30. igraph_generalized_petersen — Creates a Generalized Petersen graph."><code class="function">igraph_generalized_petersen()</code></a>, <a class="link" href="igraph-Generators.html#igraph_extended_chordal_ring" title="1.31. igraph_extended_chordal_ring — Create an extended chordal ring."><code class="function">igraph_extended_chordal_ring()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V||shifts|), the number of vertices in the graph times the number
of shifts.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_generalized_petersen"></a>1.30. <code class="function">igraph_generalized_petersen</code> —  Creates a Generalized Petersen graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.31.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_generalized_petersen(igraph_t *graph, igraph_integer_t n, igraph_integer_t k);
</pre></div>
<p>
</p>
<p>



The generalized Petersen graph <code class="literal">G(n, k)</code> consists of <em class="parameter"><code>n</code></em> vertices
<code class="constant">v_0</code>, ..., <code class="constant">v_n</code> forming an "outer" cycle graph, and <em class="parameter"><code>n</code></em> additional vertices
<code class="constant">u_0</code>, ..., <code class="constant">u_n</code> forming an "inner" circulant graph where <code class="literal">u_i</code>
is connected to <code class="literal">u_(i + k mod n)</code>. Additionally, all <code class="constant">v_i</code> are
connected to <code class="constant">u_i</code>.

</p>
<p>
<code class="literal">G(n, k)</code> has <code class="constant">2n</code> vertices and <code class="constant">3n</code> edges. The Petersen graph
itself is <code class="literal">G(5, 2)</code>.

</p>
<p>
Reference:

</p>
<p>
M. E. Watkins,
A Theorem on Tait Colorings with an Application to the Generalized Petersen Graphs,
Journal of Combinatorial Theory 6, 152-164 (1969).
<a class="ulink" href="https://doi.org/10.1016%2FS0021-9800%2869%2980116-X" target="_top">https://doi.org/10.1016%2FS0021-9800%2869%2980116-X</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the result will
be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Integer, <code class="constant">n</code> is the number of vertices in the inner and outer
cycle/circulant graphs. It must be at least 3.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>k</code></em>:</span></p></td>
<td><p>
  Integer, <code class="constant">k</code> is the shift of the circulant graph. It must be
positive and less than <code class="literal">n/2</code>.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_famous" title="1.22. igraph_famous — Create a famous graph by simply providing its name."><code class="function">igraph_famous()</code></a> for the original Petersen graph.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|), the number of vertices in the graph.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_extended_chordal_ring"></a>1.31. <code class="function">igraph_extended_chordal_ring</code> —  Create an extended chordal ring.</h3></div></div></div>
<a class="indexterm" name="id-1.10.4.32.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_extended_chordal_ring(
    igraph_t *graph, igraph_integer_t nodes, const igraph_matrix_int_t *W,
    igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



An extended chordal ring is a cycle graph with additional chords
connecting its vertices.

Each row <code class="constant">L</code> of the matrix <em class="parameter"><code>W</code></em> specifies a set of chords to be
inserted, in the following way: vertex <code class="constant">i</code> will connect to a vertex
<code class="literal">L[(i mod p)]</code> steps ahead of it along the cycle, where
<code class="constant">p</code> is the length of <code class="constant">L</code>.
In other words, vertex <code class="constant">i</code> will be connected to vertex
<code class="literal">(i + L[(i mod p)]) mod nodes</code>. If multiple edges are
defined in this way, this will output a non-simple graph. The result
can be simplified using <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.7. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a>.

</p>
<p>
See also Kotsis, G: Interconnection Topologies for Parallel Processing
Systems, PARS Mitteilungen 11, 1-6, 1993. The igraph extended chordal
rings are not identical to the ones in the paper. In igraph
the matrix specifies which edges to add. In the paper, a condition is
specified which should simultaneously hold between two endpoints and
the reverse endpoints.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the result
  will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  Integer constant, the number of vertices in the
  graph. It must be at least 3.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>W</code></em>:</span></p></td>
<td><p>
  The matrix specifying the extra edges. The number of
  columns should divide the number of total vertices. The elements
  are allowed to be negative.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Whether the graph should be directed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_ring" title="1.13. igraph_ring — Creates a cycle graph or a path graph."><code class="function">igraph_ring()</code></a>, <a class="link" href="igraph-Generators.html#igraph_lcf" title="1.23. igraph_lcf — Creates a graph from LCF notation."><code class="function">igraph_lcf()</code></a>, <a class="link" href="igraph-Generators.html#igraph_lcf_vector" title="1.24. igraph_lcf_vector — Creates a graph from LCF notation."><code class="function">igraph_lcf_vector()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number
of edges.
 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="games-randomized-graph-generators"></a>2. Games: Randomized graph generators</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Generators.html#igraph_grg_game">2.1. <code class="function">igraph_grg_game</code> —  Generates a geometric random graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_barabasi_game">2.2. <code class="function">igraph_barabasi_game</code> —  Generates a graph based on the Barabási-Albert model.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_erdos_renyi_game_gnm">2.3. <code class="function">igraph_erdos_renyi_game_gnm</code> —  Generates a random (Erdős-Rényi) graph with a fixed number of edges.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_erdos_renyi_game_gnp">2.4. <code class="function">igraph_erdos_renyi_game_gnp</code> —  Generates a random (Erdős-Rényi) graph with fixed edge probabilities.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_watts_strogatz_game">2.5. <code class="function">igraph_watts_strogatz_game</code> —  The Watts-Strogatz small-world model.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_rewire_edges">2.6. <code class="function">igraph_rewire_edges</code> —  Rewires the edges of a graph with constant probability.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_rewire_directed_edges">2.7. <code class="function">igraph_rewire_directed_edges</code> —  Rewires the chosen endpoint of directed edges.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_degree_sequence_game">2.8. <code class="function">igraph_degree_sequence_game</code> —  Generates a random graph with a given degree sequence.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_k_regular_game">2.9. <code class="function">igraph_k_regular_game</code> —  Generates a random graph where each vertex has the same degree.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_static_fitness_game">2.10. <code class="function">igraph_static_fitness_game</code> —  Non-growing random graph with edge probabilities proportional to node fitness scores.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_static_power_law_game">2.11. <code class="function">igraph_static_power_law_game</code> —  Generates a non-growing random graph with expected power-law degree distributions.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_forest_fire_game">2.12. <code class="function">igraph_forest_fire_game</code> —  Generates a network according to the <span class="quote">“<span class="quote">forest fire game</span>”</span>.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_rewire">2.13. <code class="function">igraph_rewire</code> —  Randomly rewires a graph while preserving its degree sequence.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_growing_random_game">2.14. <code class="function">igraph_growing_random_game</code> —  Generates a growing random graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_callaway_traits_game">2.15. <code class="function">igraph_callaway_traits_game</code> —  Simulates a growing network with vertex types.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_establishment_game">2.16. <code class="function">igraph_establishment_game</code> —  Generates a graph with a simple growing model with vertex types.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_preference_game">2.17. <code class="function">igraph_preference_game</code> —  Generates a graph with vertex types and connection preferences.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_asymmetric_preference_game">2.18. <code class="function">igraph_asymmetric_preference_game</code> —  Generates a graph with asymmetric vertex types and connection preferences.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_recent_degree_game">2.19. <code class="function">igraph_recent_degree_game</code> —  Stochastic graph generator based on the number of incident edges a node has gained recently.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_barabasi_aging_game">2.20. <code class="function">igraph_barabasi_aging_game</code> —  Preferential attachment with aging of vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_recent_degree_aging_game">2.21. <code class="function">igraph_recent_degree_aging_game</code> —  Preferential attachment based on the number of edges gained recently, with aging of vertices.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_lastcit_game">2.22. <code class="function">igraph_lastcit_game</code> —  Simulates a citation network, based on time passed since the last citation.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_cited_type_game">2.23. <code class="function">igraph_cited_type_game</code> —  Simulates a citation based on vertex types.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_citing_cited_type_game">2.24. <code class="function">igraph_citing_cited_type_game</code> —  Simulates a citation network based on vertex types.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_sbm_game">2.25. <code class="function">igraph_sbm_game</code> —  Sample from a stochastic block model.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_hsbm_game">2.26. <code class="function">igraph_hsbm_game</code> —  Hierarchical stochastic block model.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_hsbm_list_game">2.27. <code class="function">igraph_hsbm_list_game</code> —  Hierarchical stochastic block model, more general version.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_dot_product_game">2.28. <code class="function">igraph_dot_product_game</code> —  Generates a random dot product graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_tree_game">2.29. <code class="function">igraph_tree_game</code> —  Generates a random tree with the given number of nodes.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_correlated_game">2.30. <code class="function">igraph_correlated_game</code> —  Generates a random graph correlated to an existing graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_correlated_pair_game">2.31. <code class="function">igraph_correlated_pair_game</code> —  Generates pairs of correlated random graphs.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_simple_interconnected_islands_game">2.32. <code class="function">igraph_simple_interconnected_islands_game</code> —  Generates a random graph made of several interconnected islands, each island being a random graph.</a></span></dt>
</dl></div>
<p>Games are randomized graph generators. Randomization means that
they generate a different graph every time you call them. </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_grg_game"></a>2.1. <code class="function">igraph_grg_game</code> —  Generates a geometric random graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_grg_game(igraph_t *graph, igraph_integer_t nodes,
                    igraph_real_t radius, igraph_bool_t torus,
                    igraph_vector_t *x, igraph_vector_t *y);
</pre></div>
<p>
</p>
<p>



A geometric random graph is created by dropping points (i.e. vertices)
randomly on the unit square and then connecting all those pairs
which are strictly less than <code class="constant">radius</code> apart in Euclidean distance.

</p>
<p>
Original code contributed by Keith Briggs, thanks Keith.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>radius</code></em>:</span></p></td>
<td><p>
  The radius within which the vertices will be connected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>torus</code></em>:</span></p></td>
<td><p>
  Logical constant. If true, periodic boundary conditions
       will be used, i.e. the vertices are assumed to be on a torus
       instead of a square.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>x</code></em>:</span></p></td>
<td><p>
  An initialized vector or <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, the points'
         x coordinates will be returned here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>y</code></em>:</span></p></td>
<td><p>
  An initialized vector or <code class="constant">NULL</code>. If not <code class="constant">NULL</code>, the points'
         y coordinates will be returned here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO, less than O(|V|^2+|E|).

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.5.3.9.1"></a><p class="title"><b>Example 9.14.  File <code class="code">examples/simple/igraph_grg_game.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;math.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {
    igraph_t graph;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> x, y;
    <a class="link" href="igraph-Data-structures.html#igraph_vector_t" title="2.1.  About igraph_vector_t objects">igraph_vector_t</a> weights;
    igraph_eit_t eit;
    igraph_real_t avg_dist;

    <span class="emphasis"><em>/* Set random seed for reproducible results */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Seeds a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);

    <span class="emphasis"><em>/* Create a random geometric graph and retrieve vertex coordinates */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;x, 0);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;y, 0);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_grg_game" title="2.1. igraph_grg_game — Generates a geometric random graph.">igraph_grg_game</a></strong></span>(&amp;graph, 200, 0.1, <span class="emphasis"><em>/* torus */</em></span> 0, &amp;x, &amp;y);

    <span class="emphasis"><em>/* Compute edge weights as geometric distance */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_init" title="2.2.1. igraph_vector_init — Initializes a vector object (constructor).">igraph_vector_init</a></strong></span>(&amp;weights, <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;graph));
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_create" title="9.1. igraph_eit_create — Creates an edge iterator from an edge selector.">igraph_eit_create</a></strong></span>(&amp;graph, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_ess_all" title="7.1. igraph_ess_all — Edge set, all edges (immediate version).">igraph_ess_all</a></strong></span>(IGRAPH_EDGEORDER_ID), &amp;eit);
    <span class="strong"><strong>for</strong></span> (; ! <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_END" title="9.5. IGRAPH_EIT_END — Are we at the end?">IGRAPH_EIT_END</a></strong></span>(eit); <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_NEXT" title="9.4. IGRAPH_EIT_NEXT — Next edge.">IGRAPH_EIT_NEXT</a></strong></span>(eit)) {
        igraph_integer_t e = <span class="strong"><strong><a class="link" href="igraph-Iterators.html#IGRAPH_EIT_GET" title="9.8. IGRAPH_EIT_GET — Query an edge iterator.">IGRAPH_EIT_GET</a></strong></span>(eit);
        igraph_integer_t u = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_FROM" title="4.2.6. IGRAPH_FROM — The source vertex of an edge.">IGRAPH_FROM</a></strong></span>(&amp;graph, e);
        igraph_integer_t v = <span class="strong"><strong><a class="link" href="igraph-Basic.html#IGRAPH_TO" title="4.2.7. IGRAPH_TO — The target vertex of an edge.">IGRAPH_TO</a></strong></span>(&amp;graph, e);

        <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(weights)[e] = <span class="strong"><strong>hypot</strong></span>(<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(x)[u] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(x)[v], <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(y)[u] - <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(y)[v]);
    }
    <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_eit_destroy" title="9.2. igraph_eit_destroy — Destroys an edge iterator.">igraph_eit_destroy</a></strong></span>(&amp;eit);

    <span class="emphasis"><em>/* Compute average path length */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_average_path_length_dijkstra" title="3.21. igraph_average_path_length_dijkstra — Calculates the average weighted shortest path length between all vertex pairs.">igraph_average_path_length_dijkstra</a></strong></span>(&amp;graph, &amp;avg_dist, NULL, &amp;weights, IGRAPH_UNDIRECTED, <span class="emphasis"><em>/* unconn */</em></span> 1);

    <span class="strong"><strong>printf</strong></span>("Average distance in the geometric graph: %g.\n", avg_dist);

    <span class="emphasis"><em>/* Destroy data structures when no longer needed */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;weights);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;x);
    <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#igraph_vector_destroy" title="2.2.5. igraph_vector_destroy — Destroys a vector object.">igraph_vector_destroy</a></strong></span>(&amp;y);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_barabasi_game"></a>2.2. <code class="function">igraph_barabasi_game</code> —  Generates a graph based on the Barabási-Albert model.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_barabasi_game(igraph_t *graph, igraph_integer_t n,
                         igraph_real_t power,
                         igraph_integer_t m,
                         const igraph_vector_int_t *outseq,
                         igraph_bool_t outpref,
                         igraph_real_t A,
                         igraph_bool_t directed,
                         igraph_barabasi_algorithm_t algo,
                         const igraph_t *start_from);
</pre></div>
<p>
</p>
<p>




This function implements several variants of the preferential attachment
process, including linear and non-linear varieties of the Barabási-Albert
and Price models. The graph construction starts with a single vertex,
or an existing graph given by the <em class="parameter"><code>start_from</code></em> parameter. Then new vertices
are added one at a time. Each new vertex connects to <em class="parameter"><code>m</code></em> existing vertices,
choosing them with probabilities proportional to

</p>
<p>
<code class="literal">d^power + A</code>,

</p>
<p>
where <code class="constant">d</code> is the in- or total degree of the existing vertex (controlled
by the <em class="parameter"><code>outpref</code></em> argument), while <em class="parameter"><code>power</code></em> and <em class="parameter"><code>A</code></em> are given by
parameters. The <span class="emphasis"><em>constant attractiveness</em></span> <em class="parameter"><code>A</code></em>
is used to ensure that vertices with zero in-degree can also be
connected to with non-zero probability.

</p>
<p>
Barabási, A.-L. and Albert R. 1999. Emergence of scaling in
random networks, Science, 286 509--512.
<a class="ulink" href="https://doi.org/10.1126/science.286.5439.509" target="_top">https://doi.org/10.1126/science.286.5439.509</a>

</p>
<p>
de Solla Price, D. J. 1965. Networks of Scientific Papers, Science,
149 510--515.
<a class="ulink" href="https://doi.org/10.1126/science.149.3683.510" target="_top">https://doi.org/10.1126/science.149.3683.510</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  An uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>power</code></em>:</span></p></td>
<td><p>
  Power of the preferential attachment. In the classic preferential
       attachment model <code class="literal">power=1</code>. Other values allow for
       sampling from a non-linear preferential attachment model.
       Negative values are only allowed when no zero-degree vertices
       are present during the construction process, i.e. when
       the starting graph has no isolated vertices and <em class="parameter"><code>outpref</code></em>
       is set to <code class="constant">true</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The number of outgoing edges generated for each
       vertex. Only used when <em class="parameter"><code>outseq</code></em> is <code class="constant">NULL</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>outseq</code></em>:</span></p></td>
<td><p>
  Gives the (out-)degrees of the vertices. If this is
       constant, this can be a <code class="constant">NULL</code> pointer or an empty vector.
       In this case <em class="parameter"><code>m</code></em> contains the constant out-degree.
       The very first vertex has by definition no outgoing edges,
       so the first number in this vector is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>outpref</code></em>:</span></p></td>
<td><p>
  Boolean, if true not only the in- but also the out-degree
       of a vertex increases its citation probability. I.e., the
       citation probability is determined by the total degree of
       the vertices. Ignored and assumed to be true if the graph
       being generated is undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>A</code></em>:</span></p></td>
<td><p>
  The constant attractiveness of vertices. When <em class="parameter"><code>outpref</code></em>
       is set to <code class="constant">false</code>, it should be positive to ensure that
       zero in-degree vertices can be connected to as well.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to generate a directed graph.
       When set to <code class="constant">false</code>, outpref is assumed to be <code class="constant">true</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>algo</code></em>:</span></p></td>
<td>
<p>
  The algorithm to use to generate the network. Possible
       values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BARABASI_BAG</code></span></p></td>
<td><p>

         This is the algorithm that was previously (before version
         0.6) solely implemented in igraph. It works by putting the
         IDs of the vertices into a bag (multiset, really), exactly
         as many times as their (in-)degree, plus once more. Then
         the required number of cited vertices are drawn from the
         bag, with replacement. This method might generate multiple
         edges. It only works if power=1 and A=1.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BARABASI_PSUMTREE</code></span></p></td>
<td><p>

         This algorithm uses a partial prefix-sum tree to generate
         the graph. It does not generate multiple edges and
         works for any power and A values.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_BARABASI_PSUMTREE_MULTIPLE</code></span></p></td>
<td><p>

         This algorithm also uses a partial prefix-sum tree to
         generate the graph. The difference is, that now multiple
         edges are allowed. This method was implemented under the
         name <code class="constant">igraph_nonlinear_barabasi_game</code> before version 0.6.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>start_from</code></em>:</span></p></td>
<td><p>
  Either a <code class="constant">NULL</code> pointer, or a graph. In the former
       case, the starting configuration is a clique of size <em class="parameter"><code>m</code></em>.
       In the latter case, the graph is a starting configuration.
       The graph must be non-empty, i.e. it must have at least one
       vertex. If a graph is supplied here and the <em class="parameter"><code>outseq</code></em>
       argument is also given, then <em class="parameter"><code>outseq</code></em> should only contain
       information on the vertices that are not in the <em class="parameter"><code>start_from</code></em> graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid <em class="parameter"><code>n</code></em>, <em class="parameter"><code>m</code></em>, <em class="parameter"><code>A</code></em> or <em class="parameter"><code>outseq</code></em> parameter.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the
number of vertices plus the number of edges.

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.5.4.12.1"></a><p class="title"><b>Example 9.15.  File <code class="code">examples/simple/igraph_barabasi_game.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {

    igraph_t g;
    igraph_vector_int_t v;
    igraph_vector_int_t v2, v3;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model.">igraph_barabasi_game</a></strong></span>(&amp;g, 10, <span class="emphasis"><em>/*power=*/</em></span> 1, 2, 0, 0, <span class="emphasis"><em>/*A=*/</em></span> 1, 1,
                         IGRAPH_BARABASI_BAG, <span class="emphasis"><em>/*start_from=*/</em></span> 0);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g) != 18) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) != 10) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="4.2.3. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(&amp;g)) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;v, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_edgelist" title="26.10. igraph_get_edgelist — The list of edges in a graph.">igraph_get_edgelist</a></strong></span>(&amp;g, &amp;v, 0);
    <span class="strong"><strong>for</strong></span> (igraph_integer_t i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g); i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[2 * i] &lt;= <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[2 * i + 1]) {
            <span class="strong"><strong>return</strong></span> 4;
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;v);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* out-degree sequence */</em></span>
    <span class="strong"><strong>igraph_vector_int_init_int</strong></span>(&amp;v3, 10, 0, 1, 3, 3, 4, 5, 6, 7, 8, 9);

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model.">igraph_barabasi_game</a></strong></span>(&amp;g, 10, <span class="emphasis"><em>/*power=*/</em></span> 1, 0, &amp;v3, 0, <span class="emphasis"><em>/*A=*/</em></span> 1, 1,
                         IGRAPH_BARABASI_BAG, <span class="emphasis"><em>/*start_from=*/</em></span> 0);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g) != <span class="strong"><strong>igraph_vector_int_sum</strong></span>(&amp;v3)) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;v2, 0);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;v2, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT, 1);
    <span class="strong"><strong>for</strong></span> (igraph_integer_t i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g); i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v3)[i] != <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v2)[i]) {
            <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;v3);
            <span class="strong"><strong>printf</strong></span>("\n");
            <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;v2);
            <span class="strong"><strong>return</strong></span> 6;
        }
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;v3);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;v2);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* outpref, we cannot really test this quantitatively,</em></span>
<span class="emphasis"><em>       would need to set random seed */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model.">igraph_barabasi_game</a></strong></span>(&amp;g, 10, <span class="emphasis"><em>/*power=*/</em></span> 1, 2, 0, 1, <span class="emphasis"><em>/*A=*/</em></span> 1, 1,
                         IGRAPH_BARABASI_BAG, <span class="emphasis"><em>/*start_from=*/</em></span> 0);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;v, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_get_edgelist" title="26.10. igraph_get_edgelist — The list of edges in a graph.">igraph_get_edgelist</a></strong></span>(&amp;g, &amp;v, 0);
    <span class="strong"><strong>for</strong></span> (igraph_integer_t i = 0; i &lt; <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g); i++) {
        <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[2 * i] &lt;= <span class="strong"><strong><a class="link" href="igraph-Data-structures.html#VECTOR" title="2.4.1. VECTOR — Accessing an element of a vector.">VECTOR</a></strong></span>(v)[2 * i + 1]) {
            <span class="strong"><strong>return</strong></span> 7;
        }
    }
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="4.2.3. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(&amp;g)) {
        <span class="strong"><strong>return</strong></span> 8;
    }
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;v);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.5.4.12.2"></a><p class="title"><b>Example 9.16.  File <code class="code">examples/simple/igraph_barabasi_game2.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;
<span class="strong"><strong>#include</strong></span> &lt;stdio.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {

    igraph_t g;
    igraph_bool_t simple;

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model.">igraph_barabasi_game</a></strong></span>(<span class="emphasis"><em>/* graph=    */</em></span> &amp;g,
                                         <span class="emphasis"><em>/* n=        */</em></span> 100,
                                         <span class="emphasis"><em>/* power=    */</em></span> 1.0,
                                         <span class="emphasis"><em>/* m=        */</em></span> 2,
                                         <span class="emphasis"><em>/* outseq=   */</em></span> 0,
                                         <span class="emphasis"><em>/* outpref=  */</em></span> 0,
                                         <span class="emphasis"><em>/* A=        */</em></span> 1.0,
                                         <span class="emphasis"><em>/* directed= */</em></span> IGRAPH_DIRECTED,
                                         <span class="emphasis"><em>/* algo=     */</em></span> IGRAPH_BARABASI_PSUMTREE,
                                         <span class="emphasis"><em>/* start_from= */</em></span> 0);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g) != 197) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) != 100) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_simple" title="19.1. igraph_is_simple — Decides whether the input graph is a simple graph.">igraph_is_simple</a></strong></span>(&amp;g, &amp;simple);
    <span class="strong"><strong>if</strong></span> (!simple) {
        <span class="strong"><strong>return</strong></span> 3;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* ============================== */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model.">igraph_barabasi_game</a></strong></span>(<span class="emphasis"><em>/* graph=    */</em></span> &amp;g,
                                         <span class="emphasis"><em>/* n=        */</em></span> 100,
                                         <span class="emphasis"><em>/* power=    */</em></span> 1.0,
                                         <span class="emphasis"><em>/* m=        */</em></span> 2,
                                         <span class="emphasis"><em>/* outseq=   */</em></span> 0,
                                         <span class="emphasis"><em>/* outpref=  */</em></span> 0,
                                         <span class="emphasis"><em>/* A=        */</em></span> 1.0,
                                         <span class="emphasis"><em>/* directed= */</em></span> IGRAPH_DIRECTED,
                                         <span class="emphasis"><em>/* algo=     */</em></span> IGRAPH_BARABASI_PSUMTREE_MULTIPLE,
                                         <span class="emphasis"><em>/* start_from= */</em></span> 0);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g) != 198) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) != 100) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_simple" title="19.1. igraph_is_simple — Decides whether the input graph is a simple graph.">igraph_is_simple</a></strong></span>(&amp;g, &amp;simple);
    <span class="strong"><strong>if</strong></span> (simple) {
        <span class="strong"><strong>return</strong></span> 6;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* ============================== */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model.">igraph_barabasi_game</a></strong></span>(<span class="emphasis"><em>/* graph=    */</em></span> &amp;g,
                                         <span class="emphasis"><em>/* n=        */</em></span> 100,
                                         <span class="emphasis"><em>/* power=    */</em></span> 1.0,
                                         <span class="emphasis"><em>/* m=        */</em></span> 2,
                                         <span class="emphasis"><em>/* outseq=   */</em></span> 0,
                                         <span class="emphasis"><em>/* outpref=  */</em></span> 0,
                                         <span class="emphasis"><em>/* A=        */</em></span> 1.0,
                                         <span class="emphasis"><em>/* directed= */</em></span> IGRAPH_DIRECTED,
                                         <span class="emphasis"><em>/* algo=     */</em></span> IGRAPH_BARABASI_BAG,
                                         <span class="emphasis"><em>/* start_from= */</em></span> 0);

    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_ecount" title="4.2.2. igraph_ecount — The number of edges in a graph.">igraph_ecount</a></strong></span>(&amp;g) != 198) {
        <span class="strong"><strong>return</strong></span> 7;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) != 100) {
        <span class="strong"><strong>return</strong></span> 8;
    }
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_simple" title="19.1. igraph_is_simple — Decides whether the input graph is a simple graph.">igraph_is_simple</a></strong></span>(&amp;g, &amp;simple);
    <span class="strong"><strong>if</strong></span> (simple) {
        <span class="strong"><strong>return</strong></span> 9;
    }

    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_erdos_renyi_game_gnm"></a>2.3. <code class="function">igraph_erdos_renyi_game_gnm</code> —  Generates a random (Erdős-Rényi) graph with a fixed number of edges.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.5.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_erdos_renyi_game_gnm(
    igraph_t *graph, igraph_integer_t n, igraph_integer_t m,
    igraph_bool_t directed, igraph_bool_t loops
);
</pre></div>
<p>
</p>
<p>




In this model, a graph with n vertices and m edges is generated such that the
edges are selected uniformly at random.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The number of edges in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, whether to generate a directed graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Logical, whether to generate loops (self) edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid <em class="parameter"><code>n</code></em> or <em class="parameter"><code>m</code></em> parameter.
        <code class="constant">IGRAPH_ENOMEM</code>: there is not enough memory for the operation.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the
number of vertices plus the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model."><code class="function">igraph_barabasi_game()</code></a>, <a class="link" href="igraph-Generators.html#igraph_growing_random_game" title="2.14. igraph_growing_random_game — Generates a growing random graph."><code class="function">igraph_growing_random_game()</code></a>,
<a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game_gnp" title="2.4. igraph_erdos_renyi_game_gnp — Generates a random (Erdős-Rényi) graph with fixed edge probabilities."><code class="function">igraph_erdos_renyi_game_gnp()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.5.5.10.1"></a><p class="title"><b>Example 9.17.  File <code class="code">examples/simple/igraph_erdos_renyi_game_gnm.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {
    igraph_t graph;
    igraph_vector_int_t component_sizes;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Seeds a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42); <span class="emphasis"><em>/* make program deterministic */</em></span>

    <span class="emphasis"><em>/* Sample a graph from the Erdős-Rényi G(n,m) model */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game_gnm" title="2.3. igraph_erdos_renyi_game_gnm — Generates a random (Erdős-Rényi) graph with a fixed number of edges.">igraph_erdos_renyi_game_gnm</a></strong></span>(
        &amp;graph, <span class="emphasis"><em>/* n= */</em></span> 100, <span class="emphasis"><em>/* m= */</em></span> 100,
        IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS
    );

    <span class="emphasis"><em>/* Compute the fraction of vertices contained within the largest connected component */</em></span>

    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;component_sizes, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_connected_components" title="8.2. igraph_connected_components — Calculates the (weakly or strongly) connected components in a graph.">igraph_connected_components</a></strong></span>(&amp;graph, NULL, &amp;component_sizes, NULL, IGRAPH_STRONG);

    <span class="strong"><strong>printf</strong></span>(
        "Fraction of vertices in giant component: %g\n",
        ((double) <span class="strong"><strong>igraph_vector_int_max</strong></span>(&amp;component_sizes)) / <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;graph)
    );

    <span class="emphasis"><em>/* Clean up data structures when no longer needed */</em></span>

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;component_sizes);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_erdos_renyi_game_gnp"></a>2.4. <code class="function">igraph_erdos_renyi_game_gnp</code> —  Generates a random (Erdős-Rényi) graph with fixed edge probabilities.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.6.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_erdos_renyi_game_gnp(
    igraph_t *graph, igraph_integer_t n, igraph_real_t p,
    igraph_bool_t directed, igraph_bool_t loops
);
</pre></div>
<p>
</p>
<p>




In this model, a graph with n vertices is generated such that every possible
edge is included in the graph with probability p.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  The probability of the existence of an edge in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, whether to generate a directed graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Logical, whether to generate loops (self) edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid <em class="parameter"><code>n</code></em> or <em class="parameter"><code>p</code></em> parameter.
        <code class="constant">IGRAPH_ENOMEM</code>: there is not enough memory for the operation.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the
number of vertices plus the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model."><code class="function">igraph_barabasi_game()</code></a>, <a class="link" href="igraph-Generators.html#igraph_growing_random_game" title="2.14. igraph_growing_random_game — Generates a growing random graph."><code class="function">igraph_growing_random_game()</code></a>,
<a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game_gnm" title="2.3. igraph_erdos_renyi_game_gnm — Generates a random (Erdős-Rényi) graph with a fixed number of edges."><code class="function">igraph_erdos_renyi_game_gnm()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.5.6.10.1"></a><p class="title"><b>Example 9.18.  File <code class="code">examples/simple/igraph_erdos_renyi_game_gnp.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {
    igraph_t graph;
    igraph_vector_int_t component_sizes;

    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Seeds a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42); <span class="emphasis"><em>/* make program deterministic */</em></span>

    <span class="emphasis"><em>/* Sample a graph from the Erdős-Rényi G(n,p) model */</em></span>

    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game_gnp" title="2.4. igraph_erdos_renyi_game_gnp — Generates a random (Erdős-Rényi) graph with fixed edge probabilities.">igraph_erdos_renyi_game_gnp</a></strong></span>(
        &amp;graph, <span class="emphasis"><em>/* n= */</em></span> 100, <span class="emphasis"><em>/* p= */</em></span> 0.01,
        IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS
    );

    <span class="emphasis"><em>/* Compute the fraction of vertices contained within the largest connected component */</em></span>

    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;component_sizes, 0);
    <span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_connected_components" title="8.2. igraph_connected_components — Calculates the (weakly or strongly) connected components in a graph.">igraph_connected_components</a></strong></span>(&amp;graph, NULL, &amp;component_sizes, NULL, IGRAPH_STRONG);

    <span class="strong"><strong>printf</strong></span>(
        "Fraction of vertices in giant component: %g\n",
        ((double) <span class="strong"><strong>igraph_vector_int_max</strong></span>(&amp;component_sizes)) / <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;graph)
    );

    <span class="emphasis"><em>/* Clean up data structures when no longer needed */</em></span>

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;component_sizes);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;graph);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_watts_strogatz_game"></a>2.5. <code class="function">igraph_watts_strogatz_game</code> —  The Watts-Strogatz small-world model.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.7.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_watts_strogatz_game(igraph_t *graph, igraph_integer_t dim,
                               igraph_integer_t size, igraph_integer_t nei,
                               igraph_real_t p, igraph_bool_t loops,
                               igraph_bool_t multiple);
</pre></div>
<p>
</p>
<p>



This function generates a graph according to the Watts-Strogatz
model of small-world networks. The graph is obtained by creating a
circular undirected lattice and then rewire the edges randomly with
a constant probability.

</p>
<p>See also: Duncan J Watts and Steven H Strogatz:
Collective dynamics of <span class="quote">“<span class="quote">small world</span>”</span> networks, Nature
393, 440-442, 1998.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph to initialize.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>dim</code></em>:</span></p></td>
<td><p>
  The dimension of the lattice.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>size</code></em>:</span></p></td>
<td><p>
  The size of the lattice along each dimension.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nei</code></em>:</span></p></td>
<td><p>
  The size of the neighborhood for each vertex. This is
   the same as the <em class="parameter"><code>nei</code></em> argument of <a class="link" href="igraph-Operators.html#igraph_connect_neighborhood" title="3.1. igraph_connect_neighborhood — Connects each vertex to its neighborhood."><code class="function">igraph_connect_neighborhood()</code></a>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  The rewiring probability. A real number between zero and
  one (inclusive).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Logical, whether to generate loop edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiple</code></em>:</span></p></td>
<td><p>
  Logical, whether to allow multiple edges in the
  generated graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_square_lattice" title="1.10. igraph_square_lattice — Arbitrary dimensional square lattices."><code class="function">igraph_square_lattice()</code></a>, <a class="link" href="igraph-Operators.html#igraph_connect_neighborhood" title="3.1. igraph_connect_neighborhood — Connects each vertex to its neighborhood."><code class="function">igraph_connect_neighborhood()</code></a> and
<a class="link" href="igraph-Generators.html#igraph_rewire_edges" title="2.6. igraph_rewire_edges — Rewires the edges of a graph with constant probability."><code class="function">igraph_rewire_edges()</code></a> can be used if more flexibility is
needed, e.g. a different type of lattice.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*d^o+|E|), |V| and |E| are the number of
vertices and edges, d is the average degree, o is the <em class="parameter"><code>nei</code></em>
argument.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_rewire_edges"></a>2.6. <code class="function">igraph_rewire_edges</code> —  Rewires the edges of a graph with constant probability.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.8.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_rewire_edges(igraph_t *graph, igraph_real_t prob,
                        igraph_bool_t loops, igraph_bool_t multiple);
</pre></div>
<p>
</p>
<p>



This function rewires the edges of a graph with a constant
probability. More precisely each end point of each edge is rewired
to a uniformly randomly chosen vertex with constant probability <em class="parameter"><code>prob</code></em>.

</p>
<p> Note that this function modifies the input <em class="parameter"><code>graph</code></em>,
call <a class="link" href="igraph-Basic.html#igraph_copy" title="4.1.3. igraph_copy — Creates an exact (deep) copy of a graph."><code class="function">igraph_copy()</code></a> if you want to keep it.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, this will be rewired, it can be
   directed or undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>prob</code></em>:</span></p></td>
<td><p>
  The rewiring probability a constant between zero and
   one (inclusive).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Boolean, whether loop edges are allowed in the new
   graph, or not.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiple</code></em>:</span></p></td>
<td><p>
  Boolean, whether multiple edges are allowed in the
   new graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_watts_strogatz_game" title="2.5. igraph_watts_strogatz_game — The Watts-Strogatz small-world model."><code class="function">igraph_watts_strogatz_game()</code></a> uses this function for the
rewiring.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_rewire_directed_edges"></a>2.7. <code class="function">igraph_rewire_directed_edges</code> —  Rewires the chosen endpoint of directed edges.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.9.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_rewire_directed_edges(igraph_t *graph, igraph_real_t prob,
                                 igraph_bool_t loops, igraph_neimode_t mode);
</pre></div>
<p>
</p>
<p>



This function rewires either the start or end of directed edges in a graph
with a constant probability. Correspondingly, either the in-degree sequence
or the out-degree sequence of the graph will be preserved.

</p>
<p> Note that this function modifies the input <em class="parameter"><code>graph</code></em>,
call <a class="link" href="igraph-Basic.html#igraph_copy" title="4.1.3. igraph_copy — Creates an exact (deep) copy of a graph."><code class="function">igraph_copy()</code></a> if you want to keep it.

</p>
<p> This function can produce multiple edges between two vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The input graph, this will be rewired, it can be
   directed or undirected. If it is undirected or <em class="parameter"><code>mode</code></em> is set to
   IGRAPH_ALL, <a class="link" href="igraph-Generators.html#igraph_rewire_edges" title="2.6. igraph_rewire_edges — Rewires the edges of a graph with constant probability."><code class="function">igraph_rewire_edges()</code></a> will be called.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>prob</code></em>:</span></p></td>
<td><p>
  The rewiring probability, a constant between zero and
   one (inclusive).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Boolean, whether loop edges are allowed in the new
   graph, or not.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The endpoints of directed edges to rewire. It is ignored for
   undirected graphs. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_OUT</code></span></p></td>
<td><p>

         rewire the end of each directed edge
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_IN</code></span></p></td>
<td><p>

         rewire the start of each directed edge
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ALL</code></span></p></td>
<td><p>

         rewire both endpoints of each edge
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_rewire_edges" title="2.6. igraph_rewire_edges — Rewires the edges of a graph with constant probability."><code class="function">igraph_rewire_edges()</code></a>, <a class="link" href="igraph-Generators.html#igraph_rewire" title="2.13. igraph_rewire — Randomly rewires a graph while preserving its degree sequence."><code class="function">igraph_rewire()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|E|).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_degree_sequence_game"></a>2.8. <code class="function">igraph_degree_sequence_game</code> —  Generates a random graph with a given degree sequence.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.10.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_degree_sequence_game(igraph_t *graph, const igraph_vector_int_t *out_deg,
                                const igraph_vector_int_t *in_deg,
                                igraph_degseq_t method);
</pre></div>
<p>
</p>
<p>




</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>out_deg</code></em>:</span></p></td>
<td><p>
  The degree sequence for an undirected graph (if
       <em class="parameter"><code>in_seq</code></em> is <code class="constant">NULL</code> or of length zero), or the out-degree
       sequence of a directed graph (if <em class="parameter"><code>in_deq</code></em> is not
       of length zero).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>in_deg</code></em>:</span></p></td>
<td><p>
  It is either a zero-length vector or
       <code class="constant">NULL</code> (if an undirected
       graph is generated), or the in-degree sequence.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>method</code></em>:</span></p></td>
<td>
<p>
  The method to generate the graph. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_DEGSEQ_CONFIGURATION</code></span></p></td>
<td><p>

         This method implements the configuration model.
         For undirected graphs, it puts all vertex IDs in a bag
         such that the multiplicity of a vertex in the bag is the same as
         its degree. Then it draws pairs from the bag until the bag becomes
         empty. This method may generate both loop (self) edges and multiple
         edges. For directed graphs, the algorithm is basically the same,
         but two separate bags are used for the in- and out-degrees.
         Undirected graphs are generated with probability proportional to
         <code class="literal">(\prod_{i&lt;j} A_{ij} ! \prod_i A_{ii} !!)^{-1}</code>,
         where <code class="constant">A</code> denotes the adjacency matrix and <code class="literal">!!</code> denotes
         the double factorial. Here <code class="constant">A</code> is assumed to have twice the number of
         self-loops on its diagonal.
         The corresponding  expression for directed graphs is
         <code class="literal">(\prod_{i,j} A_{ij}!)^{-1}</code>.
         Thus the probability of all simple graphs (which only have 0s and 1s
         in the adjacency matrix) is the same, while that of
         non-simple ones depends on their edge and self-loop multiplicities.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_DEGSEQ_CONFIGURATION_SIMPLE</code></span></p></td>
<td><p>

         This method is identical to <code class="constant">IGRAPH_DEGSEQ_CONFIGURATION</code>, but if the
         generated graph is not simple, it rejects it and re-starts the
         generation. It generates all simple graphs with the same probability.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_DEGSEQ_FAST_HEUR_SIMPLE</code></span></p></td>
<td><p>

         This method generates simple graphs.
         It is similar to <code class="constant">IGRAPH_DEGSEQ_CONFIGURATION</code>
         but tries to avoid multiple and loop edges and restarts the
         generation from scratch if it gets stuck. It can generate all simple
         realizations of a degree sequence, but it is not guaranteed
         to sample them uniformly. This method is relatively fast and it will
         eventually succeed if the provided degree sequence is graphical,
         but there is no upper bound on the number of iterations.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_DEGSEQ_EDGE_SWITCHING_SIMPLE</code></span></p></td>
<td><p>

         This is an MCMC sampler based on degree-preserving edge switches.
         It generates simple undirected or directed graphs.
         It uses <a class="link" href="igraph-Generators.html#igraph_realize_degree_sequence" title="1.21. igraph_realize_degree_sequence — Generates a graph with the given degree sequence."><code class="function">igraph_realize_degree_sequence()</code></a> to construct an initial
         graph, then rewires it using <a class="link" href="igraph-Generators.html#igraph_rewire" title="2.13. igraph_rewire — Randomly rewires a graph while preserving its degree sequence."><code class="function">igraph_rewire()</code></a>.
         
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_DEGSEQ_VL</code></span></p></td>
<td><p>

         This method samples undirected <span class="emphasis"><em>connected</em></span> graphs approximately
         uniformly. It is a Monte Carlo method based on degree-preserving
         edge switches.
         This generator should be favoured if undirected and connected
         graphs are to be generated and execution time is not a concern.
         igraph uses the original implementation of Fabien Viger; for the algorithm,
         see <a class="ulink" href="https://www-complexnetworks.lip6.fr/~latapy/FV/generation.html" target="_top">https://www-complexnetworks.lip6.fr/~latapy/FV/generation.html</a>
         and the paper <a class="ulink" href="https://arxiv.org/abs/cs/0502085" target="_top">https://arxiv.org/abs/cs/0502085</a>
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
         <code class="constant">IGRAPH_ENOMEM</code>: there is not enough
          memory to perform the operation.
         <code class="constant">IGRAPH_EINVAL</code>: invalid method parameter, or
          invalid in- and/or out-degree vectors. The degree vectors
          should be non-negative, <em class="parameter"><code>out_deg</code></em> should sum
          up to an even integer for undirected graphs; the length
          and sum of <em class="parameter"><code>out_deg</code></em> and
          <em class="parameter"><code>in_deg</code></em>
          should match for directed graphs.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the number of vertices plus the number of edges
                 for <code class="constant">IGRAPH_DEGSEQ_SIMPLE</code>. The time complexity of the
                 other modes is not known.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model."><code class="function">igraph_barabasi_game()</code></a>, <a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game_gnm" title="2.3. igraph_erdos_renyi_game_gnm — Generates a random (Erdős-Rényi) graph with a fixed number of edges."><code class="function">igraph_erdos_renyi_game_gnm()</code></a>,
    <a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game_gnp" title="2.4. igraph_erdos_renyi_game_gnp — Generates a random (Erdős-Rényi) graph with fixed edge probabilities."><code class="function">igraph_erdos_renyi_game_gnp()</code></a>, <a class="link" href="igraph-Structural.html#igraph_is_graphical" title="9.1. igraph_is_graphical — Is there a graph with the given degree sequence?"><code class="function">igraph_is_graphical()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<div class="hideshow" onClick="toggle(this, event)">
<div class="example">
<a name="id-1.10.5.10.10.1"></a><p class="title"><b>Example 9.19.  File <code class="code">examples/simple/igraph_degree_sequence_game.c</code></b></p>
<div class="example-contents">
<pre class="programlisting"><span class="strong"><strong>#include</strong></span> &lt;igraph.h&gt;

int <span class="strong"><strong>main</strong></span>(void) {
    igraph_t g;
    igraph_vector_int_t outdeg, indeg;
    igraph_vector_int_t vec;
    igraph_bool_t is_simple;

    <span class="emphasis"><em>/* Set random seed for reproducibility */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_seed" title="3.3. igraph_rng_seed — Seeds a random number generator.">igraph_rng_seed</a></strong></span>(<span class="strong"><strong><a class="link" href="igraph-Random.html#igraph_rng_default" title="2.1. igraph_rng_default — Query the default random number generator.">igraph_rng_default</a></strong></span>(), 42);

    <span class="strong"><strong>igraph_vector_int_init_int</strong></span>(&amp;outdeg, 10, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3);
    <span class="strong"><strong>igraph_vector_int_init_int</strong></span>(&amp;indeg, 10, 4, 4, 2, 2, 4, 4, 2, 2, 3, 3);
    <span class="strong"><strong>igraph_vector_int_init</strong></span>(&amp;vec, 0);

    <span class="emphasis"><em>/* checking the configuration model, undirected graphs */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_degree_sequence_game" title="2.8. igraph_degree_sequence_game — Generates a random graph with a given degree sequence.">igraph_degree_sequence_game</a></strong></span>(&amp;g, &amp;outdeg, 0, IGRAPH_DEGSEQ_CONFIGURATION);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="4.2.3. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(&amp;g) || <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) != 10) {
        <span class="strong"><strong>return</strong></span> 1;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;vec, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT, 1)) {
        <span class="strong"><strong>return</strong></span> 2;
    }
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;vec);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* checking the Viger-Latapy method, undirected graphs */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_degree_sequence_game" title="2.8. igraph_degree_sequence_game — Generates a random graph with a given degree sequence.">igraph_degree_sequence_game</a></strong></span>(&amp;g, &amp;outdeg, 0, IGRAPH_DEGSEQ_VL);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="4.2.3. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(&amp;g) || <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) != 10) {
        <span class="strong"><strong>return</strong></span> 3;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_simple" title="19.1. igraph_is_simple — Decides whether the input graph is a simple graph.">igraph_is_simple</a></strong></span>(&amp;g, &amp;is_simple) || !is_simple) {
        <span class="strong"><strong>return</strong></span> 4;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;vec, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT, 0)) {
        <span class="strong"><strong>return</strong></span> 5;
    }
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;vec);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* checking the configuration model, directed graphs */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_degree_sequence_game" title="2.8. igraph_degree_sequence_game — Generates a random graph with a given degree sequence.">igraph_degree_sequence_game</a></strong></span>(&amp;g, &amp;outdeg, &amp;indeg, IGRAPH_DEGSEQ_CONFIGURATION);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="4.2.3. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(&amp;g) || <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) != 10) {
        <span class="strong"><strong>return</strong></span> 6;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;vec, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT, 1)) {
        <span class="strong"><strong>return</strong></span> 7;
    }
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;vec);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;vec, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN, 1)) {
        <span class="strong"><strong>return</strong></span> 8;
    }
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;vec);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* checking the fast heuristic method, undirected graphs */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_degree_sequence_game" title="2.8. igraph_degree_sequence_game — Generates a random graph with a given degree sequence.">igraph_degree_sequence_game</a></strong></span>(&amp;g, &amp;outdeg, 0, IGRAPH_DEGSEQ_FAST_HEUR_SIMPLE);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="4.2.3. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(&amp;g) || <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) != 10) {
        <span class="strong"><strong>return</strong></span> 9;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_simple" title="19.1. igraph_is_simple — Decides whether the input graph is a simple graph.">igraph_is_simple</a></strong></span>(&amp;g, &amp;is_simple) || !is_simple) {
        <span class="strong"><strong>return</strong></span> 10;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;vec, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT, 1)) {
        <span class="strong"><strong>return</strong></span> 11;
    }
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;vec);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="emphasis"><em>/* checking the fast heuristic method, directed graphs */</em></span>
    <span class="strong"><strong><a class="link" href="igraph-Generators.html#igraph_degree_sequence_game" title="2.8. igraph_degree_sequence_game — Generates a random graph with a given degree sequence.">igraph_degree_sequence_game</a></strong></span>(&amp;g, &amp;outdeg, &amp;indeg, IGRAPH_DEGSEQ_FAST_HEUR_SIMPLE);
    <span class="strong"><strong>if</strong></span> (!<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_is_directed" title="4.2.3. igraph_is_directed — Is this a directed graph?">igraph_is_directed</a></strong></span>(&amp;g) || <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_vcount" title="4.2.1. igraph_vcount — The number of vertices in a graph.">igraph_vcount</a></strong></span>(&amp;g) != 10) {
        <span class="strong"><strong>return</strong></span> 12;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Structural.html#igraph_is_simple" title="19.1. igraph_is_simple — Decides whether the input graph is a simple graph.">igraph_is_simple</a></strong></span>(&amp;g, &amp;is_simple) || !is_simple) {
        <span class="strong"><strong>return</strong></span> 13;
    }
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;vec, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_OUT, 1)) {
        <span class="strong"><strong>return</strong></span> 14;
    }
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;vec);
    <span class="strong"><strong>if</strong></span> (<span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_degree" title="4.2.14. igraph_degree — The degree of some vertices in a graph.">igraph_degree</a></strong></span>(&amp;g, &amp;vec, <span class="strong"><strong><a class="link" href="igraph-Iterators.html#igraph_vss_all" title="4.1. igraph_vss_all — All vertices of a graph (immediate version).">igraph_vss_all</a></strong></span>(), IGRAPH_IN, 1)) {
        <span class="strong"><strong>return</strong></span> 15;
    }
    <span class="strong"><strong>igraph_vector_int_print</strong></span>(&amp;vec);
    <span class="strong"><strong><a class="link" href="igraph-Basic.html#igraph_destroy" title="4.1.4. igraph_destroy — Frees the memory allocated for a graph object.">igraph_destroy</a></strong></span>(&amp;g);

    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;vec);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;outdeg);
    <span class="strong"><strong>igraph_vector_int_destroy</strong></span>(&amp;indeg);

    <span class="strong"><strong>return</strong></span> 0;
}
</pre>
<p></p>
</div>
</div>
<br class="example-break">
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_k_regular_game"></a>2.9. <code class="function">igraph_k_regular_game</code> —  Generates a random graph where each vertex has the same degree.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.11.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_k_regular_game(igraph_t *graph,
                          igraph_integer_t no_of_nodes, igraph_integer_t k,
                          igraph_bool_t directed, igraph_bool_t multiple);
</pre></div>
<p>
</p>
<p>




This game generates a directed or undirected random graph where the
degrees of vertices are equal to a predefined constant k. For undirected
graphs, at least one of k and the number of vertices must be even.

</p>
<p>
Currently, this game simply uses <a class="link" href="igraph-Generators.html#igraph_degree_sequence_game" title="2.8. igraph_degree_sequence_game — Generates a random graph with a given degree sequence."><code class="function">igraph_degree_sequence_game</code></a> with
the <code class="constant">IGRAPH_DEGSEQ_CONFIGURATION</code> or the <code class="constant">IGRAPH_DEGSEQ_FAST_SIMPLE</code>
method and appropriately constructed degree sequences.
Thefore, it does not sample uniformly: while it can generate all k-regular
graphs with the given number of vertices, it does not generate each one with
the same probability.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no_of_nodes</code></em>:</span></p></td>
<td><p>
  The number of nodes in the generated graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>k</code></em>:</span></p></td>
<td><p>
  The degree of each vertex in an undirected graph, or
                    the out-degree and in-degree of each vertex in a
                    directed graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Whether the generated graph will be directed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiple</code></em>:</span></p></td>
<td><p>
  Whether to allow multiple edges in the generated graph.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid parameter; e.g., negative number of nodes,
                          or odd number of nodes and odd k for undirected
                          graphs.
        <code class="constant">IGRAPH_ENOMEM</code>: there is not enough memory for the operation.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|) if <code class="constant">multiple</code> is true, otherwise not known.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_static_fitness_game"></a>2.10. <code class="function">igraph_static_fitness_game</code> —  Non-growing random graph with edge probabilities proportional to node fitness scores.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.12.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_static_fitness_game(igraph_t *graph, igraph_integer_t no_of_edges,
                               const igraph_vector_t *fitness_out, const igraph_vector_t *fitness_in,
                               igraph_bool_t loops, igraph_bool_t multiple);
</pre></div>
<p>
</p>
<p>




This game generates a directed or undirected random graph where the
probability of an edge between vertices i and j depends on the fitness
scores of the two vertices involved. For undirected graphs, each vertex
has a single fitness score. For directed graphs, each vertex has an out-
and an in-fitness, and the probability of an edge from i to j depends on
the out-fitness of vertex i and the in-fitness of vertex j.

</p>
<p>
The generation process goes as follows. We start from N disconnected nodes
(where N is given by the length of the fitness vector). Then we randomly
select two vertices i and j, with probabilities proportional to their
fitnesses. (When the generated graph is directed, i is selected according to
the out-fitnesses and j is selected according to the in-fitnesses). If the
vertices are not connected yet (or if multiple edges are allowed), we
connect them; otherwise we select a new pair. This is repeated until the
desired number of links are created.

</p>
<p>
It can be shown that the <span class="emphasis"><em>expected</em></span> degree of each vertex will be
proportional to its fitness, although the actual, observed degree will not
be. If you need to generate a graph with an exact degree sequence, consider
<a class="link" href="igraph-Generators.html#igraph_degree_sequence_game" title="2.8. igraph_degree_sequence_game — Generates a random graph with a given degree sequence."><code class="function">igraph_degree_sequence_game</code></a> instead.

</p>
<p>
This model is commonly used to generate static scale-free networks. To
achieve this, you have to draw the fitness scores from the desired power-law
distribution. Alternatively, you may use <a class="link" href="igraph-Generators.html#igraph_static_power_law_game" title="2.11. igraph_static_power_law_game — Generates a non-growing random graph with expected power-law degree distributions."><code class="function">igraph_static_power_law_game</code></a>
which generates the fitnesses for you with a given exponent.

</p>
<p>
Reference:

</p>
<p>
Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution
in scale-free networks. Phys Rev Lett 87(27):278701, 2001
<a class="ulink" href="https://doi.org/10.1103/PhysRevLett.87.278701" target="_top">https://doi.org/10.1103/PhysRevLett.87.278701</a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>fitness_out</code></em>:</span></p></td>
<td><p>
  A numeric vector containing the fitness of each vertex.
                    For directed graphs, this specifies the out-fitness
                    of each vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>fitness_in</code></em>:</span></p></td>
<td><p>
  If <code class="constant">NULL</code>, the generated graph will be undirected.
                    If not <code class="constant">NULL</code>, this argument specifies the in-fitness
                    of each vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no_of_edges</code></em>:</span></p></td>
<td><p>
  The number of edges in the generated graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to allow loop edges in the generated graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiple</code></em>:</span></p></td>
<td><p>
  Whether to allow multiple edges in the generated graph.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid parameter
        <code class="constant">IGRAPH_ENOMEM</code>: there is not enough
        memory for the operation.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V| + |E| log |E|).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_static_power_law_game"></a>2.11. <code class="function">igraph_static_power_law_game</code> —  Generates a non-growing random graph with expected power-law degree distributions.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.13.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_static_power_law_game(igraph_t *graph,
                                 igraph_integer_t no_of_nodes, igraph_integer_t no_of_edges,
                                 igraph_real_t exponent_out, igraph_real_t exponent_in,
                                 igraph_bool_t loops, igraph_bool_t multiple,
                                 igraph_bool_t finite_size_correction);
</pre></div>
<p>
</p>
<p>




This game generates a directed or undirected random graph where the
degrees of vertices follow power-law distributions with prescribed
exponents. For directed graphs, the exponents of the in- and out-degree
distributions may be specified separately.

</p>
<p>
The game simply uses <a class="link" href="igraph-Generators.html#igraph_static_fitness_game" title="2.10. igraph_static_fitness_game — Non-growing random graph with edge probabilities proportional to node fitness scores."><code class="function">igraph_static_fitness_game</code></a> with appropriately
constructed fitness vectors. In particular, the fitness of vertex i
is i<sup>-alpha</sup>, where alpha = 1/(gamma-1)
and gamma is the exponent given in the arguments.

</p>
<p>
To remove correlations between in- and out-degrees in case of directed
graphs, the in-fitness vector will be shuffled after it has been set up
and before <a class="link" href="igraph-Generators.html#igraph_static_fitness_game" title="2.10. igraph_static_fitness_game — Non-growing random graph with edge probabilities proportional to node fitness scores."><code class="function">igraph_static_fitness_game</code></a> is called.

</p>
<p>
Note that significant finite size effects may be observed for exponents
smaller than 3 in the original formulation of the game. This function
provides an argument that lets you remove the finite size effects by
assuming that the fitness of vertex i is
(i+i0-1)<sup>-alpha</sup>,
where i0 is a constant chosen appropriately to ensure that the maximum
degree is less than the square root of the number of edges times the
average degree; see the paper of Chung and Lu, and Cho et al for more
details.

</p>
<p>
References:

</p>
<p>
Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution
in scale-free networks. Phys Rev Lett 87(27):278701, 2001.

</p>
<p>
Chung F and Lu L: Connected components in a random graph with given
degree sequences. Annals of Combinatorics 6, 125-145, 2002.

</p>
<p>
Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in
scale-free networks under the Achlioptas process. Phys Rev Lett
103:135702, 2009.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no_of_nodes</code></em>:</span></p></td>
<td><p>
  The number of nodes in the generated graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no_of_edges</code></em>:</span></p></td>
<td><p>
  The number of edges in the generated graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>exponent_out</code></em>:</span></p></td>
<td><p>
  The power law exponent of the degree distribution.
                    For directed graphs, this specifies the exponent of the
                    out-degree distribution. It must be greater than or
                    equal to 2. If you pass <code class="constant">IGRAPH_INFINITY</code> here, you
                    will get back an Erdős-Rényi random network.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>exponent_in</code></em>:</span></p></td>
<td><p>
  If negative, the generated graph will be undirected.
                    If greater than or equal to 2, this argument specifies
                    the exponent of the in-degree distribution. If
                    non-negative but less than 2, an error will be
                    generated.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Whether to allow loop edges in the generated graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>multiple</code></em>:</span></p></td>
<td><p>
  Whether to allow multiple edges in the generated graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>finite_size_correction</code></em>:</span></p></td>
<td><p>
  Whether to use the proposed finite size
                    correction of Cho et al.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid parameter
        <code class="constant">IGRAPH_ENOMEM</code>: there is not enough
        memory for the operation.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V| + |E| log |E|).
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_forest_fire_game"></a>2.12. <code class="function">igraph_forest_fire_game</code> —  Generates a network according to the <span class="quote">“<span class="quote">forest fire game</span>”</span>.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.14.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_forest_fire_game(igraph_t *graph, igraph_integer_t nodes,
                            igraph_real_t fw_prob, igraph_real_t bw_factor,
                            igraph_integer_t pambs, igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



The forest fire model intends to reproduce the following network
characteristics, observed in real networks:
</p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem"><p>
Heavy-tailed in-degree distribution.

</p></li>
<li class="listitem"><p>
Heavy-tailed out-degree distribution.

</p></li>
<li class="listitem"><p>
Communities.

</p></li>
<li class="listitem"><p>
Densification power-law. The network is densifying in time,
     according to a power-law rule.

</p></li>
<li class="listitem"><p>
Shrinking diameter. The diameter of the network decreases in
     time.

</p></li>
</ul></div>
<p>

</p>
<p>
The network is generated in the following way. One vertex is added at
a time. This vertex connects to (cites) <code class="literal">ambs</code> vertices already
present in the network, chosen uniformly random. Now, for each cited
vertex <code class="literal">v</code> we do the following procedure:
</p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>
We generate two random numbers, <code class="literal">x</code> and <code class="literal">y</code>, that are
  geometrically distributed with means <code class="literal">p/(1-p)</code> and
  <code class="literal">rp(1-rp)</code>. (<code class="literal">p</code> is <em class="parameter"><code>fw_prob</code></em>, <code class="literal">r</code> is
  <em class="parameter"><code>bw_factor</code></em>.) The new vertex cites <code class="literal">x</code> outgoing neighbors
  and <code class="literal">y</code> incoming neighbors of <code class="literal">v</code>, from those which are
  not yet cited by the new vertex. If there are less than <code class="literal">x</code> or
  <code class="literal">y</code> such vertices available then we cite all of them.

</p></li>
<li class="listitem"><p>
The same procedure is applied to all the newly cited
  vertices.

</p></li>
</ol></div>
<p>

</p>
<p>
See also:
Jure Leskovec, Jon Kleinberg and Christos Faloutsos. Graphs over time:
densification laws, shrinking diameters and possible explanations.
<span class="emphasis"><em> KDD '05: Proceeding of the eleventh ACM SIGKDD international
conference on Knowledge discovery in data mining </em></span>, 177--187, 2005.

</p>
<p>
Note however, that the version of the model in the published paper is incorrect
in the sense that it cannot generate the kind of graphs the authors
claim. A corrected version is available from
<a class="ulink" href="http://cs.stanford.edu/people/jure/pubs/powergrowth-tkdd.pdf" target="_top">http://cs.stanford.edu/people/jure/pubs/powergrowth-tkdd.pdf</a> , our
implementation is based on this.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>fw_prob</code></em>:</span></p></td>
<td><p>
  The forward burning probability.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>bw_factor</code></em>:</span></p></td>
<td><p>
  The backward burning ratio. The backward burning
      probability is calculated as <code class="literal">bw_factor * fw_prob</code>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pambs</code></em>:</span></p></td>
<td><p>
  The number of ambassador vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Whether to create a directed graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_rewire"></a>2.13. <code class="function">igraph_rewire</code> —  Randomly rewires a graph while preserving its degree sequence.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.15.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_rewire(igraph_t *graph, igraph_integer_t n, igraph_rewiring_t mode);
</pre></div>
<p>
</p>
<p>




</p>
<p>
This function generates a new graph based on the original one by randomly
rewiring edges while preserving the original graph's degree sequence.
The rewiring is done "in place", so no new graph will
be allocated. If you would like to keep the original graph intact, use
<a class="link" href="igraph-Basic.html#igraph_copy" title="4.1.3. igraph_copy — Creates an exact (deep) copy of a graph."><code class="function">igraph_copy()</code></a> beforehand. All graph attributes will be lost.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The graph object to be rewired.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Number of rewiring trials to perform.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mode</code></em>:</span></p></td>
<td>
<p>
  The rewiring algorithm to be used. It can be one of the following flags:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_REWIRING_SIMPLE</code></span></p></td>
<td><p>

               Simple rewiring algorithm which chooses two arbitrary edges
               in each step (namely (a,b) and (c,d)) and substitutes them
               with (a,d) and (c,b) if they don't exist.  The method will
               neither destroy nor create self-loops.
          
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_REWIRING_SIMPLE_LOOPS</code></span></p></td>
<td><p>

               Same as <code class="constant">IGRAPH_REWIRING_SIMPLE</code> but allows the creation or
               destruction of self-loops.
        
</p></td>
</tr>
</tbody>
</table></div>
</td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td>
<p>
  Error code:
        </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVMODE</code></span></p></td>
<td><p>

               Invalid rewiring mode.
          
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_EINVAL</code></span></p></td>
<td><p>

               Graph unsuitable for rewiring (e.g. it has
               less than 4 nodes in case of <code class="constant">IGRAPH_REWIRING_SIMPLE</code>)
          
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ENOMEM</code></span></p></td>
<td><p>

               Not enough memory for temporary data.
        
</p></td>
</tr>
</tbody>
</table></div>
<p>
  </p>
</td>
</tr></tbody>
</table></div>
<p>

Time complexity: TODO.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_growing_random_game"></a>2.14. <code class="function">igraph_growing_random_game</code> —  Generates a growing random graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.16.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_growing_random_game(igraph_t *graph, igraph_integer_t n,
                               igraph_integer_t m, igraph_bool_t directed,
                               igraph_bool_t citation);
</pre></div>
<p>
</p>
<p>




This function simulates a growing random graph. We start out with
one vertex. In each step a new vertex is added and a number of new
edges are also added. These graphs are known to be different
from standard (not growing) random graphs.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The number of edges to add in a time step (i.e. after
       adding a vertex).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to generate a directed graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>citation</code></em>:</span></p></td>
<td><p>
  Boolean, if <code class="constant">true</code>, the edges always
       originate from the most recently added vertex and are
       connected to a previous vertex.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
         <code class="constant">IGRAPH_EINVAL</code>: invalid
         <em class="parameter"><code>n</code></em> or <em class="parameter"><code>m</code></em>
         parameter.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the
number of vertices plus the number of edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_callaway_traits_game"></a>2.15. <code class="function">igraph_callaway_traits_game</code> —  Simulates a growing network with vertex types.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.17.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_callaway_traits_game(igraph_t *graph, igraph_integer_t nodes,
                                igraph_integer_t types, igraph_integer_t edges_per_step,
                                const igraph_vector_t *type_dist,
                                const igraph_matrix_t *pref_matrix,
                                igraph_bool_t directed,
                                igraph_vector_int_t *node_type_vec);
</pre></div>
<p>
</p>
<p>



The different types of vertices prefer to connect other types of
vertices with a given probability.

</p>
<p>
The simulation goes like this: in each discrete time step a new
vertex is added to the graph. The type of this vertex is generated
based on <em class="parameter"><code>type_dist</code></em>. Then two vertices are selected uniformly
randomly from the graph. The probability that they will be
connected depends on the types of these vertices and is taken from
<em class="parameter"><code>pref_matrix</code></em>. Then another two vertices are selected and this is
repeated <em class="parameter"><code>edges_per_step</code></em> times in each time step.

</p>
<p>
References:

</p>
<p>
D. S. Callaway, J. E. Hopcroft, J. M. Kleinberg, M. E. J. Newman, and S. H. Strogatz,
Are randomly grown graphs really random?
Phys. Rev. E 64, 041902 (2001).
<a class="ulink" href="https://doi.org/10.1103/PhysRevE.64.041902" target="_top">https://doi.org/10.1103/PhysRevE.64.041902</a>

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of nodes in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Number of node types.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges_per_step</code></em>:</span></p></td>
<td><p>
  The number of connections tried in each time step.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type_dist</code></em>:</span></p></td>
<td><p>
  Vector giving the distribution of the vertex types.
If <code class="constant">NULL</code>, the distribution is assumed to be uniform.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pref_matrix</code></em>:</span></p></td>
<td><p>
  Matrix giving the connection probabilities for
the vertex types.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, whether to generate a directed graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_type_vec</code></em>:</span></p></td>
<td><p>
  An initialized vector or <code class="constant">NULL</code>.
If not <code class="constant">NULL</code>, the type of each node will be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Added in version 0.2.</p>
<p>

Time complexity: O(|V|*k*log(|V|)), |V| is the number of vertices,
k is <em class="parameter"><code>edges_per_step</code></em>.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_establishment_game"></a>2.16. <code class="function">igraph_establishment_game</code> —  Generates a graph with a simple growing model with vertex types.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.18.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_establishment_game(igraph_t *graph, igraph_integer_t nodes,
                              igraph_integer_t types, igraph_integer_t k,
                              const igraph_vector_t *type_dist,
                              const igraph_matrix_t *pref_matrix,
                              igraph_bool_t directed,
                              igraph_vector_int_t *node_type_vec);
</pre></div>
<p>
</p>
<p>



</p>
<p>
The simulation goes like this: a single vertex is added at each
time step. This new vertex tries to connect to <em class="parameter"><code>k</code></em> vertices in the
graph. The probability that such a connection is realized depends
on the types of the vertices involved.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  The number of vertex types.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>k</code></em>:</span></p></td>
<td><p>
  The number of connections tried in each time step.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type_dist</code></em>:</span></p></td>
<td><p>
  Vector giving the distribution of vertex types.
If <code class="constant">NULL</code>, the distribution is assumed to be uniform.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pref_matrix</code></em>:</span></p></td>
<td><p>
  Matrix giving the connection probabilities for
different vertex types.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, whether to generate a directed graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_type_vec</code></em>:</span></p></td>
<td><p>
  An initialized vector or <code class="constant">NULL</code>.
If not <code class="constant">NULL</code>, the type of each node will be stored here.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Added in version 0.2.</p>
<p>

Time complexity: O(|V|*k*log(|V|)), |V| is the number of vertices
and k is the <em class="parameter"><code>k</code></em> parameter.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_preference_game"></a>2.17. <code class="function">igraph_preference_game</code> —  Generates a graph with vertex types and connection preferences.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.19.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_preference_game(igraph_t *graph, igraph_integer_t nodes,
                           igraph_integer_t types,
                           const igraph_vector_t *type_dist,
                           igraph_bool_t fixed_sizes,
                           const igraph_matrix_t *pref_matrix,
                           igraph_vector_int_t *node_type_vec,
                           igraph_bool_t directed,
                           igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This is practically the nongrowing variant of
<a class="link" href="igraph-Generators.html#igraph_establishment_game" title="2.16. igraph_establishment_game — Generates a graph with a simple growing model with vertex types."><code class="function">igraph_establishment_game()</code></a>. A given number of vertices are
generated. Every vertex is assigned to a vertex type according to
the given type probabilities. Finally, every
vertex pair is evaluated and an edge is created between them with a
probability depending on the types of the vertices involved.

</p>
<p>
In other words, this function generates a graph according to a
block-model. Vertices are divided into groups (or blocks), and
the probability the two vertices are connected depends on their
groups only.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  The number of vertex types.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type_dist</code></em>:</span></p></td>
<td><p>
  Vector giving the distribution of vertex types. If
  <code class="constant">NULL</code>, all vertex types will have equal probability. See also the
  <em class="parameter"><code>fixed_sizes</code></em> argument.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>fixed_sizes</code></em>:</span></p></td>
<td><p>
  Boolean. If true, then the number of vertices with a
  given vertex type is fixed and the <em class="parameter"><code>type_dist</code></em> argument gives these
  numbers for each vertex type. If true, and <em class="parameter"><code>type_dist</code></em> is <code class="constant">NULL</code>,
  then the function tries to make vertex groups of the same size. If this
  is not possible, then some groups will have an extra vertex.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pref_matrix</code></em>:</span></p></td>
<td><p>
  Matrix giving the connection probabilities for
  different vertex types. This should be symmetric if the requested
  graph is undirected.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_type_vec</code></em>:</span></p></td>
<td><p>
  A vector where the individual generated vertex types
  will be stored. If <code class="constant">NULL</code>, the vertex types won't be saved.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, whether to generate a directed graph. If undirected
  graphs are requested, only the lower left triangle of the preference
  matrix is considered.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Logical, whether loop edges are allowed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Added in version 0.3.</p>
<p>

Time complexity: O(|V|+|E|), the
number of vertices plus the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_asymmetric_preference_game" title="2.18. igraph_asymmetric_preference_game — Generates a graph with asymmetric vertex types and connection preferences."><code class="function">igraph_asymmetric_preference_game()</code></a>,
<a class="link" href="igraph-Generators.html#igraph_establishment_game" title="2.16. igraph_establishment_game — Generates a graph with a simple growing model with vertex types."><code class="function">igraph_establishment_game()</code></a>, <a class="link" href="igraph-Generators.html#igraph_callaway_traits_game" title="2.15. igraph_callaway_traits_game — Simulates a growing network with vertex types."><code class="function">igraph_callaway_traits_game()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_asymmetric_preference_game"></a>2.18. <code class="function">igraph_asymmetric_preference_game</code> —  Generates a graph with asymmetric vertex types and connection preferences.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.20.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_asymmetric_preference_game(igraph_t *graph, igraph_integer_t nodes,
                                      igraph_integer_t no_out_types,
                                      igraph_integer_t no_in_types,
                                      const igraph_matrix_t *type_dist_matrix,
                                      const igraph_matrix_t *pref_matrix,
                                      igraph_vector_int_t *node_type_out_vec,
                                      igraph_vector_int_t *node_type_in_vec,
                                      igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This is the asymmetric variant of <a class="link" href="igraph-Generators.html#igraph_preference_game" title="2.17. igraph_preference_game — Generates a graph with vertex types and connection preferences."><code class="function">igraph_preference_game()</code></a>.
A given number of vertices are generated. Every vertex is assigned to an
"outgoing" and an "incoming " vertex type according to the given joint
type probabilities. Finally, every vertex pair is evaluated and a
directed edge is created between them with a probability depending on the
"outgoing" type of the source vertex and the "incoming" type of the target
vertex.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no_out_types</code></em>:</span></p></td>
<td><p>
  The number of vertex out-types.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>no_in_types</code></em>:</span></p></td>
<td><p>
  The number of vertex in-types.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type_dist_matrix</code></em>:</span></p></td>
<td><p>
  Matrix of size <code class="literal">out_types * in_types</code>,
  giving the joint distribution of vertex types.
  If <code class="constant">NULL</code>, incoming and outgoing vertex types are independent and uniformly
  distributed.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pref_matrix</code></em>:</span></p></td>
<td><p>
  Matrix of size <code class="literal">out_types * in_types</code>,
  giving the connection probabilities for different vertex types.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_type_out_vec</code></em>:</span></p></td>
<td><p>
  A vector where the individual generated "outgoing"
  vertex types will be stored. If <code class="constant">NULL</code>, the vertex types won't be saved.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node_type_in_vec</code></em>:</span></p></td>
<td><p>
  A vector where the individual generated "incoming"
  vertex types will be stored. If <code class="constant">NULL</code>, the vertex types won't be saved.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Logical, whether loop edges are allowed.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Added in version 0.3.</p>
<p>

Time complexity: O(|V|+|E|), the
number of vertices plus the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_preference_game" title="2.17. igraph_preference_game — Generates a graph with vertex types and connection preferences."><code class="function">igraph_preference_game()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_recent_degree_game"></a>2.19. <code class="function">igraph_recent_degree_game</code> —  Stochastic graph generator based on the number of incident edges a node has gained recently.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.21.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_recent_degree_game(igraph_t *graph, igraph_integer_t nodes,
                              igraph_real_t power,
                              igraph_integer_t time_window,
                              igraph_integer_t m,
                              const igraph_vector_int_t *outseq,
                              igraph_bool_t outpref,
                              igraph_real_t zero_appeal,
                              igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph, this is the same as
       the number of time steps.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>power</code></em>:</span></p></td>
<td><p>
  The exponent, the probability that a node gains a
       new edge is proportional to the number of edges it has
       gained recently (in the last <em class="parameter"><code>window</code></em> time steps) to <em class="parameter"><code>power</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>time_window</code></em>:</span></p></td>
<td><p>
  Integer constant, the size of the time window to use
       to count the number of recent edges.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  Integer constant, the number of edges to add per time
       step if the <em class="parameter"><code>outseq</code></em> parameter is a null pointer or a
       zero-length vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>outseq</code></em>:</span></p></td>
<td><p>
  The number of edges to add in each time step. This
       argument is ignored if it is a null pointer or a zero length
       vector. In this case the constant <em class="parameter"><code>m</code></em> parameter is used.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>outpref</code></em>:</span></p></td>
<td><p>
  Logical constant, if true the edges originated by a
       vertex also count as recent incident edges.
       For most applications it is reasonable to set it to false.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>zero_appeal</code></em>:</span></p></td>
<td><p>
  Constant giving the attractiveness of the
       vertices which haven't gained any edge recently.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical constant, whether to generate a directed
       graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*log(|V|)+|E|), |V| is the number of
vertices, |E| is the number of edges in the graph.

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_barabasi_aging_game"></a>2.20. <code class="function">igraph_barabasi_aging_game</code> —  Preferential attachment with aging of vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.22.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_barabasi_aging_game(igraph_t *graph,
                               igraph_integer_t nodes,
                               igraph_integer_t m,
                               const igraph_vector_int_t *outseq,
                               igraph_bool_t outpref,
                               igraph_real_t pa_exp,
                               igraph_real_t aging_exp,
                               igraph_integer_t aging_bins,
                               igraph_real_t zero_deg_appeal,
                               igraph_real_t zero_age_appeal,
                               igraph_real_t deg_coef,
                               igraph_real_t age_coef,
                               igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This game starts with one vertex (if <em class="parameter"><code>nodes</code></em> &gt; 0). In each step
a new node is added, and it is connected to <em class="parameter"><code>m</code></em> existing nodes.
Existing nodes to connect to are chosen with probability dependent
on their (in-)degree (<code class="constant">k</code>) and age (<code class="constant">l</code>).
The degree-dependent part is
<code class="literal">deg_coef * k^pa_exp + zero_deg_appeal</code>,
while the age-dependent part is
<code class="literal">age_coef * l^aging_exp + zero_age_appeal</code>,
which are multiplied to obtain the final weight.

</p>
<p>
The age <code class="constant">l</code> is based on the number of vertices in the
network and the <em class="parameter"><code>aging_bins</code></em> argument: the age of a node
is incremented by 1 after each
<code class="literal">floor(nodes / aging_bins) + 1</code>
time steps.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The number of edges to add in each time step.
       Ignored if <em class="parameter"><code>outseq</code></em> is a non-zero length vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>outseq</code></em>:</span></p></td>
<td><p>
  The number of edges to add in each time step. If it
       is <code class="constant">NULL</code> or a zero-length vector then it is ignored
       and the <em class="parameter"><code>m</code></em> argument is used instead.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>outpref</code></em>:</span></p></td>
<td><p>
  Logical constant, whether the edges
       initiated by a vertex contribute to the probability to gain
       a new edge.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pa_exp</code></em>:</span></p></td>
<td><p>
  The exponent of the preferential attachment, a small
       positive number usually, the value 1 yields the classic
       linear preferential attachment.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>aging_exp</code></em>:</span></p></td>
<td><p>
  The exponent of the aging, this is a negative
       number usually.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>aging_bins</code></em>:</span></p></td>
<td><p>
  Integer constant, the number of age bins to use.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>zero_deg_appeal</code></em>:</span></p></td>
<td><p>
  The degree dependent part of the
       attractiveness of the zero degree vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>zero_age_appeal</code></em>:</span></p></td>
<td><p>
  The age dependent part of the attractiveness
       of the vertices of age zero. This parameter is usually zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>deg_coef</code></em>:</span></p></td>
<td><p>
  The coefficient for the degree.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>age_coef</code></em>:</span></p></td>
<td><p>
  The coefficient for the age.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical constant, whether to generate a directed
       graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O((|V|+|V|/aging_bins)*log(|V|)+|E|). |V| is the number
of vertices, |E| the number of edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_recent_degree_aging_game"></a>2.21. <code class="function">igraph_recent_degree_aging_game</code> —  Preferential attachment based on the number of edges gained recently, with aging of vertices.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.23.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_recent_degree_aging_game(igraph_t *graph,
                                    igraph_integer_t nodes,
                                    igraph_integer_t m,
                                    const igraph_vector_int_t *outseq,
                                    igraph_bool_t outpref,
                                    igraph_real_t pa_exp,
                                    igraph_real_t aging_exp,
                                    igraph_integer_t aging_bins,
                                    igraph_integer_t time_window,
                                    igraph_real_t zero_appeal,
                                    igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



</p>
<p>
This game is very similar to <a class="link" href="igraph-Generators.html#igraph_barabasi_aging_game" title="2.20. igraph_barabasi_aging_game — Preferential attachment with aging of vertices."><code class="function">igraph_barabasi_aging_game()</code></a>,
except that instead of the total number of incident edges the
number of edges gained in the last <em class="parameter"><code>time_window</code></em> time steps are
counted.

</p>
<p>The degree dependent part of the attractiveness is
given by k to the power of <em class="parameter"><code>pa_exp</code></em> plus <em class="parameter"><code>zero_appeal</code></em>; the age
dependent part is l to the power to <em class="parameter"><code>aging_exp</code></em>.
k is the number of edges gained in the last <em class="parameter"><code>time_window</code></em> time
steps, l is the age of the vertex.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The number of edges to add in each time step. If the <em class="parameter"><code>outseq</code></em> argument is not a null vector or a zero-length vector
       then it is ignored.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>outseq</code></em>:</span></p></td>
<td><p>
  Vector giving the number of edges to add in each time
       step. If it is a null pointer or a zero-length vector then
       it is ignored and the <em class="parameter"><code>m</code></em> argument is used.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>outpref</code></em>:</span></p></td>
<td><p>
  Logical constant, if true the edges initiated by a
       vertex are also counted. Normally it is false.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pa_exp</code></em>:</span></p></td>
<td><p>
  The exponent for the preferential attachment.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>aging_exp</code></em>:</span></p></td>
<td><p>
  The exponent for the aging, normally it is
       negative: old vertices gain edges with less probability.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>aging_bins</code></em>:</span></p></td>
<td><p>
  Integer constant, the number of age bins to use.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>time_window</code></em>:</span></p></td>
<td><p>
  The time window to use to count the number of
       incident edges for the vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>zero_appeal</code></em>:</span></p></td>
<td><p>
  The degree dependent part of the attractiveness
       for zero degree vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical constant, whether to create a directed
       graph.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O((|V|+|V|/aging_bins)*log(|V|)+|E|). |V| is the number
of vertices, |E| the number of edges.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_lastcit_game"></a>2.22. <code class="function">igraph_lastcit_game</code> —  Simulates a citation network, based on time passed since the last citation.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.24.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_lastcit_game(igraph_t *graph,
                        igraph_integer_t nodes, igraph_integer_t edges_per_node,
                        igraph_integer_t agebins,
                        const igraph_vector_t *preference,
                        igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



This is a quite special stochastic graph generator, it models an
evolving graph. In each time step a single vertex is added to the
network and it cites a number of other vertices (as specified by
the <em class="parameter"><code>edges_per_step</code></em> argument). The cited vertices are selected
based on the last time they were cited. Time is measured by the
addition of vertices and it is binned into <em class="parameter"><code>agebins</code></em> bins.
So if the current time step is <code class="constant">t</code> and the last citation to a
given <code class="constant">i</code> vertex was made in time step <code class="constant">t0</code>, then \c
(t-t0)/binwidth is calculated where binwidth is <code class="constant">nodes</code>/agebins+1,
in the last expression '/' denotes integer division, so the
fraction part is omitted.

</p>
<p>
The <em class="parameter"><code>preference</code></em> argument specifies the preferences for the
citation lags, i.e. its first elements contains the attractivity
of the very recently cited vertices, etc. The last element is
special, it contains the attractivity of the vertices which were
never cited. This element should be bigger than zero.

</p>
<p>
Note that this function generates networks with multiple edges if
<em class="parameter"><code>edges_per_step</code></em> is bigger than one, call <a class="link" href="igraph-Operators.html#igraph_simplify" title="3.7. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a>
on the result to get rid of these edges.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object, the result
    will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>node</code></em>:</span></p></td>
<td><p>
  The number of vertices in the network.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges_per_node</code></em>:</span></p></td>
<td><p>
  The number of edges to add in each time
    step.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>agebins</code></em>:</span></p></td>
<td><p>
  The number of age bins to use.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>preference</code></em>:</span></p></td>
<td><p>
  Pointer to an initialized vector of length
    <code class="constant">agebins</code>+1. This contains the "attractivity" of the various
    age bins, the last element is the attractivity of the vertices
    which were never cited, and it should be greater than zero.
    It is a good idea to have all positive values in this vector.
    Preferences cannot be negative.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical constant, whether to create directed
     networks.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_barabasi_aging_game" title="2.20. igraph_barabasi_aging_game — Preferential attachment with aging of vertices."><code class="function">igraph_barabasi_aging_game()</code></a>.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|*a+|E|*log|V|), |V| is the number of vertices,
|E| is the total number of edges, a is the <em class="parameter"><code>agebins</code></em> parameter.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_cited_type_game"></a>2.23. <code class="function">igraph_cited_type_game</code> —  Simulates a citation based on vertex types.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.25.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_cited_type_game(igraph_t *graph, igraph_integer_t nodes,
                           const igraph_vector_int_t *types,
                           const igraph_vector_t *pref,
                           igraph_integer_t edges_per_step,
                           igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



Function to create a network based on some vertex categories. This
function creates a citation network: in each step a single vertex
and <em class="parameter"><code>edges_per_step</code></em> citing edges are added. Nodes with
different categories may have different probabilities to get
cited, as given by the <em class="parameter"><code>pref</code></em> vector.

</p>
<p>
Note that this function might generate networks with multiple edges
if <em class="parameter"><code>edges_per_step</code></em> is greater than one. You might want to call
<a class="link" href="igraph-Operators.html#igraph_simplify" title="3.7. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a> on the result to remove multiple edges.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of vertices in the network.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  Numeric vector giving the categories of the vertices,
    so it should contain <em class="parameter"><code>nodes</code></em> non-negative integer
    numbers. Types are numbered from zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pref</code></em>:</span></p></td>
<td><p>
  The attractivity of the different vertex categories in
    a vector. Its length should be the maximum element in <em class="parameter"><code>types</code></em>
    plus one (types are numbered from zero).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges_per_step</code></em>:</span></p></td>
<td><p>
  Integer constant, the number of edges to add
    in each time step.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical constant, whether to create a directed
    network.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_citing_cited_type_game" title="2.24. igraph_citing_cited_type_game — Simulates a citation network based on vertex types."><code class="function">igraph_citing_cited_type_game()</code></a> for a bit more general
game.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O((|V|+|E|)log|V|), |V| and |E| are number of
vertices and edges, respectively.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_citing_cited_type_game"></a>2.24. <code class="function">igraph_citing_cited_type_game</code> —  Simulates a citation network based on vertex types.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.26.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_citing_cited_type_game(igraph_t *graph, igraph_integer_t nodes,
                                  const igraph_vector_int_t *types,
                                  const igraph_matrix_t *pref,
                                  igraph_integer_t edges_per_step,
                                  igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



This game is similar to <a class="link" href="igraph-Generators.html#igraph_cited_type_game" title="2.23. igraph_cited_type_game — Simulates a citation based on vertex types."><code class="function">igraph_cited_type_game()</code></a> but here the
category of the citing vertex is also considered.

</p>
<p>
An evolving citation network is modeled here, a single vertex and
its <em class="parameter"><code>edges_per_step</code></em> citation are added in each time step. The
odds the a given vertex is cited by the new vertex depends on the
category of both the citing and the cited vertex and is given in
the <em class="parameter"><code>pref</code></em> matrix. The categories of the citing vertex correspond
to the rows, the categories of the cited vertex to the columns of
this matrix. I.e. the element in row <code class="constant">i</code> and column <code class="constant">j</code> gives the
probability that a <code class="constant">j</code> vertex is cited, if the category of the
citing vertex is <code class="constant">i</code>.

</p>
<p>
Note that this function might generate networks with multiple edges
if <em class="parameter"><code>edges_per_step</code></em> is greater than one. You might want to call
<a class="link" href="igraph-Operators.html#igraph_simplify" title="3.7. igraph_simplify — Removes loop and/or multiple edges from the graph."><code class="function">igraph_simplify()</code></a> on the result to remove multiple edges.
</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>nodes</code></em>:</span></p></td>
<td><p>
  The number of vertices in the network.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>types</code></em>:</span></p></td>
<td><p>
  A numeric vector of length <em class="parameter"><code>nodes</code></em>, containing the
   categories of the vertices. The categories are numbered from
   zero.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pref</code></em>:</span></p></td>
<td><p>
  The preference matrix, a square matrix is required,
    both the number of rows and columns should be the maximum
    element in <em class="parameter"><code>types</code></em> plus one (types are numbered from zero).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>edges_per_step</code></em>:</span></p></td>
<td><p>
  Integer constant, the number of edges to add
    in each time step.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical constant, whether to create a directed
    network.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O((|V|+|E|)log|V|), |V| and |E| are number of
vertices and edges, respectively.
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_sbm_game"></a>2.25. <code class="function">igraph_sbm_game</code> —  Sample from a stochastic block model.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.27.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_sbm_game(igraph_t *graph, igraph_integer_t n,
                    const igraph_matrix_t *pref_matrix,
                    const igraph_vector_int_t *block_sizes,
                    igraph_bool_t directed, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>



This function samples graphs from a stochastic block
model by (doing the equivalent of) Bernoulli
trials for each potential edge with the probabilities
given by the Bernoulli rate matrix, <em class="parameter"><code>pref_matrix</code></em>.
See Faust, K., &amp; Wasserman, S. (1992a). Blockmodels:
Interpretation and evaluation. Social Networks, 14, 5-–61.

</p>
<p>
The order of the vertex IDs in the generated graph corresponds to
the <em class="parameter"><code>block_sizes</code></em> argument.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The output graph. This should be a pointer to an
    uninitialized graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  Number of vertices.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>pref_matrix</code></em>:</span></p></td>
<td><p>
  The matrix giving the Bernoulli rates.
    This is a KxK matrix, where K is the number of groups.
    The probability of creating an edge between vertices from
    groups i and j is given by element (i,j).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>block_sizes</code></em>:</span></p></td>
<td><p>
  An integer vector giving the number of
    vertices in each group.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Boolean, whether to create a directed graph. If
    this argument is false, then <em class="parameter"><code>pref_matrix</code></em> must be symmetric.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Boolean, whether to create self-loops.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|+K^2), where |V| is the number of
vertices, |E| is the number of edges, and K is the number of
groups.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game_gnp" title="2.4. igraph_erdos_renyi_game_gnp — Generates a random (Erdős-Rényi) graph with fixed edge probabilities."><code class="function">igraph_erdos_renyi_game_gnp()</code></a> for a simple Bernoulli graph.
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_hsbm_game"></a>2.26. <code class="function">igraph_hsbm_game</code> —  Hierarchical stochastic block model.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.28.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_hsbm_game(igraph_t *graph, igraph_integer_t n,
                     igraph_integer_t m, const igraph_vector_t *rho,
                     const igraph_matrix_t *C, igraph_real_t p);
</pre></div>
<p>
</p>
<p>



The function generates a random graph according to the hierarchical
stochastic block model.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The generated graph is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>m</code></em>:</span></p></td>
<td><p>
  The number of vertices per block. n/m must be integer.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rho</code></em>:</span></p></td>
<td><p>
  The fraction of vertices per cluster,
       within a block. Must sum up to 1, and rho * m must be integer
       for all elements of rho.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>C</code></em>:</span></p></td>
<td><p>
  A square, symmetric numeric matrix, the Bernoulli rates for
       the clusters within a block. Its size must mach the size of the
       <em class="parameter"><code>rho</code></em> vector.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  The Bernoulli rate of connections between
       vertices in different blocks.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_sbm_game" title="2.25. igraph_sbm_game — Sample from a stochastic block model."><code class="function">igraph_sbm_game()</code></a> for the classic stochastic block model,
<a class="link" href="igraph-Generators.html#igraph_hsbm_list_game" title="2.27. igraph_hsbm_list_game — Hierarchical stochastic block model, more general version."><code class="function">igraph_hsbm_list_game()</code></a> for a more general version.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_hsbm_list_game"></a>2.27. <code class="function">igraph_hsbm_list_game</code> —  Hierarchical stochastic block model, more general version.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.29.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_hsbm_list_game(igraph_t *graph, igraph_integer_t n,
                          const igraph_vector_int_t *mlist,
                          const igraph_vector_list_t *rholist,
                          const igraph_matrix_list_t *Clist,
                          igraph_real_t p);
</pre></div>
<p>
</p>
<p>



The function generates a random graph according to the hierarchical
stochastic block model.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The generated graph is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>mlist</code></em>:</span></p></td>
<td><p>
  An integer vector of block sizes.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>rholist</code></em>:</span></p></td>
<td><p>
  A list of rho vectors (<code class="constant">igraph_vector_t</code> objects), one
       for each block.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>Clist</code></em>:</span></p></td>
<td><p>
  A list of square matrices (<code class="constant">igraph_matrix_t</code> objects),
       one for each block, specifying the Bernoulli rates of connections
       within the block.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  The Bernoulli rate of connections between
       vertices in different blocks.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_sbm_game" title="2.25. igraph_sbm_game — Sample from a stochastic block model."><code class="function">igraph_sbm_game()</code></a> for the classic stochastic block model,
<a class="link" href="igraph-Generators.html#igraph_hsbm_game" title="2.26. igraph_hsbm_game — Hierarchical stochastic block model."><code class="function">igraph_hsbm_game()</code></a> for a simpler general version.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_dot_product_game"></a>2.28. <code class="function">igraph_dot_product_game</code> —  Generates a random dot product graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.30.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_dot_product_game(igraph_t *graph, const igraph_matrix_t *vecs,
                            igraph_bool_t directed);
</pre></div>
<p>
</p>
<p>



In this model, each vertex is represented by a latent
position vector. Probability of an edge between two vertices are given
by the dot product of their latent position vectors.

</p>
<p>
See also Christine Leigh Myers Nickel: Random dot product graphs, a
model for social networks. Dissertation, Johns Hopkins University,
Maryland, USA, 2006.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  The output graph is stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>vecs</code></em>:</span></p></td>
<td><p>
  A matrix in which each latent position vector is a
   column. The dot product of the latent position vectors should be
   in the [0,1] interval, otherwise a warning is given. For
   negative dot products, no edges are added; dot products that are
   larger than one always add an edge.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Should the generated graph be directed?
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(n*n*m), where n is the number of vertices,
and m is the length of the latent vectors.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Nongraph.html#igraph_sample_dirichlet" title="4.3. igraph_sample_dirichlet — Sample points from a Dirichlet distribution."><code class="function">igraph_sample_dirichlet()</code></a>, <a class="link" href="igraph-Nongraph.html#igraph_sample_sphere_volume" title="4.2. igraph_sample_sphere_volume — Sample points uniformly from the volume of a sphere."><code class="function">igraph_sample_sphere_volume()</code></a>, <a class="link" href="igraph-Nongraph.html#igraph_sample_sphere_surface" title="4.1. igraph_sample_sphere_surface — Sample points uniformly from the surface of a sphere."><code class="function">igraph_sample_sphere_surface()</code></a>
for functions to generate the latent vectors.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_tree_game"></a>2.29. <code class="function">igraph_tree_game</code> —  Generates a random tree with the given number of nodes.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.31.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_tree_game(igraph_t *graph, igraph_integer_t n, igraph_bool_t directed, igraph_random_tree_t method);
</pre></div>
<p>
</p>
<p>




This function samples uniformly from the set of labelled trees,
i.e. it generates each labelled tree with the same probability.

</p>
<p>
Note that for <code class="literal">n=0</code>, the null graph is returned,
which is not considered to be a tree by <a class="link" href="igraph-Structural.html#igraph_is_tree" title="15.5. igraph_is_tree — Decides whether the graph is a tree."><code class="function">igraph_is_tree()</code></a>.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of nodes in the tree.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Whether to create a directed tree. The edges are oriented away from the root.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>method</code></em>:</span></p></td>
<td>
<p>
  The algorithm to use to generate the tree. Possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_RANDOM_TREE_PRUFER</code></span></p></td>
<td><p>

         This algorithm samples Prüfer sequences uniformly, then converts them to trees.
         Directed trees are not currently supported.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_RANDOM_LERW</code></span></p></td>
<td><p>

         This algorithm effectively performs a loop-erased random walk on the complete graph
         to uniformly sample its spanning trees (Wilson's algorithm).
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
         <code class="constant">IGRAPH_ENOMEM</code>: there is not enough
          memory to perform the operation.
         <code class="constant">IGRAPH_EINVAL</code>: invalid tree size
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_from_prufer" title="1.25. igraph_from_prufer — Generates a tree from a Prüfer sequence."><code class="function">igraph_from_prufer()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>

 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_correlated_game"></a>2.30. <code class="function">igraph_correlated_game</code> —  Generates a random graph correlated to an existing graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.32.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_correlated_game(const igraph_t *old_graph, igraph_t *new_graph,
                           igraph_real_t corr, igraph_real_t p,
                           const igraph_vector_int_t *permutation);
</pre></div>
<p>
</p>
<p>



Sample a new graph by perturbing the adjacency matrix of a
given simple graph and shuffling its vertices.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>old_graph</code></em>:</span></p></td>
<td><p>
  The original graph, it must be simple.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>new_graph</code></em>:</span></p></td>
<td><p>
  The new graph will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>corr</code></em>:</span></p></td>
<td><p>
  A scalar in the unit interval [0,1], the target Pearson
       correlation between the adjacency matrices of the original and the
       generated graph (the adjacency matrix being used as a vector).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  A numeric scalar, the probability of an edge between two
       vertices, it must in the open (0,1) interval. Typically,
       the density of <em class="parameter"><code>old_graph</code></em>.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>permutation</code></em>:</span></p></td>
<td><p>
  A permutation to apply to the vertices of the
       generated graph. It can also be a null pointer, in which case
       the vertices will not be permuted.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_correlated_pair_game" title="2.31. igraph_correlated_pair_game — Generates pairs of correlated random graphs."><code class="function">igraph_correlated_pair_game()</code></a> for generating a pair
of correlated random graphs in one go.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_correlated_pair_game"></a>2.31. <code class="function">igraph_correlated_pair_game</code> —  Generates pairs of correlated random graphs.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.33.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_correlated_pair_game(igraph_t *graph1, igraph_t *graph2,
                                igraph_integer_t n, igraph_real_t corr, igraph_real_t p,
                                igraph_bool_t directed,
                                const igraph_vector_int_t *permutation);
</pre></div>
<p>
</p>
<p>



Sample two random graphs, with given correlation.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph1</code></em>:</span></p></td>
<td><p>
  The first graph will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph2</code></em>:</span></p></td>
<td><p>
  The second graph will be stored here.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices in both graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>corr</code></em>:</span></p></td>
<td><p>
  A scalar in the unit interval, the target Pearson
       correlation between the adjacency matrices of the original the
       generated graph (the adjacency matrix being used as a vector).
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p</code></em>:</span></p></td>
<td><p>
  A numeric scalar, the probability of an edge between two
       vertices, it must in the open (0,1) interval.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Whether to generate directed graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>permutation</code></em>:</span></p></td>
<td><p>
  A permutation to apply to the vertices of the
       second graph. It can also be a null pointer, in which case
       the vertices will not be permuted.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code
  </p></td>
</tr></tbody>
</table></div>
<p>

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_correlated_game" title="2.30. igraph_correlated_game — Generates a random graph correlated to an existing graph."><code class="function">igraph_correlated_game()</code></a> for generating a correlated pair
to a given graph.
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_simple_interconnected_islands_game"></a>2.32. <code class="function">igraph_simple_interconnected_islands_game</code> —  Generates a random graph made of several interconnected islands, each island being a random graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.5.34.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_simple_interconnected_islands_game(
        igraph_t *graph,
        igraph_integer_t islands_n,
        igraph_integer_t islands_size,
        igraph_real_t islands_pin,
        igraph_integer_t n_inter);
</pre></div>
<p>
</p>
<p>




All islands are of the same size. Within an island, each edge is generated
with the same probability. A fixed number of additional edges are then
generated for each unordered pair of islands to connect them. The generated
graph is guaranteed to be simple.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>islands_n</code></em>:</span></p></td>
<td><p>
  The number of islands in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>islands_size</code></em>:</span></p></td>
<td><p>
  The size of islands in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>islands_pin</code></em>:</span></p></td>
<td><p>
  The probability to create each possible edge within islands.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n_inter</code></em>:</span></p></td>
<td><p>
  The number of edges to create between two islands. It may be
       larger than <em class="parameter"><code>islands_size</code></em> squared, but in this case it is assumed
       to be <em class="parameter"><code>islands_size</code></em> squared.</p></td>
</tr>
</tbody>
</table></div>
<p>


</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid parameter
        <code class="constant">IGRAPH_ENOMEM</code>: there is not enough memory for the operation.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the
number of vertices plus the number of edges in the graph.

 
</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="deprecated-graph-generators"></a>3. Deprecated functions</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="igraph-Generators.html#igraph_erdos_renyi_game">3.1. <code class="function">igraph_erdos_renyi_game</code> —  Generates a random (Erdős-Rényi) graph.</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_lattice">3.2. <code class="function">igraph_lattice</code> —  Arbitrary dimensional square lattices (deprecated).</a></span></dt>
<dt><span class="section"><a href="igraph-Generators.html#igraph_tree">3.3. <code class="function">igraph_tree</code> —  Creates a k-ary tree in which almost all vertices have k children (deprecated alias).</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_erdos_renyi_game"></a>3.1. <code class="function">igraph_erdos_renyi_game</code> —  Generates a random (Erdős-Rényi) graph.</h3></div></div></div>
<a class="indexterm" name="id-1.10.6.2.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_erdos_renyi_game(igraph_t *graph, igraph_erdos_renyi_t type,
                            igraph_integer_t n, igraph_real_t p_or_m,
                            igraph_bool_t directed, igraph_bool_t loops);
</pre></div>
<p>
</p>
<p>




This function is deprecated; use <a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game_gnm" title="2.3. igraph_erdos_renyi_game_gnm — Generates a random (Erdős-Rényi) graph with a fixed number of edges."><code class="function">igraph_erdos_renyi_game_gnm()</code></a> or
<a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game_gnp" title="2.4. igraph_erdos_renyi_game_gnp — Generates a random (Erdős-Rényi) graph with fixed edge probabilities."><code class="function">igraph_erdos_renyi_game_gnp()</code></a> instead.

</p>
<p><b>Arguments: </b>
</p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><em class="parameter"><code>graph</code></em>:</span></p></td>
<td><p>
  Pointer to an uninitialized graph object.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>type</code></em>:</span></p></td>
<td>
<p>
  The type of the random graph, possible values:
       </p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ERDOS_RENYI_GNM</code></span></p></td>
<td><p>

         G(n,m) graph,
         m edges are
         selected uniformly randomly in a graph with
         n vertices.
       
</p></td>
</tr>
<tr>
<td><p><span class="term"><code class="constant">IGRAPH_ERDOS_RENYI_GNP</code></span></p></td>
<td><p>

         G(n,p) graph,
         every possible edge is included in the graph with
         probability p.
       
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
</td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>n</code></em>:</span></p></td>
<td><p>
  The number of vertices in the graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>p_or_m</code></em>:</span></p></td>
<td><p>
  This is the p parameter for
       G(n,p) graphs and the
       m
       parameter for G(n,m) graphs.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>directed</code></em>:</span></p></td>
<td><p>
  Logical, whether to generate a directed graph.
</p></td>
</tr>
<tr>
<td><p><span class="term"><em class="parameter"><code>loops</code></em>:</span></p></td>
<td><p>
  Logical, whether to generate loops (self) edges.
</p></td>
</tr>
</tbody>
</table></div>
<p>
</p>
<p><b>Returns: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  Error code:
        <code class="constant">IGRAPH_EINVAL</code>: invalid
        <em class="parameter"><code>type</code></em>, <em class="parameter"><code>n</code></em>,
        <em class="parameter"><code>p</code></em> or <em class="parameter"><code>m</code></em>
         parameter.
        <code class="constant">IGRAPH_ENOMEM</code>: there is not enough
        memory for the operation.
  </p></td>
</tr></tbody>
</table></div>
<p>

Time complexity: O(|V|+|E|), the
number of vertices plus the number of edges in the graph.

</p>
<p><b>See also: </b></p>
<div class="variablelist"><table border="0" class="variablelist">
<colgroup>
<col align="left" valign="top">
<col>
</colgroup>
<tbody><tr>
<td><p><span class="term"><em class="parameter"><code></code></em></span></p></td>
<td><p>
  <a class="link" href="igraph-Generators.html#igraph_barabasi_game" title="2.2. igraph_barabasi_game — Generates a graph based on the Barabási-Albert model."><code class="function">igraph_barabasi_game()</code></a>, <a class="link" href="igraph-Generators.html#igraph_growing_random_game" title="2.14. igraph_growing_random_game — Generates a growing random graph."><code class="function">igraph_growing_random_game()</code></a>,
<a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game_gnm" title="2.3. igraph_erdos_renyi_game_gnm — Generates a random (Erdős-Rényi) graph with a fixed number of edges."><code class="function">igraph_erdos_renyi_game_gnm()</code></a>, <a class="link" href="igraph-Generators.html#igraph_erdos_renyi_game_gnp" title="2.4. igraph_erdos_renyi_game_gnp — Generates a random (Erdős-Rényi) graph with fixed edge probabilities."><code class="function">igraph_erdos_renyi_game_gnp()</code></a>
  </p></td>
</tr></tbody>
</table></div>
<p>
 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_lattice"></a>3.2. <code class="function">igraph_lattice</code> —  Arbitrary dimensional square lattices (deprecated).</h3></div></div></div>
<a class="indexterm" name="id-1.10.6.3.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_lattice(igraph_t *graph, const igraph_vector_int_t *dimvector,
                   igraph_integer_t nei, igraph_bool_t directed, igraph_bool_t mutual,
                   igraph_bool_t circular);
</pre></div>
<p>
</p>
<p>




</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.10.0. Please do not use this function in new
code; use <a class="link" href="igraph-Generators.html#igraph_square_lattice" title="1.10. igraph_square_lattice — Arbitrary dimensional square lattices."><code class="function">igraph_square_lattice()</code></a>
instead.</p>
</div>
<p> 
</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="igraph_tree"></a>3.3. <code class="function">igraph_tree</code> —  Creates a k-ary tree in which almost all vertices have k children (deprecated alias).</h3></div></div></div>
<a class="indexterm" name="id-1.10.6.4.2"></a><p>
</p>
<div class="informalexample"><pre class="programlisting">
igraph_error_t igraph_tree(igraph_t *graph, igraph_integer_t n, igraph_integer_t children,
                igraph_tree_mode_t type);
</pre></div>
<p>
</p>
<p>




</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Deprecated since version 0.10.0. Please do not use this function in new
code; use <a class="link" href="igraph-Generators.html#igraph_kary_tree" title="1.14. igraph_kary_tree — Creates a k-ary tree in which almost all vertices have k children."><code class="function">igraph_kary_tree()</code></a>
instead.</p>
</div>
<p> 
</p>
</div>
</div>
</div>
<table class="navigation-footer" width="100%" summary="Navigation footer" cellpadding="2" cellspacing="0"><tr valign="middle">
<td align="left"><a accesskey="p" href="igraph-Random.html"><b>← Chapter 8. Random numbers</b></a></td>
<td align="right"><a accesskey="n" href="igraph-Spatial-Games.html"><b>Chapter 10. Games on graphs →</b></a></td>
</tr></table>


      </div>
    </div>
  </div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	      &copy; 2003 &ndash; 2025 The igraph core team.
        &bull; Code licensed under <a href="http://www.gnu.org/licenses/gpl-2.0.html"> GNU GPL 2</a> or later,
        documentation under <a href="http://www.gnu.org/copyleft/fdl.html">GNU FDL</a>.
      </p>
      <p class="social">
        <a href="https://twitter.com/igraph2"><i class="fa-brands fa-twitter"></i></a>
        <a rel="me" href="https://fosstodon.org/@igraph"><i class="fa-brands fa-mastodon"></i></a>
        <a href="https://discord.gg/cSyHDPJWDD"><i class="fa-brands fa-discord"></i></a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'c', 'html/');
    </script>





    
  </body>
</html>
