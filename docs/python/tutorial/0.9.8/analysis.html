




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>Graph analysis</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/fontawesome.min.css" integrity="sha384-QYIZto+st3yW+o8+5OHfT6S482Zsvz2WfOzpFSXMF9zqeLcFV0/wlZpMtyFcZALm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/solid.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/brands.min.css">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DY4MJME11Z"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-DY4MJME11Z');
	</script>

    <link rel="top" title="igraph 0.9.8 documentation" href="index.html" /> <link rel="next" title="Visualisation of graphs" href="visualisation.html" /> <link rel="prev" title="Graph generation" href="generation.html" /> <link rel="stylesheet" href="_static/basic.css" type="text/css" /> <link rel="stylesheet" href="_static/pygments.css" type="text/css" /> <link rel="stylesheet" href="_static/other.css" type="text/css" />
  </head>

  <body class="python">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/python/versions/latest">python-igraph</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            0.9.8
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="https://r.igraph.org">igraph R package</a>
              <a class="dropdown-item" href="https://python.igraph.org">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa-brands fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa-solid fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa-solid fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa-solid fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa-brands fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">python-igraph Manual</h1>
        <p class="lead">For using igraph from Python</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

      <div class="main container">


<div class="row">
  <div class="col-md-12">
    <div class="navigation-header mb-4" width="100%" summary="Navigation header">
      <div class="btn-group" role="group">
        <a href="generation.html" title="Previous Chapter: Graph generation" class="btn btn-light" role="button" accesskey="P">
          <i class="fa fa-chevron-left"></i> Graph generation
        </a>
        <a href="index.html" title="Parent: igraph 0.9.8 documentation" class="btn btn-light" role="button" accesskey="U">
          <i class="fa fa-home"></i> igraph 0.9.8 documentation
        </a>
        <a href="visualisation.html" title="Next Chapter: Visualisation of graphs" class="btn btn-light" role="button" accesskey="N">
          Visualisation of graphs <i class="fa fa-chevron-right"></i>
        </a>
      </div>
    </div>
  </div>
</div>


    <div class="row">
      <div class="document col-md-12">
      <div class="documentwrapper bs-docs-section" id="top-of-docs">
        <h1 class="real">
          Graph analysis
          <a class="headerlink" href="#top-of-docs" title="Permalink to this headline">¶</a>
        </h1>
        <ul>
<li><a class="reference internal" href="#">Graph analysis</a><ul>
<li><a class="reference internal" href="#vertices-and-edges">Vertices and edges</a></li>
<li><a class="reference internal" href="#incidence">Incidence</a></li>
<li><a class="reference internal" href="#neighborhood">Neighborhood</a></li>
<li><a class="reference internal" href="#degrees">Degrees</a></li>
<li><a class="reference internal" href="#adding-and-removing-vertices-and-edges">Adding and removing vertices and edges</a></li>
<li><a class="reference internal" href="#graph-operators">Graph operators</a></li>
<li><a class="reference internal" href="#topological-sorting">Topological sorting</a></li>
<li><a class="reference internal" href="#graph-traversal">Graph traversal</a></li>
<li><a class="reference internal" href="#pathfinding-and-cuts">Pathfinding and cuts</a></li>
<li><a class="reference internal" href="#global-properties">Global properties</a></li>
<li><a class="reference internal" href="#vertex-properties">Vertex properties</a></li>
<li><a class="reference internal" href="#edge-properties">Edge properties</a></li>
<li><a class="reference internal" href="#matrix-representations">Matrix representations</a></li>
<li><a class="reference internal" href="#clustering">Clustering</a></li>
<li><a class="reference internal" href="#simplification-permutations-and-rewiring">Simplification, permutations and rewiring</a></li>
<li><a class="reference internal" href="#line-graph">Line graph</a></li>
<li><a class="reference internal" href="#composition-and-subgraphs">Composition and subgraphs</a></li>
<li><a class="reference internal" href="#morphisms">Morphisms</a></li>
<li><a class="reference internal" href="#flow">Flow</a></li>
</ul>
</li>
</ul>

        
  <section id="graph-analysis">
<h1>Graph analysis<a class="headerlink" href="#graph-analysis" title="Permalink to this heading">¶</a></h1>
<p><em>igraph</em> enables analysis of graphs/networks from simple operations such as adding and removing nodes to complex theoretical constructs such as community detection. Read the <a class="reference external" href="https://igraph.org/python/doc/igraph-module.html">API documentation</a> for details on each function and class.</p>
<p>The context for the following examples will be to import <em>igraph</em> (commonly as <cite>ig</cite>), have the <code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code> class and to have one or more graphs available:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">igraph</span> <span class="k">as</span> <span class="nn">ig</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">igraph</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
</pre></div>
</div>
<p>To get a summary representation of the graph, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.summary()</span></code>. For instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>will provide a fairly detailed description.</p>
<p>To copy a graph, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.copy()</span></code>. This is a “shallow” copy: any mutable objects in the attributes are not copied (they would refer to the same instance).
If you want to copy a graph including all its attributes, use Python’s <cite>deepcopy</cite> module.</p>
<section id="vertices-and-edges">
<h2>Vertices and edges<a class="headerlink" href="#vertices-and-edges" title="Permalink to this heading">¶</a></h2>
<p>Vertices are numbered 0 to <cite>n-1</cite>, where n is the number of vertices in the graph. These are called the “vertex ids”.
To count vertices, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.vcount()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vcount</span><span class="p">()</span>
</pre></div>
</div>
<p>Edges also have ids from 0 to <cite>m-1</cite> and are counted by <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.ecount()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">ecount</span><span class="p">()</span>
</pre></div>
</div>
<p>To get a sequence of vertices, use their ids and <code class="xref py py-attr docutils literal notranslate"><span class="pre">Graph.vs</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly for edges, use <code class="xref py py-attr docutils literal notranslate"><span class="pre">Graph.es</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>You can index and slice vertices and edges like indexing and slicing a list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <cite>vs</cite> and <cite>es</cite> attributes are special sequences with their own useful methods. See <a class="reference external" href="https://igraph.org/python/doc/igraph-module.html">API documentation</a> for a full list.</p>
</div>
<p>If you prefer a vanilla edge list, you can use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_edge_list()</span></code>.</p>
</section>
<section id="incidence">
<h2>Incidence<a class="headerlink" href="#incidence" title="Permalink to this heading">¶</a></h2>
<p>To get the vertices at the two ends of an edge, use <code class="xref py py-attr docutils literal notranslate"><span class="pre">Edge.source</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">Edge.target</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
<p>Vice versa, to get the edge if from the source and target vertices, you can use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_eid()</span></code> or, for multiple pairs of source/targets,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_eids()</span></code>. The boolean version, asking whether two vertices are directly connected, is <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.are_connected()</span></code>.</p>
<p>To get the edges incident on a vertex, you can use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Vertex.incident()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">Vertex.out_edges()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Vertex.in_edges()</span></code>. The three are equivalent on undirected graphs but not directed ones of course:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">incident</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.incident()</span></code> function fulfills the same purpose with a slightly different syntax based on vertex IDs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">incident</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>To get the full adjacency/incidence list representation of the graph, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_adjlist()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.g.get_inclist()</span></code> or, for a bipartite graph, <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_incidence()</span></code>.</p>
</section>
<section id="neighborhood">
<h2>Neighborhood<a class="headerlink" href="#neighborhood" title="Permalink to this heading">¶</a></h2>
<p>To compute the neighbors, successors, and predecessors, the methods <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.neighbors()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.successors()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.predecessors()</span></code> are available. The three give the same answer in undirected graphs and have a similar dual syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">neis</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">neighbors</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neis</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>To get the list of vertices within a certain distance from one or more initial vertices, you can use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.neighborhood()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">neighborhood</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>and to find the neighborhood size, there is <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.neighborhood_size()</span></code>.</p>
</section>
<section id="degrees">
<h2>Degrees<a class="headerlink" href="#degrees" title="Permalink to this heading">¶</a></h2>
<p>To compute the degree, in-degree, or out-degree of a node, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Vertex.degree()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">Vertex.indegree()</span></code>, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Vertex.outdegree()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">deg</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deg</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>To compute the max degree in a list of vertices, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.maxdegree()</span></code>.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.knn()</span></code> computes the average degree of the neighbors.</p>
</section>
<section id="adding-and-removing-vertices-and-edges">
<h2>Adding and removing vertices and edges<a class="headerlink" href="#adding-and-removing-vertices-and-edges" title="Permalink to this heading">¶</a></h2>
<p>To add nodes to a graph, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.add_vertex()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.add_vertices()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>This changes the graph <cite>g</cite> in place. You can specify the name of the vertices if you wish.</p>
<p>To remove nodes, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.delete_vertices()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">delete_vertices</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Again, you can specify the names or the actual <code class="xref py py-class docutils literal notranslate"><span class="pre">Vertex</span></code> objects instead.</p>
<p>To add edges, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.add_edge()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.add_edges()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
</pre></div>
</div>
<p>To remove edges, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.delete_edges()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span> <span class="c1"># remove by edge id</span>
</pre></div>
</div>
<p>You can also remove edges between source and target nodes.</p>
<p>To contract vertices, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.contract_vertices()</span></code>. Edges between contracted vertices will become loops.</p>
</section>
<section id="graph-operators">
<h2>Graph operators<a class="headerlink" href="#graph-operators" title="Permalink to this heading">¶</a></h2>
<p>It is possible to compute the union, intersection, difference, and other set operations (operators) between graphs.</p>
<p>To compute the union of the graphs (nodes/edges in either are kept):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gu</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">union</span><span class="p">([</span><span class="n">g</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">])</span>
</pre></div>
</div>
<p>Similarly for the intersection (nodes/edges present in all are kept):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gu</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">intersection</span><span class="p">([</span><span class="n">g</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">g3</span><span class="p">])</span>
</pre></div>
</div>
<p>These two operations preserve attributes and can be performed with a few variations. The most important one is that vertices can be matched across the graphs by id (number) or by name.</p>
<p>These and other operations are also available as methods of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">complementer</span><span class="p">()</span>  <span class="c1"># complement graph, same nodes but missing edges</span>
</pre></div>
</div>
<p>and even as numerical operators:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">|=</span> <span class="n">g2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g_intersection</span> <span class="o">=</span> <span class="n">g</span> <span class="ow">and</span> <span class="n">g2</span>
</pre></div>
</div>
</section>
<section id="topological-sorting">
<h2>Topological sorting<a class="headerlink" href="#topological-sorting" title="Permalink to this heading">¶</a></h2>
<p>To sort a graph topologically, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.topological_sorting()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">ig</span><span class="o">.</span><span class="n">TREE_OUT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">topological_sorting</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="graph-traversal">
<h2>Graph traversal<a class="headerlink" href="#graph-traversal" title="Permalink to this heading">¶</a></h2>
<p>A common operation is traversing the graph. <em>igraph</em> currently exposes breadth-first search (BFS) via <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.bfs()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.bfsiter()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">vertices</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">parents</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bfs</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">bfsiter</span><span class="p">()</span>  <span class="c1"># Lazy version</span>
</pre></div>
</div>
<p>Depth-first search has a similar infrastructure via <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.dfs()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.dfsiter()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">vertices</span><span class="p">,</span> <span class="n">parents</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">dfs</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">dfsiter</span><span class="p">()</span>  <span class="c1"># Lazy version</span>
</pre></div>
</div>
<p>To perform a random walk from a certain vertex, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.random_walk()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vids</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">random_walk</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="pathfinding-and-cuts">
<h2>Pathfinding and cuts<a class="headerlink" href="#pathfinding-and-cuts" title="Permalink to this heading">¶</a></h2>
<p>Several pathfinding algorithms are available:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.shortest_paths()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_shortest_paths()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_all_shortest_paths()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_all_simple_paths()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.spanning_tree()</span></code> finds a minimum spanning tree</p></li>
</ul>
<p>As well as functions related to cuts and paths:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.mincut()</span></code> calculates the minimum cut between the source and target vertices</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.st_mincut()</span></code> - as previous one, but returns a simpler data structure</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.mincut_value()</span></code> - as previous one, but returns only the value</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.all_st_cuts()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.all_st_mincuts()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.edge_connectivity()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.edge_disjoint_paths()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.adhesion()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.vertex_connectivity()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.cohesion()</span></code></p></li>
</ul>
<p>See also the section on flow.</p>
</section>
<section id="global-properties">
<h2>Global properties<a class="headerlink" href="#global-properties" title="Permalink to this heading">¶</a></h2>
<p>A number of global graph measures are available.</p>
<p>Basic:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.diameter()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_diameter()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.girth()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.radius()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.average_path_length()</span></code></p></li>
</ul>
<p>Distributions:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.degree_distribution()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.path_length_hist()</span></code></p></li>
</ul>
<p>Connectedness:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.all_minimal_st_separators()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.minimum_size_separators()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.cut_vertices()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.articulation_points()</span></code></p></li>
</ul>
<p>Cliques and motifs:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.clique_number()</span></code> (aka <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.omega()</span></code>)</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.cliques()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.maximal_cliques()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.largest_cliques()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.motifs_randesu()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.motifs_randesu_estimate()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.motifs_randesu_no()</span></code> counts the number of motifs</p></li>
</ul>
<p>Directed acyclic graphs:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_dag()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.feedback_arc_set()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.topological_sorting()</span></code></p></li>
</ul>
<p>Optimality:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.farthest_points()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.modularity()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.maximal_cliques()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.largest_cliques()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.independence_number()</span></code> (aka <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.alpha()</span></code>)</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.maximal_independent_vertex_sets()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.largest_independent_vertex_sets()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.mincut()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.mincut_value()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.feedback_arc_set()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.maximum_bipartite_matching()</span></code> (bipartite graphs)</p></li>
</ul>
<p>Other complex measures are:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.assortativity()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.assortativity_degree()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.assortativity_nominal()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.density()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.transitivity_undirected()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.transitivity_avglocal_undirected()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.dyad_census()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.triad_census()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.reciprocity()</span></code> (directed graphs)</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.isoclass()</span></code> (only 3 or 4 vertices)</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.biconnected_components()</span></code> aka <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.blocks()</span></code></p></li>
</ul>
<p>Boolean properties:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_bipartite()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_connected()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_dag()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_directed()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_named()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_simple()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_weighted()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.has_multiple()</span></code></p></li>
</ul>
</section>
<section id="vertex-properties">
<h2>Vertex properties<a class="headerlink" href="#vertex-properties" title="Permalink to this heading">¶</a></h2>
<p>A spectrum of vertex-level properties can be computed. Similarity measures include:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.similarity_dice()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.similarity_jaccard()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.similarity_inverse_log_weighted()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.diversity()</span></code></p></li>
</ul>
<p>Structural:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.authority_score()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.hub_score()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.betweenness()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.bibcoupling()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.closeness()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.constraint()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.cocitation()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.coreness()</span></code> (aka <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.shell_index()</span></code>)</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.eccentricity()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.eigenvector_centrality()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.harmonic_centrality()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.pagerank()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.personalized_pagerank()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.strength()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.transitivity_local_undirected()</span></code></p></li>
</ul>
<p>Connectedness:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.subcomponent()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_separator()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_minimal_separator()</span></code></p></li>
</ul>
</section>
<section id="edge-properties">
<h2>Edge properties<a class="headerlink" href="#edge-properties" title="Permalink to this heading">¶</a></h2>
<p>As for vertices, edge properties are implemented. Basic properties include:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_loop()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_multiple()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_mutual()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.count_multiple()</span></code></p></li>
</ul>
<p>and more complex ones:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.edge_betweenness()</span></code></p></li>
</ul>
</section>
<section id="matrix-representations">
<h2>Matrix representations<a class="headerlink" href="#matrix-representations" title="Permalink to this heading">¶</a></h2>
<p>Matrix-related functionality includes:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_adjacency()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_adjacency_sparse()</span></code> (sparse CSR matrix version)</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.laplacian()</span></code></p></li>
</ul>
</section>
<section id="clustering">
<h2>Clustering<a class="headerlink" href="#clustering" title="Permalink to this heading">¶</a></h2>
<p><em>igraph</em> includes several approaches to unsupervised graph clustering and community detection:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.components()</span></code> (aka <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.clusters()</span></code>): the connected components</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.cohesive_blocks()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.community_edge_betweenness()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.community_fastgreedy()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.community_infomap()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.community_label_propagation()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.community_leading_eigenvector()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.community_leading_eigenvector_naive()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.community_leiden()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.community_multilevel()</span></code> (a version of Louvain)</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.community_optimal_modularity()</span></code> (exact solution, &lt; 100 vertices)</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.community_spinglass()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.community_walktrap()</span></code></p></li>
</ul>
</section>
<section id="simplification-permutations-and-rewiring">
<h2>Simplification, permutations and rewiring<a class="headerlink" href="#simplification-permutations-and-rewiring" title="Permalink to this heading">¶</a></h2>
<p>To check is a graph is simple, you can use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.is_simple()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">is_simple</span><span class="p">()</span>
</pre></div>
</div>
<p>To simplify a graph (remove multiedges and loops), use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.simplify()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g_simple</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
</pre></div>
</div>
<p>To return a directed/undirected copy of the graph, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.as_directed()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.as_undirected()</span></code>, respectively.</p>
<p>To permute the order of vertices, you can use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.permute_vertices()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g_perm</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">permute_vertices</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
<p>The canonical permutation can be obtained via <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.canonical_permutation()</span></code>, which can then be directly passed to the function above.</p>
<p>To rewire the graph at random, there are:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.rewire()</span></code> - preserves the degree distribution</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.rewire_edges()</span></code> - fixed rewiring probability for each endpoint</p></li>
</ul>
</section>
<section id="line-graph">
<h2>Line graph<a class="headerlink" href="#line-graph" title="Permalink to this heading">¶</a></h2>
<p>To compute the line graph of a graph <cite>g</cite>, which represents the connectedness of the <em>edges</em> of g, you can use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.linegraph()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gl</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">linegraph</span><span class="p">()</span>
</pre></div>
</div>
<p>In this case, the line graph has two vertices, representing the two edges of the original graph, and one edge, representing the point where those two original edges touch.</p>
</section>
<section id="composition-and-subgraphs">
<h2>Composition and subgraphs<a class="headerlink" href="#composition-and-subgraphs" title="Permalink to this heading">¶</a></h2>
<p>The function <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.decompose()</span></code> decomposes the graph into subgraphs. Vice versa, the function <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.compose()</span></code> returns the composition of two graphs.</p>
<p>To compute the subgraph spannes by some vertices/edges, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.subgraph()</span></code> (aka <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.induced_subgraph()</span></code>) and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.subgraph_edges()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g_sub</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g_sub</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph_edges</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>To compute the minimum spanning tree, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.spanning_tree()</span></code>.</p>
<p>To compute graph k-cores, the method <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.k_core()</span></code> is available.</p>
<p>The dominator tree from a given node can be obtained with <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.dominator()</span></code>.</p>
<p>Bipartite graphs can be decomposed using <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.bipartite_projection()</span></code>. The size of the projections can be computed using <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.bipartite_projection_size()</span></code>.</p>
</section>
<section id="morphisms">
<h2>Morphisms<a class="headerlink" href="#morphisms" title="Permalink to this heading">¶</a></h2>
<p><em>igraph</em> enables comparisons between graphs:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.isomorphic()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.isomorphic_vf2()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.subisomorphic_vf2()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.subisomorphic_lad()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_isomorphisms_vf2()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_subisomorphisms_vf2()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_subisomorphisms_lad()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.get_automorphisms_vf2()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.count_isomorphisms_vf2()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.count_subisomorphisms_vf2()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.count_automorphisms_vf2()</span></code></p></li>
</ul>
</section>
<section id="flow">
<h2>Flow<a class="headerlink" href="#flow" title="Permalink to this heading">¶</a></h2>
<p>Flow is a characteristic of directed graphs. The following functions are available:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.maxflow()</span></code> between two nodes</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.maxflow_value()</span></code> - similar to the previous one, but only the value is returned</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.gomory_hu_tree()</span></code></p></li>
</ul>
<p>Flow and cuts are closely related, therefore you might find the following functions useful as well:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.mincut()</span></code> calculates the minimum cut between the source and target vertices</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.st_mincut()</span></code> - as previous one, but returns a simpler data structure</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.mincut_value()</span></code> - as previous one, but returns only the value</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.all_st_cuts()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.all_st_mincuts()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.edge_connectivity()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.edge_disjoint_paths()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.adhesion()</span></code></p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.vertex_connectivity()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.cohesion()</span></code></p></li>
</ul>
</section>
</section>


      </div>
    </div>
    <div class="clearer"></div>
    </div>
  </div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	      &copy; 2003 &ndash; 2025 The igraph core team.
        &bull; Code licensed under <a href="http://www.gnu.org/licenses/gpl-2.0.html"> GNU GPL 2</a> or later,
        documentation under <a href="http://www.gnu.org/copyleft/fdl.html">GNU FDL</a>.
      </p>
      <p class="social">
        <a href="https://twitter.com/igraph2"><i class="fa-brands fa-twitter"></i></a>
        <a rel="me" href="https://fosstodon.org/@igraph"><i class="fa-brands fa-mastodon"></i></a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'python', 'tutorial/');
    </script>





    
  </body>
</html>
