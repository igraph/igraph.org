




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>python-igraph API reference</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/fontawesome.min.css" integrity="sha384-QYIZto+st3yW+o8+5OHfT6S482Zsvz2WfOzpFSXMF9zqeLcFV0/wlZpMtyFcZALm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/solid.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/brands.min.css">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DY4MJME11Z"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-DY4MJME11Z');
	</script>

    <link href="/css/pydoctor.css" rel="stylesheet">
  </head>

  <body class="python">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/python/versions/latest">python-igraph</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            0.10.1
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="https://r.igraph.org">igraph R package</a>
              <a class="dropdown-item" href="https://python.igraph.org">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa-brands fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa-solid fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa-solid fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa-solid fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa-brands fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">python-igraph API reference</h1>
        <p class="lead">List of all classes, functions and methods in python-igraph</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container bs-docs-container">
<div class="row">
  <div class="col-md-12">
  <div class="bs-docs-section">

    
<nav class="navbar navbar-default mainnavbar">
      
  
  <div class="container-fluid">


    <div class="navbar-header">
      
      <div class="navlinks">
        <span class="navbar-brand">
          <a href="https://igraph.org/python" class="projecthome">"igraph"</a> <a href="index.html">API Documentation</a>
        </span>

        <a href="moduleIndex.html">
          Modules
        </a>

        <a href="classIndex.html">
          Classes
        </a>

        <a href="nameIndex.html">
          Names
        </a>

        <div id="search-box-container">
          <div class="input-group">
            <input id="search-box" type="search" name="search-query" placeholder="Search..." aria-label="Search" minlength="2" class="form-control" autocomplete="off" />
            
            <span class="input-group-btn">
              <a style="display: none;" class="btn btn-default" id="search-clear-button" title="Clear" onclick="clearSearch()"><img src="fonts/x-circle.svg" alt="Clear" /></a>
              <a class="btn btn-default" id="search-help-button" title="Help" onclick="toggleSearchHelpText()"><img src="fonts/info.svg" alt="Help" /></a>
            </span>
          </div>
        </div>

      </div>

      <div id="search-results-container" style="display: none;">
        
        <div id="search-buttons">
          <span class="label label-default" id="search-docstrings-button">
          <label class="checkbox-inline">
            <input type="checkbox" id="toggle-search-in-docstrings-checkbox" value="false" onclick="toggleSearchInDocstrings()">
              search in docstrings
            </input>
          </label>
          </span>
          
        </div>
        
        <noscript>
            <h1>Cannot search: JavaScript is not supported/enabled in your browser.</h1>
        </noscript>

        <div class="hint" id="search-help-box">
          <p class="rst-last">
      
            Search bar offers the following options:
            <ul>   
                <li>
                  <strong>Term presence.</strong> The below example searches for documents that 
                    must contain “foo”, might contain “bar” and must not contain “baz”: <code>+foo bar -baz</code>
                </li> 

                <li>
                  <strong>Wildcards.</strong> The below example searches for documents with words beginning with “foo”: <code>foo*</code>
                </li> 

                <li>
                  <strong>Search in specific fields.</strong> The following search matches all objects 
                  in "twisted.mail" that matches “search”: <code>+qname:twisted.mail.* +search</code>

                  <p>
                    Possible fields: 'name', 'qname' (fully qualified name), 'docstring', and 'kind'.
                    Last two fields are only applicable if "search in docstrings" is enabled.
                  </p>
                </li>

                <li>
                  <strong>Fuzzy matches.</strong> The following search matches all documents 
                  that have a word within 1 edit distance of “foo”: <code>foo~1</code>
                </li>
            </ul>

          </p>
        </div>

        <div id="search-status"> </div>

        <div class="warning" id="search-warn-box" style="display: none;">
          <p class="rst-last"><span id="search-warn"></span></p>
        </div>

        <table id="search-results">
          <!-- Filled dynamically by JS -->
        </table>
        
        <div style="margin-top: 8px;">
          <p>Results provided by <a href="https://lunrjs.com">Lunr.js</a></p>
        </div>
      </div>

    </div>


  </div>
</nav>
    
    <div class="container-fluid">

      <!-- Side navigation -->
      

      <div id="main" class="nosidebar">
        

        

        <div class="page-header">
          <h1 class="module"><code><code><a href="index.html" class="internal-link">igraph</a></code><wbr></wbr>.<code><a href="igraph.io.html" class="internal-link" title="igraph.io">io</a></code><wbr></wbr>.<code><a href="igraph.io.objects.html" class="internal-link" title="igraph.io.objects">objects</a></code></code></h1>
          <div id="showPrivate">
            <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
          </div>
        </div>

        <div class="categoryHeader">
          module documentation
        </div>

        <div class="extrasDocstring">
          
          <p></p>
        </div>

        <div class="moduleDocstring">
          <div><p class="undocumented">Undocumented</p></div>
        </div>

        <div id="splitTables">
          <table class="children sortable" id="id187">
  
  
  <tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_graph_from_dataframe" class="internal-link" title="igraph.io.objects._construct_graph_from_dataframe">_construct<wbr></wbr>_graph<wbr></wbr>_from<wbr></wbr>_dataframe</a></code></td>
    <td>Generates a graph from one or two dataframes.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_graph_from_dict_dict" class="internal-link" title="igraph.io.objects._construct_graph_from_dict_dict">_construct<wbr></wbr>_graph<wbr></wbr>_from<wbr></wbr>_dict<wbr></wbr>_dict</a></code></td>
    <td>Constructs a graph from a dict-of-dicts representation.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_graph_from_dict_list" class="internal-link" title="igraph.io.objects._construct_graph_from_dict_list">_construct<wbr></wbr>_graph<wbr></wbr>_from<wbr></wbr>_dict<wbr></wbr>_list</a></code></td>
    <td>Constructs a graph from a list-of-dictionaries representation.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_graph_from_list_dict" class="internal-link" title="igraph.io.objects._construct_graph_from_list_dict">_construct<wbr></wbr>_graph<wbr></wbr>_from<wbr></wbr>_list<wbr></wbr>_dict</a></code></td>
    <td>Constructs a graph from a dict-of-lists representation.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_graph_from_tuple_list" class="internal-link" title="igraph.io.objects._construct_graph_from_tuple_list">_construct<wbr></wbr>_graph<wbr></wbr>_from<wbr></wbr>_tuple<wbr></wbr>_list</a></code></td>
    <td>Constructs a graph from a list-of-tuples representation.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_export_edge_dataframe" class="internal-link" title="igraph.io.objects._export_edge_dataframe">_export<wbr></wbr>_edge<wbr></wbr>_dataframe</a></code></td>
    <td>Export edges with attributes to pandas.DataFrame</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_export_graph_to_dict_dict" class="internal-link" title="igraph.io.objects._export_graph_to_dict_dict">_export<wbr></wbr>_graph<wbr></wbr>_to<wbr></wbr>_dict<wbr></wbr>_dict</a></code></td>
    <td>Export graph to dictionary of dicts of edge attributes</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_export_graph_to_dict_list" class="internal-link" title="igraph.io.objects._export_graph_to_dict_list">_export<wbr></wbr>_graph<wbr></wbr>_to<wbr></wbr>_dict<wbr></wbr>_list</a></code></td>
    <td>Export graph as two lists of dictionaries, for vertices and edges.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_export_graph_to_list_dict" class="internal-link" title="igraph.io.objects._export_graph_to_list_dict">_export<wbr></wbr>_graph<wbr></wbr>_to<wbr></wbr>_list<wbr></wbr>_dict</a></code></td>
    <td>Export graph to a dictionary of lists (or other sequences).</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_export_graph_to_tuple_list" class="internal-link" title="igraph.io.objects._export_graph_to_tuple_list">_export<wbr></wbr>_graph<wbr></wbr>_to<wbr></wbr>_tuple<wbr></wbr>_list</a></code></td>
    <td>Export graph to a list of edge tuples</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_export_vertex_dataframe" class="internal-link" title="igraph.io.objects._export_vertex_dataframe">_export<wbr></wbr>_vertex<wbr></wbr>_dataframe</a></code></td>
    <td>Export vertices with attributes to pandas.DataFrame</td>
  </tr>
</table>
          

            
        </div>

        <div id="childList">
          <div class="basefunction private">
  
  
  <a name="igraph.io.objects._construct_graph_from_dataframe">
    
  </a>
  <a name="_construct_graph_from_dataframe">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_graph_from_dataframe</span>(cls, edges, directed=True, vertices=None, use_vids=True):
    
    <a class="headerLink" href="#_construct_graph_from_dataframe" title="igraph.io.objects._construct_graph_from_dataframe">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph from one or two dataframes.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cls</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">pandas DataFrame containing edges and metadata. The first two columns of this DataFrame contain the source and target vertices for each edge. These indicate the vertex IDs as nonnegative integers rather than vertex names unless <tt class="rst-docutils literal">use_vids</tt> is False. Further columns may contain edge attributes.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed:</span><code>bool</code></td><td class="fieldArgDesc">whether the graph is directed</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">None (default) or pandas DataFrame containing vertex metadata. The DataFrame's index must contain the vertex IDs as a sequence of intergers from 0 to <tt class="rst-docutils literal">len(vertices) - 1</tt>. If <tt class="rst-docutils literal">use_vids</tt> is <tt class="rst-docutils literal">False</tt>, the first column must contain the unique vertex names. Vertex names should be strings for full compatibility, but many functions will work if you set the name with any hashable object. All other columns will be added as vertex attributes by column name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">use<wbr></wbr>_vids:</span><code>bool</code></td><td class="fieldArgDesc">whether to interpret the first two columns of the <tt class="rst-docutils literal">edges</tt> argument as vertex ids (0-based integers) instead of vertex names. If this argument is set to True and the first two columns of <tt class="rst-docutils literal">edges</tt> are not integers, an error is thrown.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><p>the graph</p>
<p>Vertex names in either the <tt class="rst-docutils literal">edges</tt> or <tt class="rst-docutils literal">vertices</tt> arguments that are set to NaN (not a number) will be set to the string "NA". That might lead to unexpected behaviour: fill your NaNs with values before calling this function to mitigate.</p>
</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.objects._construct_graph_from_dict_dict">
    
  </a>
  <a name="_construct_graph_from_dict_dict">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_graph_from_dict_dict</span>(cls, edges, directed=False, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#_construct_graph_from_dict_dict" title="igraph.io.objects._construct_graph_from_dict_dict">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Constructs a graph from a dict-of-dicts representation.</p>
<p>Each key can be an integer or a string and represent a vertex. Each value is a dict representing edges (outgoing if the graph is directed) from that vertex. Each dict key is an integer/string for a target vertex, such that an edge will be created between those two vertices. Integers are interpreted as vertex_ids from 0 (as used in igraph), strings are interpreted as vertex names, in which case vertices are given separate numeric ids. Each value is a dictionary of edge attributes for that edge.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>{<span class="py-string">'Alice'</span>: {<span class="py-string">'Bob'</span>: {<span class="py-string">'weight'</span>: 1.5}, <span class="py-string">'David'</span>: {<span class="py-string">'weight'</span>: 2}}}</pre><p>creates a graph with three vertices (Alice, Bob, and David) and two edges:</p>
<ul class="rst-simple">
<li>Alice - Bob (with weight 1.5)</li>
<li>Alice - David (with weight 2)</li>
</ul>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cls</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">the dict of dict of dicts specifying the edges and their attributes</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed:</span><code>bool</code></td><td class="fieldArgDesc">whether to create a directed graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a Graph object</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: vertex_name_attr</td></tr><tr><td colspan="2">vertex attribute that will store the names</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.objects._construct_graph_from_dict_list">
    
  </a>
  <a name="_construct_graph_from_dict_list">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_graph_from_dict_list</span>(cls, vertices, edges, directed=False, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>, edge_foreign_keys=(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">source</span><span class="rst-variable-quote">'</span>, <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">target</span><span class="rst-variable-quote">'</span>), iterative=False):
    
    <a class="headerLink" href="#_construct_graph_from_dict_list" title="igraph.io.objects._construct_graph_from_dict_list">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Constructs a graph from a list-of-dictionaries representation.</p>
<p>This function is useful when you have two lists of dictionaries, one for vertices and one for edges, each containing their attributes (e.g. name, weight). Of course, the edge dictionary must also contain two special keys that indicate the source and target vertices connected by that edge. Non-list iterables should work as long as they yield dictionaries or dict-like objects (they should have the 'items' and '__getitem__' methods). For instance, a database query result is likely to be fit as long as it's iterable and yields dict-like objects with every iteration.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cls</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the list of dictionaries for the vertices or <tt class="rst-docutils literal">None</tt> if there are no special attributes assigned to vertices and we should simply use the edge list of dicts to infer vertex names.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">the list of dictionaries for the edges. Each dict must have at least the two keys specified by edge_foreign_keys to label the source and target vertices, while additional items will be treated as edge attributes.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed:</span><code>bool</code></td><td class="fieldArgDesc">whether the constructed graph will be directed</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc">the name of the distinguished key in the dicts in the vertex data source that contains the vertex names. Ignored if <tt class="rst-docutils literal">vertices</tt> is <tt class="rst-docutils literal">None</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_foreign<wbr></wbr>_keys</span></td><td class="fieldArgDesc">tuple specifying the attributes in each edge dictionary that contain the source (1st) and target (2nd) vertex names. These items of each dictionary are also added as edge_attributes.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">iterative:</span><code>bool</code></td><td class="fieldArgDesc">whether to add the edges to the graph one by one, iteratively, or to build a large edge list first and use that to construct the graph. The latter approach is faster but it may not be suitable if your dataset is large. The default is to add the edges in a batch from an edge list.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><p>the graph that was constructed</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>vertices = [{<span class="py-string">'name'</span>: <span class="py-string">'apple'</span>}, {<span class="py-string">'name'</span>: <span class="py-string">'pear'</span>}, {<span class="py-string">'name'</span>: <span class="py-string">'peach'</span>}]
<span class="py-prompt">&gt;&gt;&gt; </span>edges = [{<span class="py-string">'source'</span>: <span class="py-string">'apple'</span>, <span class="py-string">'target'</span>: <span class="py-string">'pear'</span>, <span class="py-string">'weight'</span>: 1.2},
<span class="py-more">... </span>         {<span class="py-string">'source'</span>: <span class="py-string">'apple'</span>, <span class="py-string">'target'</span>: <span class="py-string">'peach'</span>, <span class="py-string">'weight'</span>: 0.9}]
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.DictList(vertices, edges)</pre><p>The graph has three vertices with names and two edges with weights.</p>
</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.objects._construct_graph_from_list_dict">
    
  </a>
  <a name="_construct_graph_from_list_dict">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_graph_from_list_dict</span>(cls, edges, directed=False, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#_construct_graph_from_list_dict" title="igraph.io.objects._construct_graph_from_list_dict">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Constructs a graph from a dict-of-lists representation.</p>
<p>This function is used to construct a graph from a dictionary of lists. Other, non-list sequences (e.g. tuples) and lazy iterators are are accepted. For each key x, its corresponding value must be a sequence of multiple values y: the edge (x,y) will be created in the graph. x and y must be either one of:</p>
<ul class="rst-simple">
<li>two integers: the vertices with those ids will be connected</li>
<li>two strings: the vertices with those names will be connected</li>
</ul>
<p>If names are used, the order of vertices is not guaranteed, and each vertex will be given the vertex_name_attr attribute.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cls</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">the dict of sequences describing the edges</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed:</span><code>bool</code></td><td class="fieldArgDesc">whether to create a directed graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><p>a Graph object</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>mydict = {<span class="py-string">'apple'</span>: [<span class="py-string">'pear'</span>, <span class="py-string">'peach'</span>], <span class="py-string">'pear'</span>: [<span class="py-string">'peach'</span>]}
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.ListDict(mydict)</pre><p># The graph has three vertices with names and three edges connecting # each pair.</p>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: vertex_name_attr</td></tr><tr><td colspan="2">vertex attribute that will store the names</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.objects._construct_graph_from_tuple_list">
    
  </a>
  <a name="_construct_graph_from_tuple_list">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_graph_from_tuple_list</span>(cls, edges, directed=False, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>, edge_attrs=None, weights=False):
    
    <a class="headerLink" href="#_construct_graph_from_tuple_list" title="igraph.io.objects._construct_graph_from_tuple_list">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Constructs a graph from a list-of-tuples representation.</p>
<p>This representation assumes that the edges of the graph are encoded in a list of tuples (or lists). Each item in the list must have at least two elements, which specify the source and the target vertices of the edge. The remaining elements (if any) specify the edge attributes of that edge, where the names of the edge attributes originate from the <tt class="rst-docutils literal">edge_attrs</tt> list. The names of the vertices will be stored in the vertex attribute given by <tt class="rst-docutils literal">vertex_name_attr</tt>.</p>
<p>The default parameters of this function are suitable for creating unweighted graphs from lists where each item contains the source vertex and the target vertex. If you have a weighted graph, you can use items where the third item contains the weight of the edge by setting <tt class="rst-docutils literal">edge_attrs</tt> to <tt class="rst-docutils literal">"weight"</tt> or <tt class="rst-docutils literal">["weight"]</tt>. If you have even more edge attributes, add them to the end of each item in the <tt class="rst-docutils literal">edges</tt> list and also specify the corresponding edge attribute names in <tt class="rst-docutils literal">edge_attrs</tt> as a list.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cls</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">the data source for the edges. This must be a list where each item is a tuple (or list) containing at least two items: the name of the source and the target vertex. Note that names will be assigned to the <tt class="rst-docutils literal">name</tt> vertex attribute (or another vertex attribute if <tt class="rst-docutils literal">vertex_name_attr</tt> is specified), even if all the vertex names in the list are in fact numbers.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed:</span><code>bool</code></td><td class="fieldArgDesc">whether the constructed graph will be directed</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc">the name of the vertex attribute that will contain the vertex names.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_attrs</span></td><td class="fieldArgDesc">the names of the edge attributes that are filled with the extra items in the edge list (starting from index 2, since the first two items are the source and target vertices). If <tt class="rst-docutils literal">None</tt> or an empty sequence, only the source and target vertices will be extracted and additional tuple items will be ignored. If a string, it is interpreted as a single edge attribute.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">alternative way to specify that the graph is weighted. If you set <tt class="rst-docutils literal">weights</tt> to <tt class="rst-docutils literal">true</tt> and <tt class="rst-docutils literal">edge_attrs</tt> is not given, it will be assumed that <tt class="rst-docutils literal">edge_attrs</tt> is <tt class="rst-docutils literal">["weight"]</tt> and igraph will parse the third element from each item into an edge weight. If you set <tt class="rst-docutils literal">weights</tt> to a string, it will be assumed that <tt class="rst-docutils literal">edge_attrs</tt> contains that string only, and igraph will store the edge weights in that attribute.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the graph that was constructed</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.objects._export_edge_dataframe">
    
  </a>
  <a name="_export_edge_dataframe">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_export_edge_dataframe</span>(graph):
    
    <a class="headerLink" href="#_export_edge_dataframe" title="igraph.io.objects._export_edge_dataframe">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Export edges with attributes to pandas.DataFrame</p>
<p>If you want to use source and target vertex IDs as index, you can do:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> string <span class="py-keyword">import</span> ascii_letters
<span class="py-prompt">&gt;&gt;&gt; </span>graph = Graph.GRG(25, 0.4)
<span class="py-prompt">&gt;&gt;&gt; </span>graph.vs[<span class="py-string">"name"</span>] = ascii_letters[:graph.vcount()]
<span class="py-prompt">&gt;&gt;&gt; </span>df = graph.get_edge_dataframe()
<span class="py-prompt">&gt;&gt;&gt; </span>df.set_index([<span class="py-string">'source'</span>, <span class="py-string">'target'</span>], inplace=<span class="py-builtin">True</span>)</pre><p>The index will be a pandas.MultiIndex. You can use the <tt class="rst-docutils literal">drop=False</tt> option to keep the <tt class="rst-docutils literal">source</tt> and <tt class="rst-docutils literal">target</tt> columns.</p>
<p>If you want to use vertex names in the source and target columns:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>df = graph.get_edge_dataframe()
<span class="py-prompt">&gt;&gt;&gt; </span>df_vert = graph.get_vertex_dataframe()
<span class="py-prompt">&gt;&gt;&gt; </span>df[<span class="py-string">'source'</span>].replace(df_vert[<span class="py-string">'name'</span>], inplace=<span class="py-builtin">True</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>df[<span class="py-string">'target'</span>].replace(df_vert[<span class="py-string">'name'</span>], inplace=<span class="py-builtin">True</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>df_vert.set_index(<span class="py-string">'name'</span>, inplace=<span class="py-builtin">True</span>)  <span class="py-comment"># Optional</span></pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a pandas.DataFrame representing edges and their attributes. The index uses edge IDs, from 0 to M - 1 where M is the number of edges. The first two columns of the dataframe represent the IDs of source and target vertices for each edge. These columns have names "source" and "target". If your edges have attributes with the same names, they will be present in the dataframe, but not in the first two columns.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.objects._export_graph_to_dict_dict">
    
  </a>
  <a name="_export_graph_to_dict_dict">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_export_graph_to_dict_dict</span>(graph, use_vids=True, edge_attrs=None, skip_none=False, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#_export_graph_to_dict_dict" title="igraph.io.objects._export_graph_to_dict_dict">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Export graph to dictionary of dicts of edge attributes</p>
<p>This function is the reverse of Graph.DictDict.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Full(3)
<span class="py-prompt">&gt;&gt;&gt; </span>g.es[<span class="py-string">'name'</span>] = [<span class="py-string">'first_edge'</span>, <span class="py-string">'second'</span>, <span class="py-string">'third'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_dict_dict()
<span class="py-output">{0: {1: {'name': 'first_edge'}, 2: {'name': 'second'}}, 1: {2: {'name': 'third'}}}</span>
</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">use<wbr></wbr>_vids:</span><code>bool</code></td><td class="fieldArgDesc">whether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If use_vids=False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_attrs:</span><code>Union[<wbr></wbr>str, <wbr></wbr>Sequence[<wbr></wbr>str]]</code></td><td class="fieldArgDesc">list of edge attributes to export. None (default) signified all attributes (unlike Graph.to_tuple_list). A string is acceptable to signify a single attribute and will be wrapped in a list internally.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">skip<wbr></wbr>_none:</span><code>bool</code></td><td class="fieldArgDesc">whether to skip, for each edge, attributes that have a value of None. This is useful if only some edges are expected to possess an attribute.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">dictionary of dictionaries of dictionaries, with the outer keys vertex ids/names, the middle keys ids/names of their neighbors, and the innermost dictionary representing attributes of that edge.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: vertex_name_attr</td></tr><tr><td colspan="2">only used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.objects._export_graph_to_dict_list">
    
  </a>
  <a name="_export_graph_to_dict_list">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_export_graph_to_dict_list</span>(graph, use_vids=True, skip_none=False, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#_export_graph_to_dict_list" title="igraph.io.objects._export_graph_to_dict_list">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Export graph as two lists of dictionaries, for vertices and edges.</p>
<p>This function is the reverse of Graph.DictList.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph([(0, 1), (1, 2)])
<span class="py-prompt">&gt;&gt;&gt; </span>g.vs[<span class="py-string">"name"</span>] = [<span class="py-string">"apple"</span>, <span class="py-string">"pear"</span>, <span class="py-string">"peach"</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>g.es[<span class="py-string">"name"</span>] = [<span class="py-string">"first_edge"</span>, <span class="py-string">"second"</span>]</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_dict_list()
<span class="py-output">([{"name": "apple"}, {"name": "pear"}, {"name": "peach"}],</span>
<span class="py-output"> [{"source": 0, "target": 1, "name": "first_edge"},</span>
<span class="py-output">  {"source" 0, "target": 2, name": "second"}])</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_dict_list(use_vids=<span class="py-builtin">False</span>)
<span class="py-output">([{"name": "apple"}, {"name": "pear"}, {"name": "peach"}],</span>
<span class="py-output"> [{"source": "apple", "target": "pear", "name": "first_edge"},</span>
<span class="py-output">  {"source" "apple", "target": "peach", name": "second"}])</span>
</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">use<wbr></wbr>_vids:</span><code>bool</code></td><td class="fieldArgDesc">whether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If use_vids=False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">skip<wbr></wbr>_none:</span><code>bool</code></td><td class="fieldArgDesc">whether to skip, for each edge, attributes that have a value of None. This is useful if only some edges are expected to possess an attribute.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a tuple with two lists of dictionaries, representing the vertices and the edges, respectively, with their attributes.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: vertex_name_attr</td></tr><tr><td colspan="2">only used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.objects._export_graph_to_list_dict">
    
  </a>
  <a name="_export_graph_to_list_dict">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_export_graph_to_list_dict</span>(graph, use_vids=True, sequence_constructor=list, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#_export_graph_to_list_dict" title="igraph.io.objects._export_graph_to_list_dict">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Export graph to a dictionary of lists (or other sequences).</p>
<p>This function is the reverse of Graph.ListDict.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Full(3)
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_sequence_dict() -&gt; {0: [1, 2], 1: [2]}
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_sequence_dict(sequence_constructor=<span class="py-builtin">tuple</span>) -&gt; {0: (1, 2), 1: (2,)}
<span class="py-prompt">&gt;&gt;&gt; </span>g.vs[<span class="py-string">'name'</span>] = [<span class="py-string">'apple'</span>, <span class="py-string">'pear'</span>, <span class="py-string">'peach'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_sequence_dict(use_vids=<span class="py-builtin">False</span>)
<span class="py-output">{'apple': ['pear', 'peach'], 'pear': ['peach']}</span>
</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">use<wbr></wbr>_vids:</span><code>bool</code></td><td class="fieldArgDesc">whether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If use_vids=False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">sequence<wbr></wbr>_constructor:</span><code>callable</code></td><td class="fieldArgDesc">constructor for the data structure to be used as values of the dictionary. The default (list) makes a dict of lists, with each list representing the neighbors of the vertex specified in the respective dictionary key.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">dictionary of sequences, keyed by vertices, with each value containing the neighbors of that vertex.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: vertex_name_attr</td></tr><tr><td colspan="2">only used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.objects._export_graph_to_tuple_list">
    
  </a>
  <a name="_export_graph_to_tuple_list">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_export_graph_to_tuple_list</span>(graph, use_vids=True, edge_attrs=None, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#_export_graph_to_tuple_list" title="igraph.io.objects._export_graph_to_tuple_list">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Export graph to a list of edge tuples</p>
<p>This function is the reverse of Graph.TupleList.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Full(3)
<span class="py-prompt">&gt;&gt;&gt; </span>g.vs[<span class="py-string">"name"</span>] = [<span class="py-string">"apple"</span>, <span class="py-string">"pear"</span>, <span class="py-string">"peach"</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>g.es[<span class="py-string">"name"</span>] = [<span class="py-string">"first_edge"</span>, <span class="py-string">"second"</span>, <span class="py-string">"third"</span>]</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># Get name of the edge</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_tuple_list(edge_attrs=[<span class="py-string">"name"</span>])
<span class="py-output">[(0, 1, "first_edge"), (0, 2, "second"), (1, 2, "third")]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># Use vertex names, no edge attributes</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_tuple_list(use_vids=<span class="py-builtin">False</span>)
<span class="py-output">[("apple", "pear"), ("apple", "peach"), ("pear", "peach")]</span>
</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">use<wbr></wbr>_vids:</span><code>bool</code></td><td class="fieldArgDesc">whether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If use_vids=False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_attrs:</span><code>Union[<wbr></wbr>str, <wbr></wbr>Sequence[<wbr></wbr>str]]</code></td><td class="fieldArgDesc">list of edge attributes to export in addition to source and target vertex, which are always the first two elements of each tuple. None (default) is equivalent to an empty list. A string is acceptable to signify a single attribute and will be wrapped in a list internally.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of tuples, each representing an edge of the graph.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: vertex_name_attr</td></tr><tr><td colspan="2">only used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.objects._export_vertex_dataframe">
    
  </a>
  <a name="_export_vertex_dataframe">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_export_vertex_dataframe</span>(graph):
    
    <a class="headerLink" href="#_export_vertex_dataframe" title="igraph.io.objects._export_vertex_dataframe">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Export vertices with attributes to pandas.DataFrame</p>
<p>If you want to use vertex names as index, you can do:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> string <span class="py-keyword">import</span> ascii_letters
<span class="py-prompt">&gt;&gt;&gt; </span>graph = Graph.GRG(25, 0.4)
<span class="py-prompt">&gt;&gt;&gt; </span>graph.vs[<span class="py-string">"name"</span>] = ascii_letters[:graph.vcount()]
<span class="py-prompt">&gt;&gt;&gt; </span>df = graph.get_vertex_dataframe()
<span class="py-prompt">&gt;&gt;&gt; </span>df.set_index(<span class="py-string">'name'</span>, inplace=<span class="py-builtin">True</span>)</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a pandas.DataFrame representing vertices and their attributes. The index uses vertex IDs, from 0 to N - 1 where N is the number of vertices.</td></tr></table></div>
  </div>
</div>
        </div>
      
      </div>
    </div>

    


  </div>
  </div>
</div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	      &copy; 2003 &ndash; 2025 The igraph core team.
        &bull; Code licensed under <a href="http://www.gnu.org/licenses/gpl-2.0.html"> GNU GPL 2</a> or later,
        documentation under <a href="http://www.gnu.org/copyleft/fdl.html">GNU FDL</a>.
      </p>
      <p class="social">
        <a href="https://twitter.com/igraph2"><i class="fa-brands fa-twitter"></i></a>
        <a rel="me" href="https://fosstodon.org/@igraph"><i class="fa-brands fa-mastodon"></i></a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'python', 'api/');
    </script>





    
  </body>
</html>
