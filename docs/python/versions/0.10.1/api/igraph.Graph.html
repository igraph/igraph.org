




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>python-igraph API reference</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DY4MJME11Z"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-DY4MJME11Z');
	</script>

    <link href="/css/pydoctor.css" rel="stylesheet">
  </head>

  <body class="python">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/python/versions/latest">python-igraph</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            0.10.1
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="/r">igraph R package</a>
              <a class="dropdown-item" href="/python">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">python-igraph API reference</h1>
        <p class="lead">List of all classes, functions and methods in python-igraph</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container bs-docs-container">
<div class="row">
  <div class="col-md-12">
  <div class="bs-docs-section">

    
<nav class="navbar navbar-default mainnavbar">
      
  
  <div class="container-fluid">


    <div class="navbar-header">
      
      <div class="navlinks">
        <span class="navbar-brand">
          <a href="https://igraph.org/python" class="projecthome">"igraph"</a> <a href="index.html">API Documentation</a>
        </span>

        <a href="moduleIndex.html">
          Modules
        </a>

        <a href="classIndex.html">
          Classes
        </a>

        <a href="nameIndex.html">
          Names
        </a>

        <div id="search-box-container">
          <div class="input-group">
            <input id="search-box" type="search" name="search-query" placeholder="Search..." aria-label="Search" minlength="2" class="form-control" autocomplete="off" />
            
            <span class="input-group-btn">
              <a style="display: none;" class="btn btn-default" id="search-clear-button" title="Clear" onclick="clearSearch()"><img src="fonts/x-circle.svg" alt="Clear" /></a>
              <a class="btn btn-default" id="search-help-button" title="Help" onclick="toggleSearchHelpText()"><img src="fonts/info.svg" alt="Help" /></a>
            </span>
          </div>
        </div>

      </div>

      <div id="search-results-container" style="display: none;">
        
        <div id="search-buttons">
          <span class="label label-default" id="search-docstrings-button">
          <label class="checkbox-inline">
            <input type="checkbox" id="toggle-search-in-docstrings-checkbox" value="false" onclick="toggleSearchInDocstrings()">
              search in docstrings
            </input>
          </label>
          </span>
          
        </div>
        
        <noscript>
            <h1>Cannot search: JavaScript is not supported/enabled in your browser.</h1>
        </noscript>

        <div class="hint" id="search-help-box">
          <p class="rst-last">
      
            Search bar offers the following options:
            <ul>   
                <li>
                  <strong>Term presence.</strong> The below example searches for documents that 
                    must contain “foo”, might contain “bar” and must not contain “baz”: <code>+foo bar -baz</code>
                </li> 

                <li>
                  <strong>Wildcards.</strong> The below example searches for documents with words beginning with “foo”: <code>foo*</code>
                </li> 

                <li>
                  <strong>Search in specific fields.</strong> The following search matches all objects 
                  in "twisted.mail" that matches “search”: <code>+qname:twisted.mail.* +search</code>

                  <p>
                    Possible fields: 'name', 'qname' (fully qualified name), 'docstring', and 'kind'.
                    Last two fields are only applicable if "search in docstrings" is enabled.
                  </p>
                </li>

                <li>
                  <strong>Fuzzy matches.</strong> The following search matches all documents 
                  that have a word within 1 edit distance of “foo”: <code>foo~1</code>
                </li>
            </ul>

          </p>
        </div>

        <div id="search-status"> </div>

        <div class="warning" id="search-warn-box" style="display: none;">
          <p class="rst-last"><span id="search-warn"></span></p>
        </div>

        <table id="search-results">
          <!-- Filled dynamically by JS -->
        </table>
        
        <div style="margin-top: 8px;">
          <p>Results provided by <a href="https://lunrjs.com">Lunr.js</a></p>
        </div>
      </div>

    </div>


  </div>
</nav>
    
    <div class="container-fluid">

      <!-- Side navigation -->
      

      <div id="main" class="nosidebar">
        

        

        <div class="page-header">
          <h1 class="class"><code><code><a href="index.html" class="internal-link">igraph</a></code><wbr></wbr>.<code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code></code></h1>
          <div id="showPrivate">
            <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
          </div>
        </div>

        <div class="categoryHeader">
          class documentation
        </div>

        <div class="extrasDocstring">
          <p><code><span class="py-keyword">class</span> <span class="py-defname">Graph</span>(<a href="igraph.GraphBase.html" class="internal-link" title="igraph.GraphBase">GraphBase</a>):</code></p>
          <p><a href="classIndex.html#igraph.Graph">View In Hierarchy</a></p>
        </div>

        <div class="moduleDocstring">
          <div><p>Generic graph.</p>
<p>This class is built on top of <code><a href="igraph.GraphBase.html" class="internal-link" title="igraph.GraphBase">GraphBase</a></code>, so the order of the methods in the generated API documentation is a little bit obscure: inherited methods come after the ones implemented directly in the subclass. <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> provides many functions that <code><a href="igraph.GraphBase.html" class="internal-link" title="igraph.GraphBase">GraphBase</a></code> does not, mostly because these functions are not speed critical and they were easier to implement in Python than in pure C. An example is the attribute handling in the constructor: the constructor of <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> accepts three dictionaries corresponding to the graph, vertex and edge attributes while the constructor of <code><a href="igraph.GraphBase.html" class="internal-link" title="igraph.GraphBase">GraphBase</a></code> does not. This extension was needed to make <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> serializable through the <tt class="rst-docutils literal">pickle</tt> module. <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> also overrides some functions from <code><a href="igraph.GraphBase.html" class="internal-link" title="igraph.GraphBase">GraphBase</a></code> to provide a more convenient interface; e.g., layout functions return a <code><a href="igraph.layout.Layout.html" class="internal-link" title="igraph.layout.Layout">Layout</a></code> instance from <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> instead of a list of coordinate pairs.</p>
<p>Graphs can also be indexed by strings or pairs of vertex indices or vertex names.  When a graph is indexed by a string, the operation translates to the retrieval, creation, modification or deletion of a graph attribute:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Full(3)
<span class="py-prompt">&gt;&gt;&gt; </span>g[<span class="py-string">"name"</span>] = <span class="py-string">"Triangle graph"</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g[<span class="py-string">"name"</span>]
<span class="py-output">'Triangle graph'</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">del</span> g[<span class="py-string">"name"</span>]</pre><p>When a graph is indexed by a pair of vertex indices or names, the graph itself is treated as an adjacency matrix and the corresponding cell of the matrix is returned:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Full(3)
<span class="py-prompt">&gt;&gt;&gt; </span>g.vs[<span class="py-string">"name"</span>] = [<span class="py-string">"A"</span>, <span class="py-string">"B"</span>, <span class="py-string">"C"</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>g[1, 2]
<span class="py-output">1</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g[<span class="py-string">"A"</span>, <span class="py-string">"B"</span>]
<span class="py-output">1</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g[<span class="py-string">"A"</span>, <span class="py-string">"B"</span>] = 0
<span class="py-prompt">&gt;&gt;&gt; </span>g.ecount()
<span class="py-output">2</span>
</pre><p>Assigning values different from zero or one to the adjacency matrix will be translated to one, unless the graph is weighted, in which case the numbers will be treated as weights:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g.is_weighted()
<span class="py-output">False</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g[<span class="py-string">"A"</span>, <span class="py-string">"B"</span>] = 2
<span class="py-prompt">&gt;&gt;&gt; </span>g[<span class="py-string">"A"</span>, <span class="py-string">"B"</span>]
<span class="py-output">1</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g.es[<span class="py-string">"weight"</span>] = 1.0
<span class="py-prompt">&gt;&gt;&gt; </span>g.is_weighted()
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g[<span class="py-string">"A"</span>, <span class="py-string">"B"</span>] = 2
<span class="py-prompt">&gt;&gt;&gt; </span>g[<span class="py-string">"A"</span>, <span class="py-string">"B"</span>]
<span class="py-output">2</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g.es[<span class="py-string">"weight"</span>]
<span class="py-output">[1.0, 1.0, 2]</span>
</pre></div>
        </div>

        <div id="splitTables">
          <table class="children sortable" id="id246">
  
  
  <tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#Adjacency" class="internal-link" title="igraph.Graph.Adjacency"><wbr></wbr>Adjacency</a></code></td>
    <td>Generates a graph from its adjacency matrix.</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#Bipartite" class="internal-link" title="igraph.Graph.Bipartite"><wbr></wbr>Bipartite</a></code></td>
    <td>Creates a bipartite graph with the given vertex types and edges. This is similar to the default constructor of the graph, the only difference is that it checks whether all the edges go between the two vertex classes and it assigns the type vector to a ...</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#DataFrame" class="internal-link" title="igraph.Graph.DataFrame"><wbr></wbr>Data<wbr></wbr>Frame</a></code></td>
    <td>Generates a graph from one or two dataframes.</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#DictDict" class="internal-link" title="igraph.Graph.DictDict"><wbr></wbr>Dict<wbr></wbr>Dict</a></code></td>
    <td>Constructs a graph from a dict-of-dicts representation.</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#DictList" class="internal-link" title="igraph.Graph.DictList"><wbr></wbr>Dict<wbr></wbr>List</a></code></td>
    <td>Constructs a graph from a list-of-dictionaries representation.</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#from_graph_tool" class="internal-link" title="igraph.Graph.from_graph_tool">from<wbr></wbr>_graph<wbr></wbr>_tool</a></code></td>
    <td>Converts the graph from graph-tool</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#from_networkx" class="internal-link" title="igraph.Graph.from_networkx">from<wbr></wbr>_networkx</a></code></td>
    <td>Converts the graph from networkx</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#GRG" class="internal-link" title="igraph.Graph.GRG">GRG</a></code></td>
    <td>Generates a random geometric graph.</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#Incidence" class="internal-link" title="igraph.Graph.Incidence"><wbr></wbr>Incidence</a></code></td>
    <td>Creates a bipartite graph from an incidence matrix.</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#ListDict" class="internal-link" title="igraph.Graph.ListDict"><wbr></wbr>List<wbr></wbr>Dict</a></code></td>
    <td>Constructs a graph from a dict-of-lists representation.</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#Read" class="internal-link" title="igraph.Graph.Read"><wbr></wbr>Read</a></code></td>
    <td>Unified reading function for graphs.</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#Read_DIMACS" class="internal-link" title="igraph.Graph.Read_DIMACS"><wbr></wbr>Read_<wbr></wbr>DIMACS</a></code></td>
    <td>Reads a graph from a file conforming to the DIMACS minimum-cost flow file format.</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#Read_GraphMLz" class="internal-link" title="igraph.Graph.Read_GraphMLz"><wbr></wbr>Read_<wbr></wbr>Graph<wbr></wbr>MLz</a></code></td>
    <td>Reads a graph from a zipped GraphML file.</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#Read_Pickle" class="internal-link" title="igraph.Graph.Read_Pickle"><wbr></wbr>Read_<wbr></wbr>Pickle</a></code></td>
    <td>Reads a graph from Python pickled format</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#Read_Picklez" class="internal-link" title="igraph.Graph.Read_Picklez"><wbr></wbr>Read_<wbr></wbr>Picklez</a></code></td>
    <td>Reads a graph from compressed Python pickled format, uncompressing it on-the-fly.</td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><code><a href="#TupleList" class="internal-link" title="igraph.Graph.TupleList"><wbr></wbr>Tuple<wbr></wbr>List</a></code></td>
    <td>Constructs a graph from a list-of-tuples representation.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__add__" class="internal-link" title="igraph.Graph.__add__">__add__</a></code></td>
    <td>Copies the graph and extends the copy depending on the type of the other object given.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__and__" class="internal-link" title="igraph.Graph.__and__">__and__</a></code></td>
    <td>Graph intersection operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__bool__" class="internal-link" title="igraph.Graph.__bool__">__bool__</a></code></td>
    <td>Returns True if the graph has at least one vertex, False otherwise.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__coerce__" class="internal-link" title="igraph.Graph.__coerce__">__coerce__</a></code></td>
    <td>Coercion rules.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__iadd__" class="internal-link" title="igraph.Graph.__iadd__">__iadd__</a></code></td>
    <td>In-place addition (disjoint union).</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__init__" class="internal-link" title="igraph.Graph.__init__">__init__</a></code></td>
    <td>__init__(n=0, edges=None, directed=False, graph_attrs=None, vertex_attrs=None, edge_attrs=None)</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__isub__" class="internal-link" title="igraph.Graph.__isub__">__isub__</a></code></td>
    <td>In-place subtraction (difference).</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__mul__" class="internal-link" title="igraph.Graph.__mul__">__mul__</a></code></td>
    <td>Copies exact replicas of the original graph an arbitrary number of times.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__or__" class="internal-link" title="igraph.Graph.__or__">__or__</a></code></td>
    <td>Graph union operator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__plot__" class="internal-link" title="igraph.Graph.__plot__">__plot__</a></code></td>
    <td>Plots the graph to the given Cairo context or matplotlib Axes.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__reduce__" class="internal-link" title="igraph.Graph.__reduce__">__reduce__</a></code></td>
    <td>Support for pickling.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__str__" class="internal-link" title="igraph.Graph.__str__">__str__</a></code></td>
    <td>Returns a string representation of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__sub__" class="internal-link" title="igraph.Graph.__sub__">__sub__</a></code></td>
    <td>Removes the given object(s) from the graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add_edge" class="internal-link" title="igraph.Graph.add_edge">add<wbr></wbr>_edge</a></code></td>
    <td>Adds a single edge to the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add_edges" class="internal-link" title="igraph.Graph.add_edges">add<wbr></wbr>_edges</a></code></td>
    <td>Adds some edges to the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add_vertex" class="internal-link" title="igraph.Graph.add_vertex">add<wbr></wbr>_vertex</a></code></td>
    <td>Adds a single vertex to the graph. Keyword arguments will be assigned as vertex attributes. Note that <tt class="rst-docutils literal">name</tt> as a keyword argument is treated specially; if a graph has <tt class="rst-docutils literal">name</tt> as a vertex attribute, it allows one to refer to vertices by their names in most places where igraph expects a vertex ID.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add_vertices" class="internal-link" title="igraph.Graph.add_vertices">add<wbr></wbr>_vertices</a></code></td>
    <td>Adds some vertices to the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#all_st_cuts" class="internal-link" title="igraph.Graph.all_st_cuts">all<wbr></wbr>_st<wbr></wbr>_cuts</a></code></td>
    <td>Returns all the cuts between the source and target vertices in a directed graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#all_st_mincuts" class="internal-link" title="igraph.Graph.all_st_mincuts">all<wbr></wbr>_st<wbr></wbr>_mincuts</a></code></td>
    <td>Returns all the mincuts between the source and target vertices in a directed graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#as_directed" class="internal-link" title="igraph.Graph.as_directed">as<wbr></wbr>_directed</a></code></td>
    <td>Returns a directed copy of this graph. Arguments are passed on to <code><a href="igraph.GraphBase.html#to_directed" class="internal-link" title="igraph.GraphBase.to_directed">GraphBase.to_directed()</a></code> that is invoked on the copy.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#as_undirected" class="internal-link" title="igraph.Graph.as_undirected">as<wbr></wbr>_undirected</a></code></td>
    <td>Returns an undirected copy of this graph. Arguments are passed on to <code><a href="igraph.GraphBase.html#to_undirected" class="internal-link" title="igraph.GraphBase.to_undirected">GraphBase.to_undirected()</a></code> that is invoked on the copy.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#biconnected_components" class="internal-link" title="igraph.Graph.biconnected_components">biconnected<wbr></wbr>_components</a></code></td>
    <td>Calculates the biconnected components of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bipartite_projection" class="internal-link" title="igraph.Graph.bipartite_projection">bipartite<wbr></wbr>_projection</a></code></td>
    <td>Projects a bipartite graph into two one-mode graphs. Edge directions are ignored while projecting.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bipartite_projection_size" class="internal-link" title="igraph.Graph.bipartite_projection_size">bipartite<wbr></wbr>_projection<wbr></wbr>_size</a></code></td>
    <td>Calculates the number of vertices and edges in the bipartite projections of this graph according to the specified vertex types. This is useful if you have a bipartite graph and you want to estimate the amount of memory you would need to calculate the projections themselves.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#blocks" class="internal-link" title="igraph.Graph.blocks">blocks</a></code></td>
    <td>Calculates the biconnected components of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#clear" class="internal-link" title="igraph.Graph.clear">clear</a></code></td>
    <td>Clears the graph, deleting all vertices, edges, and attributes.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#clusters" class="internal-link" title="igraph.Graph.clusters">clusters</a></code></td>
    <td>Deprecated alias to <code><a href="igraph.GraphBase.html#connected_components" class="internal-link" title="igraph.GraphBase.connected_components">Graph.connected_components()</a></code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_edge_betweenness" class="internal-link" title="igraph.Graph.community_edge_betweenness">community<wbr></wbr>_edge<wbr></wbr>_betweenness</a></code></td>
    <td>Community structure based on the betweenness of the edges in the network.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_fastgreedy" class="internal-link" title="igraph.Graph.community_fastgreedy">community<wbr></wbr>_fastgreedy</a></code></td>
    <td>Community structure based on the greedy optimization of modularity.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_infomap" class="internal-link" title="igraph.Graph.community_infomap">community<wbr></wbr>_infomap</a></code></td>
    <td>Finds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_label_propagation" class="internal-link" title="igraph.Graph.community_label_propagation">community<wbr></wbr>_label<wbr></wbr>_propagation</a></code></td>
    <td>Finds the community structure of the graph according to the label propagation method of Raghavan et al.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_leading_eigenvector" class="internal-link" title="igraph.Graph.community_leading_eigenvector">community<wbr></wbr>_leading<wbr></wbr>_eigenvector</a></code></td>
    <td>Newman's leading eigenvector method for detecting community structure.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_leading_eigenvector_naive" class="internal-link" title="igraph.Graph.community_leading_eigenvector_naive">community<wbr></wbr>_leading<wbr></wbr>_eigenvector<wbr></wbr>_naive</a></code></td>
    <td>Naive implementation of Newman's eigenvector community structure detection.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_leiden" class="internal-link" title="igraph.Graph.community_leiden">community<wbr></wbr>_leiden</a></code></td>
    <td>Finds the community structure of the graph using the Leiden algorithm of Traag, van Eck &amp; Waltman.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_multilevel" class="internal-link" title="igraph.Graph.community_multilevel">community<wbr></wbr>_multilevel</a></code></td>
    <td>Community structure based on the multilevel algorithm of Blondel et al.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_optimal_modularity" class="internal-link" title="igraph.Graph.community_optimal_modularity">community<wbr></wbr>_optimal<wbr></wbr>_modularity</a></code></td>
    <td>Calculates the optimal modularity score of the graph and the corresponding community structure.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_spinglass" class="internal-link" title="igraph.Graph.community_spinglass">community<wbr></wbr>_spinglass</a></code></td>
    <td>Finds the community structure of the graph according to the spinglass community detection method of Reichardt &amp; Bornholdt.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_walktrap" class="internal-link" title="igraph.Graph.community_walktrap">community<wbr></wbr>_walktrap</a></code></td>
    <td>Community detection algorithm of Latapy &amp; Pons, based on random walks.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#components" class="internal-link" title="igraph.Graph.components">components</a></code></td>
    <td>Calculates the (strong or weak) connected components for a given graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#count_automorphisms_vf2" class="internal-link" title="igraph.Graph.count_automorphisms_vf2">count<wbr></wbr>_automorphisms<wbr></wbr>_vf2</a></code></td>
    <td>Returns the number of automorphisms of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#degree_distribution" class="internal-link" title="igraph.Graph.degree_distribution">degree<wbr></wbr>_distribution</a></code></td>
    <td>Calculates the degree distribution of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#delete_edges" class="internal-link" title="igraph.Graph.delete_edges">delete<wbr></wbr>_edges</a></code></td>
    <td>Deletes some edges from the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#dfs" class="internal-link" title="igraph.Graph.dfs">dfs</a></code></td>
    <td>Conducts a depth first search (DFS) on the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#disjoint_union" class="internal-link" title="igraph.Graph.disjoint_union">disjoint<wbr></wbr>_union</a></code></td>
    <td>Creates the disjoint union of two (or more) graphs.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#dyad_census" class="internal-link" title="igraph.Graph.dyad_census">dyad<wbr></wbr>_census</a></code></td>
    <td>Calculates the dyad census of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_adjacency" class="internal-link" title="igraph.Graph.get_adjacency">get<wbr></wbr>_adjacency</a></code></td>
    <td>Returns the adjacency matrix of a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_adjacency_sparse" class="internal-link" title="igraph.Graph.get_adjacency_sparse">get<wbr></wbr>_adjacency<wbr></wbr>_sparse</a></code></td>
    <td>Returns the adjacency matrix of a graph as a SciPy CSR matrix.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_adjlist" class="internal-link" title="igraph.Graph.get_adjlist">get<wbr></wbr>_adjlist</a></code></td>
    <td>Returns the adjacency list representation of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_all_simple_paths" class="internal-link" title="igraph.Graph.get_all_simple_paths">get<wbr></wbr>_all<wbr></wbr>_simple<wbr></wbr>_paths</a></code></td>
    <td>Calculates all the simple paths from a given node to some other nodes (or all of them) in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_automorphisms_vf2" class="internal-link" title="igraph.Graph.get_automorphisms_vf2">get<wbr></wbr>_automorphisms<wbr></wbr>_vf2</a></code></td>
    <td>Returns all the automorphisms of the graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_edge_dataframe" class="internal-link" title="igraph.Graph.get_edge_dataframe">get<wbr></wbr>_edge<wbr></wbr>_dataframe</a></code></td>
    <td>Export edges with attributes to pandas.DataFrame</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_incidence" class="internal-link" title="igraph.Graph.get_incidence">get<wbr></wbr>_incidence</a></code></td>
    <td>Returns the incidence matrix of a bipartite graph. The incidence matrix is an <span class="rst-math rst-formula"><i>n</i></span> times <span class="rst-math rst-formula"><i>m</i></span> matrix, where <span class="rst-math rst-formula"><i>n</i></span> and <span class="rst-math rst-formula"><i>m</i></span> are the number of vertices in the two vertex classes.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_inclist" class="internal-link" title="igraph.Graph.get_inclist">get<wbr></wbr>_inclist</a></code></td>
    <td>Returns the incidence list representation of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_vertex_dataframe" class="internal-link" title="igraph.Graph.get_vertex_dataframe">get<wbr></wbr>_vertex<wbr></wbr>_dataframe</a></code></td>
    <td>Export vertices with attributes to pandas.DataFrame</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#gomory_hu_tree" class="internal-link" title="igraph.Graph.gomory_hu_tree">gomory<wbr></wbr>_hu<wbr></wbr>_tree</a></code></td>
    <td>Calculates the Gomory-Hu tree of an undirected graph with optional edge capacities.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#indegree" class="internal-link" title="igraph.Graph.indegree">indegree</a></code></td>
    <td>Returns the in-degrees in a list.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#intersection" class="internal-link" title="igraph.Graph.intersection">intersection</a></code></td>
    <td>Creates the intersection of two (or more) graphs.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_named" class="internal-link" title="igraph.Graph.is_named">is<wbr></wbr>_named</a></code></td>
    <td>Returns whether the graph is named.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_weighted" class="internal-link" title="igraph.Graph.is_weighted">is<wbr></wbr>_weighted</a></code></td>
    <td>Returns whether the graph is weighted.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#k_core" class="internal-link" title="igraph.Graph.k_core">k<wbr></wbr>_core</a></code></td>
    <td>Returns some k-cores of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout" class="internal-link" title="igraph.Graph.layout">layout</a></code></td>
    <td>Returns the layout of the graph according to a layout algorithm.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_auto" class="internal-link" title="igraph.Graph.layout_auto">layout<wbr></wbr>_auto</a></code></td>
    <td>Chooses and runs a suitable layout function based on simple topological properties of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_sugiyama" class="internal-link" title="igraph.Graph.layout_sugiyama">layout<wbr></wbr>_sugiyama</a></code></td>
    <td>Places the vertices using a layered Sugiyama layout.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maxflow" class="internal-link" title="igraph.Graph.maxflow">maxflow</a></code></td>
    <td>Returns a maximum flow between the given source and target vertices in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maximum_bipartite_matching" class="internal-link" title="igraph.Graph.maximum_bipartite_matching">maximum<wbr></wbr>_bipartite<wbr></wbr>_matching</a></code></td>
    <td>Finds a maximum matching in a bipartite graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#mincut" class="internal-link" title="igraph.Graph.mincut">mincut</a></code></td>
    <td>Calculates the minimum cut between the given source and target vertices or within the whole graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#modularity" class="internal-link" title="igraph.Graph.modularity">modularity</a></code></td>
    <td>Calculates the modularity score of the graph with respect to a given clustering.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#outdegree" class="internal-link" title="igraph.Graph.outdegree">outdegree</a></code></td>
    <td>Returns the out-degrees in a list.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#pagerank" class="internal-link" title="igraph.Graph.pagerank">pagerank</a></code></td>
    <td>Calculates the PageRank values of a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#path_length_hist" class="internal-link" title="igraph.Graph.path_length_hist">path<wbr></wbr>_length<wbr></wbr>_hist</a></code></td>
    <td>Returns the path length histogram of the graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#shortest_paths" class="internal-link" title="igraph.Graph.shortest_paths">shortest<wbr></wbr>_paths</a></code></td>
    <td>Deprecated alias to <code><a href="igraph.GraphBase.html#distances" class="internal-link" title="igraph.GraphBase.distances">Graph.distances()</a></code>.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#spanning_tree" class="internal-link" title="igraph.Graph.spanning_tree">spanning<wbr></wbr>_tree</a></code></td>
    <td>Calculates a minimum spanning tree for a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#summary" class="internal-link" title="igraph.Graph.summary">summary</a></code></td>
    <td>Returns the summary of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#to_dict_dict" class="internal-link" title="igraph.Graph.to_dict_dict">to<wbr></wbr>_dict<wbr></wbr>_dict</a></code></td>
    <td>Export graph to dictionary of dicts of edge attributes</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#to_dict_list" class="internal-link" title="igraph.Graph.to_dict_list">to<wbr></wbr>_dict<wbr></wbr>_list</a></code></td>
    <td>Export graph as two lists of dictionaries, for vertices and edges.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#to_graph_tool" class="internal-link" title="igraph.Graph.to_graph_tool">to<wbr></wbr>_graph<wbr></wbr>_tool</a></code></td>
    <td>Converts the graph to graph-tool</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#to_list_dict" class="internal-link" title="igraph.Graph.to_list_dict">to<wbr></wbr>_list<wbr></wbr>_dict</a></code></td>
    <td>Export graph to a dictionary of lists (or other sequences).</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#to_networkx" class="internal-link" title="igraph.Graph.to_networkx">to<wbr></wbr>_networkx</a></code></td>
    <td>Converts the graph to networkx format.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#to_tuple_list" class="internal-link" title="igraph.Graph.to_tuple_list">to<wbr></wbr>_tuple<wbr></wbr>_list</a></code></td>
    <td>Export graph to a list of edge tuples</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#transitivity_avglocal_undirected" class="internal-link" title="igraph.Graph.transitivity_avglocal_undirected">transitivity<wbr></wbr>_avglocal<wbr></wbr>_undirected</a></code></td>
    <td>Calculates the average of the vertex transitivities of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#triad_census" class="internal-link" title="igraph.Graph.triad_census">triad<wbr></wbr>_census</a></code></td>
    <td>Calculates the triad census of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#union" class="internal-link" title="igraph.Graph.union">union</a></code></td>
    <td>Creates the union of two (or more) graphs.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write" class="internal-link" title="igraph.Graph.write">write</a></code></td>
    <td>Unified writing function for graphs.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_adjacency" class="internal-link" title="igraph.Graph.write_adjacency">write<wbr></wbr>_adjacency</a></code></td>
    <td>Writes the adjacency matrix of the graph to the given file</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_dimacs" class="internal-link" title="igraph.Graph.write_dimacs">write<wbr></wbr>_dimacs</a></code></td>
    <td>Writes the graph in DIMACS format to the given file.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_graphmlz" class="internal-link" title="igraph.Graph.write_graphmlz">write<wbr></wbr>_graphmlz</a></code></td>
    <td>Writes the graph to a zipped GraphML file.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_pickle" class="internal-link" title="igraph.Graph.write_pickle">write<wbr></wbr>_pickle</a></code></td>
    <td>Saves the graph in Python pickled format</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_picklez" class="internal-link" title="igraph.Graph.write_picklez">write<wbr></wbr>_picklez</a></code></td>
    <td>Saves the graph in Python pickled format, compressed with gzip.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_svg" class="internal-link" title="igraph.Graph.write_svg">write<wbr></wbr>_svg</a></code></td>
    <td>Saves the graph as an SVG (Scalable Vector Graphics) file</td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><code><a href="#__hash__" class="internal-link" title="igraph.Graph.__hash__">__hash__</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><code><a href="#__iter__" class="internal-link" title="igraph.Graph.__iter__">__iter__</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><code><a href="#Formula" class="internal-link" title="igraph.Graph.Formula"><wbr></wbr>Formula</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="property">
    
    <td>Property</td>
    <td><code><a href="#es" class="internal-link" title="igraph.Graph.es">es</a></code></td>
    <td>The edge sequence of the graph</td>
  </tr><tr class="property">
    
    <td>Property</td>
    <td><code><a href="#vs" class="internal-link" title="igraph.Graph.vs">vs</a></code></td>
    <td>The vertex sequence of the graph</td>
  </tr><tr class="classmethod private">
    
    <td>Class Method</td>
    <td><code><a href="#_reconstruct" class="internal-link" title="igraph.Graph._reconstruct">_reconstruct</a></code></td>
    <td>Reconstructs a Graph object from Python's pickled format.</td>
  </tr><tr class="property private">
    
    <td>Property</td>
    <td><code><a href="#_as_parameter_" class="internal-link" title="igraph.Graph._as_parameter_">_as<wbr></wbr>_parameter_</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
          
            <p class="inheritedFrom">
              Inherited from <code><a href="igraph.GraphBase.html" class="internal-link" title="igraph.GraphBase">GraphBase</a></code>:
            </p>
            <table class="children sortable" id="id247">
  
  
  <tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#__new__" class="internal-link" title="igraph.GraphBase.__new__">__new__</a></code></td>
    <td>Create and return a new object.  See help(type) for accurate signature.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#all_minimal_st_separators" class="internal-link" title="igraph.GraphBase.all_minimal_st_separators">all<wbr></wbr>_minimal<wbr></wbr>_st<wbr></wbr>_separators</a></code></td>
    <td>Returns a list containing all the minimal s-t separators of a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#are_connected" class="internal-link" title="igraph.GraphBase.are_connected">are<wbr></wbr>_connected</a></code></td>
    <td>Decides whether two given vertices are directly connected.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#articulation_points" class="internal-link" title="igraph.GraphBase.articulation_points">articulation<wbr></wbr>_points</a></code></td>
    <td>Returns the list of articulation points in the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#assortativity" class="internal-link" title="igraph.GraphBase.assortativity">assortativity</a></code></td>
    <td>Returns the assortativity of the graph based on numeric properties of the vertices.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#assortativity_degree" class="internal-link" title="igraph.GraphBase.assortativity_degree">assortativity<wbr></wbr>_degree</a></code></td>
    <td>Returns the assortativity of a graph based on vertex degrees.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#assortativity_nominal" class="internal-link" title="igraph.GraphBase.assortativity_nominal">assortativity<wbr></wbr>_nominal</a></code></td>
    <td>Returns the assortativity of the graph based on vertex categories.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Asymmetric_Preference" class="internal-link" title="igraph.GraphBase.Asymmetric_Preference"><wbr></wbr>Asymmetric_<wbr></wbr>Preference</a></code></td>
    <td>Generates a graph based on asymmetric vertex types and connection probabilities.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Atlas" class="internal-link" title="igraph.GraphBase.Atlas"><wbr></wbr>Atlas</a></code></td>
    <td>Generates a graph from the Graph Atlas.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#attributes" class="internal-link" title="igraph.GraphBase.attributes">attributes</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#authority_score" class="internal-link" title="igraph.GraphBase.authority_score">authority<wbr></wbr>_score</a></code></td>
    <td>Calculates Kleinberg's authority score for the vertices of the graph</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#average_path_length" class="internal-link" title="igraph.GraphBase.average_path_length">average<wbr></wbr>_path<wbr></wbr>_length</a></code></td>
    <td>Calculates the average path length in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Barabasi" class="internal-link" title="igraph.GraphBase.Barabasi"><wbr></wbr>Barabasi</a></code></td>
    <td>Generates a graph based on the Barabasi-Albert model.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#betweenness" class="internal-link" title="igraph.GraphBase.betweenness">betweenness</a></code></td>
    <td>Calculates or estimates the betweenness of vertices in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#bfs" class="internal-link" title="igraph.GraphBase.bfs">bfs</a></code></td>
    <td>Conducts a breadth first search (BFS) on the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#bfsiter" class="internal-link" title="igraph.GraphBase.bfsiter">bfsiter</a></code></td>
    <td>Constructs a breadth first search (BFS) iterator of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#bibcoupling" class="internal-link" title="igraph.GraphBase.bibcoupling">bibcoupling</a></code></td>
    <td>Calculates bibliographic coupling scores for given vertices in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#bridges" class="internal-link" title="igraph.GraphBase.bridges">bridges</a></code></td>
    <td>Returns the list of bridges in the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#canonical_permutation" class="internal-link" title="igraph.GraphBase.canonical_permutation">canonical<wbr></wbr>_permutation</a></code></td>
    <td>Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#chordal_completion" class="internal-link" title="igraph.GraphBase.chordal_completion">chordal<wbr></wbr>_completion</a></code></td>
    <td>Returns the list of edges needed to be added to the graph to make it chordal.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#clique_number" class="internal-link" title="igraph.GraphBase.clique_number">clique<wbr></wbr>_number</a></code></td>
    <td>Returns the clique number of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#cliques" class="internal-link" title="igraph.GraphBase.cliques">cliques</a></code></td>
    <td>Returns some or all cliques of the graph as a list of tuples.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#closeness" class="internal-link" title="igraph.GraphBase.closeness">closeness</a></code></td>
    <td>Calculates the closeness centralities of given vertices in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#cocitation" class="internal-link" title="igraph.GraphBase.cocitation">cocitation</a></code></td>
    <td>Calculates cocitation scores for given vertices in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#cohesive_blocks" class="internal-link" title="igraph.GraphBase.cohesive_blocks">cohesive<wbr></wbr>_blocks</a></code></td>
    <td>Calculates the cohesive block structure of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#complementer" class="internal-link" title="igraph.GraphBase.complementer">complementer</a></code></td>
    <td>Returns the complementer of the graph</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#compose" class="internal-link" title="igraph.GraphBase.compose">compose</a></code></td>
    <td>Returns the composition of two graphs.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#connected_components" class="internal-link" title="igraph.GraphBase.connected_components">connected<wbr></wbr>_components</a></code></td>
    <td>Calculates the (strong or weak) connected components for a given graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#constraint" class="internal-link" title="igraph.GraphBase.constraint">constraint</a></code></td>
    <td>Calculates Burt's constraint scores for given vertices in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#contract_vertices" class="internal-link" title="igraph.GraphBase.contract_vertices">contract<wbr></wbr>_vertices</a></code></td>
    <td>Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#convergence_degree" class="internal-link" title="igraph.GraphBase.convergence_degree">convergence<wbr></wbr>_degree</a></code></td>
    <td>Undocumented (yet).</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#convergence_field_size" class="internal-link" title="igraph.GraphBase.convergence_field_size">convergence<wbr></wbr>_field<wbr></wbr>_size</a></code></td>
    <td>Undocumented (yet).</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#copy" class="internal-link" title="igraph.GraphBase.copy">copy</a></code></td>
    <td>Creates a copy of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#coreness" class="internal-link" title="igraph.GraphBase.coreness">coreness</a></code></td>
    <td>Finds the coreness (shell index) of the vertices of the network.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#count_isomorphisms_vf2" class="internal-link" title="igraph.GraphBase.count_isomorphisms_vf2">count<wbr></wbr>_isomorphisms<wbr></wbr>_vf2</a></code></td>
    <td>Determines the number of isomorphisms between the graph and another one</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#count_multiple" class="internal-link" title="igraph.GraphBase.count_multiple">count<wbr></wbr>_multiple</a></code></td>
    <td>Counts the multiplicities of the given edges.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#count_subisomorphisms_vf2" class="internal-link" title="igraph.GraphBase.count_subisomorphisms_vf2">count<wbr></wbr>_subisomorphisms<wbr></wbr>_vf2</a></code></td>
    <td>Determines the number of subisomorphisms between the graph and another one</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#De_Bruijn" class="internal-link" title="igraph.GraphBase.De_Bruijn"><wbr></wbr>De_<wbr></wbr>Bruijn</a></code></td>
    <td>Generates a de Bruijn graph with parameters (m, n)</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#decompose" class="internal-link" title="igraph.GraphBase.decompose">decompose</a></code></td>
    <td>Decomposes the graph into subgraphs.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#degree" class="internal-link" title="igraph.GraphBase.degree">degree</a></code></td>
    <td>Returns some vertex degrees from the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Degree_Sequence" class="internal-link" title="igraph.GraphBase.Degree_Sequence"><wbr></wbr>Degree_<wbr></wbr>Sequence</a></code></td>
    <td>Generates a graph with a given degree sequence.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#delete_vertices" class="internal-link" title="igraph.GraphBase.delete_vertices">delete<wbr></wbr>_vertices</a></code></td>
    <td>Deletes vertices and all its edges from the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#density" class="internal-link" title="igraph.GraphBase.density">density</a></code></td>
    <td>Calculates the density of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#dfsiter" class="internal-link" title="igraph.GraphBase.dfsiter">dfsiter</a></code></td>
    <td>Constructs a depth first search (DFS) iterator of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#diameter" class="internal-link" title="igraph.GraphBase.diameter">diameter</a></code></td>
    <td>Calculates the diameter of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#difference" class="internal-link" title="igraph.GraphBase.difference">difference</a></code></td>
    <td>Subtracts the given graph from the original</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#distances" class="internal-link" title="igraph.GraphBase.distances">distances</a></code></td>
    <td>Calculates shortest path lengths for given vertices in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#diversity" class="internal-link" title="igraph.GraphBase.diversity">diversity</a></code></td>
    <td>Calculates the structural diversity index of the vertices.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#dominator" class="internal-link" title="igraph.GraphBase.dominator">dominator</a></code></td>
    <td>Returns the dominator tree from the given root node</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#eccentricity" class="internal-link" title="igraph.GraphBase.eccentricity">eccentricity</a></code></td>
    <td>Calculates the eccentricities of given vertices in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#ecount" class="internal-link" title="igraph.GraphBase.ecount">ecount</a></code></td>
    <td>Counts the number of edges.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#edge_attributes" class="internal-link" title="igraph.GraphBase.edge_attributes">edge<wbr></wbr>_attributes</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#edge_betweenness" class="internal-link" title="igraph.GraphBase.edge_betweenness">edge<wbr></wbr>_betweenness</a></code></td>
    <td>Calculates or estimates the edge betweennesses in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#edge_connectivity" class="internal-link" title="igraph.GraphBase.edge_connectivity">edge<wbr></wbr>_connectivity</a></code></td>
    <td>Calculates the edge connectivity of the graph or between some vertices.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#eigen_adjacency" class="internal-link" title="igraph.GraphBase.eigen_adjacency">eigen<wbr></wbr>_adjacency</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#eigenvector_centrality" class="internal-link" title="igraph.GraphBase.eigenvector_centrality">eigenvector<wbr></wbr>_centrality</a></code></td>
    <td>Calculates the eigenvector centralities of the vertices in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Erdos_Renyi" class="internal-link" title="igraph.GraphBase.Erdos_Renyi"><wbr></wbr>Erdos_<wbr></wbr>Renyi</a></code></td>
    <td>Generates a graph based on the Erdos-Renyi model.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Establishment" class="internal-link" title="igraph.GraphBase.Establishment"><wbr></wbr>Establishment</a></code></td>
    <td>Generates a graph based on a simple growing model with vertex types.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Famous" class="internal-link" title="igraph.GraphBase.Famous"><wbr></wbr>Famous</a></code></td>
    <td>Generates a famous graph based on its name.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#farthest_points" class="internal-link" title="igraph.GraphBase.farthest_points">farthest<wbr></wbr>_points</a></code></td>
    <td>Returns two vertex IDs whose distance equals the actual diameter of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#feedback_arc_set" class="internal-link" title="igraph.GraphBase.feedback_arc_set">feedback<wbr></wbr>_arc<wbr></wbr>_set</a></code></td>
    <td>Calculates an approximately or exactly minimal feedback arc set.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Forest_Fire" class="internal-link" title="igraph.GraphBase.Forest_Fire"><wbr></wbr>Forest_<wbr></wbr>Fire</a></code></td>
    <td>Generates a graph based on the forest fire model</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Full" class="internal-link" title="igraph.GraphBase.Full"><wbr></wbr>Full</a></code></td>
    <td>Generates a full graph (directed or undirected, with or without loops).</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Full_Citation" class="internal-link" title="igraph.GraphBase.Full_Citation"><wbr></wbr>Full_<wbr></wbr>Citation</a></code></td>
    <td>Generates a full citation graph</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#fundamental_cycles" class="internal-link" title="igraph.GraphBase.fundamental_cycles">fundamental<wbr></wbr>_cycles</a></code></td>
    <td>Finds a single fundamental cycle basis of the graph</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#get_all_shortest_paths" class="internal-link" title="igraph.GraphBase.get_all_shortest_paths">get<wbr></wbr>_all<wbr></wbr>_shortest<wbr></wbr>_paths</a></code></td>
    <td>Calculates all of the shortest paths from/to a given node in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#get_diameter" class="internal-link" title="igraph.GraphBase.get_diameter">get<wbr></wbr>_diameter</a></code></td>
    <td>Returns a path with the actual diameter of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#get_edgelist" class="internal-link" title="igraph.GraphBase.get_edgelist">get<wbr></wbr>_edgelist</a></code></td>
    <td>Returns the edge list of a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#get_eid" class="internal-link" title="igraph.GraphBase.get_eid">get<wbr></wbr>_eid</a></code></td>
    <td>Returns the edge ID of an arbitrary edge between vertices v1 and v2</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#get_eids" class="internal-link" title="igraph.GraphBase.get_eids">get<wbr></wbr>_eids</a></code></td>
    <td>Returns the edge IDs of some edges between some vertices.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#get_isomorphisms_vf2" class="internal-link" title="igraph.GraphBase.get_isomorphisms_vf2">get<wbr></wbr>_isomorphisms<wbr></wbr>_vf2</a></code></td>
    <td>Returns all isomorphisms between the graph and another one</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#get_shortest_paths" class="internal-link" title="igraph.GraphBase.get_shortest_paths">get<wbr></wbr>_shortest<wbr></wbr>_paths</a></code></td>
    <td>Calculates the shortest paths from/to a given node in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#get_subisomorphisms_lad" class="internal-link" title="igraph.GraphBase.get_subisomorphisms_lad">get<wbr></wbr>_subisomorphisms<wbr></wbr>_lad</a></code></td>
    <td>Returns all subisomorphisms between the graph and another one using the LAD algorithm.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#get_subisomorphisms_vf2" class="internal-link" title="igraph.GraphBase.get_subisomorphisms_vf2">get<wbr></wbr>_subisomorphisms<wbr></wbr>_vf2</a></code></td>
    <td>Returns all subisomorphisms between the graph and another one</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#girth" class="internal-link" title="igraph.GraphBase.girth">girth</a></code></td>
    <td>Returns the girth of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Growing_Random" class="internal-link" title="igraph.GraphBase.Growing_Random"><wbr></wbr>Growing_<wbr></wbr>Random</a></code></td>
    <td>Generates a growing random graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#harmonic_centrality" class="internal-link" title="igraph.GraphBase.harmonic_centrality">harmonic<wbr></wbr>_centrality</a></code></td>
    <td>Calculates the harmonic centralities of given vertices in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#has_multiple" class="internal-link" title="igraph.GraphBase.has_multiple">has<wbr></wbr>_multiple</a></code></td>
    <td>Checks whether the graph has multiple edges.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#hub_score" class="internal-link" title="igraph.GraphBase.hub_score">hub<wbr></wbr>_score</a></code></td>
    <td>Calculates Kleinberg's hub score for the vertices of the graph</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#incident" class="internal-link" title="igraph.GraphBase.incident">incident</a></code></td>
    <td>Returns the edges a given vertex is incident on.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#independence_number" class="internal-link" title="igraph.GraphBase.independence_number">independence<wbr></wbr>_number</a></code></td>
    <td>Returns the independence number of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#independent_vertex_sets" class="internal-link" title="igraph.GraphBase.independent_vertex_sets">independent<wbr></wbr>_vertex<wbr></wbr>_sets</a></code></td>
    <td>Returns some or all independent vertex sets of the graph as a list of tuples.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#induced_subgraph" class="internal-link" title="igraph.GraphBase.induced_subgraph">induced<wbr></wbr>_subgraph</a></code></td>
    <td>Returns a subgraph spanned by the given vertices.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_acyclic" class="internal-link" title="igraph.GraphBase.is_acyclic">is<wbr></wbr>_acyclic</a></code></td>
    <td>Returns whether the graph is acyclic (i.e. contains no cycles).</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_bipartite" class="internal-link" title="igraph.GraphBase.is_bipartite">is<wbr></wbr>_bipartite</a></code></td>
    <td>Decides whether the graph is bipartite or not.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_chordal" class="internal-link" title="igraph.GraphBase.is_chordal">is<wbr></wbr>_chordal</a></code></td>
    <td>Returns whether the graph is chordal or not.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_connected" class="internal-link" title="igraph.GraphBase.is_connected">is<wbr></wbr>_connected</a></code></td>
    <td>Decides whether the graph is connected.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_dag" class="internal-link" title="igraph.GraphBase.is_dag">is<wbr></wbr>_dag</a></code></td>
    <td>Checks whether the graph is a DAG (directed acyclic graph).</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_directed" class="internal-link" title="igraph.GraphBase.is_directed">is<wbr></wbr>_directed</a></code></td>
    <td>Checks whether the graph is directed.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_loop" class="internal-link" title="igraph.GraphBase.is_loop">is<wbr></wbr>_loop</a></code></td>
    <td>Checks whether a specific set of edges contain loop edges</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_minimal_separator" class="internal-link" title="igraph.GraphBase.is_minimal_separator">is<wbr></wbr>_minimal<wbr></wbr>_separator</a></code></td>
    <td>Decides whether the given vertex set is a minimal separator.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_multiple" class="internal-link" title="igraph.GraphBase.is_multiple">is<wbr></wbr>_multiple</a></code></td>
    <td>Checks whether an edge is a multiple edge.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_mutual" class="internal-link" title="igraph.GraphBase.is_mutual">is<wbr></wbr>_mutual</a></code></td>
    <td>Checks whether an edge has an opposite pair.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_separator" class="internal-link" title="igraph.GraphBase.is_separator">is<wbr></wbr>_separator</a></code></td>
    <td>Decides whether the removal of the given vertices disconnects the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_simple" class="internal-link" title="igraph.GraphBase.is_simple">is<wbr></wbr>_simple</a></code></td>
    <td>Checks whether the graph is simple (no loop or multiple edges).</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#is_tree" class="internal-link" title="igraph.GraphBase.is_tree">is<wbr></wbr>_tree</a></code></td>
    <td>Checks whether the graph is a (directed or undirected) tree graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Isoclass" class="internal-link" title="igraph.GraphBase.Isoclass"><wbr></wbr>Isoclass</a></code></td>
    <td>Generates a graph with a given isomorphism class.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#isoclass" class="internal-link" title="igraph.GraphBase.isoclass">isoclass</a></code></td>
    <td>Returns the isomorphism class of the graph or its subgraph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#isomorphic" class="internal-link" title="igraph.GraphBase.isomorphic">isomorphic</a></code></td>
    <td>Checks whether the graph is isomorphic to another graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#isomorphic_bliss" class="internal-link" title="igraph.GraphBase.isomorphic_bliss">isomorphic<wbr></wbr>_bliss</a></code></td>
    <td>Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#isomorphic_vf2" class="internal-link" title="igraph.GraphBase.isomorphic_vf2">isomorphic<wbr></wbr>_vf2</a></code></td>
    <td>Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#K_Regular" class="internal-link" title="igraph.GraphBase.K_Regular"><wbr></wbr>K_<wbr></wbr>Regular</a></code></td>
    <td>Generates a k-regular random graph</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Kautz" class="internal-link" title="igraph.GraphBase.Kautz"><wbr></wbr>Kautz</a></code></td>
    <td>Generates a Kautz graph with parameters (m, n)</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#knn" class="internal-link" title="igraph.GraphBase.knn">knn</a></code></td>
    <td>Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#laplacian" class="internal-link" title="igraph.GraphBase.laplacian">laplacian</a></code></td>
    <td>Returns the Laplacian matrix of a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#largest_cliques" class="internal-link" title="igraph.GraphBase.largest_cliques">largest<wbr></wbr>_cliques</a></code></td>
    <td>Returns the largest cliques of the graph as a list of tuples.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#largest_independent_vertex_sets" class="internal-link" title="igraph.GraphBase.largest_independent_vertex_sets">largest<wbr></wbr>_independent<wbr></wbr>_vertex<wbr></wbr>_sets</a></code></td>
    <td>Returns the largest independent vertex sets of the graph as a list of tuples.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Lattice" class="internal-link" title="igraph.GraphBase.Lattice"><wbr></wbr>Lattice</a></code></td>
    <td>Generates a regular lattice.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_bipartite" class="internal-link" title="igraph.GraphBase.layout_bipartite">layout<wbr></wbr>_bipartite</a></code></td>
    <td>Place the vertices of a bipartite graph in two layers.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_circle" class="internal-link" title="igraph.GraphBase.layout_circle">layout<wbr></wbr>_circle</a></code></td>
    <td>Places the vertices of the graph uniformly on a circle or a sphere.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_davidson_harel" class="internal-link" title="igraph.GraphBase.layout_davidson_harel">layout<wbr></wbr>_davidson<wbr></wbr>_harel</a></code></td>
    <td>Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_drl" class="internal-link" title="igraph.GraphBase.layout_drl">layout<wbr></wbr>_drl</a></code></td>
    <td>Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_fruchterman_reingold" class="internal-link" title="igraph.GraphBase.layout_fruchterman_reingold">layout<wbr></wbr>_fruchterman<wbr></wbr>_reingold</a></code></td>
    <td>Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_graphopt" class="internal-link" title="igraph.GraphBase.layout_graphopt">layout<wbr></wbr>_graphopt</a></code></td>
    <td>This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_grid" class="internal-link" title="igraph.GraphBase.layout_grid">layout<wbr></wbr>_grid</a></code></td>
    <td>Places the vertices of a graph in a 2D or 3D grid.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_kamada_kawai" class="internal-link" title="igraph.GraphBase.layout_kamada_kawai">layout<wbr></wbr>_kamada<wbr></wbr>_kawai</a></code></td>
    <td>Places the vertices on a plane according to the Kamada-Kawai algorithm.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_lgl" class="internal-link" title="igraph.GraphBase.layout_lgl">layout<wbr></wbr>_lgl</a></code></td>
    <td>Places the vertices on a 2D plane according to the Large Graph Layout.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_mds" class="internal-link" title="igraph.GraphBase.layout_mds">layout<wbr></wbr>_mds</a></code></td>
    <td>Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_random" class="internal-link" title="igraph.GraphBase.layout_random">layout<wbr></wbr>_random</a></code></td>
    <td>Places the vertices of the graph randomly.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_reingold_tilford" class="internal-link" title="igraph.GraphBase.layout_reingold_tilford">layout<wbr></wbr>_reingold<wbr></wbr>_tilford</a></code></td>
    <td>Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_reingold_tilford_circular" class="internal-link" title="igraph.GraphBase.layout_reingold_tilford_circular">layout<wbr></wbr>_reingold<wbr></wbr>_tilford<wbr></wbr>_circular</a></code></td>
    <td>Circular Reingold-Tilford layout for trees.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_star" class="internal-link" title="igraph.GraphBase.layout_star">layout<wbr></wbr>_star</a></code></td>
    <td>Calculates a star-like layout for the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#layout_umap" class="internal-link" title="igraph.GraphBase.layout_umap">layout<wbr></wbr>_umap</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#LCF" class="internal-link" title="igraph.GraphBase.LCF">LCF</a></code></td>
    <td>Generates a graph from LCF notation.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#linegraph" class="internal-link" title="igraph.GraphBase.linegraph">linegraph</a></code></td>
    <td>Returns the line graph of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#list_triangles" class="internal-link" title="igraph.GraphBase.list_triangles">list<wbr></wbr>_triangles</a></code></td>
    <td>Lists the triangles of the graph</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#maxdegree" class="internal-link" title="igraph.GraphBase.maxdegree">maxdegree</a></code></td>
    <td>Returns the maximum degree of a vertex set in the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#maxflow_value" class="internal-link" title="igraph.GraphBase.maxflow_value">maxflow<wbr></wbr>_value</a></code></td>
    <td>Returns the value of the maximum flow between the source and target vertices.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#maximal_cliques" class="internal-link" title="igraph.GraphBase.maximal_cliques">maximal<wbr></wbr>_cliques</a></code></td>
    <td>Returns the maximal cliques of the graph as a list of tuples.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#maximal_independent_vertex_sets" class="internal-link" title="igraph.GraphBase.maximal_independent_vertex_sets">maximal<wbr></wbr>_independent<wbr></wbr>_vertex<wbr></wbr>_sets</a></code></td>
    <td>Returns the maximal independent vertex sets of the graph as a list of tuples.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#maximum_cardinality_search" class="internal-link" title="igraph.GraphBase.maximum_cardinality_search">maximum<wbr></wbr>_cardinality<wbr></wbr>_search</a></code></td>
    <td>Conducts a maximum cardinality search on the graph. The function computes a rank <em>alpha</em> for each vertex such that visiting vertices in decreasing rank order corresponds to always choosing the vertex with the most already visited neighbors as the next one to visit.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#mincut_value" class="internal-link" title="igraph.GraphBase.mincut_value">mincut<wbr></wbr>_value</a></code></td>
    <td>Returns the minimum cut between the source and target vertices or within the whole graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#minimum_cycle_basis" class="internal-link" title="igraph.GraphBase.minimum_cycle_basis">minimum<wbr></wbr>_cycle<wbr></wbr>_basis</a></code></td>
    <td>Computes a minimum cycle basis of the graph</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#minimum_size_separators" class="internal-link" title="igraph.GraphBase.minimum_size_separators">minimum<wbr></wbr>_size<wbr></wbr>_separators</a></code></td>
    <td>Returns a list containing all separator vertex sets of minimum size.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#motifs_randesu" class="internal-link" title="igraph.GraphBase.motifs_randesu">motifs<wbr></wbr>_randesu</a></code></td>
    <td>Counts the number of motifs in the graph</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#motifs_randesu_estimate" class="internal-link" title="igraph.GraphBase.motifs_randesu_estimate">motifs<wbr></wbr>_randesu<wbr></wbr>_estimate</a></code></td>
    <td>Counts the total number of motifs in the graph</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#motifs_randesu_no" class="internal-link" title="igraph.GraphBase.motifs_randesu_no">motifs<wbr></wbr>_randesu<wbr></wbr>_no</a></code></td>
    <td>Counts the total number of motifs in the graph</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#neighborhood" class="internal-link" title="igraph.GraphBase.neighborhood">neighborhood</a></code></td>
    <td>For each vertex specified by <em>vertices</em>, returns the vertices reachable from that vertex in at most <em>order</em> steps. If <em>mindist</em> is larger than zero, vertices that are reachable in less than <em>mindist</em> steps are excluded.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#neighborhood_size" class="internal-link" title="igraph.GraphBase.neighborhood_size">neighborhood<wbr></wbr>_size</a></code></td>
    <td>For each vertex specified by <em>vertices</em>, returns the number of vertices reachable from that vertex in at most <em>order</em> steps. If <em>mindist</em> is larger than zero, vertices that are reachable in less than <em>mindist</em>...</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#neighbors" class="internal-link" title="igraph.GraphBase.neighbors">neighbors</a></code></td>
    <td>Returns adjacent vertices to a given vertex.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#permute_vertices" class="internal-link" title="igraph.GraphBase.permute_vertices">permute<wbr></wbr>_vertices</a></code></td>
    <td>Permutes the vertices of the graph according to the given permutation and returns the new graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#personalized_pagerank" class="internal-link" title="igraph.GraphBase.personalized_pagerank">personalized<wbr></wbr>_pagerank</a></code></td>
    <td>Calculates the personalized PageRank values of a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#predecessors" class="internal-link" title="igraph.GraphBase.predecessors">predecessors</a></code></td>
    <td>Returns the predecessors of a given vertex.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Preference" class="internal-link" title="igraph.GraphBase.Preference"><wbr></wbr>Preference</a></code></td>
    <td>Generates a graph based on vertex types and connection probabilities.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#radius" class="internal-link" title="igraph.GraphBase.radius">radius</a></code></td>
    <td>Calculates the radius of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#random_walk" class="internal-link" title="igraph.GraphBase.random_walk">random<wbr></wbr>_walk</a></code></td>
    <td>Performs a random walk of a given length from a given node.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Read_DL" class="internal-link" title="igraph.GraphBase.Read_DL"><wbr></wbr>Read_<wbr></wbr>DL</a></code></td>
    <td>Reads an UCINET DL file and creates a graph based on it.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Read_Edgelist" class="internal-link" title="igraph.GraphBase.Read_Edgelist"><wbr></wbr>Read_<wbr></wbr>Edgelist</a></code></td>
    <td>Reads an edge list from a file and creates a graph based on it.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Read_GML" class="internal-link" title="igraph.GraphBase.Read_GML"><wbr></wbr>Read_<wbr></wbr>GML</a></code></td>
    <td>Reads a GML file and creates a graph based on it.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Read_GraphDB" class="internal-link" title="igraph.GraphBase.Read_GraphDB"><wbr></wbr>Read_<wbr></wbr>Graph<wbr></wbr>DB</a></code></td>
    <td>Reads a GraphDB format file and creates a graph based on it.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Read_GraphML" class="internal-link" title="igraph.GraphBase.Read_GraphML"><wbr></wbr>Read_<wbr></wbr>Graph<wbr></wbr>ML</a></code></td>
    <td>Reads a GraphML format file and creates a graph based on it.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Read_Lgl" class="internal-link" title="igraph.GraphBase.Read_Lgl"><wbr></wbr>Read_<wbr></wbr>Lgl</a></code></td>
    <td>Reads an .lgl file used by LGL.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Read_Ncol" class="internal-link" title="igraph.GraphBase.Read_Ncol"><wbr></wbr>Read_<wbr></wbr>Ncol</a></code></td>
    <td>Reads an .ncol file used by LGL.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Read_Pajek" class="internal-link" title="igraph.GraphBase.Read_Pajek"><wbr></wbr>Read_<wbr></wbr>Pajek</a></code></td>
    <td>Reads a file in the Pajek format and creates a graph based on it. Only Pajek network files (.net extension) are supported, not project files (.paj).</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Realize_Degree_Sequence" class="internal-link" title="igraph.GraphBase.Realize_Degree_Sequence"><wbr></wbr>Realize_<wbr></wbr>Degree_<wbr></wbr>Sequence</a></code></td>
    <td>Generates a graph from a degree sequence.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Recent_Degree" class="internal-link" title="igraph.GraphBase.Recent_Degree"><wbr></wbr>Recent_<wbr></wbr>Degree</a></code></td>
    <td>Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#reciprocity" class="internal-link" title="igraph.GraphBase.reciprocity">reciprocity</a></code></td>
    <td>Reciprocity defines the proportion of mutual connections in a directed graph. It is most commonly defined as the probability that the opposite counterpart of a directed edge is also included in the graph...</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#reverse_edges" class="internal-link" title="igraph.GraphBase.reverse_edges">reverse<wbr></wbr>_edges</a></code></td>
    <td>Reverses the direction of some edges in the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#rewire" class="internal-link" title="igraph.GraphBase.rewire">rewire</a></code></td>
    <td>Randomly rewires the graph while preserving the degree distribution.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#rewire_edges" class="internal-link" title="igraph.GraphBase.rewire_edges">rewire<wbr></wbr>_edges</a></code></td>
    <td>Rewires the edges of a graph with constant probability.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Ring" class="internal-link" title="igraph.GraphBase.Ring"><wbr></wbr>Ring</a></code></td>
    <td>Generates a ring graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#SBM" class="internal-link" title="igraph.GraphBase.SBM">SBM</a></code></td>
    <td>Generates a graph based on a stochastic blockmodel.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#similarity_dice" class="internal-link" title="igraph.GraphBase.similarity_dice">similarity<wbr></wbr>_dice</a></code></td>
    <td>Dice similarity coefficient of vertices.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#similarity_inverse_log_weighted" class="internal-link" title="igraph.GraphBase.similarity_inverse_log_weighted">similarity<wbr></wbr>_inverse<wbr></wbr>_log<wbr></wbr>_weighted</a></code></td>
    <td>Inverse log-weighted similarity coefficient of vertices.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#similarity_jaccard" class="internal-link" title="igraph.GraphBase.similarity_jaccard">similarity<wbr></wbr>_jaccard</a></code></td>
    <td>Jaccard similarity coefficient of vertices.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#simplify" class="internal-link" title="igraph.GraphBase.simplify">simplify</a></code></td>
    <td>Simplifies a graph by removing self-loops and/or multiple edges.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#st_mincut" class="internal-link" title="igraph.GraphBase.st_mincut">st<wbr></wbr>_mincut</a></code></td>
    <td>Calculates the minimum cut between the source and target vertices in a graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Star" class="internal-link" title="igraph.GraphBase.Star"><wbr></wbr>Star</a></code></td>
    <td>Generates a star graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Static_Fitness" class="internal-link" title="igraph.GraphBase.Static_Fitness"><wbr></wbr>Static_<wbr></wbr>Fitness</a></code></td>
    <td>Generates a non-growing graph with edge probabilities proportional to node fitnesses.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Static_Power_Law" class="internal-link" title="igraph.GraphBase.Static_Power_Law"><wbr></wbr>Static_<wbr></wbr>Power_<wbr></wbr>Law</a></code></td>
    <td>Generates a non-growing graph with prescribed power-law degree distributions.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#strength" class="internal-link" title="igraph.GraphBase.strength">strength</a></code></td>
    <td>Returns the strength (weighted degree) of some vertices from the graph</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#subcomponent" class="internal-link" title="igraph.GraphBase.subcomponent">subcomponent</a></code></td>
    <td>Determines the indices of vertices which are in the same component as a given vertex.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#subgraph_edges" class="internal-link" title="igraph.GraphBase.subgraph_edges">subgraph<wbr></wbr>_edges</a></code></td>
    <td>Returns a subgraph spanned by the given edges.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#subisomorphic_lad" class="internal-link" title="igraph.GraphBase.subisomorphic_lad">subisomorphic<wbr></wbr>_lad</a></code></td>
    <td>Checks whether a subgraph of the graph is isomorphic to another graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#subisomorphic_vf2" class="internal-link" title="igraph.GraphBase.subisomorphic_vf2">subisomorphic<wbr></wbr>_vf2</a></code></td>
    <td>Checks whether a subgraph of the graph is isomorphic to another graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#successors" class="internal-link" title="igraph.GraphBase.successors">successors</a></code></td>
    <td>Returns the successors of a given vertex.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#to_directed" class="internal-link" title="igraph.GraphBase.to_directed">to<wbr></wbr>_directed</a></code></td>
    <td>Converts an undirected graph to directed.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#to_prufer" class="internal-link" title="igraph.GraphBase.to_prufer">to<wbr></wbr>_prufer</a></code></td>
    <td>Converts a tree graph into a Prufer sequence.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#to_undirected" class="internal-link" title="igraph.GraphBase.to_undirected">to<wbr></wbr>_undirected</a></code></td>
    <td>Converts a directed graph to undirected.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#topological_sorting" class="internal-link" title="igraph.GraphBase.topological_sorting">topological<wbr></wbr>_sorting</a></code></td>
    <td>Calculates a possible topological sorting of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#transitivity_local_undirected" class="internal-link" title="igraph.GraphBase.transitivity_local_undirected">transitivity<wbr></wbr>_local<wbr></wbr>_undirected</a></code></td>
    <td>Calculates the local transitivity (clustering coefficient) of the given vertices in the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#transitivity_undirected" class="internal-link" title="igraph.GraphBase.transitivity_undirected">transitivity<wbr></wbr>_undirected</a></code></td>
    <td>Calculates the global transitivity (clustering coefficient) of the graph.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Tree" class="internal-link" title="igraph.GraphBase.Tree"><wbr></wbr>Tree</a></code></td>
    <td>Generates a tree in which almost all vertices have the same number of children.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Tree_Game" class="internal-link" title="igraph.GraphBase.Tree_Game"><wbr></wbr>Tree_<wbr></wbr>Game</a></code></td>
    <td>Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#unfold_tree" class="internal-link" title="igraph.GraphBase.unfold_tree">unfold<wbr></wbr>_tree</a></code></td>
    <td>Unfolds the graph using a BFS to a tree by duplicating vertices as necessary.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#vcount" class="internal-link" title="igraph.GraphBase.vcount">vcount</a></code></td>
    <td>Counts the number of vertices.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#vertex_attributes" class="internal-link" title="igraph.GraphBase.vertex_attributes">vertex<wbr></wbr>_attributes</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#vertex_connectivity" class="internal-link" title="igraph.GraphBase.vertex_connectivity">vertex<wbr></wbr>_connectivity</a></code></td>
    <td>Calculates the vertex connectivity of the graph or between some vertices.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#Watts_Strogatz" class="internal-link" title="igraph.GraphBase.Watts_Strogatz"><wbr></wbr>Watts_<wbr></wbr>Strogatz</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#write_dot" class="internal-link" title="igraph.GraphBase.write_dot">write<wbr></wbr>_dot</a></code></td>
    <td>Writes the graph in DOT format to the given file.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#write_edgelist" class="internal-link" title="igraph.GraphBase.write_edgelist">write<wbr></wbr>_edgelist</a></code></td>
    <td>Writes the edge list of a graph to a file.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#write_gml" class="internal-link" title="igraph.GraphBase.write_gml">write<wbr></wbr>_gml</a></code></td>
    <td>Writes the graph in GML format to the given file.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#write_graphml" class="internal-link" title="igraph.GraphBase.write_graphml">write<wbr></wbr>_graphml</a></code></td>
    <td>Writes the graph to a GraphML file.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#write_leda" class="internal-link" title="igraph.GraphBase.write_leda">write<wbr></wbr>_leda</a></code></td>
    <td>Writes the graph to a file in LEDA native format.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#write_lgl" class="internal-link" title="igraph.GraphBase.write_lgl">write<wbr></wbr>_lgl</a></code></td>
    <td>Writes the edge list of a graph to a file in .lgl format.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#write_ncol" class="internal-link" title="igraph.GraphBase.write_ncol">write<wbr></wbr>_ncol</a></code></td>
    <td>Writes the edge list of a graph to a file in .ncol format.</td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#write_pajek" class="internal-link" title="igraph.GraphBase.write_pajek">write<wbr></wbr>_pajek</a></code></td>
    <td>Writes the graph in Pajek format to the given file.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#__graph_as_capsule" class="internal-link" title="igraph.GraphBase.__graph_as_capsule">__graph<wbr></wbr>_as<wbr></wbr>_capsule</a></code></td>
    <td>Returns the igraph graph encapsulated by the Python object as a PyCapsule</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#__register_destructor" class="internal-link" title="igraph.GraphBase.__register_destructor">__register<wbr></wbr>_destructor</a></code></td>
    <td>Registers a destructor to be called when the object is freed by Python. This function should not be used directly by igraph users.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_Bipartite" class="internal-link" title="igraph.GraphBase._Bipartite">_<wbr></wbr>Bipartite</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_Full_Bipartite" class="internal-link" title="igraph.GraphBase._Full_Bipartite">_<wbr></wbr>Full_<wbr></wbr>Bipartite</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_get_all_simple_paths" class="internal-link" title="igraph.GraphBase._get_all_simple_paths">_get<wbr></wbr>_all<wbr></wbr>_simple<wbr></wbr>_paths</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_GRG" class="internal-link" title="igraph.GraphBase._GRG">_GRG</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_Incidence" class="internal-link" title="igraph.GraphBase._Incidence">_<wbr></wbr>Incidence</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_is_matching" class="internal-link" title="igraph.GraphBase._is_matching">_is<wbr></wbr>_matching</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_is_maximal_matching" class="internal-link" title="igraph.GraphBase._is_maximal_matching">_is<wbr></wbr>_maximal<wbr></wbr>_matching</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_layout_sugiyama" class="internal-link" title="igraph.GraphBase._layout_sugiyama">_layout<wbr></wbr>_sugiyama</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_maximum_bipartite_matching" class="internal-link" title="igraph.GraphBase._maximum_bipartite_matching">_maximum<wbr></wbr>_bipartite<wbr></wbr>_matching</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_Random_Bipartite" class="internal-link" title="igraph.GraphBase._Random_Bipartite">_<wbr></wbr>Random_<wbr></wbr>Bipartite</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_raw_pointer" class="internal-link" title="igraph.GraphBase._raw_pointer">_raw<wbr></wbr>_pointer</a></code></td>
    <td>Returns the memory address of the igraph graph encapsulated by the Python object as an ordinary Python integer.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_spanning_tree" class="internal-link" title="igraph.GraphBase._spanning_tree">_spanning<wbr></wbr>_tree</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><code><a href="igraph.GraphBase.html#_Weighted_Adjacency" class="internal-link" title="igraph.GraphBase._Weighted_Adjacency">_<wbr></wbr>Weighted_<wbr></wbr>Adjacency</a></code></td>
    <td>Generates a graph from its adjacency matrix.</td>
  </tr>
</table>
            

            
        </div>

        <div id="childList">
          <div class="baseclassmethod">
  
  
  <a name="igraph.Graph.Adjacency">
    
  </a>
  <a name="Adjacency">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">Adjacency</span>(cls, matrix, mode=<span class="rst-variable-quote">'</span><span class="rst-variable-string">directed</span><span class="rst-variable-quote">'</span>, *args, **kwargs):
    
    <a class="headerLink" href="#Adjacency" title="igraph.Graph.Adjacency">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#Adjacency" class="internal-link">igraph.GraphBase.Adjacency</a></code></div>
    <div><p>Generates a graph from its adjacency matrix.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">matrix</span></td><td class="fieldArgDesc"><p>the adjacency matrix. Possible types are:</p>
<ul class="rst-simple">
<li>a list of lists</li>
<li>a numpy 2D array or matrix (will be converted to list of lists)</li>
<li>a scipy.sparse matrix (will be converted to a COO matrix, but not to a dense matrix)</li>
<li>a pandas.DataFrame (column/row names must match, and will be used as vertex names).</li>
</ul>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc"><p>the mode to be used. Possible values are:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"directed"</tt> - the graph will be directed and a matrix element gives the number of edges between two vertex.</li>
<li><tt class="rst-docutils literal">"undirected"</tt> - alias to <tt class="rst-docutils literal">"max"</tt> for convenience.</li>
<li><tt class="rst-docutils literal">"max"</tt> - undirected graph will be created and the number of edges between vertex <span class="rst-math rst-formula"><i>i</i></span> and <span class="rst-math rst-formula"><i>j</i></span> is <span class="rst-math rst-formula"><i>max</i>(<i>A</i>(<i>i</i>, <i>j</i>), <i>A</i>(<i>j</i>, <i>i</i>))</span></li>
<li><tt class="rst-docutils literal">"min"</tt> - like <tt class="rst-docutils literal">"max"</tt>, but with <span class="rst-math rst-formula"><i>min</i>(<i>A</i>(<i>i</i>, <i>j</i>), <i>A</i>(<i>j</i>, <i>i</i>))</span></li>
<li><tt class="rst-docutils literal">"plus"</tt>  - like <tt class="rst-docutils literal">"max"</tt>, but with <span class="rst-math rst-formula"><i>A</i>(<i>i</i>, <i>j</i>) + <i>A</i>(<i>j</i>, <i>i</i>)</span></li>
<li><tt class="rst-docutils literal">"upper"</tt> - undirected graph with the upper right triangle of the matrix (including the diagonal)</li>
<li><tt class="rst-docutils literal">"lower"</tt> - undirected graph with the lower left triangle of the matrix (including the diagonal)</li>
</ul>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwargs</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.Bipartite">
    
  </a>
  <a name="Bipartite">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">Bipartite</span>(cls, types, edges, directed=False, *args, **kwds):
    
    <a class="headerLink" href="#Bipartite" title="igraph.Graph.Bipartite">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Creates a bipartite graph with the given vertex types and edges. This is similar to the default constructor of the graph, the only difference is that it checks whether all the edges go between the two vertex classes and it assigns the type vector to a <tt class="rst-docutils literal">type</tt> attribute afterwards.</p>
<p>Examples:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Bipartite([0, 1, 0, 1], [(0, 1), (2, 3), (0, 3)])
<span class="py-prompt">&gt;&gt;&gt; </span>g.is_bipartite()
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g.vs[<span class="py-string">"type"</span>]
<span class="py-output">[False, True, False, True]</span>
</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">types</span></td><td class="fieldArgDesc">the vertex types as a boolean list. Anything that evaluates to <tt class="rst-docutils literal">False</tt> will denote a vertex of the first kind, anything that evaluates to <tt class="rst-docutils literal">True</tt> will denote a vertex of the second kind.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">the edges as a list of tuples.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to create a directed graph. Bipartite networks are usually undirected, so the default is <tt class="rst-docutils literal">False</tt></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the graph with a binary vertex attribute named <tt class="rst-docutils literal">"type"</tt> that stores the vertex classes.</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.DataFrame">
    
  </a>
  <a name="DataFrame">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">DataFrame</span>(cls, edges, directed=True, vertices=None, use_vids=True):
    
    <a class="headerLink" href="#DataFrame" title="igraph.Graph.DataFrame">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph from one or two dataframes.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">pandas DataFrame containing edges and metadata. The first two columns of this DataFrame contain the source and target vertices for each edge. These indicate the vertex IDs as nonnegative integers rather than vertex names unless <tt class="rst-docutils literal">use_vids</tt> is False. Further columns may contain edge attributes.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed:</span><code>bool</code></td><td class="fieldArgDesc">whether the graph is directed</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">None (default) or pandas DataFrame containing vertex metadata. The DataFrame's index must contain the vertex IDs as a sequence of intergers from 0 to <tt class="rst-docutils literal">len(vertices) - 1</tt>. If <tt class="rst-docutils literal">use_vids</tt> is <tt class="rst-docutils literal">False</tt>, the first column must contain the unique vertex names. Vertex names should be strings for full compatibility, but many functions will work if you set the name with any hashable object. All other columns will be added as vertex attributes by column name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">use<wbr></wbr>_vids:</span><code>bool</code></td><td class="fieldArgDesc">whether to interpret the first two columns of the <tt class="rst-docutils literal">edges</tt> argument as vertex ids (0-based integers) instead of vertex names. If this argument is set to True and the first two columns of <tt class="rst-docutils literal">edges</tt> are not integers, an error is thrown.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><p>the graph</p>
<p>Vertex names in either the <tt class="rst-docutils literal">edges</tt> or <tt class="rst-docutils literal">vertices</tt> arguments that are set to NaN (not a number) will be set to the string "NA". That might lead to unexpected behaviour: fill your NaNs with values before calling this function to mitigate.</p>
</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.DictDict">
    
  </a>
  <a name="DictDict">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">DictDict</span>(cls, edges, directed=False, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#DictDict" title="igraph.Graph.DictDict">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Constructs a graph from a dict-of-dicts representation.</p>
<p>Each key can be an integer or a string and represent a vertex. Each value is a dict representing edges (outgoing if the graph is directed) from that vertex. Each dict key is an integer/string for a target vertex, such that an edge will be created between those two vertices. Integers are interpreted as vertex_ids from 0 (as used in igraph), strings are interpreted as vertex names, in which case vertices are given separate numeric ids. Each value is a dictionary of edge attributes for that edge.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>{<span class="py-string">'Alice'</span>: {<span class="py-string">'Bob'</span>: {<span class="py-string">'weight'</span>: 1.5}, <span class="py-string">'David'</span>: {<span class="py-string">'weight'</span>: 2}}}</pre><p>creates a graph with three vertices (Alice, Bob, and David) and two edges:</p>
<ul class="rst-simple">
<li>Alice - Bob (with weight 1.5)</li>
<li>Alice - David (with weight 2)</li>
</ul>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">the dict of dict of dicts specifying the edges and their attributes</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed:</span><code>bool</code></td><td class="fieldArgDesc">whether to create a directed graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a Graph object</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: vertex_name_attr</td></tr><tr><td colspan="2">vertex attribute that will store the names</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.DictList">
    
  </a>
  <a name="DictList">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">DictList</span>(cls, vertices, edges, directed=False, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>, edge_foreign_keys=(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">source</span><span class="rst-variable-quote">'</span>, <wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">target</span><span class="rst-variable-quote">'</span>), iterative=False):
    
    <a class="headerLink" href="#DictList" title="igraph.Graph.DictList">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Constructs a graph from a list-of-dictionaries representation.</p>
<p>This function is useful when you have two lists of dictionaries, one for vertices and one for edges, each containing their attributes (e.g. name, weight). Of course, the edge dictionary must also contain two special keys that indicate the source and target vertices connected by that edge. Non-list iterables should work as long as they yield dictionaries or dict-like objects (they should have the 'items' and '__getitem__' methods). For instance, a database query result is likely to be fit as long as it's iterable and yields dict-like objects with every iteration.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the list of dictionaries for the vertices or <tt class="rst-docutils literal">None</tt> if there are no special attributes assigned to vertices and we should simply use the edge list of dicts to infer vertex names.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">the list of dictionaries for the edges. Each dict must have at least the two keys specified by edge_foreign_keys to label the source and target vertices, while additional items will be treated as edge attributes.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed:</span><code>bool</code></td><td class="fieldArgDesc">whether the constructed graph will be directed</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc">the name of the distinguished key in the dicts in the vertex data source that contains the vertex names. Ignored if <tt class="rst-docutils literal">vertices</tt> is <tt class="rst-docutils literal">None</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_foreign<wbr></wbr>_keys</span></td><td class="fieldArgDesc">tuple specifying the attributes in each edge dictionary that contain the source (1st) and target (2nd) vertex names. These items of each dictionary are also added as edge_attributes.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">iterative:</span><code>bool</code></td><td class="fieldArgDesc">whether to add the edges to the graph one by one, iteratively, or to build a large edge list first and use that to construct the graph. The latter approach is faster but it may not be suitable if your dataset is large. The default is to add the edges in a batch from an edge list.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><p>the graph that was constructed</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>vertices = [{<span class="py-string">'name'</span>: <span class="py-string">'apple'</span>}, {<span class="py-string">'name'</span>: <span class="py-string">'pear'</span>}, {<span class="py-string">'name'</span>: <span class="py-string">'peach'</span>}]
<span class="py-prompt">&gt;&gt;&gt; </span>edges = [{<span class="py-string">'source'</span>: <span class="py-string">'apple'</span>, <span class="py-string">'target'</span>: <span class="py-string">'pear'</span>, <span class="py-string">'weight'</span>: 1.2},
<span class="py-more">... </span>         {<span class="py-string">'source'</span>: <span class="py-string">'apple'</span>, <span class="py-string">'target'</span>: <span class="py-string">'peach'</span>, <span class="py-string">'weight'</span>: 0.9}]
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.DictList(vertices, edges)</pre><p>The graph has three vertices with names and two edges with weights.</p>
</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.from_graph_tool">
    
  </a>
  <a name="from_graph_tool">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">from_graph_tool</span>(cls, g):
    
    <a class="headerLink" href="#from_graph_tool" title="igraph.Graph.from_graph_tool">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Converts the graph from graph-tool</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">g</span></td><td class="fieldArgDesc">graph-tool Graph</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.from_networkx">
    
  </a>
  <a name="from_networkx">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">from_networkx</span>(cls, g, vertex_attr_hashable=<span class="rst-variable-quote">'</span><span class="rst-variable-string">_nx_name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#from_networkx" title="igraph.Graph.from_networkx">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Converts the graph from networkx</p>
<p>Vertex names will be stored as a vertex_attr_hashable attribute (usually "_nx_name", but see below). Because igraph stored vertices in an ordered manner, vertices will get new IDs from 0 up. In case of multigraphs, each edge will have an "_nx_multiedge_key" attribute, to distinguish edges that connect the same two vertices.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">g</span></td><td class="fieldArgDesc">networkx Graph or DiGraph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_attr<wbr></wbr>_hashable:</span><code>str</code></td><td class="fieldArgDesc">attribute used to store the Python hashable used by networkx to identify each vertex. The default value '_nx_name' ensures lossless round trip conversions to/from networkx. An alternative choice is 'name': in that case, using strings for vertex names is recommended and, if the graph is re-exported to networkx, Graph.to_networkx(vertex_attr_hashable="name") must be used to recover the correct vertex nomenclature in the exported network.</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.GRG">
    
  </a>
  <a name="GRG">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">GRG</span>(cls, n, radius, torus=False):
    
    <a class="headerLink" href="#GRG" title="igraph.Graph.GRG">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a random geometric graph.</p>
<p>The algorithm drops the vertices randomly on the 2D unit square and connects them if they are closer to each other than the given radius. The coordinates of the vertices are stored in the vertex attributes <tt class="rst-docutils literal">x</tt> and <tt class="rst-docutils literal">y</tt>.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">The number of vertices in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">radius</span></td><td class="fieldArgDesc">The given radius</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">torus</span></td><td class="fieldArgDesc">This should be <tt class="rst-docutils literal">True</tt> if we want to use a torus instead of a square.</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.Incidence">
    
  </a>
  <a name="Incidence">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">Incidence</span>(cls, matrix, directed=False, mode=<span class="rst-variable-quote">'</span><span class="rst-variable-string">out</span><span class="rst-variable-quote">'</span>, multiple=False, weighted=None, *args, **kwds):
    
    <a class="headerLink" href="#Incidence" title="igraph.Graph.Incidence">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Creates a bipartite graph from an incidence matrix.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Incidence([[0, 1, 1], [1, 1, 0]])</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">matrix</span></td><td class="fieldArgDesc">the incidence matrix.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to create a directed graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">defines the direction of edges in the graph. If <tt class="rst-docutils literal">"out"</tt>, then edges go from vertices of the first kind (corresponding to rows of the matrix) to vertices of the second kind (the columns of the matrix). If <tt class="rst-docutils literal">"in"</tt>, the opposite direction is used. <tt class="rst-docutils literal">"all"</tt> creates mutual edges. Ignored for undirected graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">multiple</span></td><td class="fieldArgDesc">defines what to do with non-zero entries in the matrix. If <tt class="rst-docutils literal">False</tt>, non-zero entries will create an edge no matter what the value is. If <tt class="rst-docutils literal">True</tt>, non-zero entries are rounded up to the nearest integer and this will be the number of multiple edges created.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weighted</span></td><td class="fieldArgDesc">defines whether to create a weighted graph from the incidence matrix. If it is c{None} then an unweighted graph is created and the multiple argument is used to determine the edges of the graph. If it is a string then for every non-zero matrix entry, an edge is created and the value of the entry is added as an edge attribute named by the weighted argument. If it is <tt class="rst-docutils literal">True</tt> then a weighted graph is created and the name of the edge attribute will be ‘weight’.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the graph with a binary vertex attribute named <tt class="rst-docutils literal">"type"</tt> that stores the vertex classes.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code>ValueError</code></td><td>if the weighted and multiple are passed together.</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.ListDict">
    
  </a>
  <a name="ListDict">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">ListDict</span>(cls, edges, directed=False, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#ListDict" title="igraph.Graph.ListDict">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Constructs a graph from a dict-of-lists representation.</p>
<p>This function is used to construct a graph from a dictionary of lists. Other, non-list sequences (e.g. tuples) and lazy iterators are are accepted. For each key x, its corresponding value must be a sequence of multiple values y: the edge (x,y) will be created in the graph. x and y must be either one of:</p>
<ul class="rst-simple">
<li>two integers: the vertices with those ids will be connected</li>
<li>two strings: the vertices with those names will be connected</li>
</ul>
<p>If names are used, the order of vertices is not guaranteed, and each vertex will be given the vertex_name_attr attribute.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">the dict of sequences describing the edges</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed:</span><code>bool</code></td><td class="fieldArgDesc">whether to create a directed graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><p>a Graph object</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>mydict = {<span class="py-string">'apple'</span>: [<span class="py-string">'pear'</span>, <span class="py-string">'peach'</span>], <span class="py-string">'pear'</span>: [<span class="py-string">'peach'</span>]}
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.ListDict(mydict)</pre><p># The graph has three vertices with names and three edges connecting # each pair.</p>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: vertex_name_attr</td></tr><tr><td colspan="2">vertex attribute that will store the names</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.Read">
    
  </a>
  <a name="Read">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">Read</span>(cls, f, format=None, *args, **kwds):
    
    <a class="headerLink" href="#Read" title="igraph.Graph.Read">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Unified reading function for graphs.</p>
<p>This method tries to identify the format of the graph given in the first parameter and calls the corresponding reader method.</p>
<p>The remaining arguments are passed to the reader method without any changes.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the file containing the graph to be loaded</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">format</span></td><td class="fieldArgDesc">the format of the file (if known in advance). <tt class="rst-docutils literal">None</tt> means auto-detection. Possible values are: <tt class="rst-docutils literal">"ncol"</tt> (NCOL format), <tt class="rst-docutils literal">"lgl"</tt> (LGL format), <tt class="rst-docutils literal">"graphdb"</tt> (GraphDB format), <tt class="rst-docutils literal">"graphml"</tt>, <tt class="rst-docutils literal">"graphmlz"</tt> (GraphML and gzipped GraphML format), <tt class="rst-docutils literal">"gml"</tt> (GML format), <tt class="rst-docutils literal">"net"</tt>, <tt class="rst-docutils literal">"pajek"</tt> (Pajek format), <tt class="rst-docutils literal">"dimacs"</tt> (DIMACS format), <tt class="rst-docutils literal">"edgelist"</tt>, <tt class="rst-docutils literal">"edges"</tt> or <tt class="rst-docutils literal">"edge"</tt> (edge list), <tt class="rst-docutils literal">"adjacency"</tt> (adjacency matrix), <tt class="rst-docutils literal">"dl"</tt> (DL format used by UCINET), <tt class="rst-docutils literal">"pickle"</tt> (Python pickled format), <tt class="rst-docutils literal">"picklez"</tt> (gzipped Python pickled format)</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code>IOError</code></td><td>if the file format can't be identified and none was given.</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.Read_DIMACS">
    
  </a>
  <a name="Read_DIMACS">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">Read_DIMACS</span>(cls, f, directed=False):
    
    <a class="headerLink" href="#Read_DIMACS" title="igraph.Graph.Read_DIMACS">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#Read_DIMACS" class="internal-link">igraph.GraphBase.Read_DIMACS</a></code></div>
    <div><p>Reads a graph from a file conforming to the DIMACS minimum-cost flow file format.</p>
<p>For the exact definition of the format, see <a class="rst-reference external" href="http://lpsolve.sourceforge.net/5.5/DIMACS.htm" target="_top">http://lpsolve.sourceforge.net/5.5/DIMACS.htm</a>.</p>
<p>Restrictions compared to the official description of the format are as follows:</p>
<ul class="rst-simple">
<li>igraph's DIMACS reader requires only three fields in an arc definition, describing the edge's source and target node and its capacity.</li>
<li>Source vertices are identified by 's' in the FLOW field, target vertices are identified by 't'.</li>
<li>Node indices start from 1. Only a single source and target node is allowed.</li>
</ul>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the generated graph should be directed.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the generated graph. The indices of the source and target vertices are attached as graph attributes <tt class="rst-docutils literal">source</tt> and <tt class="rst-docutils literal">target</tt>, the edge capacities are stored in the <tt class="rst-docutils literal">capacity</tt> edge attribute.</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.Read_GraphMLz">
    
  </a>
  <a name="Read_GraphMLz">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">Read_GraphMLz</span>(cls, f, index=0):
    
    <a class="headerLink" href="#Read_GraphMLz" title="igraph.Graph.Read_GraphMLz">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reads a graph from a zipped GraphML file.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">index</span></td><td class="fieldArgDesc">if the GraphML file contains multiple graphs, specified the one that should be loaded. Graph indices start from zero, so if you want to load the first graph, specify 0 here.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the loaded graph object</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.Read_Pickle">
    
  </a>
  <a name="Read_Pickle">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">Read_Pickle</span>(cls, fname=None):
    
    <a class="headerLink" href="#Read_Pickle" title="igraph.Graph.Read_Pickle">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reads a graph from Python pickled format</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fname</span></td><td class="fieldArgDesc">the name of the file, a stream to read from, or a string containing the pickled data.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the created graph object.</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.Read_Picklez">
    
  </a>
  <a name="Read_Picklez">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">Read_Picklez</span>(cls, fname):
    
    <a class="headerLink" href="#Read_Picklez" title="igraph.Graph.Read_Picklez">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reads a graph from compressed Python pickled format, uncompressing it on-the-fly.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fname</span></td><td class="fieldArgDesc">the name of the file or a stream to read from.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the created graph object.</td></tr></table></div>
  </div>
</div><div class="baseclassmethod">
  
  
  <a name="igraph.Graph.TupleList">
    
  </a>
  <a name="TupleList">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">TupleList</span>(cls, edges, directed=False, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>, edge_attrs=None, weights=False):
    
    <a class="headerLink" href="#TupleList" title="igraph.Graph.TupleList">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Constructs a graph from a list-of-tuples representation.</p>
<p>This representation assumes that the edges of the graph are encoded in a list of tuples (or lists). Each item in the list must have at least two elements, which specify the source and the target vertices of the edge. The remaining elements (if any) specify the edge attributes of that edge, where the names of the edge attributes originate from the <tt class="rst-docutils literal">edge_attrs</tt> list. The names of the vertices will be stored in the vertex attribute given by <tt class="rst-docutils literal">vertex_name_attr</tt>.</p>
<p>The default parameters of this function are suitable for creating unweighted graphs from lists where each item contains the source vertex and the target vertex. If you have a weighted graph, you can use items where the third item contains the weight of the edge by setting <tt class="rst-docutils literal">edge_attrs</tt> to <tt class="rst-docutils literal">"weight"</tt> or <tt class="rst-docutils literal">["weight"]</tt>. If you have even more edge attributes, add them to the end of each item in the <tt class="rst-docutils literal">edges</tt> list and also specify the corresponding edge attribute names in <tt class="rst-docutils literal">edge_attrs</tt> as a list.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">the data source for the edges. This must be a list where each item is a tuple (or list) containing at least two items: the name of the source and the target vertex. Note that names will be assigned to the <tt class="rst-docutils literal">name</tt> vertex attribute (or another vertex attribute if <tt class="rst-docutils literal">vertex_name_attr</tt> is specified), even if all the vertex names in the list are in fact numbers.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed:</span><code>bool</code></td><td class="fieldArgDesc">whether the constructed graph will be directed</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc">the name of the vertex attribute that will contain the vertex names.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_attrs</span></td><td class="fieldArgDesc">the names of the edge attributes that are filled with the extra items in the edge list (starting from index 2, since the first two items are the source and target vertices). If <tt class="rst-docutils literal">None</tt> or an empty sequence, only the source and target vertices will be extracted and additional tuple items will be ignored. If a string, it is interpreted as a single edge attribute.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">alternative way to specify that the graph is weighted. If you set <tt class="rst-docutils literal">weights</tt> to <tt class="rst-docutils literal">true</tt> and <tt class="rst-docutils literal">edge_attrs</tt> is not given, it will be assumed that <tt class="rst-docutils literal">edge_attrs</tt> is <tt class="rst-docutils literal">["weight"]</tt> and igraph will parse the third element from each item into an edge weight. If you set <tt class="rst-docutils literal">weights</tt> to a string, it will be assumed that <tt class="rst-docutils literal">edge_attrs</tt> contains that string only, and igraph will store the edge weights in that attribute.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the graph that was constructed</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__add__">
    
  </a>
  <a name="__add__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__add__</span>(graph, other):
    
    <a class="headerLink" href="#__add__" title="igraph.Graph.__add__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Copies the graph and extends the copy depending on the type of the other object given.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">if it is an integer, the copy is extended by the given number of vertices. If it is a string, the copy is extended by a single vertex whose <tt class="rst-docutils literal">name</tt> attribute will be equal to the given string. If it is a tuple with two elements, the copy is extended by a single edge. If it is a list of tuples, the copy is extended by multiple edges. If it is a <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code>, a disjoint union is performed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__and__">
    
  </a>
  <a name="__and__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__and__</span>(graph, other):
    
    <a class="headerLink" href="#__and__" title="igraph.Graph.__and__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Graph intersection operator.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">the other graph to take the intersection with.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the intersected graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__bool__">
    
  </a>
  <a name="__bool__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__bool__</span>(self):
    
    <a class="headerLink" href="#__bool__" title="igraph.Graph.__bool__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns True if the graph has at least one vertex, False otherwise.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__coerce__">
    
  </a>
  <a name="__coerce__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__coerce__</span>(self, other):
    
    <a class="headerLink" href="#__coerce__" title="igraph.Graph.__coerce__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Coercion rules.</p>
<p>This method is needed to allow the graph to react to additions with lists, tuples, integers, strings, vertices, edges and so on.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__iadd__">
    
  </a>
  <a name="__iadd__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__iadd__</span>(graph, other):
    
    <a class="headerLink" href="#__iadd__" title="igraph.Graph.__iadd__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>In-place addition (disjoint union).</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#__add__" class="internal-link" title="igraph.Graph.__add__">__add__</a></code></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__init__</span>(self, *args, **kwds):
    
    <a class="headerLink" href="#__init__" title="igraph.Graph.__init__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>__init__(n=0, edges=None, directed=False, graph_attrs=None, vertex_attrs=None, edge_attrs=None)</p>
<p>Constructs a graph from scratch.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices. Can be omitted, the default is zero. Note that if the edge list contains vertices with indexes larger than or equal to <span class="rst-math rst-formula"><i>m</i></span>, then the number of vertices will be adjusted accordingly.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">the edge list where every list item is a pair of integers. If any of the integers is larger than <span class="rst-math rst-formula"><i>n</i> − 1</span>, the number of vertices is adjusted accordingly. <tt class="rst-docutils literal">None</tt> means no edges.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the graph should be directed</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph<wbr></wbr>_attrs</span></td><td class="fieldArgDesc">the attributes of the graph as a dictionary.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_attrs</span></td><td class="fieldArgDesc">the attributes of the vertices as a dictionary. Every dictionary value must be an iterable with exactly <span class="rst-math rst-formula"><i>n</i></span> items.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_attrs</span></td><td class="fieldArgDesc">the attributes of the edges as a dictionary. Every dictionary value must be an iterable with exactly <span class="rst-math rst-formula"><i>m</i></span> items where <span class="rst-math rst-formula"><i>m</i></span> is the number of edges.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__isub__">
    
  </a>
  <a name="__isub__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__isub__</span>(graph, other):
    
    <a class="headerLink" href="#__isub__" title="igraph.Graph.__isub__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>In-place subtraction (difference).</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#__sub__" class="internal-link" title="igraph.Graph.__sub__">__sub__</a></code></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__mul__">
    
  </a>
  <a name="__mul__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__mul__</span>(graph, other):
    
    <a class="headerLink" href="#__mul__" title="igraph.Graph.__mul__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Copies exact replicas of the original graph an arbitrary number of times.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">if it is an integer, multiplies the graph by creating the given number of identical copies and taking the disjoint union of them.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__or__">
    
  </a>
  <a name="__or__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__or__</span>(graph, other):
    
    <a class="headerLink" href="#__or__" title="igraph.Graph.__or__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Graph union operator.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">the other graph to take the union with.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the union graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__plot__">
    
  </a>
  <a name="__plot__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__plot__</span>(self, backend, context, *args, **kwds):
    
    <a class="headerLink" href="#__plot__" title="igraph.Graph.__plot__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Plots the graph to the given Cairo context or matplotlib Axes.</p>
<p>The visual style of vertices and edges can be modified at three places in the following order of precedence (lower indices override higher indices):</p>
<ol class="rst-simple">
<li>Keyword arguments of this function (or of <code><a href="igraph.drawing.html#plot" class="internal-link" title="igraph.drawing.plot">plot()</a></code> which is passed intact to <tt class="rst-docutils literal">Graph.__plot__()</tt>.</li>
<li>Vertex or edge attributes, specified later in the list of keyword arguments.</li>
<li>igraph-wide plotting defaults (see <code><a href="igraph.Configuration.html" class="internal-link" title="igraph.Configuration">igraph.config.Configuration</a></code>)</li>
<li>Built-in defaults.</li>
</ol>
<p>E.g., if the <tt class="rst-docutils literal">vertex_size</tt> keyword attribute is not present, but there exists a vertex attribute named <tt class="rst-docutils literal">size</tt>, the sizes of the vertices will be specified by that attribute.</p>
<p>Besides the usual self-explanatory plotting parameters (<tt class="rst-docutils literal">context</tt>, <tt class="rst-docutils literal">bbox</tt>, <tt class="rst-docutils literal">palette</tt>), it accepts the following keyword arguments:</p>
<ul>
<li><p class="rst-first"><tt class="rst-docutils literal">autocurve</tt>: whether to use curves instead of straight lines for multiple edges on the graph plot. This argument may be <tt class="rst-docutils literal">True</tt> or <tt class="rst-docutils literal">False</tt>; when omitted, <tt class="rst-docutils literal">True</tt> is assumed for graphs with less than 10.000 edges and <tt class="rst-docutils literal">False</tt> otherwise.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">drawer_factory</tt>: a subclass of <code><a href="igraph.drawing.cairo.graph.AbstractCairoGraphDrawer.html" class="internal-link" title="igraph.drawing.cairo.graph.AbstractCairoGraphDrawer">AbstractCairoGraphDrawer</a></code> which will be used to draw the graph. You may also provide a function here which takes two arguments: the Cairo context to draw on and a bounding box (an instance of <code><a href="igraph.drawing.utils.BoundingBox.html" class="internal-link" title="igraph.drawing.utils.BoundingBox">BoundingBox</a></code>). If this keyword argument is missing, igraph will use the default graph drawer which should be suitable for most purposes. It is safe to omit this keyword argument unless you need to use a specific graph drawer.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">keep_aspect_ratio</tt>: whether to keep the aspect ratio of the layout that igraph calculates to place the nodes. <tt class="rst-docutils literal">True</tt> means that the layout will be scaled proportionally to fit into the bounding box where the graph is to be drawn but the aspect ratio will be kept the same (potentially leaving empty space next to, below or above the graph). <tt class="rst-docutils literal">False</tt> means that the layout will be scaled independently along the X and Y axis in order to fill the entire bounding box. The default is <tt class="rst-docutils literal">False</tt>.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">layout</tt>: the layout to be used. If not an instance of <code><a href="igraph.layout.Layout.html" class="internal-link" title="igraph.layout.Layout">Layout</a></code>, it will be passed to <code><a href="#layout" class="internal-link" title="igraph.Graph.layout">layout</a></code> to calculate the layout. Note that if you want a deterministic layout that does not change with every plot, you must either use a deterministic layout function (like <code><a href="igraph.GraphBase.html#layout_circle" class="internal-link" title="igraph.GraphBase.layout_circle">GraphBase.layout_circle</a></code>) or calculate the layout in advance and pass a <code><a href="igraph.layout.Layout.html" class="internal-link" title="igraph.layout.Layout">Layout</a></code> object here.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">margin</tt>: the top, right, bottom, left margins as a 4-tuple. If it has less than 4 elements or is a single float, the elements will be re-used until the length is at least 4.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">mark_groups</tt>: whether to highlight some of the vertex groups by colored polygons. This argument can be one of the following:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">False</tt>: no groups will be highlighted</li>
<li><tt class="rst-docutils literal">True</tt>: only valid if the object plotted is a <code><a href="igraph.VertexClustering.html" class="internal-link" title="igraph.VertexClustering">VertexClustering</a></code> or <code><a href="igraph.VertexCover.html" class="internal-link" title="igraph.VertexCover">VertexCover</a></code>. The vertex groups in the clutering or cover will be highlighted such that the i-th group will be colored by the i-th color from the current palette. If used when plotting a graph, it will throw an error.</li>
<li>A dict mapping tuples of vertex indices to color names. The given vertex groups will be highlighted by the given colors.</li>
<li>A list containing pairs or an iterable yielding pairs, where the first element of each pair is a list of vertex indices and the second element is a color.</li>
<li>A <code><a href="igraph.VertexClustering.html" class="internal-link" title="igraph.VertexClustering">VertexClustering</a></code> or <code><a href="igraph.VertexCover.html" class="internal-link" title="igraph.VertexCover">VertexCover</a></code> instance. The vertex groups in the clustering or cover will be highlighted such that the i-th group will be colored by the i-th color from the current palette.</li>
</ul>
<p>In place of lists of vertex indices, you may also use <code><a href="igraph.VertexSeq.html" class="internal-link" title="igraph.VertexSeq">VertexSeq</a></code> instances.</p>
<p>In place of color names, you may also use color indices into the current palette. <tt class="rst-docutils literal">None</tt> as a color name will mean that the corresponding group is ignored.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">vertex_size</tt>: size of the vertices. The corresponding vertex attribute is called <tt class="rst-docutils literal">size</tt>. The default is 10. Vertex sizes are measured in the unit of the Cairo context on which igraph is drawing.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">vertex_color</tt>: color of the vertices. The corresponding vertex attribute is <tt class="rst-docutils literal">color</tt>, the default is red.  Colors can be specified either by common X11 color names (see the source code of <code><a href="igraph.drawing.colors.html" class="internal-link" title="igraph.drawing.colors">igraph.drawing.colors</a></code> for a list of known colors), by 3-tuples of floats (ranging between 0 and 255 for the R, G and B components), by CSS-style string specifications (<tt class="rst-docutils literal">#rrggbb</tt>) or by integer color indices of the specified palette.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">vertex_frame_color</tt>: color of the frame (i.e. stroke) of the vertices. The corresponding vertex attribute is <tt class="rst-docutils literal">frame_color</tt>, the default is black. See <tt class="rst-docutils literal">vertex_color</tt> for the possible ways of specifying a color.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">vertex_frame_width</tt>: the width of the frame (i.e. stroke) of the vertices. The corresponding vertex attribute is <tt class="rst-docutils literal">frame_width</tt>. The default is 1. Vertex frame widths are measured in the unit of the Cairo context on which igraph is drawing.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">vertex_shape</tt>: shape of the vertices. Alternatively it can be specified by the <tt class="rst-docutils literal">shape</tt> vertex attribute. Possibilities are: <tt class="rst-docutils literal">square</tt>, {circle}, {triangle}, {triangle-down} or <tt class="rst-docutils literal">hidden</tt>. See the source code of <code><a href="igraph.drawing.html" class="internal-link" title="igraph.drawing">igraph.drawing</a></code> for a list of alternative shape names that are also accepted and mapped to these.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">vertex_label</tt>: labels drawn next to the vertices. The corresponding vertex attribute is <tt class="rst-docutils literal">label</tt>.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">vertex_label_dist</tt>: distance of the midpoint of the vertex label from the center of the corresponding vertex. The corresponding vertex attribute is <tt class="rst-docutils literal">label_dist</tt>.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">vertex_label_color</tt>: color of the label. Corresponding vertex attribute: <tt class="rst-docutils literal">label_color</tt>. See <tt class="rst-docutils literal">vertex_color</tt> for color specification syntax.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">vertex_label_size</tt>: font size of the label, specified in the unit of the Cairo context on which we are drawing. Corresponding vertex attribute: <tt class="rst-docutils literal">label_size</tt>.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">vertex_label_angle</tt>: the direction of the line connecting the midpoint of the vertex with the midpoint of the label. This can be used to position the labels relative to the vertices themselves in conjunction with <tt class="rst-docutils literal">vertex_label_dist</tt>. Corresponding vertex attribute: <tt class="rst-docutils literal">label_angle</tt>. The default is <tt class="rst-docutils literal"><span class="pre">-math.pi/2</span></tt>.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">vertex_order</tt>: drawing order of the vertices. This must be a list or tuple containing vertex indices; vertices are then drawn according to this order.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">vertex_order_by</tt>: an alternative way to specify the drawing order of the vertices; this attribute is interpreted as the name of a vertex attribute, and vertices are drawn such that those with a smaller attribute value are drawn first. You may also reverse the order by passing a tuple here; the first element of the tuple should be the name of the attribute, the second element specifies whether the order is reversed (<tt class="rst-docutils literal">True</tt>, <tt class="rst-docutils literal">False</tt>, <tt class="rst-docutils literal">"asc"</tt> and <tt class="rst-docutils literal">"desc"</tt> are accepted values).</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">edge_color</tt>: color of the edges. The corresponding edge attribute is <tt class="rst-docutils literal">color</tt>, the default is red. See <tt class="rst-docutils literal">vertex_color</tt> for color specification syntax.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">edge_curved</tt>: whether the edges should be curved. Positive numbers correspond to edges curved in a counter-clockwise direction, negative numbers correspond to edges curved in a clockwise direction. Zero represents straight edges. <tt class="rst-docutils literal">True</tt> is interpreted as 0.5, <tt class="rst-docutils literal">False</tt> is interpreted as 0. The default is 0 which makes all the edges straight.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">edge_width</tt>: width of the edges in the default unit of the Cairo context on which we are drawing. The corresponding edge attribute is <tt class="rst-docutils literal">width</tt>, the default is 1.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">edge_arrow_size</tt>: arrow size of the edges. The corresponding edge attribute is <tt class="rst-docutils literal">arrow_size</tt>, the default is 1.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">edge_arrow_width</tt>: width of the arrowhead on the edge. The corresponding edge attribute is <tt class="rst-docutils literal">arrow_width</tt>, the default is 1.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">edge_order</tt>: drawing order of the edges. This must be a list or tuple containing edge indices; edges are then drawn according to this order.</p>
</li>
<li><p class="rst-first"><tt class="rst-docutils literal">edge_order_by</tt>: an alternative way to specify the drawing order of the edges; this attribute is interpreted as the name of an edge attribute, and edges are drawn such that those with a smaller attribute value are drawn first. You may also reverse the order by passing a tuple here; the first element of the tuple should be the name of the attribute, the second element specifies whether the order is reversed (<tt class="rst-docutils literal">True</tt>, <tt class="rst-docutils literal">False</tt>, <tt class="rst-docutils literal">"asc"</tt> and <tt class="rst-docutils literal">"desc"</tt> are accepted values).</p>
</li>
</ul>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__reduce__">
    
  </a>
  <a name="__reduce__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__reduce__</span>(self):
    
    <a class="headerLink" href="#__reduce__" title="igraph.Graph.__reduce__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Support for pickling.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__str__">
    
  </a>
  <a name="__str__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__str__</span>(self):
    
    <a class="headerLink" href="#__str__" title="igraph.Graph.__str__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns a string representation of the graph.</p>
<p>Behind the scenes, this method constructs a <code><a href="igraph.summary.GraphSummary.html" class="internal-link" title="igraph.summary.GraphSummary">GraphSummary</a></code> instance and invokes its <tt class="rst-docutils literal">__str__</tt> method with a verbosity of 1 and attribute printing turned off.</p>
<p>See the documentation of <code><a href="igraph.summary.GraphSummary.html" class="internal-link" title="igraph.summary.GraphSummary">GraphSummary</a></code> for more details about the output.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.__sub__">
    
  </a>
  <a name="__sub__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__sub__</span>(graph, other):
    
    <a class="headerLink" href="#__sub__" title="igraph.Graph.__sub__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Removes the given object(s) from the graph</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">if it is an integer, removes the vertex with the given ID from the graph (note that the remaining vertices will get re-indexed!). If it is a tuple, removes the given edge. If it is a graph, takes the difference of the two graphs. Accepts lists of integers or lists of tuples as well, but they can't be mixed! Also accepts <code><a href="igraph.Edge.html" class="internal-link" title="igraph.Edge">Edge</a></code> and <code><a href="igraph.EdgeSeq.html" class="internal-link" title="igraph.EdgeSeq">EdgeSeq</a></code> objects.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.add_edge">
    
  </a>
  <a name="add_edge">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">add_edge</span>(graph, source, target, **kwds):
    
    <a class="headerLink" href="#add_edge" title="igraph.Graph.add_edge">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Adds a single edge to the graph.</p>
<p>Keyword arguments (except the source and target arguments) will be assigned to the edge as attributes.</p>
<p>The performance cost of adding a single edge or several edges to a graph is similar. Thus, when adding several edges, a single <tt class="rst-docutils literal">add_edges()</tt> call is more efficient than multiple <tt class="rst-docutils literal">add_edge()</tt> calls.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex of the edge or its name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex of the edge or its name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the newly added edge as an <code><a href="igraph.Edge.html" class="internal-link" title="igraph.Edge">Edge</a></code> object. Use <tt class="rst-docutils literal"><span class="pre">add_edges([(source,</span> <span class="pre">target)])</span></tt> if you don't need the <code><a href="igraph.Edge.html" class="internal-link" title="igraph.Edge">Edge</a></code> object and want to avoid the overhead of creating it.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.add_edges">
    
  </a>
  <a name="add_edges">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">add_edges</span>(graph, es, attributes=None):
    
    <a class="headerLink" href="#add_edges" title="igraph.Graph.add_edges">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#add_edges" class="internal-link">igraph.GraphBase.add_edges</a></code></div>
    <div><p>Adds some edges to the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">es</span></td><td class="fieldArgDesc">the list of edges to be added. Every edge is represented with a tuple containing the vertex IDs or names of the two endpoints. Vertices are enumerated from zero.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">attributes</span></td><td class="fieldArgDesc">dict of sequences, all of length equal to the number of edges to be added, containing the attributes of the new edges.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.add_vertex">
    
  </a>
  <a name="add_vertex">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">add_vertex</span>(graph, name=None, **kwds):
    
    <a class="headerLink" href="#add_vertex" title="igraph.Graph.add_vertex">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Adds a single vertex to the graph. Keyword arguments will be assigned as vertex attributes. Note that <tt class="rst-docutils literal">name</tt> as a keyword argument is treated specially; if a graph has <tt class="rst-docutils literal">name</tt> as a vertex attribute, it allows one to refer to vertices by their names in most places where igraph expects a vertex ID.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the newly added vertex as a <code><a href="igraph.Vertex.html" class="internal-link" title="igraph.Vertex">Vertex</a></code> object. Use <tt class="rst-docutils literal">add_vertices(1)</tt> if you don't need the <code><a href="igraph.Vertex.html" class="internal-link" title="igraph.Vertex">Vertex</a></code> object and want to avoid the overhead of creating t.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.add_vertices">
    
  </a>
  <a name="add_vertices">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">add_vertices</span>(graph, n, attributes=None):
    
    <a class="headerLink" href="#add_vertices" title="igraph.Graph.add_vertices">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#add_vertices" class="internal-link">igraph.GraphBase.add_vertices</a></code></div>
    <div><p>Adds some vertices to the graph.</p>
<p>Note that if <tt class="rst-docutils literal">n</tt> is a sequence of strings, indicating the names of the new vertices, and attributes has a key <tt class="rst-docutils literal">name</tt>, the two conflict. In that case the attribute will be applied.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices to be added, or the name of a single vertex to be added, or a sequence of strings, each corresponding to the name of a vertex to be added. Names will be assigned to the <tt class="rst-docutils literal">name</tt> vertex attribute.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">attributes</span></td><td class="fieldArgDesc">dict of sequences, all of length equal to the number of vertices to be added, containing the attributes of the new vertices. If n is a string (so a single vertex is added), then the values of this dict are the attributes themselves, but if n=1 then they have to be lists of length 1.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.all_st_cuts">
    
  </a>
  <a name="all_st_cuts">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">all_st_cuts</span>(graph, source, target):
    
    <a class="headerLink" href="#all_st_cuts" title="igraph.Graph.all_st_cuts">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#all_st_cuts" class="internal-link">igraph.GraphBase.all_st_cuts</a></code></div>
    <div><p>Returns all the cuts between the source and target vertices in a directed graph.</p>
<p>This function lists all edge-cuts between a source and a target vertex. Every cut is listed exactly once.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex ID</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of <code><a href="igraph.Cut.html" class="internal-link" title="igraph.Cut">Cut</a></code> objects.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in graphs. Algorithmica 15, 351--372, 1996.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.all_st_mincuts">
    
  </a>
  <a name="all_st_mincuts">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">all_st_mincuts</span>(graph, source, target, capacity=None):
    
    <a class="headerLink" href="#all_st_mincuts" title="igraph.Graph.all_st_mincuts">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#all_st_mincuts" class="internal-link">igraph.GraphBase.all_st_mincuts</a></code></div>
    <div><p>Returns all the mincuts between the source and target vertices in a directed graph.</p>
<p>This function lists all minimum edge-cuts between a source and a target vertex.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">capacity</span></td><td class="fieldArgDesc">the edge capacities (weights). If <tt class="rst-docutils literal">None</tt>, all edges have equal weight. May also be an attribute name.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of <code><a href="igraph.Cut.html" class="internal-link" title="igraph.Cut">Cut</a></code> objects.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">JS Provan and DR Shier: A paradigm for listing (s,t)-cuts in graphs. Algorithmica 15, 351--372, 1996.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.as_directed">
    
  </a>
  <a name="as_directed">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">as_directed</span>(graph, *args, **kwds):
    
    <a class="headerLink" href="#as_directed" title="igraph.Graph.as_directed">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns a directed copy of this graph. Arguments are passed on to <code><a href="igraph.GraphBase.html#to_directed" class="internal-link" title="igraph.GraphBase.to_directed">GraphBase.to_directed()</a></code> that is invoked on the copy.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.as_undirected">
    
  </a>
  <a name="as_undirected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">as_undirected</span>(graph, *args, **kwds):
    
    <a class="headerLink" href="#as_undirected" title="igraph.Graph.as_undirected">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns an undirected copy of this graph. Arguments are passed on to <code><a href="igraph.GraphBase.html#to_undirected" class="internal-link" title="igraph.GraphBase.to_undirected">GraphBase.to_undirected()</a></code> that is invoked on the copy.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.biconnected_components">
    
  </a>
  <a name="biconnected_components">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">biconnected_components</span>(graph, return_articulation_points=False):
    
    <a class="headerLink" href="#biconnected_components" title="igraph.Graph.biconnected_components">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#biconnected_components" class="internal-link">igraph.GraphBase.biconnected_components</a></code></div>
    <div><p>Calculates the biconnected components of the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_articulation<wbr></wbr>_points</span></td><td class="fieldArgDesc">whether to return the articulation points as well</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.VertexCover.html" class="internal-link" title="igraph.VertexCover">VertexCover</a></code> object describing the biconnected components, and optionally the list of articulation points as well</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.bipartite_projection">
    
  </a>
  <a name="bipartite_projection">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bipartite_projection</span>(graph, types=<span class="rst-variable-quote">'</span><span class="rst-variable-string">type</span><span class="rst-variable-quote">'</span>, multiplicity=True, probe1=-1, which=<span class="rst-variable-quote">'</span><span class="rst-variable-string">both</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#bipartite_projection" title="igraph.Graph.bipartite_projection">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#bipartite_projection" class="internal-link">igraph.GraphBase.bipartite_projection</a></code></div>
    <div><p>Projects a bipartite graph into two one-mode graphs. Edge directions are ignored while projecting.</p>
<p>Examples:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Full_Bipartite(10, 5)
<span class="py-prompt">&gt;&gt;&gt; </span>g1, g2 = g.bipartite_projection()
<span class="py-prompt">&gt;&gt;&gt; </span>g1.isomorphic(Graph.Full(10))
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g2.isomorphic(Graph.Full(5))
<span class="py-output">True</span>
</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">types</span></td><td class="fieldArgDesc">an igraph vector containing the vertex types, or an attribute name. Anything that evalulates to <tt class="rst-docutils literal">False</tt> corresponds to vertices of the first kind, everything else to the second kind.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">multiplicity</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, then igraph keeps the multiplicity of the edges in the projection in an edge attribute called <tt class="rst-docutils literal">"weight"</tt>. E.g., if there is an A-C-B and an A-D-B triplet in the bipartite graph and there is no other X (apart from X=B and X=D) for which an A-X-B triplet would exist in the bipartite graph, the multiplicity of the A-B edge in the projection will be 2.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">probe1</span></td><td class="fieldArgDesc">this argument can be used to specify the order of the projections in the resulting list. If given and non-negative, then it is considered as a vertex ID; the projection containing the vertex will be the first one in the result.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">which</span></td><td class="fieldArgDesc">this argument can be used to specify which of the two projections should be returned if only one of them is needed. Passing 0 here means that only the first projection is returned, while 1 means that only the second projection is returned. (Note that we use 0 and 1 because Python indexing is zero-based). <tt class="rst-docutils literal">False</tt> is equivalent to 0 and <tt class="rst-docutils literal">True</tt> is equivalent to 1. Any other value means that both projections will be returned in a tuple.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a tuple containing the two projected one-mode graphs if <tt class="rst-docutils literal">which</tt> is not 1 or 2, or the projected one-mode graph specified by the <tt class="rst-docutils literal">which</tt> argument if its value is 0, 1, <tt class="rst-docutils literal">False</tt> or <tt class="rst-docutils literal">True</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.bipartite_projection_size">
    
  </a>
  <a name="bipartite_projection_size">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bipartite_projection_size</span>(graph, types=<span class="rst-variable-quote">'</span><span class="rst-variable-string">type</span><span class="rst-variable-quote">'</span>, *args, **kwds):
    
    <a class="headerLink" href="#bipartite_projection_size" title="igraph.Graph.bipartite_projection_size">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#bipartite_projection_size" class="internal-link">igraph.GraphBase.bipartite_projection_size</a></code></div>
    <div><p>Calculates the number of vertices and edges in the bipartite projections of this graph according to the specified vertex types. This is useful if you have a bipartite graph and you want to estimate the amount of memory you would need to calculate the projections themselves.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">types</span></td><td class="fieldArgDesc">an igraph vector containing the vertex types, or an attribute name. Anything that evalulates to <tt class="rst-docutils literal">False</tt> corresponds to vertices of the first kind, everything else to the second kind.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a 4-tuple containing the number of vertices and edges in the first projection, followed by the number of vertices and edges in the second projection.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.blocks">
    
  </a>
  <a name="blocks">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">blocks</span>(graph, return_articulation_points=False):
    
    <a class="headerLink" href="#blocks" title="igraph.Graph.blocks">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the biconnected components of the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_articulation<wbr></wbr>_points</span></td><td class="fieldArgDesc">whether to return the articulation points as well</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.VertexCover.html" class="internal-link" title="igraph.VertexCover">VertexCover</a></code> object describing the biconnected components, and optionally the list of articulation points as well</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.clear">
    
  </a>
  <a name="clear">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">clear</span>(graph):
    
    <a class="headerLink" href="#clear" title="igraph.Graph.clear">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Clears the graph, deleting all vertices, edges, and attributes.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="igraph.GraphBase.html#delete_vertices" class="internal-link" title="igraph.GraphBase.delete_vertices">GraphBase.delete_vertices</a></code> and <code><a href="#delete_edges" class="internal-link" title="igraph.Graph.delete_edges">Graph.delete_edges</a></code>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.clusters">
    
  </a>
  <a name="clusters">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">clusters</span>(graph, mode=<span class="rst-variable-quote">'</span><span class="rst-variable-string">strong</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#clusters" title="igraph.Graph.clusters">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Deprecated alias to <code><a href="igraph.GraphBase.html#connected_components" class="internal-link" title="igraph.GraphBase.connected_components">Graph.connected_components()</a></code>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.community_edge_betweenness">
    
  </a>
  <a name="community_edge_betweenness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_edge_betweenness</span>(graph, clusters=None, directed=True, weights=None):
    
    <a class="headerLink" href="#community_edge_betweenness" title="igraph.Graph.community_edge_betweenness">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#community_edge_betweenness" class="internal-link">igraph.GraphBase.community_edge_betweenness</a></code></div>
    <div><p>Community structure based on the betweenness of the edges in the network.</p>
<p>The idea is that the betweenness of the edges connecting two communities is typically high, as many of the shortest paths between nodes in separate communities go through them. So we gradually remove the edge with the highest betweenness and recalculate the betweennesses after every removal. This way sooner or later the network falls of to separate components. The result of the clustering will be represented by a dendrogram.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">clusters</span></td><td class="fieldArgDesc">the number of clusters we would like to see. This practically defines the "level" where we "cut" the dendrogram to get the membership vector of the vertices. If <tt class="rst-docutils literal">None</tt>, the dendrogram is cut at the level which maximizes the modularity when the graph is unweighted; otherwise the dendrogram is cut at at a single cluster (because cluster count selection based on modularities does not make sense for this method if not all the weights are equal).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the directionality of the edges should be taken into account or not.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.VertexDendrogram.html" class="internal-link" title="igraph.VertexDendrogram">VertexDendrogram</a></code> object, initally cut at the maximum modularity or at the desired number of clusters.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.community_fastgreedy">
    
  </a>
  <a name="community_fastgreedy">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_fastgreedy</span>(graph, weights=None):
    
    <a class="headerLink" href="#community_fastgreedy" title="igraph.Graph.community_fastgreedy">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#community_fastgreedy" class="internal-link">igraph.GraphBase.community_fastgreedy</a></code></div>
    <div><p>Community structure based on the greedy optimization of modularity.</p>
<p>This algorithm merges individual nodes into communities in a way that greedily maximizes the modularity score of the graph. It can be proven that if no merge can increase the current modularity score, the algorithm can be stopped since no further increase can be achieved.</p>
<p>This algorithm is said to run almost in linear time on sparse graphs.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge attribute name or a list containing edge weights</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.VertexDendrogram.html" class="internal-link" title="igraph.VertexDendrogram">VertexDendrogram</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">A Clauset, MEJ Newman and C Moore: Finding community structure in very large networks. Phys Rev E 70, 066111 (2004).</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.community_infomap">
    
  </a>
  <a name="community_infomap">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_infomap</span>(graph, edge_weights=None, vertex_weights=None, trials=10):
    
    <a class="headerLink" href="#community_infomap" title="igraph.Graph.community_infomap">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#community_infomap" class="internal-link">igraph.GraphBase.community_infomap</a></code></div>
    <div><p>Finds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_weights</span></td><td class="fieldArgDesc">name of an vertex attribute or a list containing vertex weights.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">trials</span></td><td class="fieldArgDesc">the number of attempts to partition the network.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.VertexClustering.html" class="internal-link" title="igraph.VertexClustering">VertexClustering</a></code> object with an extra attribute called <tt class="rst-docutils literal">codelength</tt> that stores the code length determined by the algorithm.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">M. Rosvall and C. T. Bergstrom: Maps of information flow reveal community structure in complex networks, PNAS 105, 1118 (2008). <a class="rst-reference external" href="http://dx.doi.org/10.1073/pnas.0706851105" target="_top">http://dx.doi.org/10.1073/pnas.0706851105</a>, <a class="rst-reference external" href="http://arxiv.org/abs/0707.0609" target="_top">http://arxiv.org/abs/0707.0609</a>.</td></tr><tr><td colspan="2">M. Rosvall, D. Axelsson, and C. T. Bergstrom: The map equation, Eur. Phys. J. Special Topics 178, 13 (2009). <a class="rst-reference external" href="http://dx.doi.org/10.1140/epjst/e2010-01179-1" target="_top">http://dx.doi.org/10.1140/epjst/e2010-01179-1</a>, <a class="rst-reference external" href="http://arxiv.org/abs/0906.1405" target="_top">http://arxiv.org/abs/0906.1405</a>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.community_label_propagation">
    
  </a>
  <a name="community_label_propagation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_label_propagation</span>(graph, weights=None, initial=None, fixed=None):
    
    <a class="headerLink" href="#community_label_propagation" title="igraph.Graph.community_label_propagation">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#community_label_propagation" class="internal-link">igraph.GraphBase.community_label_propagation</a></code></div>
    <div><p>Finds the community structure of the graph according to the label propagation method of Raghavan et al.</p>
<p>Initially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus.</p>
<p>Note that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al on how to come up with an aggregated community structure.</p>
<p>Also note that the community _labels_ (numbers) have no semantic meaning and igraph is free to re-number communities. If you use fixed labels, igraph may still re-number the communities, but co-community membership constraints will be respected: if you had two vertices with fixed labels that belonged to the same community, they will still be in the same community at the end. Similarly, if you had two vertices with fixed labels that belonged to different communities, they will still be in different communities at the end.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">initial</span></td><td class="fieldArgDesc">name of a vertex attribute or a list containing the initial vertex labels. Labels are identified by integers from zero to <span class="rst-math rst-formula"><i>n</i> − 1</span> where <span class="rst-math rst-formula"><i>n</i></span> is the number of vertices. Negative numbers may also be present in this vector, they represent unlabeled vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fixed</span></td><td class="fieldArgDesc">a list of booleans for each vertex. <tt class="rst-docutils literal">True</tt> corresponds to vertices whose labeling should not change during the algorithm. It only makes sense if initial labels are also given. Unlabeled vertices cannot be fixed. It may also be the name of a vertex attribute; each attribute value will be interpreted as a Boolean.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.VertexClustering.html" class="internal-link" title="igraph.VertexClustering">VertexClustering</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. <a class="rst-reference external" href="http://arxiv.org/abs/0709.2938" target="_top">http://arxiv.org/abs/0709.2938</a>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.community_leading_eigenvector">
    
  </a>
  <a name="community_leading_eigenvector">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_leading_eigenvector</span>(graph, clusters=None, weights=None, arpack_options=None):
    
    <a class="headerLink" href="#community_leading_eigenvector" title="igraph.Graph.community_leading_eigenvector">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#community_leading_eigenvector" class="internal-link">igraph.GraphBase.community_leading_eigenvector</a></code></div>
    <div><p>Newman's leading eigenvector method for detecting community structure.</p>
<p>This is the proper implementation of the recursive, divisive algorithm: each split is done by maximizing the modularity regarding the original network.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">clusters</span></td><td class="fieldArgDesc">the desired number of communities. If <tt class="rst-docutils literal">None</tt>, the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same, so the actual number of discovered communities can be less than the desired one.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">arpack<wbr></wbr>_options</span></td><td class="fieldArgDesc">an <code><a href="igraph.ARPACKOptions.html" class="internal-link" title="igraph.ARPACKOptions">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <tt class="rst-docutils literal">arpack_options</tt> is used.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.VertexClustering.html" class="internal-link" title="igraph.VertexClustering">VertexClustering</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.community_leading_eigenvector_naive">
    
  </a>
  <a name="community_leading_eigenvector_naive">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_leading_eigenvector_naive</span>(graph, clusters=None, return_merges=False):
    
    <a class="headerLink" href="#community_leading_eigenvector_naive" title="igraph.Graph.community_leading_eigenvector_naive">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Naive implementation of Newman's eigenvector community structure detection.</p>
<p>This function splits the network into two components according to the leading eigenvector of the modularity matrix and then recursively takes the given number of steps by splitting the communities as individual networks. This is not the correct way, however, see the reference for explanation. Consider using the correct <code><a href="#community_leading_eigenvector" class="internal-link" title="igraph.Graph.community_leading_eigenvector">Graph.community_leading_eigenvector</a></code> method instead.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">clusters</span></td><td class="fieldArgDesc">the desired number of communities. If <tt class="rst-docutils literal">None</tt>, the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same, so the actual number of discovered communities can be less than the desired one.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_merges</span></td><td class="fieldArgDesc">whether the returned object should be a dendrogram instead of a single clustering.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.VertexClustering.html" class="internal-link" title="igraph.VertexClustering">VertexClustering</a></code> or <code><a href="igraph.VertexDendrogram.html" class="internal-link" title="igraph.VertexDendrogram">VertexDendrogram</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.community_leiden">
    
  </a>
  <a name="community_leiden">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_leiden</span>(graph, objective_function=<span class="rst-variable-quote">'</span><span class="rst-variable-string">CPM</span><span class="rst-variable-quote">'</span>, weights=None, resolution_parameter=1.0, beta=0.01, initial_membership=None, n_iterations=2, node_weights=None):
    
    <a class="headerLink" href="#community_leiden" title="igraph.Graph.community_leiden">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#community_leiden" class="internal-link">igraph.GraphBase.community_leiden</a></code></div>
    <div><p>Finds the community structure of the graph using the Leiden algorithm of Traag, van Eck &amp; Waltman.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">objective<wbr></wbr>_function</span></td><td class="fieldArgDesc">whether to use the Constant Potts Model (CPM) or modularity. Must be either <tt class="rst-docutils literal">"CPM"</tt> or <tt class="rst-docutils literal">"modularity"</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">resolution<wbr></wbr>_parameter</span></td><td class="fieldArgDesc">the resolution parameter to use. Higher resolutions lead to more smaller communities, while lower resolutions lead to fewer larger communities.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">beta</span></td><td class="fieldArgDesc">parameter affecting the randomness in the Leiden algorithm. This affects only the refinement step of the algorithm.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">initial<wbr></wbr>_membership</span></td><td class="fieldArgDesc">if provided, the Leiden algorithm will try to improve this provided membership. If no argument is provided, the aglorithm simply starts from the singleton partition.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n<wbr></wbr>_iterations</span></td><td class="fieldArgDesc">the number of iterations to iterate the Leiden algorithm. Each iteration may improve the partition further. Using a negative number of iterations will run until a stable iteration is encountered (i.e. the quality was not increased during that iteration).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">node<wbr></wbr>_weights</span></td><td class="fieldArgDesc">the node weights used in the Leiden algorithm. If this is not provided, it will be automatically determined on the basis of whether you want to use CPM or modularity. If you do provide this, please make sure that you understand what you are doing.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.VertexClustering.html" class="internal-link" title="igraph.VertexClustering">VertexClustering</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Traag, V. A., Waltman, L., &amp; van Eck, N. J. (2019). From Louvain to Leiden: guaranteeing well-connected communities. Scientific reports, 9(1), 5233. doi: 10.1038/s41598-019-41695-z</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.community_multilevel">
    
  </a>
  <a name="community_multilevel">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_multilevel</span>(graph, weights=None, return_levels=False):
    
    <a class="headerLink" href="#community_multilevel" title="igraph.Graph.community_multilevel">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#community_multilevel" class="internal-link">igraph.GraphBase.community_multilevel</a></code></div>
    <div><p>Community structure based on the multilevel algorithm of Blondel et al.</p>
<p>This is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrank to a single vertex (while keeping the total weight of the adjacent edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity any more after shrinking the communities to vertices.</p>
<p>This algorithm is said to run almost in linear time on sparse graphs.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge attribute name or a list containing edge weights</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_levels</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, the communities at each level are returned in a list. If <tt class="rst-docutils literal">False</tt>, only the community structure with the best modularity is returned.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of <code><a href="igraph.VertexClustering.html" class="internal-link" title="igraph.VertexClustering">VertexClustering</a></code> objects, one corresponding to each level (if <tt class="rst-docutils literal">return_levels</tt> is <tt class="rst-docutils literal">True</tt>), or a <code><a href="igraph.VertexClustering.html" class="internal-link" title="igraph.VertexClustering">VertexClustering</a></code> corresponding to the best modularity.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks, J Stat Mech P10008 (2008), http://arxiv.org/abs/0803.0476</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.community_optimal_modularity">
    
  </a>
  <a name="community_optimal_modularity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_optimal_modularity</span>(graph, *args, **kwds):
    
    <a class="headerLink" href="#community_optimal_modularity" title="igraph.Graph.community_optimal_modularity">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#community_optimal_modularity" class="internal-link">igraph.GraphBase.community_optimal_modularity</a></code></div>
    <div><p>Calculates the optimal modularity score of the graph and the corresponding community structure.</p>
<p>This function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated membership vector and the corresponding modularity in a tuple.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.community_spinglass">
    
  </a>
  <a name="community_spinglass">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_spinglass</span>(graph, *args, **kwds):
    
    <a class="headerLink" href="#community_spinglass" title="igraph.Graph.community_spinglass">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#community_spinglass" class="internal-link">igraph.GraphBase.community_spinglass</a></code></div>
    <div><p>Finds the community structure of the graph according to the spinglass community detection method of Reichardt &amp; Bornholdt.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">spins</span></td><td class="fieldArgDesc">integer, the number of spins to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">parupdate</span></td><td class="fieldArgDesc">whether to update the spins of the vertices in parallel (synchronously) or not</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">start<wbr></wbr>_temp</span></td><td class="fieldArgDesc">the starting temperature</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">stop<wbr></wbr>_temp</span></td><td class="fieldArgDesc">the stop temperature</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cool<wbr></wbr>_fact</span></td><td class="fieldArgDesc">cooling factor for the simulated annealing</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">update<wbr></wbr>_rule</span></td><td class="fieldArgDesc">specifies the null model of the simulation. Possible values are <tt class="rst-docutils literal">"config"</tt> (a random graph with the same vertex degrees as the input graph) or <tt class="rst-docutils literal">"simple"</tt> (a random graph with the same number of edges)</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">gamma</span></td><td class="fieldArgDesc">the gamma argument of the algorithm, specifying the balance between the importance of present and missing edges within a community. The default value of 1.0 assigns equal importance to both of them.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">implementation</span></td><td class="fieldArgDesc">currently igraph contains two implementations of the spinglass community detection algorithm. The faster original implementation is the default. The other implementation is able to take into account negative weights, this can be chosen by setting <tt class="rst-docutils literal">implementation</tt> to <tt class="rst-docutils literal">"neg"</tt></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">lambda_</span></td><td class="fieldArgDesc">the lambda argument of the algorithm, which specifies the balance between the importance of present and missing negatively weighted edges within a community. Smaller values of lambda lead to communities with less negative intra-connectivity. If the argument is zero, the algorithm reduces to a graph coloring algorithm, using the number of spins as colors. This argument is ignored if the original implementation is used. Note the underscore at the end of the argument name; this is due to the fact that lambda is a reserved keyword in Python.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.VertexClustering.html" class="internal-link" title="igraph.VertexClustering">VertexClustering</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Reichardt J and Bornholdt S: Statistical mechanics of community detection. Phys Rev E 74:016110 (2006). <a class="rst-reference external" href="http://arxiv.org/abs/cond-mat/0603718" target="_top">http://arxiv.org/abs/cond-mat/0603718</a>.</td></tr><tr><td colspan="2">Traag VA and Bruggeman J: Community detection in networks with positive and negative links. Phys Rev E 80:036115 (2009). <a class="rst-reference external" href="http://arxiv.org/abs/0811.2329" target="_top">http://arxiv.org/abs/0811.2329</a>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.community_walktrap">
    
  </a>
  <a name="community_walktrap">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_walktrap</span>(graph, weights=None, steps=4):
    
    <a class="headerLink" href="#community_walktrap" title="igraph.Graph.community_walktrap">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#community_walktrap" class="internal-link">igraph.GraphBase.community_walktrap</a></code></div>
    <div><p>Community detection algorithm of Latapy &amp; Pons, based on random walks.</p>
<p>The basic idea of the algorithm is that short random walks tend to stay in the same community. The result of the clustering will be represented as a dendrogram.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">steps</span></td><td class="fieldArgDesc">length of random walks to perform</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.VertexDendrogram.html" class="internal-link" title="igraph.VertexDendrogram">VertexDendrogram</a></code> object, initially cut at the maximum modularity.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, <a class="rst-reference external" href="http://arxiv.org/abs/physics/0512106" target="_top">http://arxiv.org/abs/physics/0512106</a>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.components">
    
  </a>
  <a name="components">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">components</span>(graph, mode=<span class="rst-variable-quote">'</span><span class="rst-variable-string">strong</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#components" title="igraph.Graph.components">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the (strong or weak) connected components for a given graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">must be either <tt class="rst-docutils literal">"strong"</tt> or <tt class="rst-docutils literal">"weak"</tt>, depending on the connected components being sought. Optional, defaults to <tt class="rst-docutils literal">"strong"</tt>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.VertexClustering.html" class="internal-link" title="igraph.VertexClustering">VertexClustering</a></code> object</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.count_automorphisms_vf2">
    
  </a>
  <a name="count_automorphisms_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">count_automorphisms_vf2</span>(graph, color=None, edge_color=None, node_compat_fn=None, edge_compat_fn=None):
    
    <a class="headerLink" href="#count_automorphisms_vf2" title="igraph.Graph.count_automorphisms_vf2">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the number of automorphisms of the graph.</p>
<p>This function simply calls <tt class="rst-docutils literal">count_isomorphisms_vf2</tt> with the graph itgraph. See <tt class="rst-docutils literal">count_isomorphisms_vf2</tt> for an explanation of the parameters.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the number of automorphisms of the graph</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.count_isomorphisms_vf2</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.degree_distribution">
    
  </a>
  <a name="degree_distribution">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">degree_distribution</span>(graph, bin_width=1, *args, **kwds):
    
    <a class="headerLink" href="#degree_distribution" title="igraph.Graph.degree_distribution">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the degree distribution of the graph.</p>
<p>Unknown keyword arguments are directly passed to <code><a href="igraph.GraphBase.html#degree" class="internal-link" title="igraph.GraphBase.degree">GraphBase.degree</a></code>.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">bin<wbr></wbr>_width</span></td><td class="fieldArgDesc">the bin width of the histogram</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a histogram representing the degree distribution of the graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.delete_edges">
    
  </a>
  <a name="delete_edges">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">delete_edges</span>(graph, *args, **kwds):
    
    <a class="headerLink" href="#delete_edges" title="igraph.Graph.delete_edges">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#delete_edges" class="internal-link">igraph.GraphBase.delete_edges</a></code></div>
    <div><p>Deletes some edges from the graph.</p>
<p>The set of edges to be deleted is determined by the positional and keyword arguments. If the function is called without any arguments, all edges are deleted. If any keyword argument is present, or the first positional argument is callable, an edge sequence is derived by calling <code><a href="igraph.EdgeSeq.html#select" class="internal-link" title="igraph.EdgeSeq.select">EdgeSeq.select</a></code> with the same positional and keyword arguments. Edges in the derived edge sequence will be removed. Otherwise the first positional argument is considered as follows:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">None</tt> - deletes all edges (deprecated since 0.8.3)</li>
<li>a single integer - deletes the edge with the given ID</li>
<li>a list of integers - deletes the edges denoted by the given IDs</li>
<li>a list of 2-tuples - deletes the edges denoted by the given source-target vertex pairs. When multiple edges are present between a given source-target vertex pair, only one is removed.</li>
</ul>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: deprecated</td></tr><tr><td colspan="2"><tt class="rst-docutils literal">delete_edges(None)</tt> has been replaced by <tt class="rst-docutils literal">delete_edges()</tt> - with no arguments - since igraph 0.8.3.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.dfs">
    
  </a>
  <a name="dfs">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">dfs</span>(self, vid, mode=OUT):
    
    <a class="headerLink" href="#dfs" title="igraph.Graph.dfs">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Conducts a depth first search (DFS) on the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vid</span></td><td class="fieldArgDesc">the root vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">either <tt class="rst-docutils literal">"in"</tt> or <tt class="rst-docutils literal">"out"</tt> or <tt class="rst-docutils literal">"all"</tt>, ignored for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><p>a tuple with the following items:</p>
<ul class="rst-simple">
<li>The vertex IDs visited (in order)</li>
<li>The parent of every vertex in the DFS</li>
</ul>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.disjoint_union">
    
  </a>
  <a name="disjoint_union">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">disjoint_union</span>(graph, other):
    
    <a class="headerLink" href="#disjoint_union" title="igraph.Graph.disjoint_union">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Creates the disjoint union of two (or more) graphs.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">graph or list of graphs to be united with the current one.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the disjoint union graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.dyad_census">
    
  </a>
  <a name="dyad_census">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">dyad_census</span>(self, *args, **kwds):
    
    <a class="headerLink" href="#dyad_census" title="igraph.Graph.dyad_census">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#dyad_census" class="internal-link">igraph.GraphBase.dyad_census</a></code></div>
    <div><p>Calculates the dyad census of the graph.</p>
<p>Dyad census means classifying each pair of vertices of a directed graph into three categories: mutual (there is an edge from <em>a</em> to <em>b</em> and also from <em>b</em> to <em>a</em>), asymmetric (there is an edge from <em>a</em> to <em>b</em> or from <em>b</em> to <em>a</em> but not the other way round) and null (there is no connection between <em>a</em> and <em>b</em>).</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.DyadCensus.html" class="internal-link" title="igraph.DyadCensus">DyadCensus</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Holland, P.W. and Leinhardt, S.  (1970).  A Method for Detecting Structure in Sociometric Data.  American Journal of Sociology, 70, 492-513.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.get_adjacency">
    
  </a>
  <a name="get_adjacency">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_adjacency</span>(self, type=GET_ADJACENCY_BOTH, attribute=None, default=0, eids=False):
    
    <a class="headerLink" href="#get_adjacency" title="igraph.Graph.get_adjacency">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#get_adjacency" class="internal-link">igraph.GraphBase.get_adjacency</a></code></div>
    <div><p>Returns the adjacency matrix of a graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">type</span></td><td class="fieldArgDesc">either <tt class="rst-docutils literal">GET_ADJACENCY_LOWER</tt> (uses the lower triangle of the matrix) or <tt class="rst-docutils literal">GET_ADJACENCY_UPPER</tt> (uses the upper triangle) or <tt class="rst-docutils literal">GET_ADJACENCY_BOTH</tt> (uses both parts). Ignored for directed graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">attribute</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">None</tt>, returns the ordinary adjacency matrix. When the name of a valid edge attribute is given here, the matrix returned will contain the default value at the places where there is no edge or the value of the given attribute where there is an edge. Multiple edges are not supported, the value written in the matrix in this case will be unpredictable. This parameter is ignored if <em>eids</em> is <tt class="rst-docutils literal">True</tt></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">default</span></td><td class="fieldArgDesc">the default value written to the cells in the case of adjacency matrices with attributes.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">eids</span></td><td class="fieldArgDesc">specifies whether the edge IDs should be returned in the adjacency matrix. Since zero is a valid edge ID, the cells in the matrix that correspond to unconnected vertex pairs will contain -1 instead of 0 if <em>eids</em> is <tt class="rst-docutils literal">True</tt>. If <em>eids</em> is <tt class="rst-docutils literal">False</tt>, the number of edges will be returned in the matrix for each vertex pair.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the adjacency matrix as a <code><a href="igraph.datatypes.Matrix.html" class="internal-link" title="igraph.datatypes.Matrix">Matrix</a></code>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.get_adjacency_sparse">
    
  </a>
  <a name="get_adjacency_sparse">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_adjacency_sparse</span>(self, attribute=None):
    
    <a class="headerLink" href="#get_adjacency_sparse" title="igraph.Graph.get_adjacency_sparse">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the adjacency matrix of a graph as a SciPy CSR matrix.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">attribute</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">None</tt>, returns the ordinary adjacency matrix. When the name of a valid edge attribute is given here, the matrix returned will contain the default value at the places where there is no edge or the value of the given attribute where there is an edge.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the adjacency matrix as a <tt class="rst-docutils literal">scipy.sparse.csr_matrix</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.get_adjlist">
    
  </a>
  <a name="get_adjlist">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_adjlist</span>(self, mode=<span class="rst-variable-quote">'</span><span class="rst-variable-string">out</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#get_adjlist" title="igraph.Graph.get_adjlist">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the adjacency list representation of the graph.</p>
<p>The adjacency list representation is a list of lists. Each item of the outer list belongs to a single vertex of the graph. The inner list contains the neighbors of the given vertex.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">"out"</tt>, returns the successors of the vertex. If <tt class="rst-docutils literal">"in"</tt>, returns the predecessors of the vertex. If <tt class="rst-docutils literal">"all""</tt>, both the predecessors and the successors will be returned. Ignored for undirected graphs.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.get_all_simple_paths">
    
  </a>
  <a name="get_all_simple_paths">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_all_simple_paths</span>(self, v, to=None, cutoff=-1, mode=<span class="rst-variable-quote">'</span><span class="rst-variable-string">out</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#get_all_simple_paths" title="igraph.Graph.get_all_simple_paths">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates all the simple paths from a given node to some other nodes (or all of them) in a graph.</p>
<p>A path is simple if its vertices are unique, i.e. no vertex is visited more than once.</p>
<p>Note that potentially there are exponentially many paths between two vertices of a graph, especially if your graph is lattice-like. In this case, you may run out of memory when using this function.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">v</span></td><td class="fieldArgDesc">the source for the calculated paths</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">to</span></td><td class="fieldArgDesc">a vertex selector describing the destination for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a <code><a href="igraph.VertexSeq.html" class="internal-link" title="igraph.VertexSeq">VertexSeq</a></code> object. <tt class="rst-docutils literal">None</tt> means all the vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cutoff</span></td><td class="fieldArgDesc">maximum length of path that is considered. If negative, paths of all lengths are considered.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">the directionality of the paths. <tt class="rst-docutils literal">"in"</tt> means to calculate incoming paths, <tt class="rst-docutils literal">"out"</tt> means to calculate outgoing paths, <tt class="rst-docutils literal">"all"</tt> means to calculate both ones.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">all of the simple paths from the given node to every other reachable node in the graph in a list. Note that in case of mode=<tt class="rst-docutils literal">"in"</tt>, the vertices in a path are returned in reversed order!</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.get_automorphisms_vf2">
    
  </a>
  <a name="get_automorphisms_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_automorphisms_vf2</span>(graph, color=None, edge_color=None, node_compat_fn=None, edge_compat_fn=None):
    
    <a class="headerLink" href="#get_automorphisms_vf2" title="igraph.Graph.get_automorphisms_vf2">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns all the automorphisms of the graph</p>
<p>This function simply calls <tt class="rst-docutils literal">get_isomorphisms_vf2</tt> with the graph itgraph. See <tt class="rst-docutils literal">get_isomorphisms_vf2</tt> for an explanation of the parameters.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of lists, each item containing a possible mapping of the graph vertices to itgraph according to the automorphism</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.get_isomorphisms_vf2</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.get_edge_dataframe">
    
  </a>
  <a name="get_edge_dataframe">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_edge_dataframe</span>(graph):
    
    <a class="headerLink" href="#get_edge_dataframe" title="igraph.Graph.get_edge_dataframe">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Export edges with attributes to pandas.DataFrame</p>
<p>If you want to use source and target vertex IDs as index, you can do:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> string <span class="py-keyword">import</span> ascii_letters
<span class="py-prompt">&gt;&gt;&gt; </span>graph = Graph.GRG(25, 0.4)
<span class="py-prompt">&gt;&gt;&gt; </span>graph.vs[<span class="py-string">"name"</span>] = ascii_letters[:graph.vcount()]
<span class="py-prompt">&gt;&gt;&gt; </span>df = graph.get_edge_dataframe()
<span class="py-prompt">&gt;&gt;&gt; </span>df.set_index([<span class="py-string">'source'</span>, <span class="py-string">'target'</span>], inplace=<span class="py-builtin">True</span>)</pre><p>The index will be a pandas.MultiIndex. You can use the <tt class="rst-docutils literal">drop=False</tt> option to keep the <tt class="rst-docutils literal">source</tt> and <tt class="rst-docutils literal">target</tt> columns.</p>
<p>If you want to use vertex names in the source and target columns:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>df = graph.get_edge_dataframe()
<span class="py-prompt">&gt;&gt;&gt; </span>df_vert = graph.get_vertex_dataframe()
<span class="py-prompt">&gt;&gt;&gt; </span>df[<span class="py-string">'source'</span>].replace(df_vert[<span class="py-string">'name'</span>], inplace=<span class="py-builtin">True</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>df[<span class="py-string">'target'</span>].replace(df_vert[<span class="py-string">'name'</span>], inplace=<span class="py-builtin">True</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>df_vert.set_index(<span class="py-string">'name'</span>, inplace=<span class="py-builtin">True</span>)  <span class="py-comment"># Optional</span></pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a pandas.DataFrame representing edges and their attributes. The index uses edge IDs, from 0 to M - 1 where M is the number of edges. The first two columns of the dataframe represent the IDs of source and target vertices for each edge. These columns have names "source" and "target". If your edges have attributes with the same names, they will be present in the dataframe, but not in the first two columns.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.get_incidence">
    
  </a>
  <a name="get_incidence">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_incidence</span>(graph, types=<span class="rst-variable-quote">'</span><span class="rst-variable-string">type</span><span class="rst-variable-quote">'</span>, *args, **kwds):
    
    <a class="headerLink" href="#get_incidence" title="igraph.Graph.get_incidence">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#get_incidence" class="internal-link">igraph.GraphBase.get_incidence</a></code></div>
    <div><p>Returns the incidence matrix of a bipartite graph. The incidence matrix is an <span class="rst-math rst-formula"><i>n</i></span> times <span class="rst-math rst-formula"><i>m</i></span> matrix, where <span class="rst-math rst-formula"><i>n</i></span> and <span class="rst-math rst-formula"><i>m</i></span> are the number of vertices in the two vertex classes.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">types</span></td><td class="fieldArgDesc">an igraph vector containing the vertex types, or an attribute name. Anything that evalulates to <tt class="rst-docutils literal">False</tt> corresponds to vertices of the first kind, everything else to the second kind.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the incidence matrix and two lists in a triplet. The first list defines the mapping between row indices of the matrix and the original vertex IDs. The second list is the same for the column indices.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.get_inclist">
    
  </a>
  <a name="get_inclist">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_inclist</span>(graph, mode=<span class="rst-variable-quote">'</span><span class="rst-variable-string">out</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#get_inclist" title="igraph.Graph.get_inclist">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the incidence list representation of the graph.</p>
<p>The incidence list representation is a list of lists. Each item of the outer list belongs to a single vertex of the graph. The inner list contains the IDs of the incident edges of the given vertex.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">"out"</tt>, returns the successors of the vertex. If <tt class="rst-docutils literal">"in"</tt>, returns the predecessors of the vertex. If <tt class="rst-docutils literal">"all"</tt>, both the predecessors and the successors will be returned. Ignored for undirected graphs.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.get_vertex_dataframe">
    
  </a>
  <a name="get_vertex_dataframe">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_vertex_dataframe</span>(graph):
    
    <a class="headerLink" href="#get_vertex_dataframe" title="igraph.Graph.get_vertex_dataframe">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Export vertices with attributes to pandas.DataFrame</p>
<p>If you want to use vertex names as index, you can do:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> string <span class="py-keyword">import</span> ascii_letters
<span class="py-prompt">&gt;&gt;&gt; </span>graph = Graph.GRG(25, 0.4)
<span class="py-prompt">&gt;&gt;&gt; </span>graph.vs[<span class="py-string">"name"</span>] = ascii_letters[:graph.vcount()]
<span class="py-prompt">&gt;&gt;&gt; </span>df = graph.get_vertex_dataframe()
<span class="py-prompt">&gt;&gt;&gt; </span>df.set_index(<span class="py-string">'name'</span>, inplace=<span class="py-builtin">True</span>)</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a pandas.DataFrame representing vertices and their attributes. The index uses vertex IDs, from 0 to N - 1 where N is the number of vertices.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.gomory_hu_tree">
    
  </a>
  <a name="gomory_hu_tree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">gomory_hu_tree</span>(graph, capacity=None, flow=<span class="rst-variable-quote">'</span><span class="rst-variable-string">flow</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#gomory_hu_tree" title="igraph.Graph.gomory_hu_tree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#gomory_hu_tree" class="internal-link">igraph.GraphBase.gomory_hu_tree</a></code></div>
    <div><p>Calculates the Gomory-Hu tree of an undirected graph with optional edge capacities.</p>
<p>The Gomory-Hu tree is a concise representation of the value of all the maximum flows (or minimum cuts) in a graph. The vertices of the tree correspond exactly to the vertices of the original graph in the same order. Edges of the Gomory-Hu tree are annotated by flow values.  The value of the maximum flow (or minimum cut) between an arbitrary (u,v) vertex pair in the original graph is then given by the minimum flow value (i.e. edge annotation) along the shortest path between u and v in the Gomory-Hu tree.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">capacity</span></td><td class="fieldArgDesc">the edge capacities (weights). If <tt class="rst-docutils literal">None</tt>, all edges have equal weight. May also be an attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">flow</span></td><td class="fieldArgDesc">the name of the edge attribute in the returned graph in which the flow values will be stored.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the Gomory-Hu tree as a <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> object.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.indegree">
    
  </a>
  <a name="indegree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">indegree</span>(graph, *args, **kwds):
    
    <a class="headerLink" href="#indegree" title="igraph.Graph.indegree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the in-degrees in a list.</p>
<p>See <code><a href="igraph.GraphBase.html#degree" class="internal-link" title="igraph.GraphBase.degree">GraphBase.degree</a></code> for possible arguments.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.intersection">
    
  </a>
  <a name="intersection">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">intersection</span>(graph, other, byname=<span class="rst-variable-quote">'</span><span class="rst-variable-string">auto</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#intersection" title="igraph.Graph.intersection">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Creates the intersection of two (or more) graphs.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">graph or list of graphs to be intersected with the current one.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">byname</span></td><td class="fieldArgDesc">whether to use vertex names instead of ids. See <code><a href="igraph.operators.functions.html#intersection" class="internal-link" title="igraph.operators.functions.intersection">igraph.operators.intersection</a></code> for details.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the intersection graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.is_named">
    
  </a>
  <a name="is_named">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_named</span>(self):
    
    <a class="headerLink" href="#is_named" title="igraph.Graph.is_named">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns whether the graph is named.</p>
<p>A graph is named if and only if it has a <tt class="rst-docutils literal">"name"</tt> vertex attribute.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.is_weighted">
    
  </a>
  <a name="is_weighted">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_weighted</span>(self):
    
    <a class="headerLink" href="#is_weighted" title="igraph.Graph.is_weighted">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns whether the graph is weighted.</p>
<p>A graph is weighted if and only if it has a <tt class="rst-docutils literal">"weight"</tt> edge attribute.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.k_core">
    
  </a>
  <a name="k_core">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">k_core</span>(graph, *args):
    
    <a class="headerLink" href="#k_core" title="igraph.Graph.k_core">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns some k-cores of the graph.</p>
<p>The method accepts an arbitrary number of arguments representing the desired indices of the <span class="rst-math rst-formula"><i>k</i></span>-cores to be returned. The arguments can also be lists or tuples. The result is a single <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> object if an only integer argument was given, otherwise the result is a list of <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> objects representing the desired k-cores in the order the arguments were specified. If no argument is given, returns all <span class="rst-math rst-formula"><i>k</i></span>-cores in increasing order of <span class="rst-math rst-formula"><i>k</i></span>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.layout">
    
  </a>
  <a name="layout">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout</span>(graph, layout=None, *args, **kwds):
    
    <a class="headerLink" href="#layout" title="igraph.Graph.layout">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the layout of the graph according to a layout algorithm.</p>
<p>Parameters and keyword arguments not specified here are passed to the layout algorithm directly. See the documentation of the layout algorithms for the explanation of these parameters.</p>
<p>Registered layout names understood by this method are:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">auto</tt>, <tt class="rst-docutils literal">automatic</tt>: automatic layout (see <code><a href="#layout_auto" class="internal-link" title="igraph.Graph.layout_auto">Graph.layout_auto</a></code>)</li>
<li><tt class="rst-docutils literal">bipartite</tt>: bipartite layout (see <code><a href="igraph.GraphBase.html#layout_bipartite" class="internal-link" title="igraph.GraphBase.layout_bipartite">GraphBase.layout_bipartite</a></code>)</li>
<li><tt class="rst-docutils literal">circle</tt>, <tt class="rst-docutils literal">circular</tt>: circular layout (see <code><a href="igraph.GraphBase.html#layout_circle" class="internal-link" title="igraph.GraphBase.layout_circle">GraphBase.layout_circle</a></code>)</li>
<li><tt class="rst-docutils literal">dh</tt>, <tt class="rst-docutils literal">davidson_harel</tt>: Davidson-Harel layout (see <code><a href="igraph.GraphBase.html#layout_davidson_harel" class="internal-link" title="igraph.GraphBase.layout_davidson_harel">GraphBase.layout_davidson_harel</a></code>)</li>
<li><tt class="rst-docutils literal">drl</tt>: DrL layout for large graphs (see <code><a href="igraph.GraphBase.html#layout_drl" class="internal-link" title="igraph.GraphBase.layout_drl">GraphBase.layout_drl</a></code>)</li>
<li><tt class="rst-docutils literal">drl_3d</tt>: 3D DrL layout for large graphs (see <code><a href="igraph.GraphBase.html#layout_drl" class="internal-link" title="igraph.GraphBase.layout_drl">GraphBase.layout_drl</a></code>)</li>
<li><tt class="rst-docutils literal">fr</tt>, <tt class="rst-docutils literal">fruchterman_reingold</tt>: Fruchterman-Reingold layout (see <code><a href="igraph.GraphBase.html#layout_fruchterman_reingold" class="internal-link" title="igraph.GraphBase.layout_fruchterman_reingold">GraphBase.layout_fruchterman_reingold</a></code>).</li>
<li><tt class="rst-docutils literal">fr_3d</tt>, <tt class="rst-docutils literal">fr3d</tt>, <tt class="rst-docutils literal">fruchterman_reingold_3d</tt>: 3D Fruchterman- Reingold layout (see <code><a href="igraph.GraphBase.html#layout_fruchterman_reingold" class="internal-link" title="igraph.GraphBase.layout_fruchterman_reingold">GraphBase.layout_fruchterman_reingold</a></code>).</li>
<li><tt class="rst-docutils literal">grid</tt>: regular grid layout in 2D (see <code><a href="igraph.GraphBase.html#layout_grid" class="internal-link" title="igraph.GraphBase.layout_grid">GraphBase.layout_grid</a></code>)</li>
<li><tt class="rst-docutils literal">grid_3d</tt>: regular grid layout in 3D (see <code><a href="igraph.GraphBase.html#layout_grid" class="internal-link" title="igraph.GraphBase.layout_grid">GraphBase.layout_grid</a></code>)</li>
<li><tt class="rst-docutils literal">graphopt</tt>: the graphopt algorithm (see <code><a href="igraph.GraphBase.html#layout_graphopt" class="internal-link" title="igraph.GraphBase.layout_graphopt">GraphBase.layout_graphopt</a></code>)</li>
<li><tt class="rst-docutils literal">kk</tt>, <tt class="rst-docutils literal">kamada_kawai</tt>: Kamada-Kawai layout (see <code><a href="igraph.GraphBase.html#layout_kamada_kawai" class="internal-link" title="igraph.GraphBase.layout_kamada_kawai">GraphBase.layout_kamada_kawai</a></code>)</li>
<li><tt class="rst-docutils literal">kk_3d</tt>, <tt class="rst-docutils literal">kk3d</tt>, <tt class="rst-docutils literal">kamada_kawai_3d</tt>: 3D Kamada-Kawai layout (see <code><a href="igraph.GraphBase.html#layout_kamada_kawai" class="internal-link" title="igraph.GraphBase.layout_kamada_kawai">GraphBase.layout_kamada_kawai</a></code>)</li>
<li><tt class="rst-docutils literal">lgl</tt>, <tt class="rst-docutils literal">large</tt>, <tt class="rst-docutils literal">large_graph</tt>: Large Graph Layout (see <code><a href="igraph.GraphBase.html#layout_lgl" class="internal-link" title="igraph.GraphBase.layout_lgl">GraphBase.layout_lgl</a></code>)</li>
<li><tt class="rst-docutils literal">mds</tt>: multidimensional scaling layout (see <code><a href="igraph.GraphBase.html#layout_mds" class="internal-link" title="igraph.GraphBase.layout_mds">GraphBase.layout_mds</a></code>)</li>
<li><tt class="rst-docutils literal">random</tt>: random layout (see <code><a href="igraph.GraphBase.html#layout_random" class="internal-link" title="igraph.GraphBase.layout_random">GraphBase.layout_random</a></code>)</li>
<li><tt class="rst-docutils literal">random_3d</tt>: random 3D layout (see <code><a href="igraph.GraphBase.html#layout_random" class="internal-link" title="igraph.GraphBase.layout_random">GraphBase.layout_random</a></code>)</li>
<li><tt class="rst-docutils literal">rt</tt>, <tt class="rst-docutils literal">tree</tt>, <tt class="rst-docutils literal">reingold_tilford</tt>: Reingold-Tilford tree layout (see <code><a href="igraph.GraphBase.html#layout_reingold_tilford" class="internal-link" title="igraph.GraphBase.layout_reingold_tilford">GraphBase.layout_reingold_tilford</a></code>)</li>
<li><tt class="rst-docutils literal">rt_circular</tt>, <tt class="rst-docutils literal">reingold_tilford_circular</tt>: circular Reingold-Tilford tree layout (see <code><a href="igraph.GraphBase.html#layout_reingold_tilford_circular" class="internal-link" title="igraph.GraphBase.layout_reingold_tilford_circular">GraphBase.layout_reingold_tilford_circular</a></code>)</li>
<li><tt class="rst-docutils literal">sphere</tt>, <tt class="rst-docutils literal">spherical</tt>, <tt class="rst-docutils literal">circle_3d</tt>, <tt class="rst-docutils literal">circular_3d</tt>: spherical layout (see <code><a href="igraph.GraphBase.html#layout_circle" class="internal-link" title="igraph.GraphBase.layout_circle">GraphBase.layout_circle</a></code>)</li>
<li><tt class="rst-docutils literal">star</tt>: star layout (see <code><a href="igraph.GraphBase.html#layout_star" class="internal-link" title="igraph.GraphBase.layout_star">GraphBase.layout_star</a></code>)</li>
<li><tt class="rst-docutils literal">sugiyama</tt>: Sugiyama layout (see <code><a href="#layout_sugiyama" class="internal-link" title="igraph.Graph.layout_sugiyama">Graph.layout_sugiyama</a></code>)</li>
</ul>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">layout</span></td><td class="fieldArgDesc">the layout to use. This can be one of the registered layout names or a callable which returns either a <code><a href="igraph.layout.Layout.html" class="internal-link" title="igraph.layout.Layout">Layout</a></code> object or a list of lists containing the coordinates. If <tt class="rst-docutils literal">None</tt>, uses the value of the <tt class="rst-docutils literal">plotting.layout</tt> configuration key.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.layout.Layout.html" class="internal-link" title="igraph.layout.Layout">Layout</a></code> object.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.layout_auto">
    
  </a>
  <a name="layout_auto">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_auto</span>(graph, *args, **kwds):
    
    <a class="headerLink" href="#layout_auto" title="igraph.Graph.layout_auto">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Chooses and runs a suitable layout function based on simple topological properties of the graph.</p>
<p>This function tries to choose an appropriate layout function for the graph using the following rules:</p>
<ol class="rst-simple">
<li>If the graph has an attribute called <tt class="rst-docutils literal">layout</tt>, it will be used. It may either be a <code><a href="igraph.layout.Layout.html" class="internal-link" title="igraph.layout.Layout">Layout</a></code> instance, a list of coordinate pairs, the name of a layout function, or a callable function which generates the layout when called with the graph as a parameter.</li>
<li>Otherwise, if the graph has vertex attributes called <tt class="rst-docutils literal">x</tt> and <tt class="rst-docutils literal">y</tt>, these will be used as coordinates in the layout. When a 3D layout is requested (by setting <tt class="rst-docutils literal">dim</tt> to 3), a vertex attribute named <tt class="rst-docutils literal">z</tt> will also be needed.</li>
<li>Otherwise, if the graph is connected and has at most 100 vertices, the Kamada-Kawai layout will be used (see <code><a href="igraph.GraphBase.html#layout_kamada_kawai" class="internal-link" title="igraph.GraphBase.layout_kamada_kawai">GraphBase.layout_kamada_kawai()</a></code>).</li>
<li>Otherwise, if the graph has at most 1000 vertices, the Fruchterman-Reingold layout will be used (see <code><a href="igraph.GraphBase.html#layout_fruchterman_reingold" class="internal-link" title="igraph.GraphBase.layout_fruchterman_reingold">GraphBase.layout_fruchterman_reingold()</a></code>).</li>
<li>If everything else above failed, the DrL layout algorithm will be used (see <code><a href="igraph.GraphBase.html#layout_drl" class="internal-link" title="igraph.GraphBase.layout_drl">GraphBase.layout_drl()</a></code>).</li>
</ol>
<p>All the arguments of this function except <tt class="rst-docutils literal">dim</tt> are passed on to the chosen layout function (in case we have to call some layout function).</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">dim</span></td><td class="fieldArgDesc">specifies whether we would like to obtain a 2D or a 3D layout.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.layout.Layout.html" class="internal-link" title="igraph.layout.Layout">Layout</a></code> object.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.layout_sugiyama">
    
  </a>
  <a name="layout_sugiyama">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_sugiyama</span>(graph, layers=None, weights=None, hgap=1, vgap=1, maxiter=100, return_extended_graph=False):
    
    <a class="headerLink" href="#layout_sugiyama" title="igraph.Graph.layout_sugiyama">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Places the vertices using a layered Sugiyama layout.</p>
<p>This is a layered layout that is most suitable for directed acyclic graphs, although it works on undirected or cyclic graphs as well.</p>
<p>Each vertex is assigned to a layer and each layer is placed on a horizontal line. Vertices within the same layer are then permuted using the barycenter heuristic that tries to minimize edge crossings.</p>
<p>Dummy vertices will be added on edges that span more than one layer. The returned layout therefore contains more rows than the number of nodes in the original graph; the extra rows correspond to the dummy vertices.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">layers</span></td><td class="fieldArgDesc">a vector specifying a non-negative integer layer index for each vertex, or the name of a numeric vertex attribute that contains the layer indices. If <tt class="rst-docutils literal">None</tt>, a layering will be determined automatically. For undirected graphs, a spanning tree will be extracted and vertices will be assigned to layers using a breadth first search from the node with the largest degree. For directed graphs, cycles are broken by reversing the direction of edges in an approximate feedback arc set using the heuristic of Eades, Lin and Smyth, and then using longest path layering to place the vertices in layers.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">hgap</span></td><td class="fieldArgDesc">minimum horizontal gap between vertices in the same layer.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vgap</span></td><td class="fieldArgDesc">vertical gap between layers. The layer index will be multiplied by <em>vgap</em> to obtain the Y coordinate.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxiter</span></td><td class="fieldArgDesc">maximum number of iterations to take in the crossing reduction step. Increase this if you feel that you are getting too many edge crossings.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_extended<wbr></wbr>_graph</span></td><td class="fieldArgDesc">specifies that the extended graph with the added dummy vertices should also be returned. When this is <tt class="rst-docutils literal">True</tt>, the result will be a tuple containing the layout and the extended graph. The first |V| nodes of the extended graph will correspond to the nodes of the original graph, the remaining ones are dummy nodes. Plotting the extended graph with the returned layout and hidden dummy nodes will produce a layout that is similar to the original graph, but with the added edge bends. The extended graph also contains an edge attribute called <tt class="rst-docutils literal">_original_eid</tt> which specifies the ID of the edge in the original graph from which the edge of the extended graph was created.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout, which may (and usually will) have more rows than the number of vertices; the remaining rows correspond to the dummy nodes introduced in the layering step. When <tt class="rst-docutils literal">return_extended_graph</tt> is <tt class="rst-docutils literal">True</tt>, it will also contain the extended graph.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">K Sugiyama, S Tagawa, M Toda: Methods for visual understanding of hierarchical system structures. IEEE Systems, Man and Cybernetics          11(2):109-125, 1981.</td></tr><tr><td colspan="2">P Eades, X Lin and WF Smyth: A fast effective heuristic for the feedback arc set problem. Information Processing Letters 47:319-323, 1993.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.maxflow">
    
  </a>
  <a name="maxflow">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maxflow</span>(graph, source, target, capacity=None):
    
    <a class="headerLink" href="#maxflow" title="igraph.Graph.maxflow">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#maxflow" class="internal-link">igraph.GraphBase.maxflow</a></code></div>
    <div><p>Returns a maximum flow between the given source and target vertices in a graph.</p>
<p>A maximum flow from <em>source</em> to <em>target</em> is an assignment of non-negative real numbers to the edges of the graph, satisfying two properties:</p>
<ol class="rst-simple">
<li>For each edge, the flow (i.e. the assigned number) is not more than the capacity of the edge (see the <em>capacity</em> argument)</li>
<li>For every vertex except the source and the target, the incoming flow is the same as the outgoing flow.</li>
</ol>
<p>The value of the flow is the incoming flow of the target or the outgoing flow of the source (which are equal). The maximum flow is the maximum possible such value.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">capacity</span></td><td class="fieldArgDesc">the edge capacities (weights). If <tt class="rst-docutils literal">None</tt>, all edges have equal weight. May also be an attribute name.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.Flow.html" class="internal-link" title="igraph.Flow">Flow</a></code> object describing the maximum flow</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.maximum_bipartite_matching">
    
  </a>
  <a name="maximum_bipartite_matching">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maximum_bipartite_matching</span>(graph, types=<span class="rst-variable-quote">'</span><span class="rst-variable-string">type</span><span class="rst-variable-quote">'</span>, weights=None, eps=None):
    
    <a class="headerLink" href="#maximum_bipartite_matching" title="igraph.Graph.maximum_bipartite_matching">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Finds a maximum matching in a bipartite graph.</p>
<p>A maximum matching is a set of edges such that each vertex is incident on at most one matched edge and the number (or weight) of such edges in the set is as large as possible.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">types</span></td><td class="fieldArgDesc">vertex types in a list or the name of a vertex attribute holding vertex types. Types should be denoted by zeros and ones (or <tt class="rst-docutils literal">False</tt> and <tt class="rst-docutils literal">True</tt>) for the two sides of the bipartite graph. If omitted, it defaults to <tt class="rst-docutils literal">type</tt>, which is the default vertex type attribute for bipartite graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">eps</span></td><td class="fieldArgDesc">a small real number used in equality tests in the weighted bipartite matching algorithm. Two real numbers are considered equal in the algorithm if their difference is smaller than this value. This is required to avoid the accumulation of numerical errors. If you pass <tt class="rst-docutils literal">None</tt> here, igraph will try to determine an appropriate value automatically.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an instance of <code><a href="igraph.Matching.html" class="internal-link" title="igraph.Matching">Matching</a></code>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.mincut">
    
  </a>
  <a name="mincut">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">mincut</span>(graph, source=None, target=None, capacity=None):
    
    <a class="headerLink" href="#mincut" title="igraph.Graph.mincut">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#mincut" class="internal-link">igraph.GraphBase.mincut</a></code></div>
    <div><p>Calculates the minimum cut between the given source and target vertices or within the whole graph.</p>
<p>The minimum cut is the minimum set of edges that needs to be removed to separate the source and the target (if they are given) or to disconnect the graph (if neither the source nor the target are given). The minimum is calculated using the weights (capacities) of the edges, so the cut with the minimum total capacity is calculated.</p>
<p>For undirected graphs and no source and target, the method uses the Stoer-Wagner algorithm. For a given source and target, the method uses the push-relabel algorithm; see the references below.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex ID. If <tt class="rst-docutils literal">None</tt>, the target must also be <tt class="rst-docutils literal">None</tt> and the calculation will be done for the entire graph (i.e. all possible vertex pairs).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex ID. If <tt class="rst-docutils literal">None</tt>, the source must also be <tt class="rst-docutils literal">None</tt> and the calculation will be done for the entire graph (i.e. all possible vertex pairs).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">capacity</span></td><td class="fieldArgDesc">the edge capacities (weights). If <tt class="rst-docutils literal">None</tt>, all edges have equal weight. May also be an attribute name.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.Cut.html" class="internal-link" title="igraph.Cut">Cut</a></code> object describing the minimum cut</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.modularity">
    
  </a>
  <a name="modularity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">modularity</span>(self, membership, weights=None):
    
    <a class="headerLink" href="#modularity" title="igraph.Graph.modularity">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#modularity" class="internal-link">igraph.GraphBase.modularity</a></code></div>
    <div><p>Calculates the modularity score of the graph with respect to a given clustering.</p>
<p>The modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It's defined as <span class="rst-math rst-formula"><i>Q</i> = 1 ⁄ (2<i>m</i>)*<i>sum</i>(<i>Aij</i> − <i>ki</i>*<i>kj</i> ⁄ (2<i>m</i>)<i>delta</i>(<i>ci</i>, <i>cj</i>), <i>i</i>, <i>j</i>)</span>. <span class="rst-math rst-formula"><i>m</i></span> is the number of edges, <span class="rst-math rst-formula"><i>Aij</i></span> is the element of the <span class="rst-math rst-formula"><i>A</i></span> adjacency matrix in row <span class="rst-math rst-formula"><i>i</i></span> and column <span class="rst-math rst-formula"><i>j</i></span>, <span class="rst-math rst-formula"><i>ki</i></span> is the degree of node <span class="rst-math rst-formula"><i>i</i></span>, <span class="rst-math rst-formula"><i>kj</i></span> is the degree of node <span class="rst-math rst-formula"><i>j</i></span>, and <span class="rst-math rst-formula"><i>Ci</i></span> and <tt class="rst-docutils literal">cj</tt> are the types of the two vertices (<span class="rst-math rst-formula"><i>i</i></span> and <span class="rst-math rst-formula"><i>j</i></span>). <span class="rst-math rst-formula"><i>delta</i>(<i>x</i>, <i>y</i>)</span> is one iff <span class="rst-math rst-formula"><i>x</i> = <i>y</i></span>, 0 otherwise.</p>
<p>If edge weights are given, the definition of modularity is modified as follows: <span class="rst-math rst-formula"><i>Aij</i></span> becomes the weight of the corresponding edge, <span class="rst-math rst-formula"><i>ki</i></span> is the total weight of edges adjacent to vertex <span class="rst-math rst-formula"><i>i</i></span>, <span class="rst-math rst-formula"><i>kj</i></span> is the total weight of edges adjacent to vertex <span class="rst-math rst-formula"><i>j</i></span> and <span class="rst-math rst-formula"><i>m</i></span> is the total edge weight in the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">membership</span></td><td class="fieldArgDesc">a membership list or a <code><a href="igraph.VertexClustering.html" class="internal-link" title="igraph.VertexClustering">VertexClustering</a></code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">optional edge weights or <tt class="rst-docutils literal">None</tt> if all edges are weighed equally. Attribute names are also allowed.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the modularity score</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.outdegree">
    
  </a>
  <a name="outdegree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">outdegree</span>(graph, *args, **kwds):
    
    <a class="headerLink" href="#outdegree" title="igraph.Graph.outdegree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the out-degrees in a list.</p>
<p>See <code><a href="igraph.GraphBase.html#degree" class="internal-link" title="igraph.GraphBase.degree">GraphBase.degree</a></code> for possible arguments.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.pagerank">
    
  </a>
  <a name="pagerank">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">pagerank</span>(graph, vertices=None, directed=True, damping=0.85, weights=None, arpack_options=None, implementation=<span class="rst-variable-quote">'</span><span class="rst-variable-string">prpack</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#pagerank" title="igraph.Graph.pagerank">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the PageRank values of a graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the indices of the vertices being queried. <tt class="rst-docutils literal">None</tt> means all of the vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider directed paths.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">damping</span></td><td class="fieldArgDesc">the damping factor. <span class="rst-math rst-formula">1 − <i>damping</i></span> is the PageRank value for nodes with no incoming links. It is also the probability of resetting the random walk to a uniform distribution in each step.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">arpack<wbr></wbr>_options</span></td><td class="fieldArgDesc">an <code><a href="igraph.ARPACKOptions.html" class="internal-link" title="igraph.ARPACKOptions">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <tt class="rst-docutils literal">arpack_options</tt> is used. This argument is ignored if not the ARPACK implementation is used, see the <em>implementation</em> argument.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">implementation</span></td><td class="fieldArgDesc"><p>which implementation to use to solve the PageRank eigenproblem. Possible values are:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"prpack"</tt>: use the PRPACK library. This is a new implementation in igraph 0.7</li>
<li><tt class="rst-docutils literal">"arpack"</tt>: use the ARPACK library. This implementation was used from version 0.5, until version 0.7.</li>
</ul>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list with the PageRank values of the specified vertices.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.path_length_hist">
    
  </a>
  <a name="path_length_hist">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">path_length_hist</span>(self, directed=True):
    
    <a class="headerLink" href="#path_length_hist" title="igraph.Graph.path_length_hist">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#path_length_hist" class="internal-link">igraph.GraphBase.path_length_hist</a></code></div>
    <div><p>Returns the path length histogram of the graph</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider directed paths. Ignored for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.statistics.Histogram.html" class="internal-link" title="igraph.statistics.Histogram">Histogram</a></code> object. The object will also have an <tt class="rst-docutils literal">unconnected</tt> attribute that stores the number of unconnected vertex pairs (where the second vertex can not be reached from the first one). The latter one will be of type long (and not a simple integer), since this can be <em>very</em> large.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.shortest_paths">
    
  </a>
  <a name="shortest_paths">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">shortest_paths</span>(graph, *args, **kwds):
    
    <a class="headerLink" href="#shortest_paths" title="igraph.Graph.shortest_paths">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Deprecated alias to <code><a href="igraph.GraphBase.html#distances" class="internal-link" title="igraph.GraphBase.distances">Graph.distances()</a></code>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.spanning_tree">
    
  </a>
  <a name="spanning_tree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">spanning_tree</span>(self, weights=None, return_tree=True):
    
    <a class="headerLink" href="#spanning_tree" title="igraph.Graph.spanning_tree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates a minimum spanning tree for a graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">a vector containing weights for every edge in the graph. <tt class="rst-docutils literal">None</tt> means that the graph is unweighted.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_tree</span></td><td class="fieldArgDesc">whether to return the minimum spanning tree (when <tt class="rst-docutils literal">return_tree</tt> is <tt class="rst-docutils literal">True</tt>) or to return the IDs of the edges in the minimum spanning tree instead (when <tt class="rst-docutils literal">return_tree</tt> is <tt class="rst-docutils literal">False</tt>). The default is <tt class="rst-docutils literal">True</tt> for historical reasons as this argument was introduced in igraph 0.6.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the spanning tree as a <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> object if <tt class="rst-docutils literal">return_tree</tt> is <tt class="rst-docutils literal">True</tt> or the IDs of the edges that constitute the spanning tree if <tt class="rst-docutils literal">return_tree</tt> is <tt class="rst-docutils literal">False</tt>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Prim, R.C.: <em>Shortest connection networks and some generalizations</em>. Bell System Technical Journal 36:1389-1401, 1957.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.summary">
    
  </a>
  <a name="summary">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">summary</span>(self, verbosity=0, width=None, *args, **kwds):
    
    <a class="headerLink" href="#summary" title="igraph.Graph.summary">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the summary of the graph.</p>
<p>The output of this method is similar to the output of the <tt class="rst-docutils literal">__str__</tt> method. If <em>verbosity</em> is zero, only the header line is returned (see <tt class="rst-docutils literal">__str__</tt> for more details), otherwise the header line and the edge list is printed.</p>
<p>Behind the scenes, this method constructs a <code><a href="igraph.summary.GraphSummary.html" class="internal-link" title="igraph.summary.GraphSummary">GraphSummary</a></code> object and invokes its <tt class="rst-docutils literal">__str__</tt> method.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">verbosity</span></td><td class="fieldArgDesc">if zero, only the header line is returned (see <tt class="rst-docutils literal">__str__</tt> for more details), otherwise the header line and the full edge list is printed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">width</span></td><td class="fieldArgDesc">the number of characters to use in one line. If <tt class="rst-docutils literal">None</tt>, no limit will be enforced on the line lengths.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the summary of the graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.to_dict_dict">
    
  </a>
  <a name="to_dict_dict">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">to_dict_dict</span>(graph, use_vids=True, edge_attrs=None, skip_none=False, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#to_dict_dict" title="igraph.Graph.to_dict_dict">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Export graph to dictionary of dicts of edge attributes</p>
<p>This function is the reverse of Graph.DictDict.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Full(3)
<span class="py-prompt">&gt;&gt;&gt; </span>g.es[<span class="py-string">'name'</span>] = [<span class="py-string">'first_edge'</span>, <span class="py-string">'second'</span>, <span class="py-string">'third'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_dict_dict()
<span class="py-output">{0: {1: {'name': 'first_edge'}, 2: {'name': 'second'}}, 1: {2: {'name': 'third'}}}</span>
</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">use<wbr></wbr>_vids:</span><code>bool</code></td><td class="fieldArgDesc">whether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If use_vids=False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_attrs:</span><code>Union[<wbr></wbr>str, <wbr></wbr>Sequence[<wbr></wbr>str]]</code></td><td class="fieldArgDesc">list of edge attributes to export. None (default) signified all attributes (unlike Graph.to_tuple_list). A string is acceptable to signify a single attribute and will be wrapped in a list internally.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">skip<wbr></wbr>_none:</span><code>bool</code></td><td class="fieldArgDesc">whether to skip, for each edge, attributes that have a value of None. This is useful if only some edges are expected to possess an attribute.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">dictionary of dictionaries of dictionaries, with the outer keys vertex ids/names, the middle keys ids/names of their neighbors, and the innermost dictionary representing attributes of that edge.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: vertex_name_attr</td></tr><tr><td colspan="2">only used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.to_dict_list">
    
  </a>
  <a name="to_dict_list">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">to_dict_list</span>(graph, use_vids=True, skip_none=False, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#to_dict_list" title="igraph.Graph.to_dict_list">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Export graph as two lists of dictionaries, for vertices and edges.</p>
<p>This function is the reverse of Graph.DictList.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph([(0, 1), (1, 2)])
<span class="py-prompt">&gt;&gt;&gt; </span>g.vs[<span class="py-string">"name"</span>] = [<span class="py-string">"apple"</span>, <span class="py-string">"pear"</span>, <span class="py-string">"peach"</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>g.es[<span class="py-string">"name"</span>] = [<span class="py-string">"first_edge"</span>, <span class="py-string">"second"</span>]</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_dict_list()
<span class="py-output">([{"name": "apple"}, {"name": "pear"}, {"name": "peach"}],</span>
<span class="py-output"> [{"source": 0, "target": 1, "name": "first_edge"},</span>
<span class="py-output">  {"source" 0, "target": 2, name": "second"}])</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_dict_list(use_vids=<span class="py-builtin">False</span>)
<span class="py-output">([{"name": "apple"}, {"name": "pear"}, {"name": "peach"}],</span>
<span class="py-output"> [{"source": "apple", "target": "pear", "name": "first_edge"},</span>
<span class="py-output">  {"source" "apple", "target": "peach", name": "second"}])</span>
</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">use<wbr></wbr>_vids:</span><code>bool</code></td><td class="fieldArgDesc">whether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If use_vids=False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">skip<wbr></wbr>_none:</span><code>bool</code></td><td class="fieldArgDesc">whether to skip, for each edge, attributes that have a value of None. This is useful if only some edges are expected to possess an attribute.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a tuple with two lists of dictionaries, representing the vertices and the edges, respectively, with their attributes.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: vertex_name_attr</td></tr><tr><td colspan="2">only used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.to_graph_tool">
    
  </a>
  <a name="to_graph_tool">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">to_graph_tool</span>(graph, graph_attributes=None, vertex_attributes=None, edge_attributes=None):
    
    <a class="headerLink" href="#to_graph_tool" title="igraph.Graph.to_graph_tool">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Converts the graph to graph-tool</p>
<p>Data types: graph-tool only accepts specific data types. See the following web page for a list:</p>
<p>https://graph-tool.skewed.de/static/doc/quickstart.html</p>
<p>Note: because of the restricted data types in graph-tool, vertex and edge attributes require to be type-consistent across all vertices or edges. If you set the property for only some vertices/edges, the other will be tagged as None in igraph, so they can only be converted to graph-tool with the type 'object' and any other conversion will fail.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph<wbr></wbr>_attributes</span></td><td class="fieldArgDesc">dictionary of graph attributes to transfer. Keys are attributes from the graph, values are data types (see below). <tt class="rst-docutils literal">None</tt> means no graph attributes are transferred.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_attributes</span></td><td class="fieldArgDesc">dictionary of vertex attributes to transfer. Keys are attributes from the vertices, values are data types (see below). <tt class="rst-docutils literal">None</tt> means no vertex attributes are transferred.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_attributes</span></td><td class="fieldArgDesc">dictionary of edge attributes to transfer. Keys are attributes from the edges, values are data types (see below). <tt class="rst-docutils literal">None</tt> means no vertex attributes are transferred.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.to_list_dict">
    
  </a>
  <a name="to_list_dict">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">to_list_dict</span>(graph, use_vids=True, sequence_constructor=list, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#to_list_dict" title="igraph.Graph.to_list_dict">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Export graph to a dictionary of lists (or other sequences).</p>
<p>This function is the reverse of Graph.ListDict.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Full(3)
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_sequence_dict() -&gt; {0: [1, 2], 1: [2]}
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_sequence_dict(sequence_constructor=<span class="py-builtin">tuple</span>) -&gt; {0: (1, 2), 1: (2,)}
<span class="py-prompt">&gt;&gt;&gt; </span>g.vs[<span class="py-string">'name'</span>] = [<span class="py-string">'apple'</span>, <span class="py-string">'pear'</span>, <span class="py-string">'peach'</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_sequence_dict(use_vids=<span class="py-builtin">False</span>)
<span class="py-output">{'apple': ['pear', 'peach'], 'pear': ['peach']}</span>
</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">use<wbr></wbr>_vids:</span><code>bool</code></td><td class="fieldArgDesc">whether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If use_vids=False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">sequence<wbr></wbr>_constructor:</span><code>callable</code></td><td class="fieldArgDesc">constructor for the data structure to be used as values of the dictionary. The default (list) makes a dict of lists, with each list representing the neighbors of the vertex specified in the respective dictionary key.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">dictionary of sequences, keyed by vertices, with each value containing the neighbors of that vertex.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: vertex_name_attr</td></tr><tr><td colspan="2">only used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.to_networkx">
    
  </a>
  <a name="to_networkx">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">to_networkx</span>(graph, create_using=None, vertex_attr_hashable=<span class="rst-variable-quote">'</span><span class="rst-variable-string">_nx_name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#to_networkx" title="igraph.Graph.to_networkx">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Converts the graph to networkx format.</p>
<p>igraph has ordered vertices and edges, but networkx does not. To keep track of the original order, the '_igraph_index' vertex property is added to both vertices and edges.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">create<wbr></wbr>_using</span></td><td class="fieldArgDesc">specifies which NetworkX graph class to use when constructing the graph. <tt class="rst-docutils literal">None</tt> means to let igraph infer the most appropriate class based on whether the graph is directed and whether it has multi-edges.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_attr<wbr></wbr>_hashable:</span><code>str</code></td><td class="fieldArgDesc">vertex attribute used to name vertices in the exported network. The default "_nx_name" ensures round trip conversions to/from networkx are lossless.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.to_tuple_list">
    
  </a>
  <a name="to_tuple_list">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">to_tuple_list</span>(graph, use_vids=True, edge_attrs=None, vertex_name_attr=<span class="rst-variable-quote">'</span><span class="rst-variable-string">name</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#to_tuple_list" title="igraph.Graph.to_tuple_list">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Export graph to a list of edge tuples</p>
<p>This function is the reverse of Graph.TupleList.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Full(3)
<span class="py-prompt">&gt;&gt;&gt; </span>g.vs[<span class="py-string">"name"</span>] = [<span class="py-string">"apple"</span>, <span class="py-string">"pear"</span>, <span class="py-string">"peach"</span>]
<span class="py-prompt">&gt;&gt;&gt; </span>g.es[<span class="py-string">"name"</span>] = [<span class="py-string">"first_edge"</span>, <span class="py-string">"second"</span>, <span class="py-string">"third"</span>]</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># Get name of the edge</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_tuple_list(edge_attrs=[<span class="py-string">"name"</span>])
<span class="py-output">[(0, 1, "first_edge"), (0, 2, "second"), (1, 2, "third")]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># Use vertex names, no edge attributes</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g.to_tuple_list(use_vids=<span class="py-builtin">False</span>)
<span class="py-output">[("apple", "pear"), ("apple", "peach"), ("pear", "peach")]</span>
</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">use<wbr></wbr>_vids:</span><code>bool</code></td><td class="fieldArgDesc">whether to label vertices in the output data structure by their ids or their vertex_name_attr attribute. If use_vids=False but vertices lack a vertex_name_attr attribute, an AttributeError is raised.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_attrs:</span><code>Union[<wbr></wbr>str, <wbr></wbr>Sequence[<wbr></wbr>str]]</code></td><td class="fieldArgDesc">list of edge attributes to export in addition to source and target vertex, which are always the first two elements of each tuple. None (default) is equivalent to an empty list. A string is acceptable to signify a single attribute and will be wrapped in a list internally.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_name<wbr></wbr>_attr:</span><code>str</code></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of tuples, each representing an edge of the graph.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: vertex_name_attr</td></tr><tr><td colspan="2">only used with use_vids=False to choose what vertex attribute to use to name your vertices in the output data structure.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.transitivity_avglocal_undirected">
    
  </a>
  <a name="transitivity_avglocal_undirected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">transitivity_avglocal_undirected</span>(self, mode=<span class="rst-variable-quote">'</span><span class="rst-variable-string">nan</span><span class="rst-variable-quote">'</span>, weights=None):
    
    <a class="headerLink" href="#transitivity_avglocal_undirected" title="igraph.Graph.transitivity_avglocal_undirected">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#transitivity_avglocal_undirected" class="internal-link">igraph.GraphBase.transitivity_avglocal_undirected</a></code></div>
    <div><p>Calculates the average of the vertex transitivities of the graph.</p>
<p>In the unweighted case, the transitivity measures the probability that two neighbors of a vertex are connected. In case of the average local transitivity, this probability is calculated for each vertex and then the average is taken. Vertices with less than two neighbors require special treatment, they will either be left out from the calculation or they will be considered as having zero transitivity, depending on the <em>mode</em> parameter. The calculation is slightly more involved for weighted graphs; in this case, weights are taken into account according to the formula of Barrat et al (see the references).</p>
<p>Note that this measure is different from the global transitivity measure (see <code><a href="igraph.GraphBase.html#transitivity_undirected" class="internal-link" title="igraph.GraphBase.transitivity_undirected">transitivity_undirected()</a></code>) as it simply takes the average local transitivity across the whole network.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">defines how to treat vertices with degree less than two. If <tt class="rst-docutils literal">TRANSITIVITY_ZERO</tt> or <tt class="rst-docutils literal">"zero"</tt>, these vertices will have zero transitivity. If <tt class="rst-docutils literal">TRANSITIVITY_NAN</tt> or <tt class="rst-docutils literal">"nan"</tt>, these vertices will be excluded from the average.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="igraph.GraphBase.html#transitivity_undirected" class="internal-link" title="igraph.GraphBase.transitivity_undirected">transitivity_undirected()</a></code>, <code><a href="igraph.GraphBase.html#transitivity_local_undirected" class="internal-link" title="igraph.GraphBase.transitivity_local_undirected">transitivity_local_undirected()</a></code></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Watts DJ and Strogatz S: <em>Collective dynamics of small-world networks</em>. Nature 393(6884):440-442, 1998.</td></tr><tr><td colspan="2">Barrat A, Barthelemy M, Pastor-Satorras R and Vespignani A: <em>The architecture of complex weighted networks</em>. PNAS 101, 3747 (2004). <a class="rst-reference external" href="http://arxiv.org/abs/cond-mat/0311416" target="_top">http://arxiv.org/abs/cond-mat/0311416</a>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.triad_census">
    
  </a>
  <a name="triad_census">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">triad_census</span>(self, *args, **kwds):
    
    <a class="headerLink" href="#triad_census" title="igraph.Graph.triad_census">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#triad_census" class="internal-link">igraph.GraphBase.triad_census</a></code></div>
    <div><p>Calculates the triad census of the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.TriadCensus.html" class="internal-link" title="igraph.TriadCensus">TriadCensus</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Davis, J.A. and Leinhardt, S.  (1972).  The Structure of Positive Interpersonal Relations in Small Groups.  In: J. Berger (Ed.), Sociological Theories in Progress, Volume 2, 218-251. Boston: Houghton Mifflin.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.union">
    
  </a>
  <a name="union">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">union</span>(graph, other, byname=<span class="rst-variable-quote">'</span><span class="rst-variable-string">auto</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#union" title="igraph.Graph.union">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Creates the union of two (or more) graphs.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">graph or list of graphs to be united with the current one.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">byname</span></td><td class="fieldArgDesc">whether to use vertex names instead of ids. See <code><a href="igraph.operators.functions.html#union" class="internal-link" title="igraph.operators.functions.union">igraph.operators.union</a></code> for details.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the union graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.write">
    
  </a>
  <a name="write">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write</span>(graph, f, format=None, *args, **kwds):
    
    <a class="headerLink" href="#write" title="igraph.Graph.write">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Unified writing function for graphs.</p>
<p>This method tries to identify the format of the graph given in the first parameter (based on extension) and calls the corresponding writer method.</p>
<p>The remaining arguments are passed to the writer method without any changes.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the file containing the graph to be saved</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">format</span></td><td class="fieldArgDesc"><p>the format of the file (if one wants to override the format determined from the filename extension, or the filename itself is a stream). <tt class="rst-docutils literal">None</tt> means auto-detection. Possible values are:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"adjacency"</tt>: adjacency matrix format</li>
<li><tt class="rst-docutils literal">"dimacs"</tt>: DIMACS format</li>
<li><tt class="rst-docutils literal">"dot"</tt>, <tt class="rst-docutils literal">"graphviz"</tt>: GraphViz DOT format</li>
<li><tt class="rst-docutils literal">"edgelist"</tt>, <tt class="rst-docutils literal">"edges"</tt> or <tt class="rst-docutils literal">"edge"</tt>: numeric edge list format</li>
<li><tt class="rst-docutils literal">"gml"</tt>: GML format</li>
<li><tt class="rst-docutils literal">"graphml"</tt> and <tt class="rst-docutils literal">"graphmlz"</tt>: standard and gzipped GraphML format</li>
<li><tt class="rst-docutils literal">"gw"</tt>, <tt class="rst-docutils literal">"leda"</tt>, <tt class="rst-docutils literal">"lgr"</tt>: LEDA native format</li>
<li><tt class="rst-docutils literal">"lgl"</tt>: LGL format</li>
<li><tt class="rst-docutils literal">"ncol"</tt>: NCOL format</li>
<li><tt class="rst-docutils literal">"net"</tt>, <tt class="rst-docutils literal">"pajek"</tt>: Pajek format</li>
<li><tt class="rst-docutils literal">"pickle"</tt>, <tt class="rst-docutils literal">"picklez"</tt>: standard and gzipped Python pickled format</li>
<li><tt class="rst-docutils literal">"svg"</tt>: SVG format</li>
</ul>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code>IOError</code></td><td>if the file format can't be identified and none was given.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.write_adjacency">
    
  </a>
  <a name="write_adjacency">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_adjacency</span>(graph, f, sep=<span class="rst-variable-quote">'</span><span class="rst-variable-string"> </span><span class="rst-variable-quote">'</span>, eol=<span class="rst-variable-quote">'</span><span class="rst-variable-string">\n</span><span class="rst-variable-quote">'</span>, *args, **kwds):
    
    <a class="headerLink" href="#write_adjacency" title="igraph.Graph.write_adjacency">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Writes the adjacency matrix of the graph to the given file</p>
<p>All the remaining arguments not mentioned here are passed intact to <code><a href="#get_adjacency" class="internal-link" title="igraph.Graph.get_adjacency">Graph.get_adjacency</a></code>.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file to be written.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">sep</span></td><td class="fieldArgDesc">the string that separates the matrix elements in a row</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">eol</span></td><td class="fieldArgDesc">the string that separates the rows of the matrix. Please note that igraph is able to read back the written adjacency matrix if and only if this is a single newline character</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.write_dimacs">
    
  </a>
  <a name="write_dimacs">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_dimacs</span>(graph, f, source=None, target=None, capacity=<span class="rst-variable-quote">'</span><span class="rst-variable-string">capacity</span><span class="rst-variable-quote">'</span>):
    
    <a class="headerLink" href="#write_dimacs" title="igraph.Graph.write_dimacs">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="igraph.GraphBase.html#write_dimacs" class="internal-link">igraph.GraphBase.write_dimacs</a></code></div>
    <div><p>Writes the graph in DIMACS format to the given file.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file to be written or a Python file handle.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex ID. If <tt class="rst-docutils literal">None</tt>, igraph will try to infer it from the <tt class="rst-docutils literal">source</tt> graph attribute.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex ID. If <tt class="rst-docutils literal">None</tt>, igraph will try to infer it from the <tt class="rst-docutils literal">target</tt> graph attribute.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">capacity</span></td><td class="fieldArgDesc">the capacities of the edges in a list or the name of an edge attribute that holds the capacities. If there is no such edge attribute, every edge will have a capacity of 1.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.write_graphmlz">
    
  </a>
  <a name="write_graphmlz">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_graphmlz</span>(graph, f, compresslevel=9):
    
    <a class="headerLink" href="#write_graphmlz" title="igraph.Graph.write_graphmlz">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Writes the graph to a zipped GraphML file.</p>
<p>The library uses the gzip compression algorithm, so the resulting file can be unzipped with regular gzip uncompression (like <tt class="rst-docutils literal">gunzip</tt> or <tt class="rst-docutils literal">zcat</tt> from Unix command line) or the Python <tt class="rst-docutils literal">gzip</tt> module.</p>
<p>Uses a temporary file to store intermediate GraphML data, so make sure you have enough free space to store the unzipped GraphML file as well.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file to be written.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">compresslevel</span></td><td class="fieldArgDesc">the level of compression. 1 is fastest and produces the least compression, and 9 is slowest and produces the most compression.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.write_pickle">
    
  </a>
  <a name="write_pickle">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_pickle</span>(graph, fname=None, version=-1):
    
    <a class="headerLink" href="#write_pickle" title="igraph.Graph.write_pickle">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Saves the graph in Python pickled format</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fname</span></td><td class="fieldArgDesc">the name of the file or a stream to save to. If <tt class="rst-docutils literal">None</tt>, saves the graph to a string and returns the string.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">version</span></td><td class="fieldArgDesc">pickle protocol version to be used. If -1, uses the highest protocol available</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><tt class="rst-docutils literal">None</tt> if the graph was saved successfully to the given file, or a string if <tt class="rst-docutils literal">fname</tt> was <tt class="rst-docutils literal">None</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.write_picklez">
    
  </a>
  <a name="write_picklez">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_picklez</span>(graph, fname=None, version=-1):
    
    <a class="headerLink" href="#write_picklez" title="igraph.Graph.write_picklez">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Saves the graph in Python pickled format, compressed with gzip.</p>
<p>Saving in this format is a bit slower than saving in a Python pickle without compression, but the final file takes up much less space on the hard drive.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fname</span></td><td class="fieldArgDesc">the name of the file or a stream to save to.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">version</span></td><td class="fieldArgDesc">pickle protocol version to be used. If -1, uses the highest protocol available</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><tt class="rst-docutils literal">None</tt> if the graph was saved successfully to the given file.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph.Graph.write_svg">
    
  </a>
  <a name="write_svg">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_svg</span>(graph, fname, layout=<span class="rst-variable-quote">'</span><span class="rst-variable-string">auto</span><span class="rst-variable-quote">'</span>, width=None, height=None, labels=<span class="rst-variable-quote">'</span><span class="rst-variable-string">label</span><span class="rst-variable-quote">'</span>, colors=<span class="rst-variable-quote">'</span><span class="rst-variable-string">color</span><span class="rst-variable-quote">'</span>, shapes=<span class="rst-variable-quote">'</span><span class="rst-variable-string">shape</span><span class="rst-variable-quote">'</span>, vertex_size=10, edge_colors=<span class="rst-variable-quote">'</span><span class="rst-variable-string">color</span><span class="rst-variable-quote">'</span>, edge_stroke_widths=<span class="rst-variable-quote">'</span><span class="rst-variable-string">width</span><span class="rst-variable-quote">'</span>, font_size=16, *args, **kwds):
    
    <a class="headerLink" href="#write_svg" title="igraph.Graph.write_svg">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Saves the graph as an SVG (Scalable Vector Graphics) file</p>
<p>The file will be Inkscape (http://inkscape.org) compatible. In Inkscape, as nodes are rearranged, the edges auto-update.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fname</span></td><td class="fieldArgDesc">the name of the file or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">layout</span></td><td class="fieldArgDesc">the layout of the graph. Can be either an explicitly specified layout (using a list of coordinate pairs) or the name of a layout algorithm (which should refer to a method in the <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> object, but without the <tt class="rst-docutils literal">layout_</tt> prefix.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">width</span></td><td class="fieldArgDesc">the preferred width in pixels (default: 400)</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">height</span></td><td class="fieldArgDesc">the preferred height in pixels (default: 400)</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">labels</span></td><td class="fieldArgDesc">the vertex labels. Either it is the name of a vertex attribute to use, or a list explicitly specifying the labels. It can also be <tt class="rst-docutils literal">None</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">colors</span></td><td class="fieldArgDesc">the vertex colors. Either it is the name of a vertex attribute to use, or a list explicitly specifying the colors. A color can be anything acceptable in an SVG file.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">shapes</span></td><td class="fieldArgDesc">the vertex shapes. Either it is the name of a vertex attribute to use, or a list explicitly specifying the shapes as integers. Shape 0 means hidden (nothing is drawn), shape 1 is a circle, shape 2 is a rectangle and shape 3 is a rectangle that automatically sizes to the inner text.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_size</span></td><td class="fieldArgDesc">vertex size in pixels</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_colors</span></td><td class="fieldArgDesc">the edge colors. Either it is the name of an edge attribute to use, or a list explicitly specifying the colors. A color can be anything acceptable in an SVG file.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_stroke<wbr></wbr>_widths</span></td><td class="fieldArgDesc">the stroke widths of the edges. Either it is the name of an edge attribute to use, or a list explicitly specifying the stroke widths. The stroke width can be anything acceptable in an SVG file.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">font<wbr></wbr>_size</span></td><td class="fieldArgDesc">font size. If it is a string, it is written into the SVG file as-is (so you can specify anything which is valid as the value of the <tt class="rst-docutils literal"><span class="pre">font-size</span></tt> style). If it is a number, it is interpreted as pixel size and converted to the proper attribute value accordingly.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div><div class="baseclassvariable">
  
  
  <a name="igraph.Graph.__hash__">
    
  </a>
  <a name="__hash__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">__hash__</span> =
    
    <a class="headerLink" href="#__hash__" title="igraph.Graph.__hash__">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseclassvariable">
  
  
  <a name="igraph.Graph.__iter__">
    
  </a>
  <a name="__iter__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">__iter__</span> =
    
    <a class="headerLink" href="#__iter__" title="igraph.Graph.__iter__">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseclassvariable">
  
  
  <a name="igraph.Graph.Formula">
    
  </a>
  <a name="Formula">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">Formula</span> =
    
    <a class="headerLink" href="#Formula" title="igraph.Graph.Formula">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="baseproperty">
  
  
  <a name="igraph.Graph.es">
    
  </a>
  <a name="es">
    
  </a>
  <div class="functionHeader">
    @property<br />
    <span class="py-defname">es</span> =
    
    <a class="headerLink" href="#es" title="igraph.Graph.es">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p>The edge sequence of the graph</p>
</div>
    
  </div>
</div><div class="baseproperty">
  
  
  <a name="igraph.Graph.vs">
    
  </a>
  <a name="vs">
    
  </a>
  <div class="functionHeader">
    @property<br />
    <span class="py-defname">vs</span> =
    
    <a class="headerLink" href="#vs" title="igraph.Graph.vs">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p>The vertex sequence of the graph</p>
</div>
    
  </div>
</div><div class="baseclassmethod private">
  
  
  <a name="igraph.Graph._reconstruct">
    
  </a>
  <a name="_reconstruct">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    <span class="py-keyword">def</span> <span class="py-defname">_reconstruct</span>(cls, attrs, *args, **kwds):
    
    <a class="headerLink" href="#_reconstruct" title="igraph.Graph._reconstruct">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reconstructs a Graph object from Python's pickled format.</p>
<p>This method is for internal use only, it should not be called directly.</p>
</div>
  </div>
</div><div class="baseproperty private">
  
  
  <a name="igraph.Graph._as_parameter_">
    
  </a>
  <a name="_as_parameter_">
    
  </a>
  <div class="functionHeader">
    @property<br />
    <span class="py-defname">_as_parameter_</span> =
    
    <a class="headerLink" href="#_as_parameter_" title="igraph.Graph._as_parameter_">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div>
        </div>
      
      </div>
    </div>

    


  </div>
  </div>
</div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	  &copy; 2003 &ndash; 2023 The igraph core team.
            &bull; Code licensed under 
            <a href="http://www.gnu.org/licenses/gpl-2.0.html">
            GNU GPL 2</a> or later, documentation under 
            <a href="http://www.gnu.org/copyleft/fdl.html">
              GNU FDL.</a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'python', 'api/');
    </script>





    
  </body>
</html>
