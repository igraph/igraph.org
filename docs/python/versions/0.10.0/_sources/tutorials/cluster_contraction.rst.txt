
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/cluster_contraction.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_cluster_contraction.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_cluster_contraction.py:


.. _tutorials-cluster-graph:

===========================
Generating Cluster Graphs
===========================

This example shows how to find the communities in a graph, then contract each community into a single node using :class:`igraph.clustering.VertexClustering`. For this tutorial, we'll use the *Donald Knuth's Les Miserables Network*, which shows the coapperances of characters in the novel *Les Miserables*.

.. GENERATED FROM PYTHON SOURCE LINES 10-13

.. code-block:: default

    import igraph as ig
    import matplotlib.pyplot as plt








.. GENERATED FROM PYTHON SOURCE LINES 14-16

We begin by load the graph from file. The file containing this network can be
downloaded `here <http://www-personal.umich.edu/~mejn/netdata/>`_.

.. GENERATED FROM PYTHON SOURCE LINES 16-18

.. code-block:: default

    g = ig.load("./lesmis/lesmis.gml")








.. GENERATED FROM PYTHON SOURCE LINES 19-23

Now that we have a graph in memory, we can generate communities using
:meth:`igraph.Graph.community_edge_betweenness` to separate out vertices into
clusters. (For a more focused tutorial on just visualising communities, check
out :ref:`tutorials-visualize-communities`).

.. GENERATED FROM PYTHON SOURCE LINES 23-25

.. code-block:: default

    communities = g.community_edge_betweenness()



.. rst-class:: sphx-glr-script-out

.. code-block:: pytb

    Traceback (most recent call last):
      File "/Users/tamas/dev/igraph/igraph.org/_build/python/doc/examples_sphinx-gallery/cluster_contraction.py", line 23, in <module>
        communities = g.community_edge_betweenness()
      File "/Users/tamas/dev/igraph/igraph.org/_build/python/.venv/lib/python3.9/site-packages/igraph/__init__.py", line 3877, in community_edge_betweenness
        clusters = _optimal_cluster_count_from_merges_and_modularity(graph, merges, qs)
    NameError: name '_optimal_cluster_count_from_merges_and_modularity' is not defined




.. GENERATED FROM PYTHON SOURCE LINES 26-27

For plots, it is convenient to convert the communities into a VertexClustering:

.. GENERATED FROM PYTHON SOURCE LINES 27-29

.. code-block:: default

    communities = communities.as_clustering()


.. GENERATED FROM PYTHON SOURCE LINES 30-31

We can also easily print out who belongs to each community:

.. GENERATED FROM PYTHON SOURCE LINES 31-36

.. code-block:: default

    for i, community in enumerate(communities):
        print(f"Community {i}:")
        for v in community:
            print(f"\t{g.vs[v]['label']}")


.. GENERATED FROM PYTHON SOURCE LINES 37-39

Finally we can proceed to plotting the graph. In order to make each community
stand out, we set "community colors" using an igraph palette:

.. GENERATED FROM PYTHON SOURCE LINES 39-46

.. code-block:: default

    num_communities = len(communities)
    palette1 = ig.RainbowPalette(n=num_communities)
    for i, community in enumerate(communities):
        g.vs[community]["color"] = i
        community_edges = g.es.select(_within=community)
        community_edges["color"] = i


.. GENERATED FROM PYTHON SOURCE LINES 47-48

We can use a dirty hack to move the labels below the vertices ;-)

.. GENERATED FROM PYTHON SOURCE LINES 48-50

.. code-block:: default

    g.vs["label"] = ["\n\n" + label for label in g.vs["label"]]


.. GENERATED FROM PYTHON SOURCE LINES 51-52

Finally, we can plot the communities:

.. GENERATED FROM PYTHON SOURCE LINES 52-64

.. code-block:: default

    fig1, ax1 = plt.subplots()
    ig.plot(
        communities,
        target=ax1,
        mark_groups=True,
        palette=palette1,
        vertex_size=0.1,
        edge_width=0.5,
    )
    fig1.set_size_inches(20, 20)



.. GENERATED FROM PYTHON SOURCE LINES 65-68

Now let's try and contract the information down, using only a single vertex
to represent each community. We start by defining x, y, and size attributes
for each node in the original graph:

.. GENERATED FROM PYTHON SOURCE LINES 68-73

.. code-block:: default

    layout = g.layout_kamada_kawai()
    g.vs["x"], g.vs["y"] = list(zip(*layout))
    g.vs["size"] = 1
    g.es["size"] = 1


.. GENERATED FROM PYTHON SOURCE LINES 74-77

Then we can generate the cluster graph that compresses each community into a
single, "composite" vertex using
:meth:`igraph.VertexClustering.cluster_graph`:

.. GENERATED FROM PYTHON SOURCE LINES 77-89

.. code-block:: default

    cluster_graph = communities.cluster_graph(
        combine_vertices={
            "x": "mean",
            "y": "mean",
            "color": "first",
            "size": "sum",
        },
        combine_edges={
            "size": "sum",
        },
    )


.. GENERATED FROM PYTHON SOURCE LINES 90-103

.. note::

     We took the mean of x and y values so that the nodes in the cluster
     graph are placed at the centroid of the original cluster.

.. note::

    ``mean``, ``first``, and ``sum`` are all built-in collapsing functions,
    along with ``prod``, ``median``, ``max``, ``min``, ``last``, ``random``.
    You can also define your own custom collapsing functions, which take in a
    list and return a single element representing the combined attribute
    value. For more details on igraph contraction, see
    :meth:`igraph.GraphBase.contract_vertices`.

.. GENERATED FROM PYTHON SOURCE LINES 106-108

Finally, we can assign colors to the clusters and plot the cluster graph,
including a legend to make things clear:

.. GENERATED FROM PYTHON SOURCE LINES 108-142

.. code-block:: default

    palette2 = ig.GradientPalette("gainsboro", "black")
    g.es["color"] = [palette2.get(int(i)) for i in ig.rescale(cluster_graph.es["size"], (0, 255), clamp=True)]

    fig2, ax2 = plt.subplots()
    ig.plot(
        cluster_graph,
        target=ax2,
        palette=palette1,
        # set a minimum size on vertex_size, otherwise vertices are too small
        vertex_size=[max(0.2, size / 20) for size in cluster_graph.vs["size"]],
        edge_color=g.es["color"],
        edge_width=0.8,
    )

    # Add a legend
    legend_handles = []
    for i in range(num_communities):
        handle = ax2.scatter(
            [], [],
            s=100,
            facecolor=palette1.get(i),
            edgecolor="k",
            label=i,
        )
        legend_handles.append(handle)

    ax2.legend(
        handles=legend_handles,
        title='Community:',
        bbox_to_anchor=(0, 1.0),
        bbox_transform=ax2.transAxes,
    )

    fig2.set_size_inches(10, 10)


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.011 seconds)


.. _sphx_glr_download_tutorials_cluster_contraction.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: cluster_contraction.py <cluster_contraction.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: cluster_contraction.ipynb <cluster_contraction.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
