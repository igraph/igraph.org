









  
  
  
  
  



<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="/img/igraph4.png" type="image/x-icon" />

    <title>Tutorial</title>

    <!-- Bootstrap core CSS -->
    <link href="/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href='http://fonts.googleapis.com/css?family=Lato:300,400,700'
          rel='stylesheet' type='text/css'>
    <link href="http://netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <link rel="top" title="python-igraph 0.7 documentation" href="index.html" /> <link rel="next" title="Graph generation" href="generation.html" /> <link rel="prev" title="Installing igraph" href="install.html" /> <link rel="stylesheet" href="_static/basic.css" type="text/css" /> <link rel="stylesheet" href="_static/pygments.css" type="text/css" /> <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />

  </head>

  <body class="python">
  <div id="wrap">

    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle"
                  data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">
            <img src="/img/igraph4.svg" width=35> igraph
          </a>
        </div>
        <div class="navbar-collapse collapse">
	  
	  <ul class="nav navbar-nav">
	    <li><a href="/python">| python-igraph</a></li>
	  </ul>
	  
          <ul class="nav navbar-nav navbar-right">
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown"
		 role="button" aria-expanded="false">Products
		<span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
		<li>
		  <a href="/r"><i class="icon-fixed-width icon-rlogo"></i>
		    igraph R package</a></li>
		<li>
		  <a href="/python"><i class="icon-fixed-width icon-python"></i>
		    python-igraph</a></li>
		<li>
		  <a href="/c"><i class="icon-fixed-width icon-c"></i>
		    igraph C library</a></li>
		<li class="divider"></li>
		<li>
		  <a href="https://github.com/igraph/igraphdata">
		    <i class="icon-fixed-width icon-rlogo"></i>
		    igraphdata R package <i class="fa fa-github"></i></a></li>
		<li>
		  <a href="http://nexus.igraph.org">
		    <i class="fa fa-times"></i>Nexus network repository</a></li>
              </ul>
            </li>
            <li>
              <a href="/news.html"><i class="icon-rss"></i>
		News</a></li>
	    <li><a href="https://github.com/igraph">
	      <i class="icon-github"></i> On github</a></li>
          </ul>
          <!-- <form class="navbar-form navbar-right"> -->
          <!--   <div class="form-group"> -->
          <!--     <input type="text" placeholder="Search docs" -->
	  <!-- 	     class="form-control" size="15"> -->
          <!--   </div> -->
          <!--   <button type="submit" class="btn btn-success"> -->
          <!--     <span class="glyphicon glyphicon-search"></span></button> -->
          <!-- </form> -->
        </div><!--/.navbar-collapse -->
      </div>
    </div>
    
    
    
    <div class="bs-header-outer"><div class="bs-header">
      <div class="container">
        <h1>python-igraph Manual</h1>
        <p class="lead">For using igraph from Python</p>        
      </div>
    </div></div>

    

    <div class="container bs-docs-container">
  <div class="row">
    <div class="col-md-9 col-md-offset-1">
        
<div class="navigation-header" width="100%" summary="Navigation header">
    <div class="btn-group">
        
        
             
                 
    <a accesskey="p" class="btn btn-default" href="install.html"
     title="Previous Chapter: Installing igraph">
        <i class="icon-chevron-left"></i>
        Installing igraph
    </a>
    <a accesskey="h" class="btn btn-default" href="index.html">
        <i class="icon-home"></i>
    </a>
    <a accesskey="n" class="btn btn-default" href="generation.html"
     title="Next Chapter: Graph generation">
        <i class="icon-chevron-right"></i>
        Graph generation
    </a>

             
        
        
        
        
            
        
    </div>
</div>


    </div>
  </div>
  <div class="row">
    <div class="col-md-9 col-md-offset-1">
      <div class="bs-docs-section">
        
  <div class="section" id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<p>This chapter contains a short overview of <em>igraph</em>&#8216;s capabilities. It is highly recommended
to read it at least once if you are new to <em>igraph</em>. I assume that you have already installed
<em>igraph</em>; if you did not, see <a class="reference internal" href="install.html#installing-igraph"><em>Installing igraph</em></a> first. Familiarity with the Python
language is also assumed; if this is the first time you are trying to use Python, there are
many good Python tutorials on the Internet to get you started. Mark Pilgrim&#8217;s
<a class="reference external" href="http://www.diveintopython.net">Dive Into Python</a> is one that I personally suggest.
If this is the first time you ever try to use a programming language,
<a class="reference external" href="http://swaroopch.com/notes/Python">A Byte of Python</a> is even better. If
you already have a stable programming background in other languages and you just want a
quick overview of Python, <a class="reference external" href="http://www.poromenos.org/tutorials/python">Learn Python in 10 minutes</a> is probably your best bet.</p>
<div class="section" id="starting-igraph">
<h2>Starting <em>igraph</em><a class="headerlink" href="#starting-igraph" title="Permalink to this headline">¶</a></h2>
<p><em>igraph</em> is a Python module, hence it can be imported exactly the same way as any other
ordinary Python module at the Python prompt:</p>
<div class="highlight-python"><pre>$ python
Python 2.7.1 (r271:86832, Jun 16 2011, 16:59:05)
[GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2335.15.00)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import igraph</pre>
</div>
<p>This imports <em>igraph</em>&#8216;s objects and methods inside an own namespace called <tt class="xref py py-mod docutils literal"><span class="pre">igraph</span></tt>. Whenever
you would like to call any of <em>igraph</em>&#8216;s methods, you will have to provide the appropriate
namespace-qualification. E.g., to check which <em>igraph</em> version you are using, you could do the
following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">igraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">igraph</span><span class="o">.</span><span class="n">__version__</span>
<span class="go">0.6</span>
</pre></div>
</div>
<p>Another way to make use of <em>igraph</em> is to import all its objects and methods into the main
Python namespace (so you do not have to type the namespace-qualification every time).
This is fine as long as none of your own objects and methods do not conflict with the ones
provided by <em>igraph</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">igraph</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>The third way to start <em>igraph</em> is to simply call the startup script that was supplied with
the <em>igraph</em> package you installed. Not too surprisingly, the script is called <strong class="command">igraph</strong>,
and provided that the script is on your path in the command line of your operating system
(which is almost surely the case on Linux and OS X), you can simply type <strong class="command">igraph</strong> at the
command line. Windows users will find the script inside the <tt class="file docutils literal"><span class="pre">scripts</span></tt> subdirectory of Python
and you may have to add it manually to your path in order to be able to use the script from
the command line without typing the whole path.</p>
<p>When you start the script, you will see something like this:</p>
<div class="highlight-python"><pre>$ igraph
No configuration file, using defaults
igraph 0.6 running inside Python 2.7.1 (r271:86832, Jun 16 2011, 16:59:05)
Type "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;</pre>
</div>
<p>The command-line startup script imports all of <em>igraph</em>&#8216;s methods and objects into the main
namespace, so it is practically equivalent to <tt class="docutils literal"><span class="pre">from</span> <span class="pre">igraph</span> <span class="pre">import</span> <span class="pre">*</span></tt>. The difference between
the two approaches (apart from saving some typing) is that the command-line script checks
whether you have any of Python&#8217;s more advanced shells installed and uses that instead of the
standard Python shell. Currently the module looks for <a class="reference external" href="http://ipython.scipy.org">IPython</a> and
IDLE (the Tcl/Tk-based graphical shell supplied with Python). If neither IPython nor IDLE is
installed, the startup script launches the default Python shell. You can also modify the
order in which these shells are searched by tweaking <em>igraph</em>&#8216;s configuration file
(see <em class="xref std std-ref">configuring-igraph</em>).</p>
<p>In general, it is advised to use the command line startup script when using <em>igraph</em>
interactively (i.e., when you just want to quickly load or generate some graphs, calculate
some basic properties and save the results somewhere). For non-disposable graph analysis
routines that you intend to re-run from time to time, you should write a script separately
in a <tt class="docutils literal"><span class="pre">.py</span></tt> source file and import <em>igraph</em> using one of the above methods at the start of
the script, then launch the script using the Python interpreter.</p>
<p>From now on, every example in the documentation will assume that <em>igraph</em>&#8216;s objects and
methods are imported into the main namespace (i.e., we used <tt class="docutils literal"><span class="pre">from</span> <span class="pre">igraph</span> <span class="pre">import</span> <span class="pre">*</span></tt>
instead of <tt class="docutils literal"><span class="pre">import</span> <span class="pre">igraph</span></tt>). If you let <em>igraph</em> take its own namespace, please adjust
all the examples accordingly.</p>
</div>
<div class="section" id="creating-a-graph-from-scratch">
<h2>Creating a graph from scratch<a class="headerlink" href="#creating-a-graph-from-scratch" title="Permalink to this headline">¶</a></h2>
<p>Assuming that you have started <em>igraph</em> successfully, it is time to create your first
<em>igraph</em> graph. This is pretty simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
</pre></div>
</div>
<p>The above statement created an undirected graph with no vertices or edges and assigned it
to the variable <cite>g</cite>. To confirm that it&#8217;s really an <em>igraph</em> graph, we can
print it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span>
<span class="go">&lt;igraph.Graph object at 0x4c87a0&gt;</span>
</pre></div>
</div>
<p>This tells us that <cite>g</cite> is an instance of <em>igraph</em>&#8216;s <tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt> class and
that it is currently living at the memory address <tt class="docutils literal"><span class="pre">0x4c87a0</span></tt> (the exact
output will almost surely be different for your platform). To obtain a more
user-friendly output, we can try to print the graph using Python&#8217;s
<tt class="docutils literal"><span class="pre">print</span></tt> statement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">IGRAPH U--- 0 0 --</span>
</pre></div>
</div>
<p>TODO: explain it</p>
<p>This is not too exciting so far; a graph with a single vertex and no edges is not really useful
for us. Let&#8217;s add some vertices first!</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="xref py py-meth docutils literal"><span class="pre">Graph.add_vertices()</span></tt> (i.e., the <tt class="xref py py-meth docutils literal"><span class="pre">add_vertices()</span></tt> method of the <tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt>
class) adds the given number of vertices to the graph.</p>
<p>Now our graph has three vertices but no edges, so let&#8217;s add some edges as well! You can
add edges by calling <tt class="xref py py-meth docutils literal"><span class="pre">Graph.add_edges()</span></tt> - but in order to add edges, you have to refer to
existing vertices somehow. <em>igraph</em> uses integer vertex IDs starting from zero, thus the
first vertex of your graph has index zero, the second vertex has index 1 and so on.
Edges are specified by pairs of integers, so <tt class="docutils literal"><span class="pre">[(0,1),</span> <span class="pre">(1,2)]</span></tt> denotes a list of two
edges: one between the first and the second, and the other one between the second and the
third vertices of the graph. Passing this list to <tt class="xref py py-meth docutils literal"><span class="pre">Graph.add_edges()</span></tt> adds these two edges
to your graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
</pre></div>
</div>
<p><tt class="xref py py-meth docutils literal"><span class="pre">add_edges()</span></tt> is clever enough to figure out what you want to do in most of the
cases: if you supply a single pair of integers, it will automatically assume that you want
to add a single edge. However, if you try to add edges to vertices with invalid IDs (i.e.,
you try to add an edge to vertex 5 when you only have three edges), you will get an
exception:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">6</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">igraph.core.InternalError</span>: <span class="n">Error at ../../src/type_indexededgelist.c:245: cannot add edges, invalid vertex id</span>
</pre></div>
</div>
<p>Most <em>igraph</em> functions will raise an <tt class="xref py py-exc docutils literal"><span class="pre">igraph.core.InternalError</span></tt> if
something goes wrong. The message corresponding to the exception gives you a
short textual explanation of what went wrong (<tt class="docutils literal"><span class="pre">cannot</span> <span class="pre">add</span> <span class="pre">edges,</span> <span class="pre">invalid</span>
<span class="pre">vertex</span> <span class="pre">id</span></tt>) along with the corresponding line in the C source where the error
occurred. The exact filename and line number may not be too informative to you,
but it is invaluable for <em>igraph</em> developers if you think you found an error in
<em>igraph</em> and you want to report it.</p>
<p>Let us go on with our graph <tt class="docutils literal"><span class="pre">g</span></tt> and add some more vertices and edges to it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">g</span>
<span class="go">IGRAPH U---- 6 7 --</span>
<span class="go">+ edges:</span>
<span class="go">0--1 1--2 0--2 2--3 3--4 4--5 3--5</span>
</pre></div>
</div>
<p>Now, this is better. We have an undirected graph with six vertices and seven
edges, and you can also see the list of edges in <em>igraph</em>&#8216;s output.  Edges also
have IDs, similarly to vertices; they also start from zero and edges that were
added later have higher IDs than edges that were added earlier. Vertex and edge
IDs are always <em>continuous</em>, and a direct consequence of this fact is that if
you happen to delete an edge, chances are that some (or all) of the edges will
be renumbered. Moreover, if you delete a vertex, even the vertex IDs will
change.  Edges can be deleted by <tt class="xref py py-meth docutils literal"><span class="pre">delete_edges()</span></tt> and it requires a
list of edge IDs to be deleted (or a single edge ID). Vertices can be deleted
by <tt class="xref py py-meth docutils literal"><span class="pre">delete_vertices()</span></tt> and you may have already guessed that it
requires a list of vertex IDs to be deleted (or a single vertex ID). If you do
not know the ID of an edge you wish to delete, but you know the IDs of the
vertices at its two endpoints, you can use <tt class="xref py py-meth docutils literal"><span class="pre">get_eid()</span></tt> to get the
edge ID. Remember, all these are <em>methods</em> of the <tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt> class and you
must call them on the appropriate <tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt> instance!</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">get_eid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">delete_edges</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">summary</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">IGRAPH U--- 6 6 --</span>
</pre></div>
</div>
<p><tt class="xref py py-meth docutils literal"><span class="pre">summary()</span></tt> is a new command that you haven&#8217;t seen before; it is a member of <em>igraph</em>&#8216;s
own namespace and it can be used to get an overview of a given graph object. Its output
is similar to the output of <tt class="docutils literal"><span class="pre">print</span></tt> but it does not print the edge list to avoid
cluttering up the display for large graphs. In general, you should use <tt class="xref py py-meth docutils literal"><span class="pre">summary()</span></tt>
instead of <tt class="docutils literal"><span class="pre">print</span></tt> when working interactively with large graphs because printing the
edge list of a graph with millions of vertices and edges could take quite a lot of time.</p>
</div>
<div class="section" id="generating-graphs">
<h2>Generating graphs<a class="headerlink" href="#generating-graphs" title="Permalink to this headline">¶</a></h2>
<p><em>igraph</em> includes a large set of graph generators which can be divided into two groups:
deterministic and stochastic graph generators. Deterministic generators produce the same
graph if you call them with exactly the same parameters, while stochastic generators
produce a different graph every time. Deterministic generators include methods for
creating trees, regular lattices, rings, extended chordal rings, several famous graphs
and so on, while stochastic generators are used to create Erdős-Rényi random networks,
Barabási-Albert networks, geometric random graphs and such. <em>igraph</em> has too many
generators to cover them all in this tutorial, so we will only try a
deterministic and a stochastic generator instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">summary</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">IGRAPH U--- 127 126 --</span>
</pre></div>
</div>
<p><tt class="xref py py-meth docutils literal"><span class="pre">Graph.Tree()</span></tt> generates a regular tree graph. The one that we generated has 127
vertices and each vertex (apart from the leaves) has two children (and of course one
parent). No matter how many times you call <tt class="xref py py-meth docutils literal"><span class="pre">Graph.Tree()</span></tt>, the generated graph will
always be the same if you use the same parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g2</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g2</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">()</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The above code snippet also shows you that the <tt class="xref py py-meth docutils literal"><span class="pre">get_edgelist()</span></tt> method
of <tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt> graph objects return a list that contains pairs of integers, one for
each edge. The first member of the pair is the source vertex ID and the second member
is the target vertex ID of the corresponding edge. This list is too long, so let&#8217;s
just print the first 10 elements!</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g2</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
<span class="go">[(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6), (3, 7), (3, 8), (4, 9), (4, 10)]</span>
</pre></div>
</div>
<p>Let&#8217;s do the same with a stochastic generator!</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">GRG</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">summary</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">IGRAPH U---- 100 516 --</span>
<span class="go">+ attr: x (v), y (v)</span>
</pre></div>
</div>
<p>TODO: discuss what the <tt class="docutils literal"><span class="pre">+</span> <span class="pre">attr</span></tt> line means.</p>
<p><tt class="xref py py-meth docutils literal"><span class="pre">Graph.GRG()</span></tt> generates a geometric random graph: <em>n</em> points are chosen randomly and
uniformly inside the unit square and pairs of points closer to each other than a predefined
distance <em>d</em> are connected by an edge. In our case, <em>n</em> is 100 and <em>d</em> is 0.2. Due to
the random nature of the algorithm, chances are that the exact graph you got is different
from the one that was generated when I wrote this tutorial, hence the values above in the
summary will not match the ones you got. This is normal and expected. Even if you generate
two geometric random graphs on the same machine, they will be different for the same parameter
set:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g2</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">GRG</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">()</span> <span class="o">==</span> <span class="n">g2</span><span class="o">.</span><span class="n">get_edgelist</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">isomorphic</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p><tt class="xref py py-meth docutils literal"><span class="pre">isomorphic()</span></tt> tells you whether two graphs are isomorphic or not. In general,
it might take quite a lot of time, especially for large graphs, but in our case, the
answer can quickly be given by checking the degree distributions of the two graphs.</p>
</div>
<div class="section" id="setting-and-retrieving-attributes">
<h2>Setting and retrieving attributes<a class="headerlink" href="#setting-and-retrieving-attributes" title="Permalink to this headline">¶</a></h2>
<p><em>igraph</em> uses vertex and edge IDs in its core. These IDs are integers, starting from zero,
and they are always continuous at any given time instance during the lifetime of the graph.
This means that whenever vertices and edges are deleted, a large set of edge and possibly
vertex IDs will be renumbered to ensure the continuiuty. Now, let us assume that our graph
is a social network where vertices represent people and edges represent social connections
between them. One way to maintain the association between vertex IDs and say, the corresponding
names is to have an additional Python list that maps from vertex IDs to names. The drawback
of this approach is that this additional list must be maintained in parallel to the
modifications of the original graph. Luckily, <em>igraph</em> knows the concept of <em>attributes</em>,
i.e., auxiliary objects associated to a given vertex or edge of a graph, or even to the
graph as a whole. Every <em>igraph</em> <tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt>, vertex and edge behaves as a standard
Python dictionary in some sense: you can add key-value pairs to any of them, with the key
representing the name of your attribute (the only restriction is that it must be a string)
and the value representing the attribute itself.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Attributes can be arbitrary Python objects, but if you are saving graphs to a
file, only string and numeric attributes will be kept. See the <tt class="xref py py-mod docutils literal"><span class="pre">pickle</span></tt> module in
the standard Python library if you are looking for a way to save other attribute types.
You can either pickle your attributes individually, store them as strings and save them,
or you can pickle the whole <tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt> if you know that you want to load the graph
back into Python only.</p>
</div>
<p>Let us create a simple imaginary social network the usual way by hand.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)])</span>
</pre></div>
</div>
<p>Now, let us assume that we want to store the names, ages and genders of people in this network as
vertex attributes, and for every connection, we want to store whether this is an informal
friendship tie or a formal tie. Every <tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt> object contains two special members
called <tt class="xref py py-attr docutils literal"><span class="pre">vs</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">es</span></tt>, standing for the sequence of all vertices
and all edges, respectively. If you try to use <tt class="xref py py-attr docutils literal"><span class="pre">vs</span></tt> or <tt class="xref py py-attr docutils literal"><span class="pre">es</span></tt> as
a Python dictionary, you will manipulate the attribute storage area of the graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span>
<span class="go">&lt;igraph.VertexSeq object at 0x1b23b90&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Alice&quot;</span><span class="p">,</span> <span class="s">&quot;Bob&quot;</span><span class="p">,</span> <span class="s">&quot;Claire&quot;</span><span class="p">,</span> <span class="s">&quot;Dennis&quot;</span><span class="p">,</span> <span class="s">&quot;Esther&quot;</span><span class="p">,</span> <span class="s">&quot;Frank&quot;</span><span class="p">,</span> <span class="s">&quot;George&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;age&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">25</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;gender&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">,</span> <span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">,</span> <span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s">&quot;is_formal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">]</span>
</pre></div>
</div>
<p>Whenever you use <tt class="xref py py-attr docutils literal"><span class="pre">vs</span></tt> or <tt class="xref py py-attr docutils literal"><span class="pre">es</span></tt> as a dictionary, you are assigning
attributes to <em>all</em> vertices/edges of the graph. However, you can simply alter the attributes
of vertices and edges individually by <em>indexing</em> <tt class="xref py py-attr docutils literal"><span class="pre">vs</span></tt> or <tt class="xref py py-attr docutils literal"><span class="pre">es</span></tt>
with integers as if they were lists (remember, they are sequences, they contain all the
vertices or all the edges). When you index them, you obtain a <tt class="xref py py-class docutils literal"><span class="pre">Vertex</span></tt> or
<tt class="xref py py-class docutils literal"><span class="pre">Edge</span></tt> object, which refers to (I am sure you already guessed that) a single vertex
or a single edge of the graph. <tt class="xref py py-class docutils literal"><span class="pre">Vertex</span></tt> and <tt class="xref py py-class docutils literal"><span class="pre">Edge</span></tt> objects can also be used
as dictionaries to alter the attributes of that single vertex or edge:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">igraph.Edge(&lt;igraph.Graph object at 0x4c87a0&gt;,0,{&#39;is_formal&#39;: False})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">attributes</span><span class="p">()</span>
<span class="go">{&#39;is_formal&#39;: False}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&quot;is_formal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">igraph.Edge(&lt;igraph.Graph object at 0x4c87a0&gt;,0,{&#39;is_formal&#39;: True})</span>
</pre></div>
</div>
<p>The above snippet illustrates that indexing an <tt class="xref py py-class docutils literal"><span class="pre">EdgeSeq</span></tt> object returns
<tt class="xref py py-class docutils literal"><span class="pre">Edge</span></tt> objects; the representation above shows the graph the object belongs to,
the edge ID (zero in our case) and the dictionary of attributes assigned to that edge.
<tt class="xref py py-class docutils literal"><span class="pre">Edge</span></tt> objects have some useful attributes, too: the <tt class="xref py py-attr docutils literal"><span class="pre">source</span></tt> property
gives you the source vertex of that edge, <tt class="xref py py-attr docutils literal"><span class="pre">target</span></tt> gives you the target vertex,
<tt class="xref py py-attr docutils literal"><span class="pre">index</span></tt> gives you the corresponding edge ID, <tt class="xref py py-attr docutils literal"><span class="pre">tuple</span></tt> gives you a
tuple containing the source and target vertices and <tt class="xref py py-meth docutils literal"><span class="pre">attributes()</span></tt> gives you
a dictionary containing the attributes of this edge. <tt class="xref py py-class docutils literal"><span class="pre">Vertex</span></tt> instances only have
<tt class="xref py py-attr docutils literal"><span class="pre">index</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">attributes()</span></tt>.</p>
<p>Since <tt class="xref py py-attr docutils literal"><span class="pre">Graph.es</span></tt> always represents all the edges in a graph, indexing it by
<em>i</em> will always return the edge with ID <em>i</em>, and of course the same applies
to <tt class="xref py py-attr docutils literal"><span class="pre">Graph.vs</span></tt>. However, keep in mind that an <tt class="xref py py-class docutils literal"><span class="pre">EdgeSeq</span></tt> object <em>in general</em>
does not necessarily represent the whole edge sequence of a graph;
<a class="reference internal" href="#querying-vertices-and-edges"><em>later in this tutorial</em></a>
we will see methods that can filter <tt class="xref py py-class docutils literal"><span class="pre">EdgeSeq</span></tt> objects and return other
<tt class="xref py py-class docutils literal"><span class="pre">EdgeSeq</span></tt> objects that are restricted to a subset of edges, and of course the same
applies to <tt class="xref py py-class docutils literal"><span class="pre">VertexSeq</span></tt> objects. But before we dive into that, let&#8217;s see how we
can assign attributes to the whole graph. Not too surprisingly, <tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt> objects
themselves can also behave as dictionaries:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">[</span><span class="s">&quot;date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;2009-01-10&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">g</span><span class="p">[</span><span class="s">&quot;date&quot;</span><span class="p">]</span>
<span class="go">2009-01-10</span>
</pre></div>
</div>
<p>Finally, it should be mentioned that attributes can be deleted by the Python keyword
<tt class="docutils literal"><span class="pre">del</span></tt> just as you would do with any member of an ordinary dictionary:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="s">&quot;foo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;bar&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;foo&quot;</span><span class="p">]</span>
<span class="go">[None, None, None, &#39;bar&#39;, None, None, None]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;foo&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;foo&quot;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">25</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">KeyError</span>: <span class="n">&#39;Attribute does not exist&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="structural-properties-of-graphs">
<h2>Structural properties of graphs<a class="headerlink" href="#structural-properties-of-graphs" title="Permalink to this headline">¶</a></h2>
<p>Besides the simple graph and attribute manipulation routines described above,
<em>igraph</em> provides a large set of methods to calculate various structural properties
of graphs. It is beyond the scope of this tutorial to document all of them, hence
this section will only introduce a few of them for illustrative purposes.
We will work on the small social network we built in the previous section.</p>
<p>Probably the simplest property one can think of is the <em class="dfn">vertex degree</em>. The
degree of a vertex equals the number of edges adjacent to it. In case of directed
networks, we can also define <em class="dfn">in-degree</em> (the number of edges pointing towards
the vertex) and <em class="dfn">out-degree</em> (the number of edges originating from the vertex).
<em>igraph</em> is able to calculate all of them using a simple syntax:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">[3, 1, 4, 3, 2, 3, 2]</span>
</pre></div>
</div>
<p>If the graph was directed, we would have been able to calculate the in- and out-degrees
separately using <tt class="docutils literal"><span class="pre">g.degree(type=&quot;in&quot;)</span></tt> and <tt class="docutils literal"><span class="pre">g.degree(type=&quot;out&quot;)</span></tt>. You can
also pass a single vertex ID or a list of vertex IDs to <tt class="xref py py-meth docutils literal"><span class="pre">degree()</span></tt> if you
want to calculate the degrees for only a subset of vertices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="go">[4, 3, 2]</span>
</pre></div>
</div>
<p>This calling convention applies to most of the structural properties <em>igraph</em> can
calculate. For vertex properties, the methods accept a vertex ID or a list of vertex IDs
(and if they are omitted, the default is the set of all vertices). For edge properties,
the methods accept a single edge ID or a list of edge IDs. Instead of a list of IDs,
you can also supply a <tt class="xref py py-class docutils literal"><span class="pre">VertexSeq</span></tt> or an <tt class="xref py py-class docutils literal"><span class="pre">EdgeSeq</span></tt> instance appropriately.
Later in the <a class="reference internal" href="#querying-vertices-and-edges"><em>next chapter</em></a>, you will learn how to
restrict them to exactly the vertices or edges you want.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For some measures, it does not make sense to calculate them only for a few vertices
or edges instead of the whole graph, as it would take the same time anyway. In this
case, the methods won&#8217;t accept vertex or edge IDs, but you can still restrict the
resulting list later using standard list indexing and slicing operators. One such
example is eigenvector centrality (<tt class="xref py py-meth docutils literal"><span class="pre">Graph.evcent()</span></tt>).</p>
</div>
<p>Besides degree, <em>igraph</em> includes built-in routines to calculate many other centrality
properties, including vertex and edge betweenness (<tt class="xref py py-meth docutils literal"><span class="pre">Graph.betweenness()</span></tt>,
<tt class="xref py py-meth docutils literal"><span class="pre">Graph.edge_betweenness()</span></tt>) or Google&#8217;s PageRank (<tt class="xref py py-meth docutils literal"><span class="pre">Graph.pagerank()</span></tt>)
just to name a few. Here we just illustrate edge betweenness:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">edge_betweenness</span><span class="p">()</span>
<span class="go">[6.0, 6.0, 4.0, 2.0, 4.0, 3.0, 4.0, 3.0. 4.0]</span>
</pre></div>
</div>
<p>Now we can also figure out which connections have the highest betweenness centrality
with some Python magic:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ebs</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_betweenness</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_eb</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ebs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">tuple</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">eb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ebs</span><span class="p">)</span> <span class="k">if</span> <span class="n">eb</span> <span class="o">==</span> <span class="n">max_eb</span><span class="p">]</span>
<span class="go">[(0, 1), (0, 2)]</span>
</pre></div>
</div>
<p>Most structural properties can also be retrieved for a subset of vertices or edges
or for a single vertex or edge by calling the appropriate method on the
<tt class="xref py py-class docutils literal"><span class="pre">VertexSeq</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">EdgeSeq</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">Vertex</span></tt> or <tt class="xref py py-class docutils literal"><span class="pre">Edge</span></tt> object of
interest:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">[3, 1, 4, 3, 2, 3, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="o">.</span><span class="n">edge_betweenness</span><span class="p">()</span>
<span class="go">[6.0, 6.0, 4.0, 2.0, 4.0, 3.0, 4.0, 3.0. 4.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
</div>
<div class="section" id="querying-vertices-and-edges-based-on-attributes">
<span id="querying-vertices-and-edges"></span><h2>Querying vertices and edges based on attributes<a class="headerlink" href="#querying-vertices-and-edges-based-on-attributes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="selecting-vertices-and-edges">
<h3>Selecting vertices and edges<a class="headerlink" href="#selecting-vertices-and-edges" title="Permalink to this headline">¶</a></h3>
<p>Imagine that in a given social network, you would like to find out who has the largest
degree or betweenness centrality. You can do that with the tools presented so far and
some basic Python knowledge, but since it is a common task to select vertices and edges
based on attributes or structural properties, <em>igraph</em> gives you an easier way to do that:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">_degree</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">maxdegree</span><span class="p">())[</span><span class="s">&quot;name&quot;</span><span class="p">]</span>
<span class="go">[&quot;Alice&quot;, &quot;Bob&quot;]</span>
</pre></div>
</div>
<p>The syntax may seem a little bit awkward for the first sight, so let&#8217;s try to interpret
it step by step. <tt class="xref py py-meth docutils literal"><span class="pre">select()</span></tt> is a method of <tt class="xref py py-class docutils literal"><span class="pre">VertexSeq</span></tt> and its
sole purpose is to filter a <tt class="xref py py-class docutils literal"><span class="pre">VertexSeq</span></tt> based on the properties of individual
vertices. The way it filters the vertices depends on its positional and keyword
arguments. Positional arguments (the ones without an explicit name like
<tt class="docutils literal"><span class="pre">_degree</span></tt> above) are always processed before keyword arguments as follows:</p>
<ul>
<li><p class="first">If the first positional argument is <tt class="docutils literal"><span class="pre">None</span></tt>, an empty sequence (containing no
vertices) is returned:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</li>
<li><p class="first">If the first positional argument is a callable object (i.e., a function, a bound
method or anything that behaves like a function), the object will be called for
every vertex that&#8217;s currently in the sequence. If the function returns <tt class="docutils literal"><span class="pre">True</span></tt>,
the vertex will be included, otherwise it will be excluded:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">Full</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">only_odd_vertices</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="k">lambda</span> <span class="n">vertex</span><span class="p">:</span> <span class="n">vertex</span><span class="o">.</span><span class="n">index</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">only_odd_vertices</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</li>
<li><p class="first">If the first positional argument is an iterable (i.e., a list, a generator or
anything that can be iterated over), it <em>must</em> return integers and these integers
will be considered as indices into the current vertex set (which is <em>not</em> necessarily
the whole graph). Only those vertices that match the given indices will be included
in the filtered vertex set. Floats, strings, invalid vertex IDs will silently be
ignored:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">]</span>
<span class="go">[2, 3, 7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>         <span class="c"># filtering an existing vertex set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">]</span>
<span class="go">[2, 7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</li>
<li><p class="first">If the first positional argument is an integer, all remaining arguments are also
expected to be integers and they are interpreted as indices into the current vertex
set. This is just syntactic sugar, you could achieve an equivalent effect by
passing a list as the first positional argument, but this way you can omit the
square brackets:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</li>
</ul>
<p>Keyword arguments can be used to filter the vertices based on their attributes
or their structural properties. The name of each keyword argument should consist
of at most two parts: the name of the attribute or structural property and the
filtering operator. The operator can be omitted; in that case, we automatically
assume the equality operator. The possibilities are as follows (where
<em>name</em> denotes the name of the attribute or property):</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword argument</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">name_eq</span></tt></td>
<td>The attribute/property value must be <em>equal to</em> the value of the
keyword argument</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">name_ne</span></tt></td>
<td>The attribute/property value must <em>not be equal to</em> the value of
the keyword argument</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">name_lt</span></tt></td>
<td>The attribute/property value must be <em>less than</em> the value of
the keyword argument</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">name_le</span></tt></td>
<td>The attribute/property value must be <em>less than or equal to</em> the
value of the keyword argument</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">name_gt</span></tt></td>
<td>The attribute/property value must be <em>greater than</em> the value of
the keyword argument</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">name_ge</span></tt></td>
<td>The attribute/property value must be <em>greater than or equal to</em>
the value of the keyword argument</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">name_in</span></tt></td>
<td>The attribute/property value must be <em>included in</em> the value of
the keyword argument, which must be a sequence in this case</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">name_notin</span></tt></td>
<td>The attribute/property value must <em>not be included in</em> the value
of the the keyword argument, which must be a sequence in this
case</td>
</tr>
</tbody>
</table>
<p>For instance, the following command gives you people younger than 30 years in
our imaginary social network:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">age_lt</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Due to the syntactical constraints of Python, you cannot use the admittedly
simpler syntax of <tt class="docutils literal"><span class="pre">g.vs.select(age</span> <span class="pre">&lt;</span> <span class="pre">30)</span></tt> as only the equality operator is
allowed to appear in an argument list in Python.</p>
</div>
<p>To save you some typing, you can even omit the <tt class="xref py py-meth docutils literal"><span class="pre">select()</span></tt> method if
you wish:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">(</span><span class="n">age_lt</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<p>Theoretically, it can happen that there exists an attribute and a structural property
with the same name (e.g., you could have a vertex attribute named <tt class="docutils literal"><span class="pre">degree</span></tt>). In that
case, we would not be able to decide whether the user meant <tt class="docutils literal"><span class="pre">degree</span></tt> as a structural
property or as a vertex attribute. To resolve this ambiguity, structural property names
<em>must</em> always be preceded by an underscore (<tt class="docutils literal"><span class="pre">_</span></tt>) when used for filtering. For example, to
find vertices with degree larger than 2:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">(</span><span class="n">_degree_gt</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>There are also a few special structural properties for selecting edges:</p>
<ul>
<li><p class="first">Using <tt class="docutils literal"><span class="pre">_source</span></tt> or <tt class="docutils literal"><span class="pre">_from</span></tt> in the keyword argument list of <tt class="xref py py-meth docutils literal"><span class="pre">EdgeSeq.select()</span></tt>
filters based on the source vertices of the edges. E.g., to select all the edges
originating from Claire (who has vertex index 2):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">_source</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Using <tt class="docutils literal"><span class="pre">_target</span></tt> or <tt class="docutils literal"><span class="pre">_to</span></tt> filters based on the target vertices. This is different
from <tt class="docutils literal"><span class="pre">_source</span></tt> and <tt class="docutils literal"><span class="pre">_from</span></tt> if the graph is directed.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">_within</span></tt> takes a <tt class="xref py py-class docutils literal"><span class="pre">VertexSeq</span></tt> object or a list or set of vertex indices
and selects all the edges that originate and terminate in the given vertex
set. For instance, the following expression selects all the edges between
Claire (vertex index 2), Dennis (vertex index 3) and Esther (vertex index 4):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">_within</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
<p>We could also have used a <tt class="xref py py-class docutils literal"><span class="pre">VertexSeq</span></tt> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">_within</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">_between</span></tt> takes a tuple consisting of two <tt class="xref py py-class docutils literal"><span class="pre">VertexSeq</span></tt> objects or lists
containing vertex indices or <tt class="xref py py-class docutils literal"><span class="pre">Vertex</span></tt> objects and selects all the edges that
originate in one of the sets and terminate in the other. E.g., to select all the
edges that connect men to women:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">men</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">gender</span><span class="o">=</span><span class="s">&quot;m&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">women</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">gender</span><span class="o">=</span><span class="s">&quot;f&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">_between</span><span class="o">=</span><span class="p">(</span><span class="n">men</span><span class="p">,</span> <span class="n">women</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="finding-a-single-vertex-or-edge-with-some-properties">
<h3>Finding a single vertex or edge with some properties<a class="headerlink" href="#finding-a-single-vertex-or-edge-with-some-properties" title="Permalink to this headline">¶</a></h3>
<p>In many cases we are looking for a single vertex or edge of a graph with some properties,
and either we do not care which one of the matches is returned if there are multiple
matches, or we know in advance that there will be only one match. A typical example is
looking up vertices by their names in the <tt class="docutils literal"><span class="pre">name</span></tt> property. <tt class="xref py py-class docutils literal"><span class="pre">VertexSeq</span></tt> and
<tt class="xref py py-class docutils literal"><span class="pre">EdgeSeq</span></tt> objects provide the <tt class="xref py py-meth docutils literal"><span class="pre">find()</span></tt> method for such use-cases.
<tt class="xref py py-meth docutils literal"><span class="pre">find()</span></tt> works similarly to <tt class="xref py py-meth docutils literal"><span class="pre">select()</span></tt>, but it returns
only the first match if there are multiple matches, and throws an exception if no
match is found. For instance, to look up the vertex corresponding to Claire, one can
do this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">claire</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Claire&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">claire</span><span class="p">)</span>
<span class="go">igraph.Vertex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">claire</span><span class="o">.</span><span class="n">index</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Looking up an unknown name will yield an exception:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Joe&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">no such vertex</span>
</pre></div>
</div>
</div>
<div class="section" id="looking-up-vertices-by-names">
<h3>Looking up vertices by names<a class="headerlink" href="#looking-up-vertices-by-names" title="Permalink to this headline">¶</a></h3>
<p>Looking up vertices by names is a very common operation, and it is usually much easier
to remember the names of the vertices in a graph than their IDs. To this end, <em>igraph</em>
treats the <tt class="docutils literal"><span class="pre">name</span></tt> attribute of vertices specially; they are indexed such that vertices
can be looked up by their names in amortized constant time. To make things even easier,
<em>igraph</em> accepts vertex names (almost) anywhere where it expects vertex IDs, and also
accepts collections (list, tuples etc) of vertex names anywhere where it expects lists
of vertex IDs or <tt class="xref py py-class docutils literal"><span class="pre">VertexSeq</span></tt> instances. E.g, you can simply look up the degree
(number of connections) of Dennis as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="s">&quot;Dennis&quot;</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>or, alternatively:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;Dennis&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>The mapping between vertex names and IDs is maintained transparently by <em>igraph</em> in
the background; whenever the graph changes, <em>igraph</em> also updates the internal mapping.
However, uniqueness of vertex names is <em>not</em> enforced; you can easily create a graph
where two vertices have the same name, but <em>igraph</em> will return only one of them when
you look them up by names, the other one will be available only by its index.</p>
</div>
</div>
<div class="section" id="treating-a-graph-as-an-adjacency-matrix">
<h2>Treating a graph as an adjacency matrix<a class="headerlink" href="#treating-a-graph-as-an-adjacency-matrix" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
</div>
<div class="section" id="layouts-and-plotting">
<h2>Layouts and plotting<a class="headerlink" href="#layouts-and-plotting" title="Permalink to this headline">¶</a></h2>
<p>A graph is an abstract mathematical object without a specific representation in 2D or
3D space. This means that whenever we want to visualise a graph, we have to find a
mapping from vertices to coordinates in two- or three-dimensional space first,
preferably in a way that is pleasing for the eye. A separate branch of graph theory,
namely graph drawing, tries to solve this problem via several graph layout algorithms.
<em>igraph</em> implements quite a few layout algorithms and is also able to draw them onto
the screen or to a PDF, PNG or SVG file using the <a class="reference external" href="http://www.cairographics.org">Cairo library</a>.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">To follow the examples of this subsection, you need the Python bindings of the
Cairo library. The previous chapter (<a class="reference internal" href="install.html#installing-igraph"><em>Installing igraph</em></a>) tells you more
about how to install Cairo&#8217;s Python bindings.</p>
</div>
<div class="section" id="layout-algorithms">
<h3>Layout algorithms<a class="headerlink" href="#layout-algorithms" title="Permalink to this headline">¶</a></h3>
<p>The layout methods in <em>igraph</em> are to be found in the <tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt> object, and their
always start with <tt class="docutils literal"><span class="pre">layout_</span></tt>. The following table summarises them:</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="16%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method name</th>
<th class="head">Short name</th>
<th class="head">Algorithm description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">layout_circle</span></tt></td>
<td><tt class="docutils literal"><span class="pre">circle</span></tt>,
<tt class="docutils literal"><span class="pre">circular</span></tt></td>
<td>Deterministic layout that places the
vertices on a circle</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">layout_drl</span></tt></td>
<td><tt class="docutils literal"><span class="pre">drl</span></tt></td>
<td>The <a class="reference external" href="http://www.cs.sandia.gov/~smartin/software.html">Distributed Recursive Layout</a> algorithm
for large graphs</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">layout_fruchterman_reingold</span></tt></td>
<td><tt class="docutils literal"><span class="pre">fr</span></tt></td>
<td>Fruchterman-Reingold force-directed algorithm</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">layout_fruchterman_reingold_3d</span></tt></td>
<td><tt class="docutils literal"><span class="pre">fr3d</span></tt>,
<tt class="docutils literal"><span class="pre">fr_3d</span></tt></td>
<td>Fruchterman-Reingold force-directed algorithm
in three dimensions</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">layout_grid_fruchterman_reingold</span></tt></td>
<td><tt class="docutils literal"><span class="pre">grid_fr</span></tt></td>
<td>Fruchterman-Reingold force-directed algorithm
with grid heuristics for large graphs</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">layout_kamada_kawai</span></tt></td>
<td><tt class="docutils literal"><span class="pre">kk</span></tt></td>
<td>Kamada-Kawai force-directed algorithm</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">layout_kamada_kawai_3d</span></tt></td>
<td><tt class="docutils literal"><span class="pre">kk3d</span></tt>,
<tt class="docutils literal"><span class="pre">kk_3d</span></tt></td>
<td>Kamada-Kawai force-directed algorithm
in three dimensions</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">layout_lgl</span></tt></td>
<td><tt class="docutils literal"><span class="pre">large</span></tt>,
<tt class="docutils literal"><span class="pre">lgl</span></tt>,
<tt class="docutils literal"><span class="pre">large_graph</span></tt></td>
<td>The <a class="reference external" href="http://sourceforge.net/projects/lgl/">Large Graph Layout</a> algorithm for
large graphs</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">layout_random</span></tt></td>
<td><tt class="docutils literal"><span class="pre">random</span></tt></td>
<td>Places the vertices completely randomly</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">layout_random_3d</span></tt></td>
<td><tt class="docutils literal"><span class="pre">random_3d</span></tt></td>
<td>Places the vertices completely randomly in 3D</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">layout_reingold_tilford</span></tt></td>
<td><tt class="docutils literal"><span class="pre">rt</span></tt>,
<tt class="docutils literal"><span class="pre">tree</span></tt></td>
<td>Reingold-Tilford tree layout, useful for
(almost) tree-like graphs</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">layout_reingold_tilford_circular</span></tt></td>
<td><p class="first"><tt class="docutils literal"><span class="pre">rt_circular</span></tt></p>
<p class="last"><tt class="docutils literal"><span class="pre">tree</span></tt></p>
</td>
<td>Reingold-Tilford tree layout with a polar
coordinate post-transformation, useful for
(almost) tree-like graphs</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">layout_sphere</span></tt></td>
<td><tt class="docutils literal"><span class="pre">sphere</span></tt>,
<tt class="docutils literal"><span class="pre">spherical</span></tt>,
<tt class="docutils literal"><span class="pre">circular</span></tt>,
<tt class="docutils literal"><span class="pre">circular_3d</span></tt></td>
<td>Deterministic layout that places the vertices
evenly on the surface of a sphere</td>
</tr>
</tbody>
</table>
<p>Layout algorithms can either be called directly or using the common layout method called
<tt class="xref py py-meth docutils literal"><span class="pre">layout()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">layout</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">layout_kamada_kawai</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">layout</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="s">&quot;kamada_kawai&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The first argument of the <tt class="xref py py-meth docutils literal"><span class="pre">layout()</span></tt> method must be the short name of the
layout algorithm (see the table above). All the remaining positional and keyword arguments
are passed intact to the chosen layout method. For instance, the following two calls are
completely equivalent:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">layout</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">layout_reingold_tilford</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">layout</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="s">&quot;rt&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Layout methods return a <tt class="xref py py-class docutils literal"><span class="pre">Layout</span></tt> object which behaves mostly like a list of lists.
Each list entry in a <tt class="xref py py-class docutils literal"><span class="pre">Layout</span></tt> object corresponds to a vertex in the original graph
and contains the vertex coordinates in the 2D or 3D space. <tt class="xref py py-class docutils literal"><span class="pre">Layout</span></tt> objects also
contain some useful methods to translate, scale or rotate the coordinates in a batch.
However, the primary utility of <tt class="xref py py-class docutils literal"><span class="pre">Layout</span></tt> objects is that you can pass them to the
<tt class="xref py py-func docutils literal"><span class="pre">plot()</span></tt> function along with the graph to obtain a 2D drawing.</p>
</div>
<div class="section" id="drawing-a-graph-using-a-layout">
<h3>Drawing a graph using a layout<a class="headerlink" href="#drawing-a-graph-using-a-layout" title="Permalink to this headline">¶</a></h3>
<p>For instance, we can plot our imaginary social network with the Kamada-Kawai
layout algorithm as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">layout</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">layout</span><span class="p">(</span><span class="s">&quot;kk&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">layout</span> <span class="o">=</span> <span class="n">layout</span><span class="p">)</span>
</pre></div>
</div>
<p>This should open an external image viewer showing a visual representation of the network,
something like the one on the following figure (although the exact placement of
nodes may be different on your machine since the layout is not deterministic):</p>
<div class="figure align-center">
<img alt="The visual representation of our social network" src="_images/tutorial_social_network_1.png" />
<p class="caption">Our social network with the Kamada-Kawai layout algorithm</p>
</div>
<p>Hmm, this is not too pretty so far. A trivial addition would be to use the names as the
vertex labels and to color the vertices according to the gender. Vertex labels are taken
from the <tt class="docutils literal"><span class="pre">label</span></tt> attribute by default and vertex colors are determined by the
<tt class="docutils literal"><span class="pre">color</span></tt> attribute, so we can simply create these attributes and re-plot the graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">color_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;m&quot;</span><span class="p">:</span> <span class="s">&quot;blue&quot;</span><span class="p">,</span> <span class="s">&quot;f&quot;</span><span class="p">:</span> <span class="s">&quot;pink&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">color_dict</span><span class="p">[</span><span class="n">gender</span><span class="p">]</span> <span class="k">for</span> <span class="n">gender</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;gender&quot;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">layout</span> <span class="o">=</span> <span class="n">layout</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span> <span class="n">margin</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we are simply re-using the previous layout object here, but we also specified
that we need a smaller plot (300 x 300 pixels) and a larger margin around the graph
to fit the labels (20 pixels). The result is:</p>
<div class="figure align-center">
<img alt="The visual representation of our social network - with names and genders" src="_images/tutorial_social_network_2.png" />
<p class="caption">Our social network - with names as labels and genders as colors</p>
</div>
<p>Instead of specifying the visual properties as vertex and edge attributes, you can
also give them as keyword arguments to <tt class="xref py py-func docutils literal"><span class="pre">plot()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">color_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;m&quot;</span><span class="p">:</span> <span class="s">&quot;blue&quot;</span><span class="p">,</span> <span class="s">&quot;f&quot;</span><span class="p">:</span> <span class="s">&quot;pink&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">layout</span> <span class="o">=</span> <span class="n">layout</span><span class="p">,</span> <span class="n">vertex_color</span> <span class="o">=</span> <span class="p">[</span><span class="n">color_dict</span><span class="p">[</span><span class="n">gender</span><span class="p">]</span> <span class="k">for</span> <span class="n">gender</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;gender&quot;</span><span class="p">]])</span>
</pre></div>
</div>
<p>This latter approach is preferred if you want to keep the properties of the visual
representation of your graph separate from the graph itself. You can simply set up
a Python dictionary containing the keyword arguments you would pass to <tt class="xref py py-func docutils literal"><span class="pre">plot()</span></tt>
and then use the double asterisk (<tt class="docutils literal"><span class="pre">**</span></tt>) operator to pass your specific styling
attributes to <tt class="xref py py-func docutils literal"><span class="pre">plot()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">visual_style</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">visual_style</span><span class="p">[</span><span class="s">&quot;vertex_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">visual_style</span><span class="p">[</span><span class="s">&quot;vertex_color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">color_dict</span><span class="p">[</span><span class="n">gender</span><span class="p">]</span> <span class="k">for</span> <span class="n">gender</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;gender&quot;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">visual_style</span><span class="p">[</span><span class="s">&quot;vertex_label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">visual_style</span><span class="p">[</span><span class="s">&quot;edge_width&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">is_formal</span><span class="p">)</span> <span class="k">for</span> <span class="n">is_formal</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s">&quot;is_formal&quot;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">visual_style</span><span class="p">[</span><span class="s">&quot;layout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">layout</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">visual_style</span><span class="p">[</span><span class="s">&quot;bbox&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">visual_style</span><span class="p">[</span><span class="s">&quot;margin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">**</span><span class="n">visual_style</span><span class="p">)</span>
</pre></div>
</div>
<p>The final plot shows the formal ties with thick lines while informal ones with thin lines:</p>
<div class="figure align-center">
<img alt="The visual representation of our social network - with names, genders and formal ties" src="_images/tutorial_social_network_3.png" />
<p class="caption">Our social network - also showing which ties are formal</p>
</div>
<p>To sum it all up: there are special vertex and edge properties that correspond to
the visual representation of the graph. These attributes override the default settings
of <em>igraph</em> (see <em class="xref std std-ref">configuring-igraph</em> for overriding the system-wide defaults).
Furthermore, appropriate keyword arguments supplied to <tt class="xref py py-func docutils literal"><span class="pre">plot()</span></tt> override the
visual properties provided by the vertex and edge attributes. The following two
tables summarise the most frequently used visual attributes for vertices and edges,
respectively:</p>
</div>
<div class="section" id="vertex-attributes-controlling-graph-plots">
<h3>Vertex attributes controlling graph plots<a class="headerlink" href="#vertex-attributes-controlling-graph-plots" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="28%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute name</th>
<th class="head">Keyword argument</th>
<th class="head">Purpose</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">color</span></tt></td>
<td><tt class="docutils literal"><span class="pre">vertex_color</span></tt></td>
<td>Color of the vertex</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">label</span></tt></td>
<td><tt class="docutils literal"><span class="pre">vertex_label</span></tt></td>
<td>Label of the vertex</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">label_angle</span></tt></td>
<td><tt class="docutils literal"><span class="pre">vertex_label_angle</span></tt></td>
<td>The placement of the vertex label on the
circle around the vertex. This is an angle
in radians, with zero belonging to the
right side of the vertex.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">label_color</span></tt></td>
<td><tt class="docutils literal"><span class="pre">vertex_label_color</span></tt></td>
<td>Color of the vertex label</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">label_dist</span></tt></td>
<td><tt class="docutils literal"><span class="pre">vertex_label_dist</span></tt></td>
<td>Distance of the vertex label from the
vertex itself, relative to the vertex size</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">label_size</span></tt></td>
<td><tt class="docutils literal"><span class="pre">vertex_label_size</span></tt></td>
<td>Font size of the vertex label</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">order</span></tt></td>
<td><tt class="docutils literal"><span class="pre">vertex_order</span></tt></td>
<td>Drawing order of the vertices. Vertices
with a smaller order parameter will be
drawn first.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">shape</span></tt></td>
<td><tt class="docutils literal"><span class="pre">vertex_shape</span></tt></td>
<td>Shape of the vertex. Known shapes are:
<tt class="docutils literal"><span class="pre">rectangle</span></tt>, <tt class="docutils literal"><span class="pre">circle</span></tt>, <tt class="docutils literal"><span class="pre">hidden</span></tt>,
<tt class="docutils literal"><span class="pre">triangle-up</span></tt>, <tt class="docutils literal"><span class="pre">triangle-down</span></tt>.
Several aliases are also accepted, see
<tt class="xref py py-data docutils literal"><span class="pre">drawing.known_shapes</span></tt>.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">size</span></tt></td>
<td><tt class="docutils literal"><span class="pre">vertex_size</span></tt></td>
<td>Size of the vertex in pixels</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="edge-attributes-controlling-graph-plots">
<h3>Edge attributes controlling graph plots<a class="headerlink" href="#edge-attributes-controlling-graph-plots" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="28%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute name</th>
<th class="head">Keyword argument</th>
<th class="head">Purpose</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">color</span></tt></td>
<td><tt class="docutils literal"><span class="pre">edge_color</span></tt></td>
<td>Color of the edge</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">curved</span></tt></td>
<td><tt class="docutils literal"><span class="pre">edge_curved</span></tt></td>
<td>The curvature of the edge. Positive values
correspond to edges curved in CCW
direction, negative numbers correspond to
edges curved in clockwise (CW) direction.
Zero represents straight edges. <tt class="docutils literal"><span class="pre">True</span></tt>
is interpreted as 0.5, <tt class="docutils literal"><span class="pre">False</span></tt> is
interpreted as zero. This is useful to
make multiple edges visible. See also the
<tt class="docutils literal"><span class="pre">autocurve</span></tt> keyword argument to
<tt class="xref py py-func docutils literal"><span class="pre">plot()</span></tt>.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">arrow_size</span></tt></td>
<td><tt class="docutils literal"><span class="pre">edge_arrow_size</span></tt></td>
<td>Size (length) of the arrowhead on the edge
if the graph is directed, relative to 15
pixels.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">arrow_width</span></tt></td>
<td><tt class="docutils literal"><span class="pre">edge_arrow_width</span></tt></td>
<td>Width of the arrowhead on the edge if the
graph is directed, relative to 10 pixels.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">width</span></tt></td>
<td><tt class="docutils literal"><span class="pre">edge_width</span></tt></td>
<td>Width of the edge in pixels</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="generic-keyword-arguments-of-plot">
<h3>Generic keyword arguments of <tt class="docutils literal"><span class="pre">plot()</span></tt><a class="headerlink" href="#generic-keyword-arguments-of-plot" title="Permalink to this headline">¶</a></h3>
<p>These settings can be specified as keyword arguments to the <tt class="docutils literal"><span class="pre">plot()</span></tt> function
to control the overall appearance of the plot.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Keyword argument</th>
<th class="head">Purpose</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">autocurve</span></tt></td>
<td>Whether to determine the curvature of the edges automatically in
graphs with multiple edges. The default is <tt class="docutils literal"><span class="pre">True</span></tt> for graphs
with less than 10.000 edges and <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">bbox</span></tt></td>
<td>The bounding box of the plot. This must be a tuple containing
the desired width and height of the plot. The default plot is
600 pixels wide and 600 pixels high.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">layout</span></tt></td>
<td>The layout to be used. It can be an instance of <tt class="xref py py-class docutils literal"><span class="pre">Layout</span></tt>,
a list of tuples containing X-Y coordinates, or the name of a
layout algorithm. The default is <tt class="docutils literal"><span class="pre">auto</span></tt>, which selects a
layout algorithm automatically based on the size and
connectedness of the graph.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">margin</span></tt></td>
<td>The top, right, bottom and left margins of the plot in pixels.
This argument must be a list or tuple and its elements will be
re-used if you specify a list or tuple with less than four
elements.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="specifying-colors-in-plots">
<h3>Specifying colors in plots<a class="headerlink" href="#specifying-colors-in-plots" title="Permalink to this headline">¶</a></h3>
<p><em>igraph</em> understands the following color specifications wherever it expects a
color (e.g., edge, vertex or label colors in the respective attributes):</p>
<dl class="docutils">
<dt>X11 color names</dt>
<dd>See the <a class="reference external" href="http://en.wikipedia.org/wiki/X11_color_names">list of X11 color names</a>
in Wikipedia for the complete list.</dd>
<dt>Color specification in CSS syntax</dt>
<dd><p class="first">This is a string according to one of the following formats (where <em>R</em>, <em>G</em> and
<em>B</em> denote the red, green and blue components, respectively):</p>
<ul class="last simple">
<li><tt class="docutils literal"><span class="pre">#RRGGBB</span></tt>, components range from 0 to 255 in hexadecimal format.
Example: <tt class="docutils literal"><span class="pre">&quot;#0088ff&quot;</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">#RGB</span></tt>, components range from 0 to 15 in hexadecimal format. Example:
<tt class="docutils literal"><span class="pre">&quot;#08f&quot;</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">rgb(R,</span> <span class="pre">G,</span> <span class="pre">B)</span></tt>, components range from 0 to 255 or from 0% to
100%. Example: <tt class="docutils literal"><span class="pre">&quot;rgb(0,</span> <span class="pre">127,</span> <span class="pre">255)&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;rgb(0%,</span> <span class="pre">50%,</span> <span class="pre">100%)&quot;</span></tt>.</li>
</ul>
</dd>
<dt>List, tuple or whitespace-separated string of RGB values</dt>
<dd>Example: <tt class="docutils literal"><span class="pre">(255,</span> <span class="pre">128,</span> <span class="pre">0)</span></tt>, <tt class="docutils literal"><span class="pre">[255,</span> <span class="pre">128,</span> <span class="pre">0]</span></tt> or <tt class="docutils literal"><span class="pre">&quot;255,</span> <span class="pre">128,</span> <span class="pre">0&quot;</span></tt>.</dd>
</dl>
</div>
<div class="section" id="saving-plots">
<h3>Saving plots<a class="headerlink" href="#saving-plots" title="Permalink to this headline">¶</a></h3>
<p><em>igraph</em> can be used to create publication-quality plots by asking the <tt class="xref py py-func docutils literal"><span class="pre">plot()</span></tt>
function to save the plot into a file instead of showing it on a screen. This can
be done simply by passing the target filename as an additional argument after the
graph itself. The preferred format is inferred from the extension. <em>igraph</em> can
save to anything that is supported by Cairo, including SVG, PDF and PNG files.
SVG or PDF files can then later be converted to PostScript (<tt class="docutils literal"><span class="pre">.ps</span></tt>) or Encapsulated
PostScript (<tt class="docutils literal"><span class="pre">.eps</span></tt>) format if you prefer that, while PNG files can be converted to
TIF (<tt class="docutils literal"><span class="pre">.tif</span></tt>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">plot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">&quot;social_network.pdf&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">visual_style</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="igraph-and-the-outside-world">
<h2><em>igraph</em> and the outside world<a class="headerlink" href="#igraph-and-the-outside-world" title="Permalink to this headline">¶</a></h2>
<p>No graph module would be complete without some kind of import/export functionality
that enables the package to communicate with external programs and toolkits. <em>igraph</em>
is no exception: it provides functions to read the most common graph formats and
to save <tt class="xref py py-class docutils literal"><span class="pre">Graph</span></tt> objects into files obeying these format specifications.
The following table summarises the formats <em>igraph</em> can read or write:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="15%" />
<col width="33%" />
<col width="34%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Short name</th>
<th class="head">Reader method</th>
<th class="head">Writer method</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Adjacency list</td>
<td><tt class="docutils literal"><span class="pre">lgl</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.Read_Lgl()</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.write_lgl()</span></tt></td>
</tr>
<tr class="row-odd"><td>(a.k.a. <a class="reference external" href="http://lgl.sourceforge.net/#FileFormat">LGL</a>)</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Adjacency matrix</td>
<td><tt class="docutils literal"><span class="pre">adjacency</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.Read_Adjacency()</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.write_adjacency()</span></tt></td>
</tr>
<tr class="row-odd"><td>DIMACS</td>
<td><tt class="docutils literal"><span class="pre">dimacs</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.Read_DIMACS()</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.write_dimacs()</span></tt></td>
</tr>
<tr class="row-even"><td>Edge list</td>
<td><tt class="docutils literal"><span class="pre">edgelist</span></tt>,
<tt class="docutils literal"><span class="pre">edges</span></tt>,
<tt class="docutils literal"><span class="pre">edge</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.Read_Edgelist()</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.write_edgelist()</span></tt></td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="http://www.graphviz.org">GraphViz</a></td>
<td><tt class="docutils literal"><span class="pre">graphviz</span></tt>,
<tt class="docutils literal"><span class="pre">dot</span></tt></td>
<td>not supported yet</td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.write_dot()</span></tt></td>
</tr>
<tr class="row-even"><td>GML</td>
<td><tt class="docutils literal"><span class="pre">gml</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.Read_GML()</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.write_gml()</span></tt></td>
</tr>
<tr class="row-odd"><td>GraphML</td>
<td><tt class="docutils literal"><span class="pre">graphml</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.Read_GraphML()</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.write_graphml()</span></tt></td>
</tr>
<tr class="row-even"><td>Gzipped GraphML</td>
<td><tt class="docutils literal"><span class="pre">graphmlz</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.Read_GraphMLz()</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.write_graphmlz()</span></tt></td>
</tr>
<tr class="row-odd"><td>Labeled edgelist</td>
<td><tt class="docutils literal"><span class="pre">ncol</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.Read_Ncol()</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.write_ncol()</span></tt></td>
</tr>
<tr class="row-even"><td>(a.k.a. <a class="reference external" href="http://lgl.sourceforge.net/#FileFormat">NCOL</a>)</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="http://pajek.imfm.si/doku.php">Pajek</a> format</td>
<td><tt class="docutils literal"><span class="pre">pajek</span></tt>,
<tt class="docutils literal"><span class="pre">net</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.Read_Pajek()</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.write_pajek()</span></tt></td>
</tr>
<tr class="row-even"><td>Pickled graph</td>
<td><tt class="docutils literal"><span class="pre">pickle</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.Read_Pickle()</span></tt></td>
<td><tt class="xref py py-meth docutils literal"><span class="pre">Graph.write_pickle()</span></tt></td>
</tr>
</tbody>
</table>
<p>As an exercise, download the graph representation of the well-known
<a class="reference external" href="http://nexus.igraph.org/api/dataset?id=1&amp;format=GraphML">Zachary karate club study</a>
from igraph&#8217;s own graph repository called <a class="reference external" href="http://nexus.igraph.org">Nexus</a>,
unzip it and try to load it into <em>igraph</em>. Since it is a GraphML file, you must
must use the GraphML reader method from the table above (make sure you use the
appropriate path to the downloaded file):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">karate</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">Read_GraphML</span><span class="p">(</span><span class="s">&quot;karate.GraphML&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">summary</span><span class="p">(</span><span class="n">karate</span><span class="p">)</span>
<span class="go">IGRAPH UNW- 34 78 -- Zachary&#39;s karate club network</span>
<span class="go">+ attr: Author (g), Citation (g), name (g), Faction (v), id (v), name (v), weight (e)</span>
</pre></div>
</div>
<p>If you want to convert the very same graph into, say, Pajek&#8217;s format, you can do it
with the Pajek writer method from the table above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">karate</span><span class="o">.</span><span class="n">write_pajek</span><span class="p">(</span><span class="s">&quot;karate.net&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Most of the formats have their own limitations; for instance, not all of
them can store attributes. Your best bet is probably GraphML or GML if you
want to save <em>igraph</em> graphs in a format that can be read from an external
package and you want to preserve numeric and string attributes. Edge list and
NCOL is also fine if you don&#8217;t have attributes (NCOL supports vertex names and
edge weights, though). If you don&#8217;t want to use your graphs outside <em>igraph</em>
but you want to store them for a later session, the pickled graph format
ensures that you get exactly the same graph back. The pickled graph format
uses Python&#8217;s <tt class="docutils literal"><span class="pre">pickle</span></tt> module to store and read graphs.</p>
</div>
<p>There are two helper methods as well: <tt class="xref py py-func docutils literal"><span class="pre">load()</span></tt> is a generic entry point for
reader methods which tries to infer the appropriate format from the file extension.
<tt class="xref py py-meth docutils literal"><span class="pre">Graph.save()</span></tt> is the opposite of <tt class="xref py py-func docutils literal"><span class="pre">load()</span></tt>: it lets you save a graph where
the preferred format is again inferred from the extension. The format detection of
<tt class="xref py py-func docutils literal"><span class="pre">load()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">Graph.save()</span></tt> can be overridden by the <tt class="docutils literal"><span class="pre">format</span></tt> keyword
argument which accepts the short names of the formats from the above table:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">karate</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="s">&quot;karate.GraphML&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">karate</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&quot;karate.net&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">karate</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&quot;karate.my_extension&quot;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&quot;gml&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="where-to-go-next">
<h2>Where to go next<a class="headerlink" href="#where-to-go-next" title="Permalink to this headline">¶</a></h2>
<p>This tutorial was only scratching the surface of what <em>igraph</em> can do.  My
long-term plans are to extend this tutorial into a proper manual-style
documentation to <em>igraph</em> in the next chapters. In the meanwhile, check out the
full <a class="reference external" href="http://igraph.org/doc/python/">API documentation</a> which should provide information about almost every
<em>igraph</em> class, function or method. A good starting point is the documentation
of the <a class="reference external" href="http://igraph.org/doc/python/igraph.Graph-class.html">Graph class</a>. Should you get stuck, drop a mail to the <a class="reference external" href="http://lists.nongnu.org/mailman/listinfo/igraph-help">igraph mailing
list</a> - maybe there is someone out there who can help you out immediately.</p>
</div>
</div>


      </div>
    </div>
  </div>
</div>




    </div>

    <div id="footer"><div class="container">
      <div class="row">
        <div class="col-xs-12">
          <p class="text-muted credit">
	    &copy; 2003 &ndash; 2015 The igraph core team.
            &bull; Code licensed under 
            <a href="http://www.gnu.org/licenses/gpl-2.0.html">
            GNU GPL 2</a> or later, documentation under 
            <a href="http://www.gnu.org/copyleft/fdl.html">
              GNU FDL.</a>
            <!-- &bull; <a href="">Download old releases</a> -->
            <!-- &bull; <a href="">Old documentation</a> -->
            <!-- &bull; <a href="">Authors</a> -->
            <!-- &bull; <a href="">Tools</a> -->
            <!-- &bull; <a href="">Papers citing igraph</a> -->
          </p>
        </div>
      </div>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/js/jquery-2.0.3.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/affix.js"></script>
    <script src="/js/tooltips.js"></script>
    <script src="/js/toggle.js"></script>

    <script src="_static/js/jquery-fix.js"></script> <script src="_static/bootstrap-sphinx.js"></script>

    <!-- Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-1392972-5', 'igraph.org');
      ga('send', 'pageview');
    </script>

  </body>
</html>
