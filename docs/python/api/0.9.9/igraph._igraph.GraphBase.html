




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>python-igraph API reference</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/fontawesome.min.css" integrity="sha384-QYIZto+st3yW+o8+5OHfT6S482Zsvz2WfOzpFSXMF9zqeLcFV0/wlZpMtyFcZALm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/solid.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/brands.min.css">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DY4MJME11Z"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-DY4MJME11Z');
	</script>

    <link href="/css/pydoctor.css" rel="stylesheet">
  </head>

  <body class="python">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/python/versions/latest">python-igraph</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            0.9.9
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="https://r.igraph.org">igraph R package</a>
              <a class="dropdown-item" href="https://python.igraph.org">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa-brands fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa-solid fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa-solid fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa-solid fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa-brands fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">python-igraph API reference</h1>
        <p class="lead">List of all classes, functions and methods in python-igraph</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container bs-docs-container">
<div class="row">
  <div class="col-md-12">
  <div class="bs-docs-section">

    
<div<body>

    <nav class="pydoctor-navbar navbar-default">
      <div class="container">
        <div class="navbar-header navbar-brand">
          <a href="https://igraph.org/python">igraph</a>
          <a href="index.html">API Documentation</a>
        </div>
      </div>
    </nav>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><code><a href="igraph.html">igraph</a></code>.<code><a href="igraph._igraph.html">_igraph</a></code>.<code><a href="igraph._igraph.GraphBase.html">GraphBase</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> <span class="py-defname">GraphBase</span>:</code></p><p>Known subclasses: <code><a href="igraph.Graph.html">igraph.Graph</a></code></p>
        <p><a href="classIndex.html#igraph._igraph.GraphBase">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p>Low-level representation of a graph.</p><p>Don't use it directly, use <code><a href="igraph.Graph.html">igraph.Graph</a></code> instead.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Unknown Field: deffield</td><td class="fieldArg">ref</td><td>Reference</td></tr></table></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id10">
  
  <tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__new__">__new__</a></code></td>
    <td><span>Create and return a new object.  See help(type) for accurate signature.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#vcount">vcount</a></code></td>
    <td><span>Counts the number of vertices.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#ecount">ecount</a></code></td>
    <td><span>Counts the number of edges.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_dag">is_dag</a></code></td>
    <td><span>Checks whether the graph is a DAG (directed acyclic graph).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_directed">is_directed</a></code></td>
    <td><span>Checks whether the graph is directed.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_simple">is_simple</a></code></td>
    <td><span>Checks whether the graph is simple (no loop or multiple edges).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_tree">is_tree</a></code></td>
    <td><span>Checks whether the graph is a (directed or undirected) tree graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add_vertices">add_vertices</a></code></td>
    <td><span>Adds vertices to the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#delete_vertices">delete_vertices</a></code></td>
    <td><span>Deletes vertices and all its edges from the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add_edges">add_edges</a></code></td>
    <td><span>Adds edges to the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#delete_edges">delete_edges</a></code></td>
    <td><span>Removes edges from the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#degree">degree</a></code></td>
    <td><span>Returns some vertex degrees from the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#strength">strength</a></code></td>
    <td><span>Returns the strength (weighted degree) of some vertices from the graph</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_loop">is_loop</a></code></td>
    <td><span>Checks whether a specific set of edges contain loop edges</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_multiple">is_multiple</a></code></td>
    <td><span>Checks whether an edge is a multiple edge.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#has_multiple">has_multiple</a></code></td>
    <td><span>Checks whether the graph has multiple edges.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_mutual">is_mutual</a></code></td>
    <td><span>Checks whether an edge has an opposite pair.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#count_multiple">count_multiple</a></code></td>
    <td><span>Counts the multiplicities of the given edges.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#neighbors">neighbors</a></code></td>
    <td><span>Returns adjacent vertices to a given vertex.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#successors">successors</a></code></td>
    <td><span>Returns the successors of a given vertex.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#predecessors">predecessors</a></code></td>
    <td><span>Returns the predecessors of a given vertex.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_eid">get_eid</a></code></td>
    <td><span>Returns the edge ID of an arbitrary edge between vertices v1 and v2</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_eids">get_eids</a></code></td>
    <td><span>Returns the edge IDs of some edges between some vertices.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#incident">incident</a></code></td>
    <td><span>Returns the edges a given vertex is incident on.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Adjacency">Adjacency</a></code></td>
    <td><span>Generates a graph from its adjacency matrix.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Asymmetric_Preference">Asymmetric_Preference</a></code></td>
    <td><span>Generates a graph based on asymmetric vertex types and connection probabilities.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Atlas">Atlas</a></code></td>
    <td><span>Generates a graph from the Graph Atlas.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Barabasi">Barabasi</a></code></td>
    <td><span>Generates a graph based on the Barabasi-Albert model.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#De_Bruijn">De_Bruijn</a></code></td>
    <td><span>Generates a de Bruijn graph with parameters (m, n)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Establishment">Establishment</a></code></td>
    <td><span>Generates a graph based on a simple growing model with vertex types.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Erdos_Renyi">Erdos_Renyi</a></code></td>
    <td><span>Generates a graph based on the Erdos-Renyi model.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Famous">Famous</a></code></td>
    <td><span>Generates a famous graph based on its name.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Forest_Fire">Forest_Fire</a></code></td>
    <td><span>Generates a graph based on the forest fire model</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Full_Citation">Full_Citation</a></code></td>
    <td><span>Generates a full citation graph</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Full">Full</a></code></td>
    <td><span>Generates a full graph (directed or undirected, with or without loops).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Growing_Random">Growing_Random</a></code></td>
    <td><span>Generates a growing random graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Kautz">Kautz</a></code></td>
    <td><span>Generates a Kautz graph with parameters (m, n)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#K_Regular">K_Regular</a></code></td>
    <td><span>Generates a k-regular random graph</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Preference">Preference</a></code></td>
    <td><span>Generates a graph based on vertex types and connection probabilities.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Recent_Degree">Recent_Degree</a></code></td>
    <td><span>Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#SBM">SBM</a></code></td>
    <td><span>Generates a graph based on a stochastic blockmodel.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Star">Star</a></code></td>
    <td><span>Generates a star graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Lattice">Lattice</a></code></td>
    <td><span>Generates a regular lattice.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#LCF">LCF</a></code></td>
    <td><span>Generates a graph from LCF notation.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Realize_Degree_Sequence">Realize_Degree_Sequence</a></code></td>
    <td><span>Generates a graph from a degree sequence.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Ring">Ring</a></code></td>
    <td><span>Generates a ring graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Static_Fitness">Static_Fitness</a></code></td>
    <td><span>Generates a non-growing graph with edge probabilities proportional to node fitnesses.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Static_Power_Law">Static_Power_Law</a></code></td>
    <td><span>Generates a non-growing graph with prescribed power-law degree distributions.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Tree">Tree</a></code></td>
    <td><span>Generates a tree in which almost all vertices have the same number of children.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Degree_Sequence">Degree_Sequence</a></code></td>
    <td><span>Generates a graph with a given degree sequence.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Isoclass">Isoclass</a></code></td>
    <td><span>Generates a graph with a given isomorphism class.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Tree_Game">Tree_Game</a></code></td>
    <td><span>Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Watts_Strogatz">Watts_Strogatz</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Weighted_Adjacency">Weighted_Adjacency</a></code></td>
    <td><span>Generates a graph from its adjacency matrix.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#are_connected">are_connected</a></code></td>
    <td><span>Decides whether two given vertices are directly connected.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#articulation_points">articulation_points</a></code></td>
    <td><span>Returns the list of articulation points in the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#assortativity">assortativity</a></code></td>
    <td><span>Returns the assortativity of the graph based on numeric properties of the vertices.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#assortativity_degree">assortativity_degree</a></code></td>
    <td><span>Returns the assortativity of a graph based on vertex degrees.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#assortativity_nominal">assortativity_nominal</a></code></td>
    <td><span>Returns the assortativity of the graph based on vertex categories.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#average_path_length">average_path_length</a></code></td>
    <td><span>Calculates the average path length in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#authority_score">authority_score</a></code></td>
    <td><span>Calculates Kleinberg's authority score for the vertices of the graph</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#betweenness">betweenness</a></code></td>
    <td><span>Calculates or estimates the betweenness of vertices in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#biconnected_components">biconnected_components</a></code></td>
    <td><span>Calculates the biconnected components of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bipartite_projection">bipartite_projection</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bipartite_projection_size">bipartite_projection_size</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bridges">bridges</a></code></td>
    <td><span>Returns the list of bridges in the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#chordal_completion">chordal_completion</a></code></td>
    <td><span>chordal_complation(alpha=None, alpham1=None) --</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#closeness">closeness</a></code></td>
    <td><span>Calculates the closeness centralities of given vertices in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#harmonic_centrality">harmonic_centrality</a></code></td>
    <td><span>Calculates the harmonic centralities of given vertices in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#clusters">clusters</a></code></td>
    <td><span>Calculates the (strong or weak) clusters for a given graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#copy">copy</a></code></td>
    <td><span>Creates a copy of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#decompose">decompose</a></code></td>
    <td><span>Decomposes the graph into subgraphs.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#contract_vertices">contract_vertices</a></code></td>
    <td><span>Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#constraint">constraint</a></code></td>
    <td><span>Calculates Burt's constraint scores for given vertices in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#density">density</a></code></td>
    <td><span>Calculates the density of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#diameter">diameter</a></code></td>
    <td><span>Calculates the diameter of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_diameter">get_diameter</a></code></td>
    <td><span>Returns a path with the actual diameter of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#farthest_points">farthest_points</a></code></td>
    <td><span>Returns two vertex IDs whose distance equals the actual diameter of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#diversity">diversity</a></code></td>
    <td><span>Calculates the structural diversity index of the vertices.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#eccentricity">eccentricity</a></code></td>
    <td><span>Calculates the eccentricities of given vertices in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#edge_betweenness">edge_betweenness</a></code></td>
    <td><span>Calculates or estimates the edge betweennesses in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#eigen_adjacency">eigen_adjacency</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#edge_connectivity">edge_connectivity</a></code></td>
    <td><span>Calculates the edge connectivity of the graph or between some vertices.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#eigenvector_centrality">eigenvector_centrality</a></code></td>
    <td><span>Calculates the eigenvector centralities of the vertices in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#feedback_arc_set">feedback_arc_set</a></code></td>
    <td><span>Calculates an approximately or exactly minimal feedback arc set.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_shortest_paths">get_shortest_paths</a></code></td>
    <td><span>Calculates the shortest paths from/to a given node in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_all_shortest_paths">get_all_shortest_paths</a></code></td>
    <td><span>Calculates all of the shortest paths from/to a given node in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#girth">girth</a></code></td>
    <td><span>Returns the girth of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#convergence_degree">convergence_degree</a></code></td>
    <td><span>Undocumented (yet).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#convergence_field_size">convergence_field_size</a></code></td>
    <td><span>Undocumented (yet).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#hub_score">hub_score</a></code></td>
    <td><span>Calculates Kleinberg's hub score for the vertices of the graph</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#induced_subgraph">induced_subgraph</a></code></td>
    <td><span>Returns a subgraph spanned by the given vertices.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_bipartite">is_bipartite</a></code></td>
    <td><span>Decides whether the graph is bipartite or not.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_chordal">is_chordal</a></code></td>
    <td><span>Returns whether the graph is chordal or not.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#knn">knn</a></code></td>
    <td><span>Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_connected">is_connected</a></code></td>
    <td><span>Decides whether the graph is connected.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#linegraph">linegraph</a></code></td>
    <td><span>Returns the line graph of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maxdegree">maxdegree</a></code></td>
    <td><span>Returns the maximum degree of a vertex set in the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maximum_cardinality_search">maximum_cardinality_search</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#neighborhood">neighborhood</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#neighborhood_size">neighborhood_size</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#personalized_pagerank">personalized_pagerank</a></code></td>
    <td><span>Calculates the personalized PageRank values of a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#path_length_hist">path_length_hist</a></code></td>
    <td><span>Calculates the path length histogram of the graph @attention: this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html">Graph</a></code>. It is advised to use that instead of this version.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#permute_vertices">permute_vertices</a></code></td>
    <td><span>Permutes the vertices of the graph according to the given permutation and returns the new graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#radius">radius</a></code></td>
    <td><span>Calculates the radius of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#reciprocity">reciprocity</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#rewire">rewire</a></code></td>
    <td><span>Randomly rewires the graph while preserving the degree distribution.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#rewire_edges">rewire_edges</a></code></td>
    <td><span>Rewires the edges of a graph with constant probability.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#shortest_paths">shortest_paths</a></code></td>
    <td><span>Calculates shortest path lengths for given vertices in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#simplify">simplify</a></code></td>
    <td><span>Simplifies a graph by removing self-loops and/or multiple edges.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#subcomponent">subcomponent</a></code></td>
    <td><span>Determines the indices of vertices which are in the same component as a given vertex.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#subgraph_edges">subgraph_edges</a></code></td>
    <td><span>Returns a subgraph spanned by the given edges.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#topological_sorting">topological_sorting</a></code></td>
    <td><span>Calculates a possible topological sorting of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#to_prufer">to_prufer</a></code></td>
    <td><span>Converts a tree graph into a Prufer sequence.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#transitivity_undirected">transitivity_undirected</a></code></td>
    <td><span>Calculates the global transitivity (clustering coefficient) of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#transitivity_local_undirected">transitivity_local_undirected</a></code></td>
    <td><span>Calculates the local transitivity (clustering coefficient) of the given vertices in the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#transitivity_avglocal_undirected">transitivity_avglocal_undirected</a></code></td>
    <td><span>Calculates the average of the vertex transitivities of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#unfold_tree">unfold_tree</a></code></td>
    <td><span>Unfolds the graph using a BFS to a tree by duplicating vertices as necessary.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#vertex_connectivity">vertex_connectivity</a></code></td>
    <td><span>Calculates the vertex connectivity of the graph or between some vertices.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bibcoupling">bibcoupling</a></code></td>
    <td><span>Calculates bibliographic coupling scores for given vertices in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#cocitation">cocitation</a></code></td>
    <td><span>Calculates cocitation scores for given vertices in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#similarity_dice">similarity_dice</a></code></td>
    <td><span>Dice similarity coefficient of vertices.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#similarity_inverse_log_weighted">similarity_inverse_log_weighted</a></code></td>
    <td><span>Inverse log-weighted similarity coefficient of vertices.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#similarity_jaccard">similarity_jaccard</a></code></td>
    <td><span>Jaccard similarity coefficient of vertices.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#motifs_randesu">motifs_randesu</a></code></td>
    <td><span>Counts the number of motifs in the graph</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#motifs_randesu_no">motifs_randesu_no</a></code></td>
    <td><span>Counts the total number of motifs in the graph</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#motifs_randesu_estimate">motifs_randesu_estimate</a></code></td>
    <td><span>Counts the total number of motifs in the graph</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#dyad_census">dyad_census</a></code></td>
    <td><span>Dyad census, as defined by Holland and Leinhardt</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#triad_census">triad_census</a></code></td>
    <td><span>Triad census, as defined by Davis and Leinhardt</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_bipartite">layout_bipartite</a></code></td>
    <td><span>Place the vertices of a bipartite graph in two layers.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_circle">layout_circle</a></code></td>
    <td><span>Places the vertices of the graph uniformly on a circle or a sphere.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_grid">layout_grid</a></code></td>
    <td><span>Places the vertices of a graph in a 2D or 3D grid.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_star">layout_star</a></code></td>
    <td><span>Calculates a star-like layout for the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_kamada_kawai">layout_kamada_kawai</a></code></td>
    <td><span>Places the vertices on a plane according to the Kamada-Kawai algorithm.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_davidson_harel">layout_davidson_harel</a></code></td>
    <td><span>Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_drl">layout_drl</a></code></td>
    <td><span>Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_fruchterman_reingold">layout_fruchterman_reingold</a></code></td>
    <td><span>Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_graphopt">layout_graphopt</a></code></td>
    <td><span>This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_lgl">layout_lgl</a></code></td>
    <td><span>Places the vertices on a 2D plane according to the Large Graph Layout.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_mds">layout_mds</a></code></td>
    <td><span>Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_reingold_tilford">layout_reingold_tilford</a></code></td>
    <td><span>Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_reingold_tilford_circular">layout_reingold_tilford_circular</a></code></td>
    <td><span>Circular Reingold-Tilford layout for trees.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_random">layout_random</a></code></td>
    <td><span>Places the vertices of the graph randomly.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bfs">bfs</a></code></td>
    <td><span>Conducts a breadth first search (BFS) on the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bfsiter">bfsiter</a></code></td>
    <td><span>Constructs a breadth first search (BFS) iterator of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#dfsiter">dfsiter</a></code></td>
    <td><span>Constructs a depth first search (DFS) iterator of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_adjacency">get_adjacency</a></code></td>
    <td><span>Returns the adjacency matrix of a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_edgelist">get_edgelist</a></code></td>
    <td><span>Returns the edge list of a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_incidence">get_incidence</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#to_directed">to_directed</a></code></td>
    <td><span>Converts an undirected graph to directed.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#to_undirected">to_undirected</a></code></td>
    <td><span>Converts a directed graph to undirected.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#laplacian">laplacian</a></code></td>
    <td><span>Returns the Laplacian matrix of a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_DIMACS">Read_DIMACS</a></code></td>
    <td><span>Reads a graph from a file conforming to the DIMACS minimum-cost flow file format.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_DL">Read_DL</a></code></td>
    <td><span>Reads an UCINET DL file and creates a graph based on it.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_Edgelist">Read_Edgelist</a></code></td>
    <td><span>Reads an edge list from a file and creates a graph based on it.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_GraphDB">Read_GraphDB</a></code></td>
    <td><span>Reads a GraphDB format file and creates a graph based on it.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_GraphML">Read_GraphML</a></code></td>
    <td><span>Reads a GraphML format file and creates a graph based on it.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_GML">Read_GML</a></code></td>
    <td><span>Reads a GML file and creates a graph based on it.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_Ncol">Read_Ncol</a></code></td>
    <td><span>Reads an .ncol file used by LGL.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_Lgl">Read_Lgl</a></code></td>
    <td><span>Reads an .lgl file used by LGL.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_Pajek">Read_Pajek</a></code></td>
    <td><span>Reads a Pajek format file and creates a graph based on it.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_dimacs">write_dimacs</a></code></td>
    <td><span>Writes the graph in DIMACS format to the given file.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_dot">write_dot</a></code></td>
    <td><span>Writes the graph in DOT format to the given file.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_edgelist">write_edgelist</a></code></td>
    <td><span>Writes the edge list of a graph to a file.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_gml">write_gml</a></code></td>
    <td><span>Writes the graph in GML format to the given file.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_ncol">write_ncol</a></code></td>
    <td><span>Writes the edge list of a graph to a file in .ncol format.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_lgl">write_lgl</a></code></td>
    <td><span>Writes the edge list of a graph to a file in .lgl format.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_pajek">write_pajek</a></code></td>
    <td><span>Writes the graph in Pajek format to the given file.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_graphml">write_graphml</a></code></td>
    <td><span>Writes the graph to a GraphML file.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_leda">write_leda</a></code></td>
    <td><span>Writes the graph to a file in LEDA native format.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#canonical_permutation">canonical_permutation</a></code></td>
    <td><span>Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#isoclass">isoclass</a></code></td>
    <td><span>Returns the isomorphism class of the graph or its subgraph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#isomorphic">isomorphic</a></code></td>
    <td><span>Checks whether the graph is isomorphic to another graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#isomorphic_bliss">isomorphic_bliss</a></code></td>
    <td><span>Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#isomorphic_vf2">isomorphic_vf2</a></code></td>
    <td><span>Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#count_isomorphisms_vf2">count_isomorphisms_vf2</a></code></td>
    <td><span>Determines the number of isomorphisms between the graph and another one</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_isomorphisms_vf2">get_isomorphisms_vf2</a></code></td>
    <td><span>Returns all isomorphisms between the graph and another one</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#subisomorphic_vf2">subisomorphic_vf2</a></code></td>
    <td><span>Checks whether a subgraph of the graph is isomorphic to another graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#count_subisomorphisms_vf2">count_subisomorphisms_vf2</a></code></td>
    <td><span>Determines the number of subisomorphisms between the graph and another one</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_subisomorphisms_vf2">get_subisomorphisms_vf2</a></code></td>
    <td><span>Returns all subisomorphisms between the graph and another one</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#subisomorphic_lad">subisomorphic_lad</a></code></td>
    <td><span>Checks whether a subgraph of the graph is isomorphic to another graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_subisomorphisms_lad">get_subisomorphisms_lad</a></code></td>
    <td><span>Returns all subisomorphisms between the graph and another one using the LAD algorithm.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#attributes">attributes</a></code></td>
    <td><span></span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#vertex_attributes">vertex_attributes</a></code></td>
    <td><span></span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#edge_attributes">edge_attributes</a></code></td>
    <td><span></span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#complementer">complementer</a></code></td>
    <td><span>Returns the complementer of the graph</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#compose">compose</a></code></td>
    <td><span>Returns the composition of two graphs.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#difference">difference</a></code></td>
    <td><span>Subtracts the given graph from the original</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#dominator">dominator</a></code></td>
    <td><span>Returns the dominator tree from the given root node</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maxflow_value">maxflow_value</a></code></td>
    <td><span>Returns the value of the maximum flow between the source and target vertices.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maxflow">maxflow</a></code></td>
    <td><span>Returns the maximum flow between the source and target vertices.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#all_st_cuts">all_st_cuts</a></code></td>
    <td><span>Returns all the cuts between the source and target vertices in a directed graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#all_st_mincuts">all_st_mincuts</a></code></td>
    <td><span>Returns all minimum cuts between the source and target vertices in a directed graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#mincut_value">mincut_value</a></code></td>
    <td><span>Returns the minimum cut between the source and target vertices or within the whole graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#mincut">mincut</a></code></td>
    <td><span>Calculates the minimum cut between the source and target vertices or within the whole graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#st_mincut">st_mincut</a></code></td>
    <td><span>Calculates the minimum cut between the source and target vertices in a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#gomory_hu_tree">gomory_hu_tree</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#all_minimal_st_separators">all_minimal_st_separators</a></code></td>
    <td><span>Returns a list containing all the minimal s-t separators of a graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_minimal_separator">is_minimal_separator</a></code></td>
    <td><span>Decides whether the given vertex set is a minimal separator.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_separator">is_separator</a></code></td>
    <td><span>Decides whether the removal of the given vertices disconnects the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#minimum_size_separators">minimum_size_separators</a></code></td>
    <td><span>Returns a list containing all separator vertex sets of minimum size.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#cohesive_blocks">cohesive_blocks</a></code></td>
    <td><span>Calculates the cohesive block structure of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#cliques">cliques</a></code></td>
    <td><span>Returns some or all cliques of the graph as a list of tuples.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#largest_cliques">largest_cliques</a></code></td>
    <td><span>Returns the largest cliques of the graph as a list of tuples.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maximal_cliques">maximal_cliques</a></code></td>
    <td><span>Returns the maximal cliques of the graph as a list of tuples.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#clique_number">clique_number</a></code></td>
    <td><span>Returns the clique number of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#independent_vertex_sets">independent_vertex_sets</a></code></td>
    <td><span>Returns some or all independent vertex sets of the graph as a list of tuples.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#largest_independent_vertex_sets">largest_independent_vertex_sets</a></code></td>
    <td><span>Returns the largest independent vertex sets of the graph as a list of tuples.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maximal_independent_vertex_sets">maximal_independent_vertex_sets</a></code></td>
    <td><span>Returns the maximal independent vertex sets of the graph as a list of tuples.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#independence_number">independence_number</a></code></td>
    <td><span>Returns the independence number of the graph.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#modularity">modularity</a></code></td>
    <td><span>Calculates the modularity of the graph with respect to some vertex types.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#coreness">coreness</a></code></td>
    <td><span>Finds the coreness (shell index) of the vertices of the network.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_fastgreedy">community_fastgreedy</a></code></td>
    <td><span>Finds the community structure of the graph according to the algorithm of Clauset et al based on the greedy optimization of modularity.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_infomap">community_infomap</a></code></td>
    <td><span>Finds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_label_propagation">community_label_propagation</a></code></td>
    <td><span>Finds the community structure of the graph according to the label propagation method of Raghavan et al.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_leading_eigenvector">community_leading_eigenvector</a></code></td>
    <td><span>A proper implementation of Newman's eigenvector community structure detection. Each split is done by maximizing the modularity regarding the original network. See the reference for details.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_multilevel">community_multilevel</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_edge_betweenness">community_edge_betweenness</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_optimal_modularity">community_optimal_modularity</a></code></td>
    <td><span>Calculates the optimal modularity score of the graph and the corresponding community structure.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_spinglass">community_spinglass</a></code></td>
    <td><span>Finds the community structure of the graph according to the spinglass community detection method of Reichardt &amp; Bornholdt.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_leiden">community_leiden</a></code></td>
    <td><span>Finds the community structure of the graph using the Leiden algorithm of Traag, van Eck &amp; Waltman.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_walktrap">community_walktrap</a></code></td>
    <td><span>Finds the community structure of the graph according to the random walk method of Latapy &amp; Pons.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#random_walk">random_walk</a></code></td>
    <td><span>Performs a random walk of a given length from a given node.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_Bipartite">_Bipartite</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_Full_Bipartite">_Full_Bipartite</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_GRG">_GRG</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_Incidence">_Incidence</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_Random_Bipartite">_Random_Bipartite</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_get_all_simple_paths">_get_all_simple_paths</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_spanning_tree">_spanning_tree</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_layout_sugiyama">_layout_sugiyama</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_is_matching">_is_matching</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_is_maximal_matching">_is_maximal_matching</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_maximum_bipartite_matching">_maximum_bipartite_matching</a></code></td>
    <td><span>Internal function, undocumented.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#__graph_as_capsule">__graph_as_capsule</a></code></td>
    <td><span>__graph_as_capsule()</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_raw_pointer">_raw_pointer</a></code></td>
    <td><span>Returns the memory address of the igraph graph encapsulated by the Python object as an ordinary Python integer.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#__register_destructor">__register_destructor</a></code></td>
    <td><span>Registers a destructor to be called when the object is freed by Python. This function should not be used directly by igraph users.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.__new__">
    
  </a>
  <a name="__new__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__new__</span>(*args, **kwargs):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Create and return a new object.  See help(type) for accurate signature.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.vcount">
    
  </a>
  <a name="vcount">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">vcount</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Counts the number of vertices.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the number of vertices in the graph. (type: integer)</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.ecount">
    
  </a>
  <a name="ecount">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">ecount</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Counts the number of edges.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the number of edges in the graph. (type: integer)</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.is_dag">
    
  </a>
  <a name="is_dag">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_dag</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether the graph is a DAG (directed acyclic graph).</p><p>A DAG is a directed graph with no directed cycles.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>True</code> if it is a DAG, <code>False</code> otherwise. (type: boolean)</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.is_directed">
    
  </a>
  <a name="is_directed">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_directed</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether the graph is directed.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>True</code> if it is directed, <code>False</code> otherwise. (type: boolean)</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.is_simple">
    
  </a>
  <a name="is_simple">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_simple</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether the graph is simple (no loop or multiple edges).</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>True</code> if it is simple, <code>False</code> otherwise. (type: boolean)</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.is_tree">
    
  </a>
  <a name="is_tree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_tree</span>(mode='out'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether the graph is a (directed or undirected) tree graph.</p><p>For directed trees, the function may require that the edges are oriented outwards from the root or inwards to the root, depending on the value of the <code>mode</code> argument.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mode</td><td>for directed graphs, specifies how the edge directions should be taken into account. <code>"all"</code> means that the edge directions must be ignored, <code>"out"</code> means that the edges must be oriented away from the root, <code>"in"</code> means that the edges must be oriented towards the root. Ignored for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>True</code> if the graph is a tree, <code>False</code> otherwise. (type: boolean)</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.add_vertices">
    
  </a>
  <a name="add_vertices">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">add_vertices</span>(n):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Adds vertices to the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices to be added</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.delete_vertices">
    
  </a>
  <a name="delete_vertices">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">delete_vertices</span>(vs):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Deletes vertices and all its edges from the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vs</td><td>a single vertex ID or the list of vertex IDs to be deleted. No argument deletes all vertices.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.add_edges">
    
  </a>
  <a name="add_edges">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">add_edges</span>(es):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Adds edges to the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">es</td><td>the list of edges to be added. Every edge is represented with a tuple, containing the vertex IDs of the two endpoints. Vertices are enumerated from zero.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.delete_edges">
    
  </a>
  <a name="delete_edges">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">delete_edges</span>(es):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Removes edges from the graph.</p><p>All vertices will be kept, even if they lose all their edges. Nonexistent edges will be silently ignored.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">es</td><td>the list of edges to be removed. Edges are identifed by edge IDs. <code><a href="igraph._igraph.EdgeSeq.html">EdgeSeq</a></code> objects are also accepted here. No argument deletes all edges.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.degree">
    
  </a>
  <a name="degree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">degree</span>(vertices, mode='all', loops=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns some vertex degrees from the graph.</p><p>This method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the degree of the given vertices (in the form of a single integer or a list, depending on the input parameter).</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>a single vertex ID or a list of vertex IDs</td></tr><tr><td></td><td class="fieldArg">mode</td><td>the type of degree to be returned (<code>"out"</code> for out-degrees, <code>"in"</code> for in-degrees or <code>"all"</code> for the sum of them).</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether self-loops should be counted.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.strength">
    
  </a>
  <a name="strength">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">strength</span>(vertices, mode='all', loops=True, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the strength (weighted degree) of some vertices from the graph</p><p>This method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the strength (that is, the sum of the weights of all incident edges) of the given vertices (in the form of a single integer or a list, depending on the input parameter).</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>a single vertex ID or a list of vertex IDs</td></tr><tr><td></td><td class="fieldArg">mode</td><td>the type of degree to be returned (<code>"out"</code> for out-degrees, <code>"in"</code> for in-degrees or <code>"all"</code> for the sum of them).</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether self-loops should be counted.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name. ``None`` means to treat the graph as unweighted, falling back to ordinary degree calculations.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.is_loop">
    
  </a>
  <a name="is_loop">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_loop</span>(edges=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether a specific set of edges contain loop edges</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">edges</td><td>edge indices which we want to check. If <code>None</code>, all edges are checked.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list of booleans, one for every edge given</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.is_multiple">
    
  </a>
  <a name="is_multiple">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_multiple</span>(edges=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether an edge is a multiple edge.</p><p>Also works for a set of edges -- in this case, every edge is checked one by one. Note that if there are multiple edges going between a pair of vertices, there is always one of them that is <i>not</i> reported as multiple (only the others). This allows one to easily detect the edges that have to be deleted in order to make the graph free of multiple edges.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">edges</td><td>edge indices which we want to check. If <code>None</code>, all edges are checked.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list of booleans, one for every edge given</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.has_multiple">
    
  </a>
  <a name="has_multiple">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">has_multiple</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether the graph has multiple edges.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>True</code> if the graph has at least one multiple edge, <code>False</code> otherwise. (type: boolean)</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.is_mutual">
    
  </a>
  <a name="is_mutual">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_mutual</span>(edges=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether an edge has an opposite pair.</p><p>Also works for a set of edges -- in this case, every edge is checked one by one. The result will be a list of booleans (or a single boolean if only an edge index is supplied), every boolean corresponding to an edge in the edge set supplied. <code>True</code> is returned for a given edge <i class="math">a</i> --&gt; <i class="math">b</i> if there exists another edge <i class="math">b</i> --&gt; <i class="math">a</i> in the original graph (not the given edge set!). All edges in an undirected graph are mutual. In case there are multiple edges between <i class="math">a</i> and <i class="math">b</i>, it is enough to have at least one edge in either direction to report all edges between them as mutual, so the multiplicity of edges do not matter.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">edges</td><td>edge indices which we want to check. If <code>None</code>, all edges are checked.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list of booleans, one for every edge given</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.count_multiple">
    
  </a>
  <a name="count_multiple">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">count_multiple</span>(edges=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Counts the multiplicities of the given edges.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">edges</td><td>edge indices for which we want to count their multiplicity. If <code>None</code>, all edges are counted.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the multiplicities of the given edges as a list.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.neighbors">
    
  </a>
  <a name="neighbors">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">neighbors</span>(vertex, mode='all'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns adjacent vertices to a given vertex.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertex</td><td>a vertex ID</td></tr><tr><td></td><td class="fieldArg">mode</td><td>whether to return only successors (<code>"out"</code>), predecessors (<code>"in"</code>) or both (<code>"all"</code>). Ignored for undirected graphs.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.successors">
    
  </a>
  <a name="successors">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">successors</span>(vertex):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the successors of a given vertex.</p><p>Equivalent to calling the <code><a href="#neighbors">neighbors()</a></code> method with type=<code>"out"</code>.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.predecessors">
    
  </a>
  <a name="predecessors">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">predecessors</span>(vertex):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the predecessors of a given vertex.</p><p>Equivalent to calling the <code><a href="#neighbors">neighbors()</a></code> method with type=<code>"in"</code>.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.get_eid">
    
  </a>
  <a name="get_eid">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_eid</span>(v1, v2, directed=True, error=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the edge ID of an arbitrary edge between vertices v1 and v2</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">v1</td><td>the ID or name of the first vertex</td></tr><tr><td></td><td class="fieldArg">v2</td><td>the ID or name of the second vertex</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether edge directions should be considered in directed graphs. The default is <code>True</code>. Ignored for undirected graphs.</td></tr><tr><td></td><td class="fieldArg">error</td><td>if <code>True</code>, an exception will be raised when the given edge does not exist. If <code>False</code>, -1 will be returned in that case.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the edge ID of an arbitrary edge between vertices v1 and v2</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.get_eids">
    
  </a>
  <a name="get_eids">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_eids</span>(pairs=None, path=None, directed=True, error=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the edge IDs of some edges between some vertices.</p><p>This method can operate in two different modes, depending on which of the keyword arguments <code>pairs</code> and <code>path</code> are given.</p><p>The method does not consider multiple edges; if there are multiple edges between a pair of vertices, only the ID of one of the edges is returned.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">pairs</td><td>a list of integer pairs. Each integer pair is considered as a source-target vertex pair; the corresponding edge is looked up in the graph and the edge ID is returned for each pair.</td></tr><tr><td></td><td class="fieldArg">path</td><td>a list of vertex IDs. The list is considered as a continuous path from the first vertex to the last, passing through the intermediate vertices. The corresponding edge IDs between the first and the second, the second and the third and so on are looked up in the graph and the edge IDs are returned. If both <code>path</code> and <code>pairs</code> are given, the two lists are concatenated.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether edge directions should be considered in directed graphs. The default is <code>True</code>. Ignored for undirected graphs.</td></tr><tr><td></td><td class="fieldArg">error</td><td>if <code>True</code>, an exception will be raised if a given edge does not exist. If <code>False</code>, -1 will be returned in that case.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the edge IDs in a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.incident">
    
  </a>
  <a name="incident">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">incident</span>(vertex, mode='out'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the edges a given vertex is incident on.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertex</td><td>a vertex ID</td></tr><tr><td></td><td class="fieldArg">mode</td><td>whether to return only successors (<code>"out"</code>), predecessors (<code>"in"</code>) or both (<code>"all"</code>). Ignored for undirected graphs.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Adjacency">
    
  </a>
  <a name="Adjacency">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Adjacency</span>(matrix, mode='directed'):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Generates a graph from its adjacency matrix.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">matrix</td><td>the adjacency matrix</td></tr><tr><td></td><td class="fieldArg">mode</td><td>the mode to be used. Possible values are:<ul><li><code>"directed"</code> - the graph will be directed and a matrix element gives the number of edges between two vertices.</li><li><code>"undirected"</code> - alias to <code>"max"</code> for convenience.</li><li><code>"max"</code>   - undirected graph will be created and the number of edges between vertex <i class="math">i</i> and <i class="math">j</i> is <i class="math">max(A(i,j), A(j,i))</i></li><li><code>"min"</code>   - like <code>"max"</code>, but with <i class="math">min(A(i,j), A(j,i))</i></li><li><code>"plus"</code>  - like <code>"max"</code>, but with <i class="math">A(i,j) + A(j,i)</i></li><li><code>"upper"</code> - undirected graph with the upper right triangle of the matrix (including the diagonal)</li><li><code>"lower"</code> - undirected graph with the lower left triangle of the matrix (including the diagonal)</li></ul></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Asymmetric_Preference">
    
  </a>
  <a name="Asymmetric_Preference">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Asymmetric_Preference</span>(n, type_dist_matrix, pref_matrix, attribute=None, loops=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph based on asymmetric vertex types and connection probabilities.</p><p>This is the asymmetric variant of <code><a href="#Preference">Preference()</a></code>. A given number of vertices are generated. Every vertex is assigned to an "incoming" and an "outgoing" vertex type according to the given joint type probabilities. Finally, every vertex pair is evaluated and a directed edge is created between them with a probability depending on the "outgoing" type of the source vertex and the "incoming" type of the target vertex.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices in the graph</td></tr><tr><td></td><td class="fieldArg">type_dist_matrix</td><td>matrix giving the joint distribution of vertex types</td></tr><tr><td></td><td class="fieldArg">pref_matrix</td><td>matrix giving the connection probabilities for different vertex types.</td></tr><tr><td></td><td class="fieldArg">attribute</td><td>the vertex attribute name used to store the vertex types. If <code>None</code>, vertex types are not stored.</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether loop edges are allowed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Atlas">
    
  </a>
  <a name="Atlas">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Atlas</span>(idx):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph from the Graph Atlas.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">idx</td><td>The index of the graph to be generated. Indices start from zero, graphs are listed:<ol><li>in increasing order of number of vertices;</li><li>for a fixed number of vertices, in increasing order of the number of edges;</li><li>for fixed numbers of vertices and edges, in increasing order of the degree sequence, for example 111223 &lt; 112222;</li><li>for fixed degree sequence, in increasing number of automorphisms.</li></ol></td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2"><i>An Atlas of Graphs</i> by Ronald C. Read and Robin J. Wilson, Oxford University Press, 1998.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Barabasi">
    
  </a>
  <a name="Barabasi">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Barabasi</span>(n, m, outpref=False, directed=False, power=1, zero_appeal=1, implementation='psumtree', start_from=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph based on the Barabasi-Albert model.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices</td></tr><tr><td></td><td class="fieldArg">m</td><td>either the number of outgoing edges generated for each vertex or a list containing the number of outgoing edges for each vertex explicitly.</td></tr><tr><td></td><td class="fieldArg">outpref</td><td><code>True</code> if the out-degree of a given vertex should also increase its citation probability (as well as its in-degree), but it defaults to <code>False</code>.</td></tr><tr><td></td><td class="fieldArg">directed</td><td><code>True</code> if the generated graph should be directed (default: <code>False</code>).</td></tr><tr><td></td><td class="fieldArg">power</td><td>the power constant of the nonlinear model. It can be omitted, and in this case the usual linear model will be used.</td></tr><tr><td></td><td class="fieldArg">zero_appeal</td><td>the attractivity of vertices with degree zero.</td></tr><tr><td></td><td class="fieldArg">implementation</td><td>the algorithm to use to generate the network. Possible values are:<ul><li><code>"bag"</code>: the algorithm that was the default in igraph before 0.6. It works by putting the ids of the vertices into a bag (multiset) exactly as many times as their in-degree, plus once more. The required number of cited vertices are then drawn from the bag with replacement. It works only for <i>power</i>=1 and <i>zero_appeal</i>=1.</li><li><code>"psumtree"</code>: this algorithm uses a partial prefix-sum tree to generate the graph. It does not generate multiple edges and it works for any values of <i>power</i> and <i>zero_appeal</i>.</li><li><code>"psumtree_multiple"</code>: similar to <code>"psumtree"</code>, but it will generate multiple edges as well. igraph before 0.6 used this algorithm for <i>power</i>s other than 1.</li></ul></td></tr><tr><td></td><td class="fieldArg">start_from</td><td>if given and not <code>None</code>, this must be another <code><a href="igraph._igraph.GraphBase.html">GraphBase</a></code> object. igraph will use this graph as a starting point for the preferential attachment model.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Barabasi, A-L and Albert, R. 1999. Emergence of scaling in random networks. Science, 286 509-512.</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase._Bipartite">
    
  </a>
  <a name="_Bipartite">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_Bipartite</span>(types, edges, directed=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.Bipartite()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.De_Bruijn">
    
  </a>
  <a name="De_Bruijn">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">De_Bruijn</span>(m, n):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a de Bruijn graph with parameters (m, n)</p><p>A de Bruijn graph represents relationships between strings. An alphabet of <i class="math">m</i> letters are used and strings of length <i class="math">n</i> are considered. A vertex corresponds to every possible string and there is a directed edge from vertex <i class="math">v</i> to vertex <i class="math">w</i> if the string of <i class="math">v</i> can be transformed into the string of <i class="math">w</i> by removing its first letter and appending a letter to it.</p><p>Please note that the graph will have <i class="math">m^n</i> vertices and even more edges, so probably you don't want to supply too big numbers for <i class="math">m</i> and <i class="math">n</i>.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">m</td><td>the size of the alphabet</td></tr><tr><td></td><td class="fieldArg">n</td><td>the length of the strings</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Establishment">
    
  </a>
  <a name="Establishment">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Establishment</span>(n, k, type_dist, pref_matrix, directed=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph based on a simple growing model with vertex types.</p><p>A single vertex is added at each time step. This new vertex tries to connect to k vertices in the graph. The probability that such a connection is realized depends on the types of the vertices involved.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices in the graph</td></tr><tr><td></td><td class="fieldArg">k</td><td>the number of connections tried in each step</td></tr><tr><td></td><td class="fieldArg">type_dist</td><td>list giving the distribution of vertex types</td></tr><tr><td></td><td class="fieldArg">pref_matrix</td><td>matrix (list of lists) giving the connection probabilities for different vertex types</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to generate a directed graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Erdos_Renyi">
    
  </a>
  <a name="Erdos_Renyi">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Erdos_Renyi</span>(n, p, m, directed=False, loops=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph based on the Erdos-Renyi model.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices.</td></tr><tr><td></td><td class="fieldArg">p</td><td>the probability of edges. If given, <code>m</code> must be missing.</td></tr><tr><td></td><td class="fieldArg">m</td><td>the number of edges. If given, <code>p</code> must be missing.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to generate a directed graph.</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether self-loops are allowed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Famous">
    
  </a>
  <a name="Famous">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Famous</span>(name):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a famous graph based on its name.</p><p>Several famous graphs are known to <code>igraph</code> including (but not limited to) the Chvatal graph, the Petersen graph or the Tutte graph. This method generates one of them based on its name (case insensitive). See the documentation of the C interface of <code>igraph</code> for the names available: <a href="https://igraph.org/c/doc" target="_top">https://igraph.org/c/doc</a>.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">name</td><td>the name of the graph to be generated.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Forest_Fire">
    
  </a>
  <a name="Forest_Fire">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Forest_Fire</span>(n, fw_prob, bw_factor=0.0, ambs=1, directed=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph based on the forest fire model</p><p>The forest fire model is a growing graph model. In every time step, a new vertex is added to the graph. The new vertex chooses an ambassador (or more than one if <i class="math">ambs&gt;1</i>) and starts a simulated forest fire at its ambassador(s). The fire spreads through the edges. The spreading probability along an edge is given by <i class="math">fw_prob</i>. The fire may also spread backwards on an edge by probability <i class="math">fw_prob * bw_factor</i>. When the fire ended, the newly added vertex connects to the vertices ``burned'' in the previous fire.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices in the graph</td></tr><tr><td></td><td class="fieldArg">fw_prob</td><td>forward burning probability</td></tr><tr><td></td><td class="fieldArg">bw_factor</td><td>ratio of backward and forward burning probability</td></tr><tr><td></td><td class="fieldArg">ambs</td><td>number of ambassadors chosen in each step</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the graph will be directed</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Full_Citation">
    
  </a>
  <a name="Full_Citation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Full_Citation</span>(n, directed=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a full citation graph</p><p>A full citation graph is a graph where the vertices are indexed from 0 to <i class="math">n-1</i> and vertex <i class="math">i</i> has a directed edge towards all vertices with an index less than <i class="math">i</i>.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to generate a directed graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Full">
    
  </a>
  <a name="Full">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Full</span>(n, directed=False, loops=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a full graph (directed or undirected, with or without loops).</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to generate a directed graph.</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether self-loops are allowed.</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase._Full_Bipartite">
    
  </a>
  <a name="_Full_Bipartite">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_Full_Bipartite</span>(n1, n2, directed=False, loops=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.Full_Bipartite()</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase._GRG">
    
  </a>
  <a name="_GRG">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_GRG</span>(n, radius, torus=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.GRG()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Growing_Random">
    
  </a>
  <a name="Growing_Random">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Growing_Random</span>(n, m, directed=False, citation=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a growing random graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>The number of vertices in the graph</td></tr><tr><td></td><td class="fieldArg">m</td><td>The number of edges to add in each step (after adding a new vertex)</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the graph should be directed.</td></tr><tr><td></td><td class="fieldArg">citation</td><td>whether the new edges should originate from the most recently added vertex.</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase._Incidence">
    
  </a>
  <a name="_Incidence">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_Incidence</span>(matrix, directed=False, mode='all', multiple=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.Incidence()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Kautz">
    
  </a>
  <a name="Kautz">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Kautz</span>(m, n):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a Kautz graph with parameters (m, n)</p><p>A Kautz graph is a labeled graph, vertices are labeled by strings of length <i class="math">n+1</i> above an alphabet with <i class="math">m+1</i> letters, with the restriction that every two consecutive letters in the string must be different. There is a directed edge from a vertex <i class="math">v</i> to another vertex <i class="math">w</i> if it is possible to transform the string of <i class="math">v</i> into the string of <i class="math">w</i> by removing the first letter and appending a letter to it.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">m</td><td>the size of the alphabet minus one</td></tr><tr><td></td><td class="fieldArg">n</td><td>the length of the strings minus one</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.K_Regular">
    
  </a>
  <a name="K_Regular">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">K_Regular</span>(n, k, directed=False, multiple=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a k-regular random graph</p><p>A k-regular random graph is a random graph where each vertex has degree k. If the graph is directed, both the in-degree and the out-degree of each vertex will be k.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>The number of vertices in the graph</td></tr><tr><td></td><td class="fieldArg">k</td><td>The degree of each vertex if the graph is undirected, or the in-degree and out-degree of each vertex if the graph is directed</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the graph should be directed.</td></tr><tr><td></td><td class="fieldArg">multiple</td><td>whether it is allowed to create multiple edges.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Preference">
    
  </a>
  <a name="Preference">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Preference</span>(n, type_dist, pref_matrix, attribute=None, directed=False, loops=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph based on vertex types and connection probabilities.</p><p>This is practically the nongrowing variant of <code><a href="#Establishment">Establishment</a></code>. A given number of vertices are generated. Every vertex is assigned to a vertex type according to the given type probabilities. Finally, every vertex pair is evaluated and an edge is created between them with a probability depending on the types of the vertices involved.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices in the graph</td></tr><tr><td></td><td class="fieldArg">type_dist</td><td>list giving the distribution of vertex types</td></tr><tr><td></td><td class="fieldArg">pref_matrix</td><td>matrix giving the connection probabilities for different vertex types.</td></tr><tr><td></td><td class="fieldArg">attribute</td><td>the vertex attribute name used to store the vertex types. If <code>None</code>, vertex types are not stored.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to generate a directed graph.</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether loop edges are allowed.</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase._Random_Bipartite">
    
  </a>
  <a name="_Random_Bipartite">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_Random_Bipartite</span>(n1, n2, p=None, m=None, directed=False, neimode='all'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.Random_Bipartite()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Recent_Degree">
    
  </a>
  <a name="Recent_Degree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Recent_Degree</span>(n, m, window, outpref=False, directed=False, power=1):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices</td></tr><tr><td></td><td class="fieldArg">m</td><td>either the number of outgoing edges generated for each vertex or a list containing the number of outgoing edges for each vertex explicitly.</td></tr><tr><td></td><td class="fieldArg">window</td><td>size of the window in time steps</td></tr><tr><td></td><td class="fieldArg">outpref</td><td><code>True</code> if the out-degree of a given vertex should also increase its citation probability (as well as its in-degree), but it defaults to <code>False</code>.</td></tr><tr><td></td><td class="fieldArg">directed</td><td><code>True</code> if the generated graph should be directed (default: <code>False</code>).</td></tr><tr><td></td><td class="fieldArg">power</td><td>the power constant of the nonlinear model. It can be omitted, and in this case the usual linear model will be used.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.SBM">
    
  </a>
  <a name="SBM">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">SBM</span>(n, pref_matrix, block_sizes, directed=False, loops=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph based on a stochastic blockmodel.</p><p>A given number of vertices are generated. Every vertex is assigned to a vertex type according to the given block sizes. Vertices of the same type will be assigned consecutive vertex IDs. Finally, every vertex pair is evaluated and an edge is created between them with a probability depending on the types of the vertices involved. The probabilities are taken from the preference matrix.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices in the graph</td></tr><tr><td></td><td class="fieldArg">pref_matrix</td><td>matrix giving the connection probabilities for different vertex types.</td></tr><tr><td></td><td class="fieldArg">block_sizes</td><td>list giving the number of vertices in each block; must sum up to <i>n</i>.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to generate a directed graph.</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether loop edges are allowed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Star">
    
  </a>
  <a name="Star">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Star</span>(n, mode='undirected', center=0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a star graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices in the graph</td></tr><tr><td></td><td class="fieldArg">mode</td><td>Gives the type of the star graph to create. Should be either "in", "out", "mutual" or "undirected"</td></tr><tr><td></td><td class="fieldArg">center</td><td>Vertex ID for the central vertex in the star.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Lattice">
    
  </a>
  <a name="Lattice">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Lattice</span>(dim, nei=1, directed=False, mutual=True, circular=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a regular lattice.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">dim</td><td>list with the dimensions of the lattice</td></tr><tr><td></td><td class="fieldArg">nei</td><td>value giving the distance (number of steps) within which two vertices will be connected.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to create a directed graph.</td></tr><tr><td></td><td class="fieldArg">mutual</td><td>whether to create all connections as mutual in case of a directed graph.</td></tr><tr><td></td><td class="fieldArg">circular</td><td>whether the generated lattice is periodic.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.LCF">
    
  </a>
  <a name="LCF">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">LCF</span>(n, shifts, repeats):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph from LCF notation.</p><p>LCF is short for Lederberg-Coxeter-Frucht, it is a concise notation for 3-regular Hamiltonian graphs. It consists of three parameters, the number of vertices in the graph, a list of shifts giving additional edges to a cycle backbone and another integer giving how many times the shifts should be performed. See <a href="http://mathworld.wolfram.com/LCFNotation.html" target="_top">http://mathworld.wolfram.com/LCFNotation.html</a> for details.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices</td></tr><tr><td></td><td class="fieldArg">shifts</td><td>the shifts in a list or tuple</td></tr><tr><td></td><td class="fieldArg">repeats</td><td>the number of repeats</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Realize_Degree_Sequence">
    
  </a>
  <a name="Realize_Degree_Sequence">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Realize_Degree_Sequence</span>(out, in_=None, allowed_edge_types='simple', method='smallest'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph from a degree sequence.</p><p>This method implements a Havel-Hakimi style graph construction from a given degree sequence. In each step, the algorithm picks two vertices in a deterministic manner and connects them. The way the vertices are picked is defined by the <code>method</code> parameter. The allowed edge types (i.e. whether multiple or loop edges are allowed) are specified in the <code>allowed_edge_types</code> parameter.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">out</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">in_</td><td><span class="undocumented">Undocumented</span></td></tr><tr><td></td><td class="fieldArg">allowed_edge_types</td><td>controls whether loops or multi-edges are allowed during the generation process. Note that not all combinations are supported for all types of graphs; an exception will be raised for unsupported combinations. Possible values are:<ul><li><code>"simple"</code>: simple graphs (no self-loops, no multi-edges)</li><li><code>"loops"</code>: single self-loops allowed, but not multi-edges</li><li><code>"multi"</code>: multi-edges allowed, but not self-loops</li><li><code>"all"</code>: multi-edges and self-loops allowed</li></ul></td></tr><tr><td></td><td class="fieldArg">method</td><td>controls how the vertices are selected during the generation process. Possible values are:<ul><li><code>smallest</code>: The vertex with smallest remaining degree first.</li><li><code>largest</code>: The vertex with the largest remaining degree first.</li><li><code>index</code>: The vertices are selected in order of their index.</li></ul></td></tr><tr><td></td><td class="fieldArg">outdeg</td><td>the degree sequence of an undirected graph (if indeg=None), or the out-degree sequence of a directed graph.</td></tr><tr><td></td><td class="fieldArg">indeg</td><td>None to generate an undirected graph, the in-degree sequence to generate a directed graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Ring">
    
  </a>
  <a name="Ring">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Ring</span>(n, directed=False, mutual=False, circular=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a ring graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices in the ring</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to create a directed ring.</td></tr><tr><td></td><td class="fieldArg">mutual</td><td>whether to create mutual edges in a directed ring.</td></tr><tr><td></td><td class="fieldArg">circular</td><td>whether to create a closed ring.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Static_Fitness">
    
  </a>
  <a name="Static_Fitness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Static_Fitness</span>(m, fitness_out, fitness_in=None, loops=False, multiple=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a non-growing graph with edge probabilities proportional to node fitnesses.</p><p>The algorithm randomly selects vertex pairs and connects them until the given number of edges are created. Each vertex is selected with a probability proportional to its fitness; for directed graphs, a vertex is selected as a source proportional to its out-fitness and as a target proportional to its in-fitness.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">m</td><td>the number of edges in the graph</td></tr><tr><td></td><td class="fieldArg">fitness_out</td><td>a numeric vector with non-negative entries, one for each vertex. These values represent the fitness scores (out-fitness scores for directed graphs). <i>fitness</i> is an alias of this keyword argument.</td></tr><tr><td></td><td class="fieldArg">fitness_in</td><td>a numeric vector with non-negative entries, one for each vertex. These values represent the in-fitness scores for directed graphs. For undirected graphs, this argument must be <code>None</code>.</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether loop edges are allowed.</td></tr><tr><td></td><td class="fieldArg">multiple</td><td>whether multiple edges are allowed.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a directed or undirected graph with the prescribed power-law degree distributions.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Static_Power_Law">
    
  </a>
  <a name="Static_Power_Law">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Static_Power_Law</span>(n, m, exponent_out, exponent_in=-1, loops=False, multiple=False, finite_size_correction=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a non-growing graph with prescribed power-law degree distributions.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices in the graph</td></tr><tr><td></td><td class="fieldArg">m</td><td>the number of edges in the graph</td></tr><tr><td></td><td class="fieldArg">exponent_out</td><td>the exponent of the out-degree distribution, which must be between 2 and infinity (inclusive). When <i>exponent_in</i> is not given or negative, the graph will be undirected and this parameter specifies the degree distribution. <i>exponent</i> is an alias to this keyword argument.</td></tr><tr><td></td><td class="fieldArg">exponent_in</td><td>the exponent of the in-degree distribution, which must be between 2 and infinity (inclusive) It can also be negative, in which case an undirected graph will be generated.</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether loop edges are allowed.</td></tr><tr><td></td><td class="fieldArg">multiple</td><td>whether multiple edges are allowed.</td></tr><tr><td></td><td class="fieldArg">finite_size_correction</td><td>whether to apply a finite-size correction to the generated fitness values for exponents less than 3. See the paper of Cho et al for more details.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a directed or undirected graph with the prescribed power-law degree distributions.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.</td></tr><tr><td></td><td colspan="2">Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Tree">
    
  </a>
  <a name="Tree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Tree</span>(n, children, type='undirected'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a tree in which almost all vertices have the same number of children.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices in the graph</td></tr><tr><td></td><td class="fieldArg">children</td><td>the number of children of a vertex in the graph</td></tr><tr><td></td><td class="fieldArg">type</td><td>determines whether the tree should be directed, and if this is the case, also its orientation. Must be one of <code>"in"</code>, <code>"out"</code> and <code>"undirected"</code>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Degree_Sequence">
    
  </a>
  <a name="Degree_Sequence">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Degree_Sequence</span>(out, in_=None, method='simple'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph with a given degree sequence.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">out</td><td>the out-degree sequence for a directed graph. If the in-degree sequence is omitted, the generated graph will be undirected, so this will be the in-degree sequence as well</td></tr><tr><td></td><td class="fieldArg">in_</td><td>the in-degree sequence for a directed graph. If omitted, the generated graph will be undirected.</td></tr><tr><td></td><td class="fieldArg">method</td><td>the generation method to be used. One of the following:<ul><li><code>"simple"</code> -- simple generator that sometimes generates loop edges and multiple edges. The generated graph is not guaranteed to be connected.</li><li><code>"no_multiple"</code> -- similar to <code>"simple"</code> but avoids the generation of multiple and loop edges at the expense of increased time complexity. The method will re-start the generation every time it gets stuck in a configuration where it is not possible to insert any more edges without creating loops or multiple edges, and there is no upper bound on the number of iterations, but it will succeed eventually if the input degree sequence is graphical and throw an exception if the input degree sequence is not graphical.</li><li><code>"vl"</code> -- a more sophisticated generator that can sample undirected, connected simple graphs uniformly. It uses Monte-Carlo methods to randomize the graphs. This generator should be favoured if undirected and connected graphs are to be generated and execution time is not a concern. igraph uses the original implementation of Fabien Viger; see the following URL and the paper cited on it for the details of the algorithm: <a href="https://www-complexnetworks.lip6.fr/~latapy/FV/generation.html" target="_top">https://www-complexnetworks.lip6.fr/~latapy/FV/generation.html</a>.</li></ul></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Isoclass">
    
  </a>
  <a name="Isoclass">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Isoclass</span>(n, cls, directed=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a graph with a given isomorphism class.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices in the graph (3 or 4)</td></tr><tr><td></td><td class="fieldArg">cls</td><td>the isomorphism class</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the graph should be directed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Tree_Game">
    
  </a>
  <a name="Tree_Game">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Tree_Game</span>(n, directed=False, method='lerw'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of vertices in the tree</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the graph should be directed</td></tr><tr><td></td><td class="fieldArg">method</td><td>the generation method to be used. One of the following:<ul><li><code>"prufer"</code> -- samples Prufer sequences uniformly, then converts them to trees</li><li><code>"lerw"</code> -- performs a loop-erased random walk on the complete graph to uniformly sample its spanning trees (Wilson's algorithm). This is the default choice as it supports both directed and undirected graphs.</li></ul></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Watts_Strogatz">
    
  </a>
  <a name="Watts_Strogatz">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Watts_Strogatz</span>(dim, size, nei, p, loops=False, multiple=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">dim</td><td>the dimension of the lattice</td></tr><tr><td></td><td class="fieldArg">size</td><td>the size of the lattice along all dimensions</td></tr><tr><td></td><td class="fieldArg">nei</td><td>value giving the distance (number of steps) within which two vertices will be connected.</td></tr><tr><td></td><td class="fieldArg">p</td><td>rewiring probability</td></tr><tr><td></td><td class="fieldArg">loops</td><td>specifies whether loop edges are allowed</td></tr><tr><td></td><td class="fieldArg">multiple</td><td>specifies whether multiple edges are allowed</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#Lattice">Lattice()</a></code>, <code><a href="#rewire">rewire()</a></code>, <code><a href="#rewire_edges">rewire_edges()</a></code> if more flexibility is needed</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Duncan J Watts and Steven H Strogatz: <i>Collective dynamics of small world networks</i>, Nature 393, 440-442, 1998</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Weighted_Adjacency">
    
  </a>
  <a name="Weighted_Adjacency">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Weighted_Adjacency</span>(matrix, mode='directed', attr='weight', loops=True):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Generates a graph from its adjacency matrix.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">matrix</td><td>the adjacency matrix</td></tr><tr><td></td><td class="fieldArg">mode</td><td>the mode to be used. Possible values are:<ul><li><code>"directed"</code> - the graph will be directed and a matrix element gives the number of edges between two vertices.</li><li><code>"undirected"</code> - alias to <code>"max"</code> for convenience.</li><li><code>"max"</code>   - undirected graph will be created and the number of edges between vertex <i class="math">i</i> and <i class="math">j</i> is <i class="math">max(A(i,j), A(j,i))</i></li><li><code>"min"</code>   - like <code>"max"</code>, but with <i class="math">min(A(i,j), A(j,i))</i></li><li><code>"plus"</code>  - like <code>"max"</code>, but with <i class="math">A(i,j) + A(j,i)</i></li><li><code>"upper"</code> - undirected graph with the upper right triangle of the matrix (including the diagonal)</li><li><code>"lower"</code> - undirected graph with the lower left triangle of the matrix (including the diagonal)</li></ul></td></tr><tr><td></td><td class="fieldArg">attr</td><td>the name of the edge attribute that stores the edge weights.</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether to include loop edges. When <code>False</code>, the diagonal of the adjacency matrix will be ignored.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.are_connected">
    
  </a>
  <a name="are_connected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">are_connected</span>(v1, v2):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Decides whether two given vertices are directly connected.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">v1</td><td>the ID or name of the first vertex</td></tr><tr><td></td><td class="fieldArg">v2</td><td>the ID or name of the second vertex</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>True</code> if there exists an edge from v1 to v2, <code>False</code> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.articulation_points">
    
  </a>
  <a name="articulation_points">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">articulation_points</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the list of articulation points in the graph.</p><p>A vertex is an articulation point if its removal increases the number of connected components in the graph.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.assortativity">
    
  </a>
  <a name="assortativity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">assortativity</span>(types1, types2=None, directed=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the assortativity of the graph based on numeric properties of the vertices.</p><p>This coefficient is basically the correlation between the actual connectivity patterns of the vertices and the pattern expected from the disribution of the vertex types.</p><p>See equation (21) in Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126 (2003) for the proper definition. The actual calculation is performed using equation (26) in the same paper for directed graphs, and equation (4) in Newman MEJ: Assortative mixing in networks, Phys Rev Lett 89:208701 (2002) for undirected graphs.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">types1</td><td>vertex types in a list or the name of a vertex attribute holding vertex types. Types are ideally denoted by numeric values.</td></tr><tr><td></td><td class="fieldArg">types2</td><td>in directed assortativity calculations, each vertex can have an out-type and an in-type. In this case, <i>types1</i> contains the out-types and this parameter contains the in-types in a list or the name of a vertex attribute. If <code>None</code>, it is assumed to be equal to <i>types1</i>.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to consider edge directions or not.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the assortativity coefficient</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#assortativity_degree">assortativity_degree()</a></code> when the types are the vertex degrees</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126, 2003.</td></tr><tr><td></td><td colspan="2">Newman MEJ: Assortative mixing in networks, Phys Rev Lett 89:208701,<ol start="2002"><li></li></ol></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.assortativity_degree">
    
  </a>
  <a name="assortativity_degree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">assortativity_degree</span>(directed=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the assortativity of a graph based on vertex degrees.</p><p>See <code><a href="#assortativity">assortativity()</a></code> for the details. <code><a href="#assortativity_degree">assortativity_degree()</a></code> simply calls <code><a href="#assortativity">assortativity()</a></code> with the vertex degrees as types.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">directed</td><td>whether to consider edge directions for directed graphs or not. This argument is ignored for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the assortativity coefficient</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#assortativity">assortativity()</a></code></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.assortativity_nominal">
    
  </a>
  <a name="assortativity_nominal">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">assortativity_nominal</span>(types, directed=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the assortativity of the graph based on vertex categories.</p><p>Assuming that the vertices belong to different categories, this function calculates the assortativity coefficient, which specifies the extent to which the connections stay within categories. The assortativity coefficient is one if all the connections stay within categories and minus one if all the connections join vertices of different categories. For a randomly connected network, it is asymptotically zero.</p><p>See equation (2) in Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126 (2003) for the proper definition.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">types</td><td>vertex types in a list or the name of a vertex attribute holding vertex types. Types should be denoted by numeric values.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to consider edge directions or not.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the assortativity coefficient</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126, 2003.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.average_path_length">
    
  </a>
  <a name="average_path_length">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">average_path_length</span>(directed=True, unconn=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the average path length in a graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">directed</td><td>whether to consider directed paths in case of a directed graph. Ignored for undirected graphs.</td></tr><tr><td></td><td class="fieldArg">unconn</td><td>what to do when the graph is unconnected. If <code>True</code>, the average of the geodesic lengths in the components is calculated. Otherwise for all unconnected vertex pairs, a path length equal to the number of vertices is used.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the average path length in the graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.authority_score">
    
  </a>
  <a name="authority_score">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">authority_score</span>(weights=None, scale=True, arpack_options=None, return_eigenvalue=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates Kleinberg's authority score for the vertices of the graph</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td></td><td class="fieldArg">scale</td><td>whether to normalize the scores so that the largest one is 1.</td></tr><tr><td></td><td class="fieldArg">arpack_options</td><td>an <code><a href="igraph._igraph.ARPACKOptions.html">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <code>arpack_options</code> is used.</td></tr><tr><td></td><td class="fieldArg">return_eigenvalue</td><td>whether to return the largest eigenvalue</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the authority scores in a list and optionally the largest eigenvalue as a second member of a tuple</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">hub_score()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.betweenness">
    
  </a>
  <a name="betweenness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">betweenness</span>(vertices=None, directed=True, cutoff=None, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates or estimates the betweenness of vertices in a graph.</p><p>Keyword arguments:</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the vertices for which the betweennesses must be returned. If <code>None</code>, assumes all of the vertices in the graph.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to consider directed paths.</td></tr><tr><td></td><td class="fieldArg">cutoff</td><td>if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the betweenness for the given vertices. If <code>None</code>, the exact betweenness is returned.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the (possibly estimated) betweenness of the given vertices in a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.biconnected_components">
    
  </a>
  <a name="biconnected_components">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">biconnected_components</span>(return_articulation_points=True):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Calculates the biconnected components of the graph.</p><p>Components containing a single vertex only are not considered as being biconnected.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">return_articulation_points</td><td>whether to return the articulation points as well</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list of lists containing edge indices making up spanning trees of the biconnected components (one spanning tree for each component) and optionally the list of articulation points</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.bipartite_projection">
    
  </a>
  <a name="bipartite_projection">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bipartite_projection</span>(types, multiplicity=True, probe1=-1, which=-1):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.bipartite_projection()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.bipartite_projection_size">
    
  </a>
  <a name="bipartite_projection_size">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bipartite_projection_size</span>(types):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.bipartite_projection_size()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.bridges">
    
  </a>
  <a name="bridges">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bridges</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the list of bridges in the graph.</p><p>An edge is a bridge if its removal increases the number of (weakly) connected components in the graph.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.chordal_completion">
    
  </a>
  <a name="chordal_completion">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">chordal_completion</span> (INVALID):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>chordal_complation(alpha=None, alpham1=None) --</p><p>Returns the list of edges needed to be added to the graph to make it chordal.</p><p>A graph is chordal if each of its cycles of four or more nodes has a chord, i.e. an edge joining two nodes that are not adjacent in the cycle. An equivalent definition is that any chordless cycles have at most three nodes.</p><p>The chordal completion of a graph is the list of edges that needed to be added to the graph to make it chordal. It is an empty list if the graph is already chordal.</p><p>Note that at the moment igraph does not guarantee that the returned chordal completion is <i>minimal</i>; there may exist a subset of the returned chordal completion that is still a valid chordal completion.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">alpha</td><td>the alpha vector from the result of calling <code><a href="#maximum_cardinality_search">maximum_cardinality_search()</a></code> on the graph. Useful only if you already have the alpha vector; simply passing <code>None</code> here will make igraph calculate the alpha vector on its own.</td></tr><tr><td></td><td class="fieldArg">alpham1</td><td>the inverse alpha vector from the result of calling <code><a href="#maximum_cardinality_search">maximum_cardinality_search()</a></code> on the graph. Useful only if you already have the inverse alpha vector; simply passing <code>None</code> here will make igraph calculate the inverse alpha vector on its own.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the list of edges to add to the graph; each item in the list is a source-target pair of vertex indices.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.closeness">
    
  </a>
  <a name="closeness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">closeness</span>(vertices=None, mode='all', cutoff=None, weights=None, normalized=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the closeness centralities of given vertices in a graph.</p><p>The closeness centerality of a vertex measures how easily other vertices can be reached from it (or the other way: how easily it can be reached from the other vertices). It is defined as the number of vertices minus one divided by the sum of the lengths of all geodesics from/to the given vertex.</p><p>If the graph is not connected, and there is no path between two vertices, the number of vertices is used instead the length of the geodesic. This is always longer than the longest possible geodesic.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the vertices for which the closenesses must be returned. If <code>None</code>, uses all of the vertices in the graph.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>must be one of <code>"in"</code>, <code>"out"</code> and <code>"all"</code>. <code>"in"</code> means that the length of the incoming paths, <code>"out"</code> means that the length of the outgoing paths must be calculated. <code>"all"</code> means that both of them must be calculated.</td></tr><tr><td></td><td class="fieldArg">cutoff</td><td>if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the closeness for the given vertices (which is always an underestimation of the real closeness, since some vertex pairs will appear as disconnected even though they are connected).. If <code>None</code>, the exact closeness is returned.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td></td><td class="fieldArg">normalized</td><td>Whether to normalize the raw closeness scores by multiplying by the number of vertices minus one.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated closenesses in a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.harmonic_centrality">
    
  </a>
  <a name="harmonic_centrality">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">harmonic_centrality</span>(vertices=None, mode='all', cutoff=None, weights=None, normalized=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the harmonic centralities of given vertices in a graph.</p><p>The harmonic centerality of a vertex measures how easily other vertices can be reached from it (or the other way: how easily it can be reached from the other vertices). It is defined as the mean inverse distance to all other vertices.</p><p>If the graph is not connected, and there is no path between two vertices, the inverse distance is taken to be zero.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the vertices for which the harmonic centrality must be returned. If <code>None</code>, uses all of the vertices in the graph.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>must be one of <code>"in"</code>, <code>"out"</code> and <code>"all"</code>. <code>"in"</code> means that the length of the incoming paths, <code>"out"</code> means that the length of the outgoing paths must be calculated. <code>"all"</code> means that both of them must be calculated.</td></tr><tr><td></td><td class="fieldArg">cutoff</td><td>if it is not <code>None</code>, only paths less than or equal to this length are considered.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td></td><td class="fieldArg">normalized</td><td>Whether to normalize the result. If True, the result is the mean inverse path length to other vertices, i.e. it is normalized by the number of vertices minus one. If False, the result is the sum of inverse path lengths to other vertices.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated harmonic centralities in a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.clusters">
    
  </a>
  <a name="clusters">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">clusters</span>(mode='strong'):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Calculates the (strong or weak) clusters for a given graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mode</td><td>must be either <code>"strong"</code> or <code>"weak"</code>, depending on the clusters being sought. Optional, defaults to <code>"strong"</code>.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the component index for every node in the graph.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html">Graph</a></code> which wraps the result in a <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> object. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.copy">
    
  </a>
  <a name="copy">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">copy</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Creates a copy of the graph.</p><p>Attributes are copied by reference; in other words, if you use mutable Python objects as attribute values, these objects will still be shared between the old and new graph. You can use `deepcopy()` from the `copy` module if you need a truly deep copy of the graph.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.decompose">
    
  </a>
  <a name="decompose">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">decompose</span>(mode='strong', maxcompno=None, minelements=1):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Decomposes the graph into subgraphs.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mode</td><td>must be either <code>"strong"</code> or <code>"weak"</code>, depending on the clusters being sought. Optional, defaults to <code>"strong"</code>.</td></tr><tr><td></td><td class="fieldArg">maxcompno</td><td>maximum number of components to return. <code>None</code> means all possible components.</td></tr><tr><td></td><td class="fieldArg">minelements</td><td>minimum number of vertices in a component. By setting this to 2, isolated vertices are not returned as separate components.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list of the subgraphs. Every returned subgraph is a copy of the original.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.contract_vertices">
    
  </a>
  <a name="contract_vertices">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">contract_vertices</span>(mapping, combine_attrs=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mapping</td><td>numeric vector which gives the mapping between old and new vertex IDs. Vertices having the same new vertex ID in this vector will be remapped into a single new vertex. It is safe to pass the membership vector of a <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> object here.</td></tr><tr><td></td><td class="fieldArg">combine_attrs</td><td>specifies how to combine the attributes of the vertices being collapsed into a single one. If it is <code>None</code>, all the attributes will be lost. If it is a function, the attributes of the vertices will be collected and passed on to that function which will return the new attribute value that has to be assigned to the single collapsed vertex. It can also be one of the following string constants which define built-in collapsing functions: <code>sum</code>, <code>prod</code>, <code>mean</code>, <code>median</code>, <code>max</code>, <code>min</code>, <code>first</code>, <code>last</code>, <code>random</code>. You can also specify different combination functions for different attributes by passing a dict here which maps attribute names to functions. See <code><a href="#simplify">simplify()</a></code> for more details.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>None</code>.</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#simplify">simplify()</a></code></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.constraint">
    
  </a>
  <a name="constraint">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">constraint</span>(vertices=None, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates Burt's constraint scores for given vertices in a graph.</p><p>Burt's constraint is higher if ego has less, or mutually stronger related (i.e. more redundant) contacts. Burt's measure of constraint, C[i], of vertex i's ego network V[i], is defined for directed and valued graphs as follows:</p><p>C[i] = sum( sum( (p[i,q] p[q,j])^2, q in V[i], q != i,j ), j in V[], j != i)</p><p>for a graph of order (ie. number od vertices) N, where proportional tie strengths are defined as follows:</p><p>p[i,j]=(a[i,j]+a[j,i]) / sum(a[i,k]+a[k,i], k in V[i], k != i), a[i,j] are elements of A and the latter being the graph adjacency matrix.</p><p>For isolated vertices, constraint is undefined.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the vertices to be analysed or <code>None</code> for all vertices.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>weights associated to the edges. Can be an attribute name as well. If <code>None</code>, every edge will have the same weight.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">constraint scores for all given vertices in a matrix.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.density">
    
  </a>
  <a name="density">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">density</span>(loops=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the density of the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">loops</td><td>whether to take loops into consideration. If <code>True</code>, the algorithm assumes that there might be some loops in the graph and calculates the density accordingly. If <code>False</code>, the algorithm assumes that there can't be any loops.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the density of the graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.diameter">
    
  </a>
  <a name="diameter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">diameter</span>(directed=True, unconn=True, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the diameter of the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">directed</td><td>whether to consider directed paths.</td></tr><tr><td></td><td class="fieldArg">unconn</td><td>if <code>True</code> and the graph is unconnected, the longest geodesic within a component will be returned. If <code>False</code> and the graph is unconnected, the result is the number of vertices if there are no weights or infinity if there are weights.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the diameter</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.get_diameter">
    
  </a>
  <a name="get_diameter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_diameter</span>(directed=True, unconn=True, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns a path with the actual diameter of the graph.</p><p>If there are many shortest paths with the length of the diameter, it returns the first one it founds.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">directed</td><td>whether to consider directed paths.</td></tr><tr><td></td><td class="fieldArg">unconn</td><td>if <code>True</code> and the graph is unconnected, the longest geodesic within a component will be returned. If <code>False</code> and the graph is unconnected, the result is the number of vertices if there are no weights or infinity if there are weights.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the vertices in the path in order.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.farthest_points">
    
  </a>
  <a name="farthest_points">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">farthest_points</span>(directed=True, unconn=True, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns two vertex IDs whose distance equals the actual diameter of the graph.</p><p>If there are many shortest paths with the length of the diameter, it returns the first one it found.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">directed</td><td>whether to consider directed paths.</td></tr><tr><td></td><td class="fieldArg">unconn</td><td>if <code>True</code> and the graph is unconnected, the longest geodesic within a component will be returned. If <code>False</code> and the graph is unconnected, the result contains the number of vertices if there are no weights or infinity if there are weights.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a triplet containing the two vertex IDs and their distance. The IDs are <code>None</code> if the graph is unconnected and <code>unconn</code> is <code>False</code>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.diversity">
    
  </a>
  <a name="diversity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">diversity</span>(vertices=None, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the structural diversity index of the vertices.</p><p>The structural diversity index of a vertex is simply the (normalized) Shannon entropy of the weights of the edges incident on the vertex.</p><p>The measure is defined for undirected graphs only; edge directions are ignored.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the vertices for which the diversity indices must be returned. If <code>None</code>, uses all of the vertices in the graph.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated diversity indices in a list, or a single number if a single vertex was supplied.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Eagle N, Macy M and Claxton R: Network diversity and economic development, Science 328, 1029--1031, 2010.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.eccentricity">
    
  </a>
  <a name="eccentricity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">eccentricity</span>(vertices=None, mode='all'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the eccentricities of given vertices in a graph.</p><p>The eccentricity of a vertex is calculated by measuring the shortest distance from (or to) the vertex, to (or from) all other vertices in the graph, and taking the maximum.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the vertices for which the eccentricity scores must be returned. If <code>None</code>, uses all of the vertices in the graph.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>must be one of <code>"in"</code>, <code>"out"</code> and <code>"all"</code>. <code>"in"</code> means that edge directions are followed; <code>"out"</code> means that edge directions are followed the opposite direction; <code>"all"</code> means that directions are ignored. The argument has no effect for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated eccentricities in a list, or a single number if a single vertex was supplied.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.edge_betweenness">
    
  </a>
  <a name="edge_betweenness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">edge_betweenness</span>(directed=True, cutoff=None, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates or estimates the edge betweennesses in a graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">directed</td><td>whether to consider directed paths.</td></tr><tr><td></td><td class="fieldArg">cutoff</td><td>if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the betweenness values. If <code>None</code>, the exact betweennesses are returned.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list with the (exact or estimated) edge betweennesses of all edges.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.eigen_adjacency">
    
  </a>
  <a name="eigen_adjacency">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">eigen_adjacency</span> (INVALID):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.edge_connectivity">
    
  </a>
  <a name="edge_connectivity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">edge_connectivity</span>(source=-1, target=-1, checks=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the edge connectivity of the graph or between some vertices.</p><p>The edge connectivity between two given vertices is the number of edges that have to be removed in order to disconnect the two vertices into two separate components. This is also the number of edge disjoint directed paths between the vertices. The edge connectivity of the graph is the minimal edge connectivity over all vertex pairs.</p><p>This method calculates the edge connectivity of a given vertex pair if both the source and target vertices are given. If none of them is given (or they are both negative), the overall edge connectivity is returned.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">source</td><td>the source vertex involved in the calculation.</td></tr><tr><td></td><td class="fieldArg">target</td><td>the target vertex involved in the calculation.</td></tr><tr><td></td><td class="fieldArg">checks</td><td>if the whole graph connectivity is calculated and this is <code>True</code>, igraph performs some basic checks before calculation. If the graph is not strongly connected, then the connectivity is obviously zero. If the minimum degree is one, then the connectivity is also one. These simple checks are much faster than checking the entire graph, therefore it is advised to set this to <code>True</code>. The parameter is ignored if the connectivity between two given vertices is computed.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the edge connectivity</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.eigenvector_centrality">
    
  </a>
  <a name="eigenvector_centrality">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">eigenvector_centrality</span>(directed=True, scale=True, weights=None, return_eigenvalue=False, arpack_options=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the eigenvector centralities of the vertices in a graph.</p><p>Eigenvector centrality is a measure of the importance of a node in a network. It assigns relative scores to all nodes in the network based on the principle that connections from high-scoring nodes contribute more to the score of the node in question than equal connections from low-scoring nodes. In practice, the centralities are determined by calculating eigenvector corresponding to the largest positive eigenvalue of the adjacency matrix. In the undirected case, this function considers the diagonal entries of the adjacency matrix to be twice the number of self-loops on the corresponding vertex.</p><p>In the directed case, the left eigenvector of the adjacency matrix is calculated. In other words, the centrality of a vertex is proportional to the sum of centralities of vertices pointing to it.</p><p>Eigenvector centrality is meaningful only for connected graphs. Graphs that are not connected should be decomposed into connected components, and the eigenvector centrality calculated for each separately.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">directed</td><td>whether to consider edge directions in a directed graph. Ignored for undirected graphs.</td></tr><tr><td></td><td class="fieldArg">scale</td><td>whether to normalize the centralities so the largest one will always be 1.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights given as a list or an edge attribute. If <code>None</code>, all edges have equal weight.</td></tr><tr><td></td><td class="fieldArg">return_eigenvalue</td><td>whether to return the actual largest eigenvalue along with the centralities</td></tr><tr><td></td><td class="fieldArg">arpack_options</td><td>an <code><a href="igraph._igraph.ARPACKOptions.html">ARPACKOptions</a></code> object that can be used to fine-tune the calculation. If it is omitted, the module-level variable called <code>arpack_options</code> is used.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the eigenvector centralities in a list and optionally the largest eigenvalue (as a second member of a tuple)</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.feedback_arc_set">
    
  </a>
  <a name="feedback_arc_set">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">feedback_arc_set</span>(weights=None, method='eades'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates an approximately or exactly minimal feedback arc set.</p><p>A feedback arc set is a set of edges whose removal makes the graph acyclic. Since this is always possible by removing all the edges, we are in general interested in removing the smallest possible number of edges, or an edge set with as small total weight as possible. This method calculates one such edge set. Note that the task is trivial for an undirected graph as it is enough to find a spanning tree and then remove all the edges not in the spanning tree. Of course it is more complicated for directed graphs.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name. When given, the algorithm will strive to remove lightweight edges in order to minimize the total weight of the feedback arc set.</td></tr><tr><td></td><td class="fieldArg">method</td><td>the algorithm to use. <code>"eades"</code> uses the greedy cycle breaking heuristic of Eades, Lin and Smyth, which is linear in the number of edges but not necessarily optimal; however, it guarantees that the number of edges to be removed is smaller than |E|/2 - |V|/6. <code>"ip"</code> uses an integer programming formulation which is guaranteed to yield an optimal result, but is too slow for large graphs.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the IDs of the edges to be removed, in a list.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Eades P, Lin X and Smyth WF: A fast and effective heuristic for the feedback arc set problem. In: Proc Inf Process Lett 319-323, 1993.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.get_shortest_paths">
    
  </a>
  <a name="get_shortest_paths">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_shortest_paths</span>(v, to=None, weights=None, mode='out', output='vpath'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the shortest paths from/to a given node in a graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">v</td><td>the source/destination for the calculated paths</td></tr><tr><td></td><td class="fieldArg">to</td><td>a vertex selector describing the destination/source for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a <code><a href="igraph._igraph.VertexSeq.html">VertexSeq</a></code> object. <code>None</code> means all the vertices.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights in a list or the name of an edge attribute holding edge weights. If <code>None</code>, all edges are assumed to have equal weight.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>the directionality of the paths. <code>"in"</code> means to calculate incoming paths, <code>"out"</code> means to calculate outgoing paths, <code>"all"</code> means to calculate both ones.</td></tr><tr><td></td><td class="fieldArg">output</td><td>determines what should be returned. If this is <code>"vpath"</code>, a list of vertex IDs will be returned, one path for each target vertex. For unconnected graphs, some of the list elements may be empty. Note that in case of mode=<code>"in"</code>, the vertices in a path are returned in reversed order. If <code>output="epath"</code>, edge IDs are returned instead of vertex IDs.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">see the documentation of the <code>output</code> parameter.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.get_all_shortest_paths">
    
  </a>
  <a name="get_all_shortest_paths">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_all_shortest_paths</span>(v, to=None, weights=None, mode='out'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates all of the shortest paths from/to a given node in a graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">v</td><td>the source for the calculated paths</td></tr><tr><td></td><td class="fieldArg">to</td><td>a vertex selector describing the destination for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a <code><a href="igraph._igraph.VertexSeq.html">VertexSeq</a></code> object. <code>None</code> means all the vertices.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights in a list or the name of an edge attribute holding edge weights. If <code>None</code>, all edges are assumed to have equal weight.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>the directionality of the paths. <code>"in"</code> means to calculate incoming paths, <code>"out"</code> means to calculate outgoing paths, <code>"all"</code> means to calculate both ones.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">all of the shortest path from the given node to every other reachable node in the graph in a list. Note that in case of mode=<code>"in"</code>, the vertices in a path are returned in reversed order!</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase._get_all_simple_paths">
    
  </a>
  <a name="_get_all_simple_paths">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_get_all_simple_paths</span>(v, to=None, cutoff=-1, mode='out'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.get_all_simple_paths()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.girth">
    
  </a>
  <a name="girth">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">girth</span>(return_shortest_circle=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the girth of the graph.</p><p>The girth of a graph is the length of the shortest circle in it.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">return_shortest_circle</td><td>whether to return one of the shortest circles found in the graph.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the length of the shortest circle or (if <code>return_shortest_circle</code>) is true, the shortest circle itself as a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.convergence_degree">
    
  </a>
  <a name="convergence_degree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">convergence_degree</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Undocumented (yet).</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.convergence_field_size">
    
  </a>
  <a name="convergence_field_size">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">convergence_field_size</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Undocumented (yet).</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.hub_score">
    
  </a>
  <a name="hub_score">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">hub_score</span>(weights=None, scale=True, arpack_options=None, return_eigenvalue=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates Kleinberg's hub score for the vertices of the graph</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td></td><td class="fieldArg">scale</td><td>whether to normalize the scores so that the largest one is 1.</td></tr><tr><td></td><td class="fieldArg">arpack_options</td><td>an <code><a href="igraph._igraph.ARPACKOptions.html">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <code>arpack_options</code> is used.</td></tr><tr><td></td><td class="fieldArg">return_eigenvalue</td><td>whether to return the largest eigenvalue</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the hub scores in a list and optionally the largest eigenvalue as a second member of a tuple</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">authority_score()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.induced_subgraph">
    
  </a>
  <a name="induced_subgraph">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">induced_subgraph</span>(vertices, implementation='auto'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns a subgraph spanned by the given vertices.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>a list containing the vertex IDs which should be included in the result.</td></tr><tr><td></td><td class="fieldArg">implementation</td><td>the implementation to use when constructing the new subgraph. igraph includes two implementations at the moment. <code>"copy_and_delete"</code> copies the original graph and removes those vertices that are not in the given set. This is more efficient if the size of the subgraph is comparable to the original graph. The other implementation (<code>"create_from_scratch"</code>) constructs the result graph from scratch and then copies the attributes accordingly. This is a better solution if the subgraph is relatively small, compared to the original graph. <code>"auto"</code> selects between the two implementations automatically, based on the ratio of the size of the subgraph and the size of the original graph.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the subgraph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.is_bipartite">
    
  </a>
  <a name="is_bipartite">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_bipartite</span>(return_types=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Decides whether the graph is bipartite or not.</p><p>Vertices of a bipartite graph can be partitioned into two groups A and B in a way that all edges go between the two groups.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">return_types</td><td>if <code>False</code>, the method will simply return <code>True</code> or <code>False</code> depending on whether the graph is bipartite or not. If <code>True</code>, the actual group assignments are also returned as a list of boolean values. (Note that the group assignment is not unique, especially if the graph consists of multiple components, since the assignments of components are independent from each other).</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>True</code> if the graph is bipartite, <code>False</code> if not. If <code>return_types</code> is <code>True</code>, the group assignment is also returned.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.is_chordal">
    
  </a>
  <a name="is_chordal">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_chordal</span>(alpha=None, alpham1=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns whether the graph is chordal or not.</p><p>A graph is chordal if each of its cycles of four or more nodes has a chord, i.e. an edge joining two nodes that are not adjacent in the cycle. An equivalent definition is that any chordless cycles have at most three nodes.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">alpha</td><td>the alpha vector from the result of calling <code><a href="#maximum_cardinality_search">maximum_cardinality_search()</a></code> on the graph. Useful only if you already have the alpha vector; simply passing <code>None</code> here will make igraph calculate the alpha vector on its own.</td></tr><tr><td></td><td class="fieldArg">alpham1</td><td>the inverse alpha vector from the result of calling <code><a href="#maximum_cardinality_search">maximum_cardinality_search()</a></code> on the graph. Useful only if you already have the inverse alpha vector; simply passing <code>None</code> here will make igraph calculate the inverse alpha vector on its own.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>True</code> if the graph is chordal, <code>False</code> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.knn">
    
  </a>
  <a name="knn">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">knn</span>(vids=None, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vids</td><td>the vertices for which the calculation is performed. <code>None</code> means all vertices.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name. If this is given, the vertex strength will be used instead of the vertex degree in the calculations, but the "ordinary" vertex degree will be used for the second (degree- dependent) list in the result.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">two lists in a tuple. The first list contains the average degree of neighbors for each vertex, the second contains the average degree of neighbors as a function of vertex degree. The zeroth element of this list corresponds to vertices of degree 1.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.is_connected">
    
  </a>
  <a name="is_connected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_connected</span>(mode='strong'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Decides whether the graph is connected.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mode</td><td>whether we should calculate strong or weak connectivity.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>True</code> if the graph is connected, <code>False</code> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.linegraph">
    
  </a>
  <a name="linegraph">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">linegraph</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the line graph of the graph.</p><p>The line graph <i class="math">L(G)</i> of an undirected graph is defined as follows: <i class="math">L(G)</i> has one vertex for each edge in G and two vertices in <i class="math">L(G)</i> are connected iff their corresponding edges in the original graph share an end point.</p><p>The line graph of a directed graph is slightly different: two vertices are connected by a directed edge iff the target of the first vertex's corresponding edge is the same as the source of the second vertex's corresponding edge.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.maxdegree">
    
  </a>
  <a name="maxdegree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maxdegree</span>(vertices=None, mode='all', loops=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the maximum degree of a vertex set in the graph.</p><p>This method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the degree of the given vertices (in the form of a single integer or a list, depending on the input parameter).</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>a single vertex ID or a list of vertex IDs, or <code>None</code> meaning all the vertices in the graph.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>the type of degree to be returned (<code>"out"</code> for out-degrees, <code>"in"</code> IN for in-degrees or <code>"all"</code> for the sum of them).</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether self-loops should be counted.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.maximum_cardinality_search">
    
  </a>
  <a name="maximum_cardinality_search">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maximum_cardinality_search</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Conducts a maximum cardinality search on the graph. The function computes a rank <i>alpha</i> for each vertex such that visiting vertices in decreasing rank order corresponds to always choosing the vertex with the most already visited neighbors as the next one to visit.</p><p>Maximum cardinality search is useful in deciding the chordality of a graph: a graph is chordal if and only if any two neighbors of a vertex that are higher in rank than the original vertex are connected to each other.</p><p>The result of this function can be passed to <code><a href="#is_chordal">is_chordal()</a></code> to speed up the chordality computation if you also need the result of the maximum cardinality search for other purposes.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a tuple consisting of the rank vector and its inverse.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.neighborhood">
    
  </a>
  <a name="neighborhood">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">neighborhood</span>(vertices=None, order=1, mode='all', mindist=0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>For each vertex specified by <i>vertices</i>, returns the vertices reachable from that vertex in at most <i>order</i> steps. If <i>mindist</i> is larger than zero, vertices that are reachable in less than <i>mindist</i> steps are excluded.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>a single vertex ID or a list of vertex IDs, or <code>None</code> meaning all the vertices in the graph.</td></tr><tr><td></td><td class="fieldArg">order</td><td>the order of the neighborhood, i.e. the maximum number of steps to take from the seed vertex.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>specifies how to take into account the direction of the edges if a directed graph is analyzed. <code>"out"</code> means that only the outgoing edges are followed, so all vertices reachable from the source vertex in at most <i>order</i> steps are counted. <code>"in"</code> means that only the incoming edges are followed (in reverse direction of course), so all vertices from which the source vertex is reachable in at most <i>order</i> steps are counted. <code>"all"</code> treats directed edges as undirected.</td></tr><tr><td></td><td class="fieldArg">mindist</td><td>the minimum distance required to include a vertex in the result. If this is one, the seed vertex is not included. If this is two, the direct neighbors of the seed vertex are not included either, and so on.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a single list specifying the neighborhood if <i>vertices</i> was an integer specifying a single vertex index, or a list of lists if <i>vertices</i> was a list or <code>None</code>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.neighborhood_size">
    
  </a>
  <a name="neighborhood_size">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">neighborhood_size</span>(vertices=None, order=1, mode='all', mindist=0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>For each vertex specified by <i>vertices</i>, returns the number of vertices reachable from that vertex in at most <i>order</i> steps. If <i>mindist</i> is larger than zero, vertices that are reachable in less than <i>mindist</i> steps are excluded.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>a single vertex ID or a list of vertex IDs, or <code>None</code> meaning all the vertices in the graph.</td></tr><tr><td></td><td class="fieldArg">order</td><td>the order of the neighborhood, i.e. the maximum number of steps to take from the seed vertex.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>specifies how to take into account the direction of the edges if a directed graph is analyzed. <code>"out"</code> means that only the outgoing edges are followed, so all vertices reachable from the source vertex in at most <i>order</i> steps are counted. <code>"in"</code> means that only the incoming edges are followed (in reverse direction of course), so all vertices from which the source vertex is reachable in at most <i>order</i> steps are counted. <code>"all"</code> treats directed edges as undirected.</td></tr><tr><td></td><td class="fieldArg">mindist</td><td>the minimum distance required to include a vertex in the result. If this is one, the seed vertex is not counted. If this is two, the direct neighbors of the seed vertex are not counted either, and so on.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a single number specifying the neighborhood size if <i>vertices</i> was an integer specifying a single vertex index, or a list of sizes if <i>vertices</i> was a list or <code>None</code>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.personalized_pagerank">
    
  </a>
  <a name="personalized_pagerank">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">personalized_pagerank</span>(vertices=None, directed=True, damping=0.85, reset=None, reset_vertices=None, weights=None, arpack_options=None, implementation='prpack', niter=1000, eps=0.001):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the personalized PageRank values of a graph.</p><p>The personalized PageRank calculation is similar to the PageRank calculation, but the random walk is reset to a non-uniform distribution over the vertices in every step with probability <i class="math">1-damping</i> instead of a uniform distribution.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the indices of the vertices being queried. <code>None</code> means all of the vertices.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to consider directed paths.</td></tr><tr><td></td><td class="fieldArg">damping</td><td>the damping factor. <i class="math">1-damping</i> is the PageRank value for vertices with no incoming links.</td></tr><tr><td></td><td class="fieldArg">reset</td><td>the distribution over the vertices to be used when resetting the random walk. Can be a sequence, an iterable or a vertex attribute name as long as they return a list of floats whose length is equal to the number of vertices. If <code>None</code>, a uniform distribution is assumed, which makes the method equivalent to the original PageRank algorithm.</td></tr><tr><td></td><td class="fieldArg">reset_vertices</td><td>an alternative way to specify the distribution over the vertices to be used when resetting the random walk. Simply supply a list of vertex IDs here, or a <code><a href="igraph._igraph.VertexSeq.html">VertexSeq</a></code> or a <code><a href="igraph._igraph.Vertex.html">Vertex</a></code>. Resetting will take place using a uniform distribution over the specified vertices.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td></td><td class="fieldArg">arpack_options</td><td>an <code><a href="igraph._igraph.ARPACKOptions.html">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <code>arpack_options</code> is used. This argument is ignored if not the ARPACK implementation is used, see the <i>implementation</i> argument.</td></tr><tr><td></td><td class="fieldArg">implementation</td><td>which implementation to use to solve the PageRank eigenproblem. Possible values are:<ul><li><code>"prpack"</code>: use the PRPACK library. This is a new implementation in igraph 0.7</li><li><code>"arpack"</code>: use the ARPACK library. This implementation was used from version 0.5, until version 0.7.</li><li><code>"power"</code>: use a simple power method. This is the implementation that was used before igraph version 0.5.</li></ul></td></tr><tr><td></td><td class="fieldArg">niter</td><td>The number of iterations to use in the power method implementation. It is ignored in the other implementations.</td></tr><tr><td></td><td class="fieldArg">eps</td><td>The power method implementation will consider the calculation as complete if the difference of PageRank values between iterations change less than this value for every node. It is ignored by the other implementations.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list with the personalized PageRank values of the specified vertices.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.path_length_hist">
    
  </a>
  <a name="path_length_hist">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">path_length_hist</span>(directed=True):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Calculates the path length histogram of the graph</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">directed</td><td>whether to consider directed paths</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a tuple. The first item of the tuple is a list of path lengths, the <i class="math">i</i>th element of the list contains the number of paths with length <i class="math">i+1</i>. The second item contains the number of unconnected vertex pairs as a float (since it might not fit into an integer)</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html">Graph</a></code>. It is advised to use that instead of this version.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.permute_vertices">
    
  </a>
  <a name="permute_vertices">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">permute_vertices</span>(permutation):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Permutes the vertices of the graph according to the given permutation and returns the new graph.</p><p>Vertex <i class="math">k</i> of the original graph will become vertex <i class="math">permutation[k]</i> in the new graph. No validity checks are performed on the permutation vector.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the new graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.radius">
    
  </a>
  <a name="radius">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">radius</span>(mode='out'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the radius of the graph.</p><p>The radius of a graph is defined as the minimum eccentricity of its vertices (see <code><a href="#eccentricity">eccentricity()</a></code>).</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mode</td><td>what kind of paths to consider for the calculation in case of directed graphs. <code>OUT</code> considers paths that follow edge directions, <code>IN</code> considers paths that follow the opposite edge directions, <code>ALL</code> ignores edge directions. The argument is ignored for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the radius</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#eccentricity">eccentricity()</a></code></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.reciprocity">
    
  </a>
  <a name="reciprocity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">reciprocity</span>(ignore_loops=True, mode='default'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Reciprocity defines the proportion of mutual connections in a directed graph. It is most commonly defined as the probability that the opposite counterpart of a directed edge is also included in the graph. This measure is calculated if <code>mode</code> is <code>"default"</code>.</p><p>Prior to igraph 0.6, another measure was implemented, defined as the probability of mutual connection between a vertex pair if we know that there is a (possibly non-mutual) connection between them. In other words, (unordered) vertex pairs are classified into three groups: (1) disconnected, (2) non-reciprocally connected and (3) reciprocally connected. The result is the size of group (3), divided by the sum of sizes of groups (2) and (3). This measure is calculated if <code>mode</code> is <code>"ratio"</code>.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">ignore_loops</td><td>whether loop edges should be ignored.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>the algorithm to use to calculate the reciprocity; see above for more details.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the reciprocity of the graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.rewire">
    
  </a>
  <a name="rewire">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rewire</span>(n=1000, mode='simple'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Randomly rewires the graph while preserving the degree distribution.</p><p>Please note that the rewiring is done "in-place", so the original graph will be modified. If you want to preserve the original graph, use the <code><a href="#copy">copy</a></code> method before.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the number of rewiring trials.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>the rewiring algorithm to use. It can either be <code>"simple"</code> or <code>"loops"</code>; the former does not create or destroy loop edges while the latter does.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.rewire_edges">
    
  </a>
  <a name="rewire_edges">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rewire_edges</span>(prob, loops=False, multiple=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Rewires the edges of a graph with constant probability.</p><p>Each endpoint of each edge of the graph will be rewired with a constant probability, given in the first argument.</p><p>Please note that the rewiring is done "in-place", so the original graph will be modified. If you want to preserve the original graph, use the <code><a href="#copy">copy</a></code> method before.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">prob</td><td>rewiring probability</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether the algorithm is allowed to create loop edges</td></tr><tr><td></td><td class="fieldArg">multiple</td><td>whether the algorithm is allowed to create multiple edges.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.shortest_paths">
    
  </a>
  <a name="shortest_paths">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">shortest_paths</span>(source=None, target=None, weights=None, mode='out'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates shortest path lengths for given vertices in a graph.</p><p>The algorithm used for the calculations is selected automatically: a simple BFS is used for unweighted graphs, Dijkstra's algorithm is used when all the weights are positive. Otherwise, the Bellman-Ford algorithm is used if the number of requested source vertices is larger than 100 and Johnson's algorithm is used otherwise.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">source</td><td>a list containing the source vertex IDs which should be included in the result. If <code>None</code>, all vertices will be considered.</td></tr><tr><td></td><td class="fieldArg">target</td><td>a list containing the target vertex IDs which should be included in the result. If <code>None</code>, all vertices will be considered.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>a list containing the edge weights. It can also be an attribute name (edge weights are retrieved from the given attribute) or <code>None</code> (all edges have equal weight).</td></tr><tr><td></td><td class="fieldArg">mode</td><td>the type of shortest paths to be used for the calculation in directed graphs. <code>"out"</code> means only outgoing, <code>"in"</code> means only incoming paths. <code>"all"</code> means to consider the directed graph as an undirected one.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the shortest path lengths for given vertices in a matrix</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.simplify">
    
  </a>
  <a name="simplify">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">simplify</span>(multiple=True, loops=True, combine_edges=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Simplifies a graph by removing self-loops and/or multiple edges.</p><p>For example, suppose you have a graph with an edge attribute named <code>weight</code>. <code>graph.simplify(combine_edges=max)</code> will take the maximum of the weights of multiple edges and assign that weight to the collapsed edge. <code>graph.simplify(combine_edges=sum)</code> will take the sum of the weights. You can also write <code>graph.simplify(combine_edges=dict(weight="sum"))</code> or <code>graph.simplify(combine_edges=dict(weight=sum))</code>, since <code>sum</code> is recognised both as a Python built-in function and as a string constant.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">multiple</td><td>whether to remove multiple edges.</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether to remove loops.</td></tr><tr><td></td><td class="fieldArg">combine_edges</td><td>specifies how to combine the attributes of multiple edges between the same pair of vertices into a single attribute. If it is <code>None</code>, only one of the edges will be kept and all the attributes will be lost. If it is a function, the attributes of multiple edges will be collected and passed on to that function which will return the new attribute value that has to be assigned to the single collapsed edge. It can also be one of the following string constants:<ul><li><code>"ignore"</code>: all the edge attributes will be ignored.</li><li><code>"sum"</code>: the sum of the edge attribute values will be used for the new edge.</li><li><code>"product"</code>: the product of the edge attribute values will be used for the new edge.</li><li><code>"mean"</code>: the mean of the edge attribute values will be used for the new edge.</li><li><code>"median"</code>: the median of the edge attribute values will be used for the new edge.</li><li><code>"min"</code>: the minimum of the edge attribute values will be used for the new edge.</li><li><code>"max"</code>: the maximum of the edge attribute values will be used for the new edge.</li><li><code>"first"</code>: the attribute value of the first edge in the collapsed set will be used for the new edge.</li><li><code>"last"</code>: the attribute value of the last edge in the collapsed set will be used for the new edge.</li><li><code>"random"</code>: a randomly selected value will be used for the new edge</li><li><code>"concat"</code>: the attribute values will be concatenated for the new edge.</li></ul><p>You can also use a dict mapping edge attribute names to functions or the above string constants if you want to make the behaviour of the simplification process depend on the name of the attribute. <code>None</code> is a special key in this dict, its value will be used for all the attributes not specified explicitly in the dictionary.</p></td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase._spanning_tree">
    
  </a>
  <a name="_spanning_tree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_spanning_tree</span>(weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.spanning_tree()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.subcomponent">
    
  </a>
  <a name="subcomponent">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">subcomponent</span>(v, mode='all'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Determines the indices of vertices which are in the same component as a given vertex.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">v</td><td>the index of the vertex used as the source/destination</td></tr><tr><td></td><td class="fieldArg">mode</td><td>if equals to <code>"in"</code>, returns the vertex IDs from where the given vertex can be reached. If equals to <code>"out"</code>, returns the vertex IDs which are reachable from the given vertex. If equals to <code>"all"</code>, returns all vertices within the same component as the given vertex, ignoring edge directions. Note that this is not equal to calculating the union of the results of <code>"in"</code> and <code>"out"</code>.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the indices of vertices which are in the same component as a given vertex.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.subgraph_edges">
    
  </a>
  <a name="subgraph_edges">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">subgraph_edges</span>(edges, delete_vertices=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns a subgraph spanned by the given edges.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">edges</td><td>a list containing the edge IDs which should be included in the result.</td></tr><tr><td></td><td class="fieldArg">delete_vertices</td><td>if <code>True</code>, vertices not incident on any of the specified edges will be deleted from the result. If <code>False</code>, all vertices will be kept.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the subgraph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.topological_sorting">
    
  </a>
  <a name="topological_sorting">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">topological_sorting</span>(mode='out'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates a possible topological sorting of the graph.</p><p>Returns a partial sorting and issues a warning if the graph is not a directed acyclic graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mode</td><td>if <code>"out"</code>, vertices are returned according to the forward topological order -- all vertices come before their successors. If <code>"in"</code>, all vertices come before their ancestors.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a possible topological ordering as a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.to_prufer">
    
  </a>
  <a name="to_prufer">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">to_prufer</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Converts a tree graph into a Prufer sequence.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the Prufer sequence as a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.transitivity_undirected">
    
  </a>
  <a name="transitivity_undirected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">transitivity_undirected</span>(mode='nan'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the global transitivity (clustering coefficient) of the graph.</p><p>The transitivity measures the probability that two neighbors of a vertex are connected. More precisely, this is the ratio of the triangles and connected triplets in the graph. The result is a single real number. Directed graphs are considered as undirected ones.</p><p>Note that this measure is different from the local transitivity measure (see <code><a href="#transitivity_local_undirected">transitivity_local_undirected()</a></code>) as it calculates a single value for the whole graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mode</td><td>if <code>TRANSITIVITY_ZERO</code> or <code>"zero"</code>, the result will be zero if the graph does not have any triplets. If <code>"nan"</code> or <code>TRANSITIVITY_NAN</code>, the result will be <code>NaN</code> (not a number).</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the transitivity</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#transitivity_local_undirected">transitivity_local_undirected()</a></code>, <code><a href="#transitivity_avglocal_undirected">transitivity_avglocal_undirected()</a></code></td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">S. Wasserman and K. Faust: <i>Social Network Analysis: Methods and Applications</i>. Cambridge: Cambridge University Press, 1994.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.transitivity_local_undirected">
    
  </a>
  <a name="transitivity_local_undirected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">transitivity_local_undirected</span>(vertices=None, mode='nan', weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the local transitivity (clustering coefficient) of the given vertices in the graph.</p><p>The transitivity measures the probability that two neighbors of a vertex are connected. In case of the local transitivity, this probability is calculated separately for each vertex.</p><p>Note that this measure is different from the global transitivity measure (see <code><a href="#transitivity_undirected">transitivity_undirected()</a></code>) as it calculates a transitivity value for each vertex individually.</p><p>The traditional local transitivity measure applies for unweighted graphs only. When the <code>weights</code> argument is given, this function calculates the weighted local transitivity proposed by Barrat et al (see references).</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>a list containing the vertex IDs which should be included in the result. <code>None</code> means all of the vertices.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>defines how to treat vertices with degree less than two. If <code>TRANSITIVITT_ZERO</code> or <code>"zero"</code>, these vertices will have zero transitivity. If <code>TRANSITIVITY_NAN</code> or <code>"nan"</code>, these vertices will have <code>NaN</code> (not a number) as their transitivity.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the transitivities for the given vertices in a list</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#transitivity_undirected">transitivity_undirected()</a></code>, <code><a href="#transitivity_avglocal_undirected">transitivity_avglocal_undirected()</a></code></td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Watts DJ and Strogatz S: <i>Collective dynamics of small-world networks</i>. Nature 393(6884):440-442, 1998.</td></tr><tr><td></td><td colspan="2">Barrat A, Barthelemy M, Pastor-Satorras R and Vespignani A: <i>The architecture of complex weighted networks</i>. PNAS 101, 3747 (2004). <a href="http://arxiv.org/abs/cond-mat/0311416" target="_top">http://arxiv.org/abs/cond-mat/0311416</a>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.transitivity_avglocal_undirected">
    
  </a>
  <a name="transitivity_avglocal_undirected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">transitivity_avglocal_undirected</span>(mode='nan'):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Calculates the average of the vertex transitivities of the graph.</p><p>The transitivity measures the probability that two neighbors of a vertex are connected. In case of the average local transitivity, this probability is calculated for each vertex and then the average is taken. Vertices with less than two neighbors require special treatment, they will either be left out from the calculation or they will be considered as having zero transitivity, depending on the <i>mode</i> parameter.</p><p>Note that this measure is different from the global transitivity measure (see <code><a href="#transitivity_undirected">transitivity_undirected()</a></code>) as it simply takes the average local transitivity across the whole network.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mode</td><td>defines how to treat vertices with degree less than two. If <code>TRANSITIVITT_ZERO</code> or <code>"zero"</code>, these vertices will have zero transitivity. If <code>TRANSITIVITY_NAN</code> or <code>"nan"</code>, these vertices will be excluded from the average.</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#transitivity_undirected">transitivity_undirected()</a></code>, <code><a href="#transitivity_local_undirected">transitivity_local_undirected()</a></code></td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">D. J. Watts and S. Strogatz: <i>Collective dynamics of small-world networks</i>. Nature 393(6884):440-442, 1998.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.unfold_tree">
    
  </a>
  <a name="unfold_tree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">unfold_tree</span>(sources=None, mode='out'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Unfolds the graph using a BFS to a tree by duplicating vertices as necessary.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">sources</td><td>the source vertices to start the unfolding from. It should be a list of vertex indices, preferably one vertex from each connected component. You can use <code><a href="#topological_sorting">topological_sorting()</a></code> to determine a suitable set. A single vertex index is also accepted.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>which edges to follow during the BFS. <code>OUT</code> follows outgoing edges, <code>IN</code> follows incoming edges, <code>ALL</code> follows both. Ignored for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the unfolded tree graph and a mapping from the new vertex indices to the old ones.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.vertex_connectivity">
    
  </a>
  <a name="vertex_connectivity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">vertex_connectivity</span>(source=-1, target=-1, checks=True, neighbors='error'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the vertex connectivity of the graph or between some vertices.</p><p>The vertex connectivity between two given vertices is the number of vertices that have to be removed in order to disconnect the two vertices into two separate components. This is also the number of vertex disjoint directed paths between the vertices (apart from the source and target vertices of course). The vertex connectivity of the graph is the minimal vertex connectivity over all vertex pairs.</p><p>This method calculates the vertex connectivity of a given vertex pair if both the source and target vertices are given. If none of them is given (or they are both negative), the overall vertex connectivity is returned.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">source</td><td>the source vertex involved in the calculation.</td></tr><tr><td></td><td class="fieldArg">target</td><td>the target vertex involved in the calculation.</td></tr><tr><td></td><td class="fieldArg">checks</td><td>if the whole graph connectivity is calculated and this is <code>True</code>, igraph performs some basic checks before calculation. If the graph is not strongly connected, then the connectivity is obviously zero. If the minimum degree is one, then the connectivity is also one. These simple checks are much faster than checking the entire graph, therefore it is advised to set this to <code>True</code>. The parameter is ignored if the connectivity between two given vertices is computed.</td></tr><tr><td></td><td class="fieldArg">neighbors</td><td>tells igraph what to do when the two vertices are connected. <code>"error"</code> raises an exception, <code>"infinity"</code> returns infinity, <code>"ignore"</code> ignores the edge.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the vertex connectivity</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.bibcoupling">
    
  </a>
  <a name="bibcoupling">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bibcoupling</span>(vertices=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates bibliographic coupling scores for given vertices in a graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the vertices to be analysed. If <code>None</code>, all vertices will be considered.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">bibliographic coupling scores for all given vertices in a matrix.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.cocitation">
    
  </a>
  <a name="cocitation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">cocitation</span>(vertices=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates cocitation scores for given vertices in a graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the vertices to be analysed. If <code>None</code>, all vertices will be considered.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">cocitation scores for all given vertices in a matrix.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.similarity_dice">
    
  </a>
  <a name="similarity_dice">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">similarity_dice</span>(vertices=None, pairs=None, mode='all', loops=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Dice similarity coefficient of vertices.</p><p>The Dice similarity coefficient of two vertices is twice the number of their common neighbors divided by the sum of their degrees. This coefficient is very similar to the Jaccard coefficient, but usually gives higher similarities than its counterpart.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the vertices to be analysed. If <code>None</code> and <i>pairs</i> is also <code>None</code>, all vertices will be considered.</td></tr><tr><td></td><td class="fieldArg">pairs</td><td>the vertex pairs to be analysed. If this is given, <i>vertices</i> must be <code>None</code>, and the similarity values will be calculated only for the given pairs. Vertex pairs must be specified as tuples of vertex IDs.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>which neighbors should be considered for directed graphs. Can be <code>"all"</code>, <code>"in"</code> or <code>"out"</code>, ignored for undirected graphs.</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether vertices should be considered adjacent to themselves. Setting this to <code>True</code> assumes a loop edge for all vertices even if none is present in the graph. Setting this to <code>False</code> may result in strange results: nonadjacent vertices may have larger similarities compared to the case when an edge is added between them -- however, this might be exactly the result you want to get.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the pairwise similarity coefficients for the vertices specified, in the form of a matrix if <code>pairs</code> is <code>None</code> or in the form of a list if <code>pairs</code> is not <code>None</code>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.similarity_inverse_log_weighted">
    
  </a>
  <a name="similarity_inverse_log_weighted">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">similarity_inverse_log_weighted</span>(vertices=None, mode='all'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Inverse log-weighted similarity coefficient of vertices.</p><p>Each vertex is assigned a weight which is 1 / log(degree). The log-weighted similarity of two vertices is the sum of the weights of their common neighbors.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the vertices to be analysed. If <code>None</code>, all vertices will be considered.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>which neighbors should be considered for directed graphs. Can be <code>"all"</code>, <code>"in"</code> or <code>"out"</code>, ignored for undirected graphs. <code>"in"</code> means that the weights are determined by the out-degrees, <code>"out"</code> means that the weights are determined by the in-degrees.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the pairwise similarity coefficients for the vertices specified, in the form of a matrix (list of lists).</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.similarity_jaccard">
    
  </a>
  <a name="similarity_jaccard">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">similarity_jaccard</span>(vertices=None, pairs=None, mode='all', loops=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Jaccard similarity coefficient of vertices.</p><p>The Jaccard similarity coefficient of two vertices is the number of their common neighbors divided by the number of vertices that are adjacent to at least one of them.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>the vertices to be analysed. If <code>None</code> and <i>pairs</i> is also <code>None</code>, all vertices will be considered.</td></tr><tr><td></td><td class="fieldArg">pairs</td><td>the vertex pairs to be analysed. If this is given, <i>vertices</i> must be <code>None</code>, and the similarity values will be calculated only for the given pairs. Vertex pairs must be specified as tuples of vertex IDs.</td></tr><tr><td></td><td class="fieldArg">mode</td><td>which neighbors should be considered for directed graphs. Can be <code>"all"</code>, <code>"in"</code> or <code>"out"</code>, ignored for undirected graphs.</td></tr><tr><td></td><td class="fieldArg">loops</td><td>whether vertices should be considered adjacent to themselves. Setting this to <code>True</code> assumes a loop edge for all vertices even if none is present in the graph. Setting this to <code>False</code> may result in strange results: nonadjacent vertices may have larger similarities compared to the case when an edge is added between them -- however, this might be exactly the result you want to get.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the pairwise similarity coefficients for the vertices specified, in the form of a matrix if <code>pairs</code> is <code>None</code> or in the form of a list if <code>pairs</code> is not <code>None</code>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.motifs_randesu">
    
  </a>
  <a name="motifs_randesu">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">motifs_randesu</span>(size=3, cut_prob=None, callback=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Counts the number of motifs in the graph</p><p>Motifs are small subgraphs of a given structure in a graph. It is argued that the motif profile (ie. the number of different motifs in the graph) is characteristic for different types of networks and network function is related to the motifs in the graph.</p><p>This function is able to find the different motifs of size three and four (ie. the number of different subgraphs with three and four vertices) in the network.</p><p>In a big network the total number of motifs can be very large, so it takes a lot of time to find all of them. In such cases, a sampling method can be used. This function is capable of doing sampling via the <i>cut_prob</i> argument. This argument gives the probability that a branch of the motif search tree will not be explored.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">size</td><td>the size of the motifs (3 or 4).</td></tr><tr><td></td><td class="fieldArg">cut_prob</td><td>the cut probabilities for different levels of the search tree. This must be a list of length <i>size</i> or <code>None</code> to find all motifs.</td></tr><tr><td></td><td class="fieldArg">callback</td><td><code>None</code> or a callable that will be called for every motif found in the graph. The callable must accept three parameters: the graph itself, the list of vertices in the motif and the isomorphism class of the motif (see <code><a href="#isoclass">isoclass()</a></code>). The search will stop when the callback returns an object with a non-zero truth value or raises an exception.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the list of motifs if <i>callback</i> is <code>None</code>, or <code>None</code> otherwise</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.motifs_randesu_no()</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.motifs_randesu_no">
    
  </a>
  <a name="motifs_randesu_no">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">motifs_randesu_no</span>(size=3, cut_prob=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Counts the total number of motifs in the graph</p><p>Motifs are small subgraphs of a given structure in a graph. This function counts the total number of motifs in a graph without assigning isomorphism classes to them.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">size</td><td>the size of the motifs (3 or 4).</td></tr><tr><td></td><td class="fieldArg">cut_prob</td><td>the cut probabilities for different levels of the search tree. This must be a list of length <i>size</i> or <code>None</code> to find all motifs.</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.motifs_randesu()</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.motifs_randesu_estimate">
    
  </a>
  <a name="motifs_randesu_estimate">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">motifs_randesu_estimate</span>(size=3, cut_prob=None, sample=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Counts the total number of motifs in the graph</p><p>Motifs are small subgraphs of a given structure in a graph. This function estimates the total number of motifs in a graph without assigning isomorphism classes to them by extrapolating from a random sample of vertices.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">size</td><td>the size of the motifs (3 or 4).</td></tr><tr><td></td><td class="fieldArg">cut_prob</td><td>the cut probabilities for different levels of the search tree. This must be a list of length <i>size</i> or <code>None</code> to find all motifs.</td></tr><tr><td></td><td class="fieldArg">sample</td><td>the size of the sample or the vertex IDs of the vertices to be used for sampling.</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.motifs_randesu()</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.dyad_census">
    
  </a>
  <a name="dyad_census">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">dyad_census</span>():
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Dyad census, as defined by Holland and Leinhardt</p><p>Dyad census means classifying each pair of vertices of a directed graph into three categories: mutual, there is an edge from <i>a</i> to <i>b</i> and also from <i>b</i> to <i>a</i>; asymmetric, there is an edge either from <i>a</i> to <i>b</i> or from <i>b</i> to <i>a</i> but not the other way and null, no edges between <i>a</i> and <i>b</i>.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the number of mutual, asymmetric and null connections in a 3-tuple.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html">Graph</a></code> which wraps the result in a <code><a href="igraph.datatypes.DyadCensus.html">DyadCensus</a></code> object. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.triad_census">
    
  </a>
  <a name="triad_census">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">triad_census</span>():
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Triad census, as defined by Davis and Leinhardt</p><p>Calculating the triad census means classifying every triplets of vertices in a directed graph. A triplet can be in one of 16 states, these are listed in the documentation of the C interface of igraph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html">Graph</a></code> which wraps the result in a <code><a href="igraph.datatypes.TriadCensus.html">TriadCensus</a></code> object. It is advised to use that. The name of the triplet classes are also documented there.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_bipartite">
    
  </a>
  <a name="layout_bipartite">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_bipartite</span>(types='type', hgap=1, vgap=1, maxiter=100):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Place the vertices of a bipartite graph in two layers.</p><p>The layout is created by placing the vertices in two rows, according to their types. The positions of the vertices within the rows are then optimized to minimize the number of edge crossings using the heuristic used by the Sugiyama layout algorithm.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">types</td><td>an igraph vector containing the vertex types, or an attribute name. Anything that evalulates to <code>False</code> corresponds to vertices of the first kind, everything else to the second kind.</td></tr><tr><td></td><td class="fieldArg">hgap</td><td>minimum horizontal gap between vertices in the same layer.</td></tr><tr><td></td><td class="fieldArg">vgap</td><td>vertical gap between the two layers.</td></tr><tr><td></td><td class="fieldArg">maxiter</td><td>maximum number of iterations to take in the crossing reduction step. Increase this if you feel that you are getting too many edge crossings.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_circle">
    
  </a>
  <a name="layout_circle">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_circle</span>(dim=2, order=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Places the vertices of the graph uniformly on a circle or a sphere.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">dim</td><td>the desired number of dimensions for the layout. dim=2 means a 2D layout, dim=3 means a 3D layout.</td></tr><tr><td></td><td class="fieldArg">order</td><td>the order in which the vertices are placed along the circle. Not supported when <i>dim</i> is not equal to 2.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_grid">
    
  </a>
  <a name="layout_grid">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_grid</span>(width=0, height=0, dim=2):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Places the vertices of a graph in a 2D or 3D grid.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">width</td><td>the number of vertices in a single row of the layout. Zero or negative numbers mean that the width should be determined automatically.</td></tr><tr><td></td><td class="fieldArg">height</td><td>the number of vertices in a single column of the layout. Zero or negative numbers mean that the height should be determined automatically. It must not be given if the number of dimensions is 2.</td></tr><tr><td></td><td class="fieldArg">dim</td><td>the desired number of dimensions for the layout. dim=2 means a 2D layout, dim=3 means a 3D layout.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_star">
    
  </a>
  <a name="layout_star">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_star</span>(center=0, order=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates a star-like layout for the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">center</td><td>the ID of the vertex to put in the center</td></tr><tr><td></td><td class="fieldArg">order</td><td>a numeric vector giving the order of the vertices (including the center vertex!). If it is <code>None</code>, the vertices will be placed in increasing vertex ID order.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_kamada_kawai">
    
  </a>
  <a name="layout_kamada_kawai">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_kamada_kawai</span>(maxiter=1000, epsilon=0, kkconst=None, seed=None, minx=None, maxx=None, miny=None, maxy=None, minz=None, maxz=None, dim=2):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Places the vertices on a plane according to the Kamada-Kawai algorithm.</p><p>This is a force directed layout, see Kamada, T. and Kawai, S.: An Algorithm for Drawing General Undirected Graphs. Information Processing Letters, 31/1, 7--15, 1989.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">maxiter</td><td>the maximum number of iterations to perform.</td></tr><tr><td></td><td class="fieldArg">epsilon</td><td>quit if the energy of the system changes less than epsilon. See the original paper for details.</td></tr><tr><td></td><td class="fieldArg">kkconst</td><td>the Kamada-Kawai vertex attraction constant. <code>None</code> means the square of the number of vertices.</td></tr><tr><td></td><td class="fieldArg">seed</td><td>if <code>None</code>, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.</td></tr><tr><td></td><td class="fieldArg">minx</td><td>if not <code>None</code>, it must be a vector with exactly as many elements as there are vertices in the graph. Each element is a minimum constraint on the X value of the vertex in the layout.</td></tr><tr><td></td><td class="fieldArg">maxx</td><td>similar to <i>minx</i>, but with maximum constraints</td></tr><tr><td></td><td class="fieldArg">miny</td><td>similar to <i>minx</i>, but with the Y coordinates</td></tr><tr><td></td><td class="fieldArg">maxy</td><td>similar to <i>maxx</i>, but with the Y coordinates</td></tr><tr><td></td><td class="fieldArg">minz</td><td>similar to <i>minx</i>, but with the Z coordinates. Use only for 3D layouts (<code>dim</code>=3).</td></tr><tr><td></td><td class="fieldArg">maxz</td><td>similar to <i>maxx</i>, but with the Z coordinates. Use only for 3D layouts (<code>dim</code>=3).</td></tr><tr><td></td><td class="fieldArg">dim</td><td>the desired number of dimensions for the layout. dim=2 means a 2D layout, dim=3 means a 3D layout.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_davidson_harel">
    
  </a>
  <a name="layout_davidson_harel">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_davidson_harel</span>(seed=None, maxiter=10, fineiter=-1, cool_fact=0.75, weight_node_dist=1.0, weight_border=0.0, weight_edge_lengths=-1, weight_edge_crossings=-1, weight_node_edge_dist=-1):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm.</p><p>The algorithm uses simulated annealing and a sophisticated energy function, which is unfortunately hard to parameterize for different graphs. The original publication did not disclose any parameter values, and the ones below were determined by experimentation.</p><p>The algorithm consists of two phases: an annealing phase and a fine-tuning phase. There is no simulated annealing in the second phase.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">seed</td><td>if <code>None</code>, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.</td></tr><tr><td></td><td class="fieldArg">maxiter</td><td>Number of iterations to perform in the annealing phase.</td></tr><tr><td></td><td class="fieldArg">fineiter</td><td>Number of iterations to perform in the fine-tuning phase. Negative numbers set up a reasonable default from the base-2 logarithm of the vertex count, bounded by 10 from above.</td></tr><tr><td></td><td class="fieldArg">cool_fact</td><td>Cooling factor of the simulated annealing phase.</td></tr><tr><td></td><td class="fieldArg">weight_node_dist</td><td>Weight for the node-node distances in the energy function.</td></tr><tr><td></td><td class="fieldArg">weight_border</td><td>Weight for the distance from the border component of the energy function. Zero means that vertices are allowed to sit on the border of the area designated for the layout.</td></tr><tr><td></td><td class="fieldArg">weight_edge_lengths</td><td>Weight for the edge length component of the energy function. Negative numbers are replaced by the density of the graph divided by 10.</td></tr><tr><td></td><td class="fieldArg">weight_edge_crossings</td><td>Weight for the edge crossing component of the energy function. Negative numbers are replaced by one minus the square root of the density of the graph.</td></tr><tr><td></td><td class="fieldArg">weight_node_edge_dist</td><td>Weight for the node-edge distance component of the energy function. Negative numbers are replaced by 0.2 minus 0.2 times the density of the graph.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_drl">
    
  </a>
  <a name="layout_drl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_drl</span>(weights=None, fixed=None, seed=None, options=None, dim=2):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm.</p><p>This is an algorithm suitable for quite large graphs, but it can be surprisingly slow for small ones (where the simpler force-based layouts like <code>layout_kamada_kawai()</code> or <code>layout_fruchterman_reingold()</code> are more useful.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td></td><td class="fieldArg">fixed</td><td>ignored. We used to assume that the DrL layout supports fixed nodes, but later it turned out that the argument has no effect in the original DrL code. We kept the argument for sake of backwards compatibility, but it will have no effect on the final layout.</td></tr><tr><td></td><td class="fieldArg">seed</td><td>if <code>None</code>, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.</td></tr><tr><td></td><td class="fieldArg">options</td><td>if you give a string argument here, you can select from five default preset parameterisations: <code>default</code>, <code>coarsen</code> for a coarser layout, <code>coarsest</code> for an even coarser layout, <code>refine</code> for refining an existing layout and <code>final</code> for finalizing a layout. If you supply an object that is not a string, the DrL layout parameters are retrieved from the respective keys of the object (so it should be a dict or something else that supports the mapping protocol). The following keys can be used:<ul><li><code>edge_cut</code>: edge cutting is done in the late stages of the algorithm in order to achieve less dense layouts. Edges are cut if there is a lot of stress on them (a large value in the objective function sum). The edge cutting parameter is a value between 0 and 1 with 0 representing no edge cutting and 1 representing maximal edge cutting.</li><li><code>init_iterations</code>: number of iterations in the initialization phase</li><li><code>init_temperature</code>: start temperature during initialization</li><li><code>init_attraction</code>: attraction during initialization</li><li><code>init_damping_mult</code>: damping multiplier during initialization</li><li><code>liquid_iterations</code>, <code>liquid_temperature</code>, <code>liquid_attraction</code>, <code>liquid_damping_mult</code>: same parameters for the liquid phase</li><li><code>expansion_iterations</code>, <code>expansion_temperature</code>, <code>expansion_attraction</code>, <code>expansion_damping_mult</code>: parameters for the expansion phase</li><li><code>cooldown_...</code>: parameters for the cooldown phase</li><li><code>crunch_...</code>: parameters for the crunch phase</li><li><code>simmer_...</code>: parameters for the simmer phase</li></ul><p>Instead of a mapping, you can also use an arbitrary Python object here: if the object does not support the mapping protocol, an attribute of the object with the same name is looked up instead. If a parameter cannot be found either as a key or an attribute, the default from the <code>default</code> preset will be used.</p></td></tr><tr><td></td><td class="fieldArg">dim</td><td>the desired number of dimensions for the layout. dim=2 means a 2D layout, dim=3 means a 3D layout.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_fruchterman_reingold">
    
  </a>
  <a name="layout_fruchterman_reingold">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_fruchterman_reingold</span>(weights=None, niter=500, seed=None, start_temp=None, minx=None, maxx=None, miny=None, maxy=None, minz=None, maxz=None, grid='auto'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm.</p><p>This is a force directed layout, see Fruchterman, T. M. J. and Reingold, E. M.: Graph Drawing by Force-directed Placement. Software -- Practice and Experience, 21/11, 1129--1164, 1991</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td></td><td class="fieldArg">niter</td><td>the number of iterations to perform. The default is 500.</td></tr><tr><td></td><td class="fieldArg">seed</td><td>if <code>None</code>, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.</td></tr><tr><td></td><td class="fieldArg">start_temp</td><td>Real scalar, the start temperature. This is the maximum amount of movement alloved along one axis, within one step, for a vertex. Currently it is decreased linearly to zero during the iteration. The default is the square root of the number of vertices divided by 10.</td></tr><tr><td></td><td class="fieldArg">minx</td><td>if not <code>None</code>, it must be a vector with exactly as many elements as there are vertices in the graph. Each element is a minimum constraint on the X value of the vertex in the layout.</td></tr><tr><td></td><td class="fieldArg">maxx</td><td>similar to <i>minx</i>, but with maximum constraints</td></tr><tr><td></td><td class="fieldArg">miny</td><td>similar to <i>minx</i>, but with the Y coordinates</td></tr><tr><td></td><td class="fieldArg">maxy</td><td>similar to <i>maxx</i>, but with the Y coordinates</td></tr><tr><td></td><td class="fieldArg">minz</td><td>similar to <i>minx</i>, but with the Z coordinates. Use only for 3D layouts (<code>dim</code>=3).</td></tr><tr><td></td><td class="fieldArg">maxz</td><td>similar to <i>maxx</i>, but with the Z coordinates. Use only for 3D layouts (<code>dim</code>=3).</td></tr><tr><td></td><td class="fieldArg">grid</td><td>whether to use a faster, but less accurate grid-based implementation of the algorithm. <code>"auto"</code> decides based on the number of vertices in the graph; a grid will be used if there are at least 1000 vertices. <code>"grid"</code> is equivalent to <code>True</code>, <code>"nogrid"</code> is equivalent to <code>False</code>.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_graphopt">
    
  </a>
  <a name="layout_graphopt">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_graphopt</span>(niter=500, node_charge=0.001, node_mass=30, spring_length=0, spring_constant=1, max_sa_movement=5, seed=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed.</p><p>graphopt uses physical analogies for defining attracting and repelling forces among the vertices and then the physical system is simulated until it reaches an equilibrium or the maximal number of iterations is reached.</p><p>See <a href="http://www.schmuhl.org/graphopt/" target="_top">http://www.schmuhl.org/graphopt/</a> for the original graphopt.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">niter</td><td>the number of iterations to perform. Should be a couple of hundred in general.</td></tr><tr><td></td><td class="fieldArg">node_charge</td><td>the charge of the vertices, used to calculate electric repulsion.</td></tr><tr><td></td><td class="fieldArg">node_mass</td><td>the mass of the vertices, used for the spring forces</td></tr><tr><td></td><td class="fieldArg">spring_length</td><td>the length of the springs</td></tr><tr><td></td><td class="fieldArg">spring_constant</td><td>the spring constant</td></tr><tr><td></td><td class="fieldArg">max_sa_movement</td><td>the maximum amount of movement allowed in a single step along a single axis.</td></tr><tr><td></td><td class="fieldArg">seed</td><td>a matrix containing a seed layout from which the algorithm will be started. If <code>None</code>, a random layout will be used.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_lgl">
    
  </a>
  <a name="layout_lgl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_lgl</span>(maxiter=150, maxdelta=-1, area=-1, coolexp=1.5, repulserad=-1, cellsize=-1, root=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Places the vertices on a 2D plane according to the Large Graph Layout.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">maxiter</td><td>the number of iterations to perform.</td></tr><tr><td></td><td class="fieldArg">maxdelta</td><td>the maximum distance to move a vertex in an iteration. If negative, defaults to the number of vertices.</td></tr><tr><td></td><td class="fieldArg">area</td><td>the area of the square on which the vertices will be placed. If negative, defaults to the number of vertices squared.</td></tr><tr><td></td><td class="fieldArg">coolexp</td><td>the cooling exponent of the simulated annealing.</td></tr><tr><td></td><td class="fieldArg">repulserad</td><td>determines the radius at which vertex-vertex repulsion cancels out attraction of adjacent vertices. If negative, defaults to <i class="math">area</i> times the number of vertices.</td></tr><tr><td></td><td class="fieldArg">cellsize</td><td>the size of the grid cells. When calculating the repulsion forces, only vertices in the same or neighboring grid cells are taken into account. Defaults to the fourth root of <i class="math">area</i>.</td></tr><tr><td></td><td class="fieldArg">root</td><td>the root vertex, this is placed first, its neighbors in the first iteration, second neighbors in the second, etc. <code>None</code> means that a random vertex will be chosen.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_mds">
    
  </a>
  <a name="layout_mds">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_mds</span>(dist=None, dim=2, arpack_options=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling.</p><p>This layout requires a distance matrix, where the intersection of row <i class="math">i</i> and column <i class="math">j</i> specifies the desired distance between vertex <i class="math">i</i> and vertex <i class="math">j</i>. The algorithm will try to place the vertices in a way that approximates the distance relations prescribed in the distance matrix. igraph uses the classical multidimensional scaling by Torgerson (see reference below).</p><p>For unconnected graphs, the method will decompose the graph into weakly connected components and then lay out the components individually using the appropriate parts of the distance matrix.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">dist</td><td>the distance matrix. It must be symmetric and the symmetry is not checked -- results are unspecified when a non-symmetric distance matrix is used. If this parameter is <code>None</code>, the shortest path lengths will be used as distances. Directed graphs are treated as undirected when calculating the shortest path lengths to ensure symmetry.</td></tr><tr><td></td><td class="fieldArg">dim</td><td>the number of dimensions. For 2D layouts, supply 2 here; for 3D layouts, supply 3.</td></tr><tr><td></td><td class="fieldArg">arpack_options</td><td>an <code><a href="igraph._igraph.ARPACKOptions.html">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <code>arpack_options</code> is used.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Cox &amp; Cox: Multidimensional Scaling (1994), Chapman and Hall, London.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_reingold_tilford">
    
  </a>
  <a name="layout_reingold_tilford">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_reingold_tilford</span>(mode='out', root=None, rootlevel=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm.</p><p>This is a tree layout. If the given graph is not a tree, a breadth-first search is executed first to obtain a possible spanning tree.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mode</td><td>specifies which edges to consider when builing the tree. If it is <code>OUT</code> then only the outgoing, if it is <code>IN</code> then only the incoming edges of a parent are considered. If it is <code>ALL</code> then all edges are used (this was the behaviour in igraph 0.5 and before). This parameter also influences how the root vertices are calculated if they are not given. See the <i>root</i> parameter.</td></tr><tr><td></td><td class="fieldArg">root</td><td>the index of the root vertex or root vertices. If this is a non-empty vector then the supplied vertex IDs are used as the roots of the trees (or a single tree if the graph is connected). If this is <code>None</code> or an empty list, the root vertices are automatically calculated in such a way so that all other vertices would be reachable from them. Currently, automatic root selection prefers low eccentricity vertices in small graphs (fewer than 500 vertices) and high degree vertices in large graphs. This heuristic may change in future versions. Specify roots manually for a consistent output.</td></tr><tr><td></td><td class="fieldArg">rootlevel</td><td>this argument is useful when drawing forests which are not trees. It specifies the level of the root vertices for every tree in the forest.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">layout_reingold_tilford_circular</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">EM Reingold, JS Tilford: <i>Tidier Drawings of Trees.</i> IEEE Transactions on Software Engineering 7:22, 223-228, 1981.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_reingold_tilford_circular">
    
  </a>
  <a name="layout_reingold_tilford_circular">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_reingold_tilford_circular</span>(mode='out', root=None, rootlevel=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Circular Reingold-Tilford layout for trees.</p><p>This layout is similar to the Reingold-Tilford layout, but the vertices are placed in a circular way, with the root vertex in the center.</p><p>See <code><a href="#layout_reingold_tilford">layout_reingold_tilford</a></code> for the explanation of the parameters.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated layout.</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">layout_reingold_tilford</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">EM Reingold, JS Tilford: <i>Tidier Drawings of Trees.</i> IEEE Transactions on Software Engineering 7:22, 223-228, 1981.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.layout_random">
    
  </a>
  <a name="layout_random">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_random</span>(dim=2):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Places the vertices of the graph randomly.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">dim</td><td>the desired number of dimensions for the layout. dim=2 means a 2D layout, dim=3 means a 3D layout.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the coordinate pairs in a list.</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase._layout_sugiyama">
    
  </a>
  <a name="_layout_sugiyama">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_layout_sugiyama</span> (INVALID):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.layout_sugiyama()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.bfs">
    
  </a>
  <a name="bfs">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bfs</span>(vid, mode='out'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Conducts a breadth first search (BFS) on the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vid</td><td>the root vertex ID</td></tr><tr><td></td><td class="fieldArg">mode</td><td>either <code>"in"</code> or <code>"out"</code> or <code>"all"</code>, ignored for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a tuple with the following items:<ul><li>The vertex IDs visited (in order)</li><li>The start indices of the layers in the vertex list</li><li>The parent of every vertex in the BFS</li></ul></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.bfsiter">
    
  </a>
  <a name="bfsiter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bfsiter</span>(vid, mode='out', advanced=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Constructs a breadth first search (BFS) iterator of the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vid</td><td>the root vertex ID</td></tr><tr><td></td><td class="fieldArg">mode</td><td>either <code>"in"</code> or <code>"out"</code> or <code>"all"</code>.</td></tr><tr><td></td><td class="fieldArg">advanced</td><td>if <code>False</code>, the iterator returns the next vertex in BFS order in every step. If <code>True</code>, the iterator returns the distance of the vertex from the root and the parent of the vertex in the BFS tree as well.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the BFS iterator as an <code><a href="igraph._igraph.BFSIter.html">igraph.BFSIter</a></code> object.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.dfsiter">
    
  </a>
  <a name="dfsiter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">dfsiter</span>(vid, mode='out', advanced=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Constructs a depth first search (DFS) iterator of the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vid</td><td>the root vertex ID</td></tr><tr><td></td><td class="fieldArg">mode</td><td>either <code>"in"</code> or <code>"out"</code> or <code>"all"</code>.</td></tr><tr><td></td><td class="fieldArg">advanced</td><td>if <code>False</code>, the iterator returns the next vertex in DFS order in every step. If <code>True</code>, the iterator returns the distance of the vertex from the root and the parent of the vertex in the DFS tree as well.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the DFS iterator as an <code><a href="igraph._igraph.DFSIter.html">igraph.DFSIter</a></code> object.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.get_adjacency">
    
  </a>
  <a name="get_adjacency">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_adjacency</span>(type='both', eids=False):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Returns the adjacency matrix of a graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">type</td><td>one of <code>"lower"</code> (uses the lower triangle of the matrix), <code>"upper"</code> (uses the upper triangle) or <code>"both"</code> (uses both parts). Ignored for directed graphs.</td></tr><tr><td></td><td class="fieldArg">eids</td><td>if <code>True</code>, the result matrix will contain zeros for non-edges and the ID of the edge plus one for edges in the appropriate cell. If <code>False</code>, the result matrix will contain the number of edges for each vertex pair.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the adjacency matrix.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.get_edgelist">
    
  </a>
  <a name="get_edgelist">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_edgelist</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the edge list of a graph.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.get_incidence">
    
  </a>
  <a name="get_incidence">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_incidence</span>(types):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.get_incidence()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.to_directed">
    
  </a>
  <a name="to_directed">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">to_directed</span>(mode='mutual'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Converts an undirected graph to directed.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mode</td><td>specifies how to convert undirected edges into directed ones. <code>True</code> or <code>"mutual"</code> creates a mutual edge pair for each undirected edge. <code>False</code> or <code>"arbitrary"</code> picks an arbitrary (but deterministic) edge direction for each edge. <code>"random"</code> picks a random direction for each edge. <code>"acyclic"</code> picks the edge directions in a way that the resulting graph will be acyclic if there were no self-loops in the original graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.to_undirected">
    
  </a>
  <a name="to_undirected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">to_undirected</span>(mode='collapse', combine_edges=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Converts a directed graph to undirected.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mode</td><td>specifies what to do with multiple directed edges going between the same vertex pair. <code>True</code> or <code>"collapse"</code> means that only a single edge should be created from multiple directed edges. <code>False</code> or <code>"each"</code> means that every edge will be kept (with the arrowheads removed). <code>"mutual"</code> creates one undirected edge for each mutual directed edge pair.</td></tr><tr><td></td><td class="fieldArg">combine_edges</td><td>specifies how to combine the attributes of multiple edges between the same pair of vertices into a single attribute. See <code><a href="#simplify">simplify()</a></code> for more details.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.laplacian">
    
  </a>
  <a name="laplacian">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">laplacian</span>(weights=None, normalized=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the Laplacian matrix of a graph.</p><p>The Laplacian matrix is similar to the adjacency matrix, but the edges are denoted with -1 and the diagonal contains the node degrees.</p><p>Normalized Laplacian matrices have 1 or 0 in their diagonals (0 for vertices with no edges), edges are denoted by 1 / sqrt(d_i * d_j) where d_i is the degree of node i.</p><p>Multiple edges and self-loops are silently ignored. Although it is possible to calculate the Laplacian matrix of a directed graph, it does not make much sense.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name. When edge weights are used, the degree of a node is considered to be the weight of its incident edges.</td></tr><tr><td></td><td class="fieldArg">normalized</td><td>whether to return the normalized Laplacian matrix.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the Laplacian matrix.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Read_DIMACS">
    
  </a>
  <a name="Read_DIMACS">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_DIMACS</span>(f, directed=False):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Reads a graph from a file conforming to the DIMACS minimum-cost flow file format.</p><p>For the exact description of the format, see <a href="http://lpsolve.sourceforge.net/5.5/DIMACS.htm" target="_top">http://lpsolve.sourceforge.net/5.5/DIMACS.htm</a></p><p>Restrictions compared to the official description of the format:</p><ul><li>igraph's DIMACS reader requires only three fields in an arc definition, describing the edge's source and target node and its capacity.</li><li>Source vertices are identified by 's' in the FLOW field, target vertices are identified by 't'.</li><li>Node indices start from 1. Only a single source and target node is allowed.</li></ul><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file or a Python file handle</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the generated graph should be directed.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the generated graph, the source and the target of the flow and the edge capacities in a tuple</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Read_DL">
    
  </a>
  <a name="Read_DL">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_DL</span>(f, directed=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Reads an UCINET DL file and creates a graph based on it.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file or a Python file handle</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the generated graph should be directed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Read_Edgelist">
    
  </a>
  <a name="Read_Edgelist">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_Edgelist</span>(f, directed=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Reads an edge list from a file and creates a graph based on it.</p><p>Please note that the vertex indices are zero-based. A vertex of zero degree will be created for every integer that is in range but does not appear in the edgelist.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file or a Python file handle</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the generated graph should be directed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Read_GraphDB">
    
  </a>
  <a name="Read_GraphDB">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_GraphDB</span>(f, directed=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Reads a GraphDB format file and creates a graph based on it.</p><p>GraphDB is a binary format, used in the graph database for isomorphism testing (see <a href="http://amalfi.dis.unina.it/graph/" target="_top">http://amalfi.dis.unina.it/graph/</a>).</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file or a Python file handle</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the generated graph should be directed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Read_GraphML">
    
  </a>
  <a name="Read_GraphML">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_GraphML</span>(f, index=0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Reads a GraphML format file and creates a graph based on it.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file or a Python file handle</td></tr><tr><td></td><td class="fieldArg">index</td><td>if the GraphML file contains multiple graphs, specifies the one that should be loaded. Graph indices start from zero, so if you want to load the first graph, specify 0 here.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Read_GML">
    
  </a>
  <a name="Read_GML">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_GML</span>(f):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Reads a GML file and creates a graph based on it.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file or a Python file handle</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Read_Ncol">
    
  </a>
  <a name="Read_Ncol">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_Ncol</span>(f, names=True, weights='if_present', directed=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Reads an .ncol file used by LGL.</p><p>It is also useful for creating graphs from "named" (and optionally weighted) edge lists.</p><p>This format is used by the Large Graph Layout program. See the <a href="https://github.com/TheOpteProject/LGL/" target="_top">repository of LGL</a> for more information.</p><p>LGL originally cannot deal with graphs containing multiple or loop edges, but this condition is not checked here, as igraph is happy with these.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file or a Python file handle</td></tr><tr><td></td><td class="fieldArg">names</td><td>If <code>True</code>, the vertex names are added as a vertex attribute called 'name'.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>If True, the edge weights are added as an edge attribute called 'weight', even if there are no weights in the file. If False, the edge weights are never added, even if they are present. <code>"auto"</code> or <code>"if_present"</code> means that weights are added if there is at least one weighted edge in the input file, but they are not added otherwise.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the graph being created should be directed</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Read_Lgl">
    
  </a>
  <a name="Read_Lgl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_Lgl</span>(f, names=True, weights='if_present', directed=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Reads an .lgl file used by LGL.</p><p>It is also useful for creating graphs from "named" (and optionally weighted) edge lists.</p><p>This format is used by the Large Graph Layout program. See the <a href="http://bioinformatics.icmb.utexas.edu/lgl/" target="_top">documentation of LGL</a> regarding the exact format description.</p><p>LGL originally cannot deal with graphs containing multiple or loop edges, but this condition is not checked here, as igraph is happy with these.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file or a Python file handle</td></tr><tr><td></td><td class="fieldArg">names</td><td>If <code>True</code>, the vertex names are added as a vertex attribute called 'name'.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>If True, the edge weights are added as an edge attribute called 'weight', even if there are no weights in the file. If False, the edge weights are never added, even if they are present. <code>"auto"</code> or <code>"if_present"</code> means that weights are added if there is at least one weighted edge in the input file, but they are not added otherwise.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether the graph being created should be directed</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.Read_Pajek">
    
  </a>
  <a name="Read_Pajek">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_Pajek</span>(f):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Reads a Pajek format file and creates a graph based on it.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file or a Python file handle</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.write_dimacs">
    
  </a>
  <a name="write_dimacs">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_dimacs</span>(f, source, target, capacity=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Writes the graph in DIMACS format to the given file.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file to be written or a Python file handle</td></tr><tr><td></td><td class="fieldArg">source</td><td>the source vertex ID</td></tr><tr><td></td><td class="fieldArg">target</td><td>the target vertex ID</td></tr><tr><td></td><td class="fieldArg">capacity</td><td>the capacities of the edges in a list. If it is not a list, the corresponding edge attribute will be used to retrieve capacities.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.write_dot">
    
  </a>
  <a name="write_dot">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_dot</span>(f):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Writes the graph in DOT format to the given file.</p><p>DOT is the format used by the <a href="http://www.graphviz.org" target="_top">GraphViz</a> software package.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file to be written or a Python file handle</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.write_edgelist">
    
  </a>
  <a name="write_edgelist">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_edgelist</span>(f):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Writes the edge list of a graph to a file.</p><p>Directed edges are written in (from, to) order.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file to be written or a Python file handle</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.write_gml">
    
  </a>
  <a name="write_gml">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_gml</span>(f, creator=None, ids=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Writes the graph in GML format to the given file.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file to be written or a Python file handle</td></tr><tr><td></td><td class="fieldArg">creator</td><td>optional creator information to be written to the file. If <code>None</code>, the current date and time is added.</td></tr><tr><td></td><td class="fieldArg">ids</td><td>optional numeric vertex IDs to use in the file. This must be a list of integers or <code>None</code>. If <code>None</code>, the <code>id</code> attribute of the vertices are used, or if they don't exist, numeric vertex IDs will be generated automatically.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.write_ncol">
    
  </a>
  <a name="write_ncol">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_ncol</span>(f, names='name', weights='weights'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Writes the edge list of a graph to a file in .ncol format.</p><p>Note that multiple edges and/or loops break the LGL software, but igraph does not check for this condition. Unless you know that the graph does not have multiple edges and/or loops, it is wise to call <code><a href="#simplify">simplify()</a></code> before saving.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file to be written or a Python file handle</td></tr><tr><td></td><td class="fieldArg">names</td><td>the name of the vertex attribute containing the name of the vertices. If you don't want to store vertex names, supply <code>None</code> here.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>the name of the edge attribute containing the weight of the vertices. If you don't want to store weights, supply <code>None</code> here.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.write_lgl">
    
  </a>
  <a name="write_lgl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_lgl</span>(f, names='name', weights='weights', isolates=True):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Writes the edge list of a graph to a file in .lgl format.</p><p>Note that multiple edges and/or loops break the LGL software, but igraph does not check for this condition. Unless you know that the graph does not have multiple edges and/or loops, it is wise to call <code><a href="#simplify">simplify()</a></code> before saving.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file to be written or a Python file handle</td></tr><tr><td></td><td class="fieldArg">names</td><td>the name of the vertex attribute containing the name of the vertices. If you don't want to store vertex names, supply <code>None</code> here.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>the name of the edge attribute containing the weight of the vertices. If you don't want to store weights, supply <code>None</code> here.</td></tr><tr><td></td><td class="fieldArg">isolates</td><td>whether to include isolated vertices in the output.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.write_pajek">
    
  </a>
  <a name="write_pajek">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_pajek</span>(f):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Writes the graph in Pajek format to the given file.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file to be written or a Python file handle</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.write_graphml">
    
  </a>
  <a name="write_graphml">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_graphml</span>(f):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Writes the graph to a GraphML file.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file to be written or a Python file handle</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.write_leda">
    
  </a>
  <a name="write_leda">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_leda</span>(f, names='name', weights='weights'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Writes the graph to a file in LEDA native format.</p><p>The LEDA format supports at most one attribute per vertex and edge. You can specify which vertex and edge attribute you want to use. Note that the name of the attribute is not saved in the LEDA file.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">f</td><td>the name of the file to be written or a Python file handle</td></tr><tr><td></td><td class="fieldArg">names</td><td>the name of the vertex attribute to be stored along with the vertices. It is usually used to store the vertex names (hence the name of the keyword argument), but you may also use a numeric attribute. If you don't want to store any vertex attributes, supply <code>None</code> here.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>the name of the edge attribute to be stored along with the edges. It is usually used to store the edge weights (hence the name of the keyword argument), but you may also use a string attribute. If you don't want to store any edge attributes, supply <code>None</code> here.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.canonical_permutation">
    
  </a>
  <a name="canonical_permutation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">canonical_permutation</span>(sh='fl', color=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm.</p><p>Passing the permutation returned here to <code><a href="#permute_vertices">permute_vertices()</a></code> will transform the graph into its canonical form.</p><p>See <a href="http://www.tcs.hut.fi/Software/bliss/index.html" target="_top">http://www.tcs.hut.fi/Software/bliss/index.html</a> for more information about the BLISS algorithm and canonical permutations.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">sh</td><td>splitting heuristics for graph as a case-insensitive string, with the following possible values:<ul><li><code>"f"</code>: first non-singleton cell</li><li><code>"fl"</code>: first largest non-singleton cell</li><li><code>"fs"</code>: first smallest non-singleton cell</li><li><code>"fm"</code>: first maximally non-trivially connected non-singleton cell</li><li><code>"flm"</code>: largest maximally non-trivially connected non-singleton cell</li><li><code>"fsm"</code>: smallest maximally non-trivially connected non-singleton cell</li></ul></td></tr><tr><td></td><td class="fieldArg">color</td><td>optional vector storing a coloring of the vertices with respect to which the isomorphism is computed.If <code>None</code>, all vertices have the same color.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a permutation vector containing vertex IDs. Vertex 0 in the original graph will be mapped to an ID contained in the first element of this vector; vertex 1 will be mapped to the second and so on.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.isoclass">
    
  </a>
  <a name="isoclass">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">isoclass</span>(vertices):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the isomorphism class of the graph or its subgraph.</p><p>Isomorphy class calculations are implemented only for graphs with 3 or 4 vertices.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>a list of vertices if we want to calculate the isomorphism class for only a subset of vertices. <code>None</code> means to use the full graph.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the isomorphism class of the (sub)graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.isomorphic">
    
  </a>
  <a name="isomorphic">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">isomorphic</span>(other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether the graph is isomorphic to another graph.</p><p>The algorithm being used is selected using a simple heuristic:</p><ul><li>If one graph is directed and the other undirected, an exception is thrown.</li><li>If the two graphs does not have the same number of vertices and edges, it returns with <code>False</code></li><li>If the graphs have three or four vertices, then an O(1) algorithm is used with precomputed data.</li><li>Otherwise if the graphs are directed, then the VF2 isomorphism algorithm is used (see <code><a href="#isomorphic_vf2">isomorphic_vf2</a></code>).</li><li>Otherwise the BLISS isomorphism algorithm is used, see <code><a href="#isomorphic_bliss">isomorphic_bliss</a></code>.</li></ul><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>True</code> if the graphs are isomorphic, <code>False</code> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.isomorphic_bliss">
    
  </a>
  <a name="isomorphic_bliss">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">isomorphic_bliss</span>(other, return_mapping_12=False, return_mapping_21=False, sh1='fl', sh2=None, color1=None, color2=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm.</p><p>See <a href="http://www.tcs.hut.fi/Software/bliss/index.html" target="_top">http://www.tcs.hut.fi/Software/bliss/index.html</a> for more information about the BLISS algorithm.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">other</td><td>the other graph with which we want to compare the graph.</td></tr><tr><td></td><td class="fieldArg">return_mapping_12</td><td>if <code>True</code>, calculates the mapping which maps the vertices of the first graph to the second.</td></tr><tr><td></td><td class="fieldArg">return_mapping_21</td><td>if <code>True</code>, calculates the mapping which maps the vertices of the second graph to the first.</td></tr><tr><td></td><td class="fieldArg">sh1</td><td>splitting heuristics for the first graph as a case-insensitive string, with the following possible values:<ul><li><code>"f"</code>: first non-singleton cell</li><li><code>"fl"</code>: first largest non-singleton cell</li><li><code>"fs"</code>: first smallest non-singleton cell</li><li><code>"fm"</code>: first maximally non-trivially connected non-singleton cell</li><li><code>"flm"</code>: largest maximally non-trivially connected non-singleton cell</li><li><code>"fsm"</code>: smallest maximally non-trivially connected non-singleton cell</li></ul></td></tr><tr><td></td><td class="fieldArg">sh2</td><td>splitting heuristics to be used for the second graph. This must be the same as <code>sh1</code>; alternatively, it can be <code>None</code>, in which case it will automatically use the same value as <code>sh1</code>. Currently it is present for backwards compatibility only.</td></tr><tr><td></td><td class="fieldArg">color1</td><td>optional vector storing the coloring of the vertices of the first graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">color2</td><td>optional vector storing the coloring of the vertices of the second graph. If <code>None</code>, all vertices have the same color.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">if no mapping is calculated, the result is <code>True</code> if the graphs are isomorphic, <code>False</code> otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -&gt; 2 mapping and the third element being the 2 -&gt; 1 mapping. If the corresponding mapping was not calculated, <code>None</code> is returned in the appropriate element of the 3-tuple.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.isomorphic_vf2">
    
  </a>
  <a name="isomorphic_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">isomorphic_vf2</span>(other=None, color1=None, color2=None, edge_color1=None, edge_color2=None, return_mapping_12=False, return_mapping_21=False, node_compat_fn=None, edge_compat_fn=None, callback=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm.</p><p>Vertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">other</td><td>the other graph with which we want to compare the graph. If <code>None</code>, the automorphjisms of the graph will be tested.</td></tr><tr><td></td><td class="fieldArg">color1</td><td>optional vector storing the coloring of the vertices of the first graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">color2</td><td>optional vector storing the coloring of the vertices of the second graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">edge_color1</td><td>optional vector storing the coloring of the edges of the first graph. If <code>None</code>, all edges have the same color.</td></tr><tr><td></td><td class="fieldArg">edge_color2</td><td>optional vector storing the coloring of the edges of the second graph. If <code>None</code>, all edges have the same color.</td></tr><tr><td></td><td class="fieldArg">return_mapping_12</td><td>if <code>True</code>, calculates the mapping which maps the vertices of the first graph to the second.</td></tr><tr><td></td><td class="fieldArg">return_mapping_21</td><td>if <code>True</code>, calculates the mapping which maps the vertices of the second graph to the first.</td></tr><tr><td></td><td class="fieldArg">node_compat_fn</td><td>a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns <code>True</code> if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or <code>False</code> otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the <code>color1</code> and <code>color2</code> parameters). <code>None</code> means that every node is compatible with every other node.</td></tr><tr><td></td><td class="fieldArg">edge_compat_fn</td><td>a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns <code>True</code> if the edges given by the two indices are compatible (i.e. they could be matched to each other) or <code>False</code> otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the <code>edge_color1</code> and <code>edge_color2</code> parameters). <code>None</code> means that every edge is compatible with every other node.</td></tr><tr><td></td><td class="fieldArg">callback</td><td>if not <code>None</code>, the isomorphism search will not stop at the first match; it will call this callback function instead for every isomorphism found. The callback function must accept four arguments: the first graph, the second graph, a mapping from the nodes of the first graph to the second, and a mapping from the nodes of the second graph to the first. The function must return <code>True</code> if the search should continue or <code>False</code> otherwise.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">if no mapping is calculated, the result is <code>True</code> if the graphs are isomorphic, <code>False</code> otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -&gt; 2 mapping and the third element being the 2 -&gt; 1 mapping. If the corresponding mapping was not calculated, <code>None</code> is returned in the appropriate element of the 3-tuple.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.count_isomorphisms_vf2">
    
  </a>
  <a name="count_isomorphisms_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">count_isomorphisms_vf2</span>(other=None, color1=None, color2=None, edge_color1=None, edge_color2=None, node_compat_fn=None, edge_compat_fn=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Determines the number of isomorphisms between the graph and another one</p><p>Vertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">other</td><td>the other graph. If <code>None</code>, the number of automorphisms will be returned.</td></tr><tr><td></td><td class="fieldArg">color1</td><td>optional vector storing the coloring of the vertices of the first graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">color2</td><td>optional vector storing the coloring of the vertices of the second graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">edge_color1</td><td>optional vector storing the coloring of the edges of the first graph. If <code>None</code>, all edges have the same color.</td></tr><tr><td></td><td class="fieldArg">edge_color2</td><td>optional vector storing the coloring of the edges of the second graph. If <code>None</code>, all edges have the same color.</td></tr><tr><td></td><td class="fieldArg">node_compat_fn</td><td>a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns <code>True</code> if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or <code>False</code> otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the <code>color1</code> and <code>color2</code> parameters). <code>None</code> means that every node is compatible with every other node.</td></tr><tr><td></td><td class="fieldArg">edge_compat_fn</td><td>a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns <code>True</code> if the edges given by the two indices are compatible (i.e. they could be matched to each other) or <code>False</code> otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the <code>edge_color1</code> and <code>edge_color2</code> parameters). <code>None</code> means that every edge is compatible with every other node.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the number of isomorphisms between the two given graphs (or the number of automorphisms if <code>other</code> is <code>None</code>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.get_isomorphisms_vf2">
    
  </a>
  <a name="get_isomorphisms_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_isomorphisms_vf2</span>(other=None, color1=None, color2=None, edge_color1=None, edge_color2=None, node_compat_fn=None, edge_compat_fn=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns all isomorphisms between the graph and another one</p><p>Vertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">other</td><td>the other graph. If <code>None</code>, the automorphisms will be returned.</td></tr><tr><td></td><td class="fieldArg">color1</td><td>optional vector storing the coloring of the vertices of the first graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">color2</td><td>optional vector storing the coloring of the vertices of the second graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">edge_color1</td><td>optional vector storing the coloring of the edges of the first graph. If <code>None</code>, all edges have the same color.</td></tr><tr><td></td><td class="fieldArg">edge_color2</td><td>optional vector storing the coloring of the edges of the second graph. If <code>None</code>, all edges have the same color.</td></tr><tr><td></td><td class="fieldArg">node_compat_fn</td><td>a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns <code>True</code> if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or <code>False</code> otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the <code>color1</code> and <code>color2</code> parameters). <code>None</code> means that every node is compatible with every other node.</td></tr><tr><td></td><td class="fieldArg">edge_compat_fn</td><td>a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns <code>True</code> if the edges given by the two indices are compatible (i.e. they could be matched to each other) or <code>False</code> otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the <code>edge_color1</code> and <code>edge_color2</code> parameters). <code>None</code> means that every edge is compatible with every other node.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.subisomorphic_vf2">
    
  </a>
  <a name="subisomorphic_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">subisomorphic_vf2</span>(other, color1=None, color2=None, edge_color1=None, edge_color2=None, return_mapping_12=False, return_mapping_21=False, callback=None, node_compat_fn=None, edge_compat_fn=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether a subgraph of the graph is isomorphic to another graph.</p><p>Vertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">other</td><td>the other graph with which we want to compare the graph.</td></tr><tr><td></td><td class="fieldArg">color1</td><td>optional vector storing the coloring of the vertices of the first graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">color2</td><td>optional vector storing the coloring of the vertices of the second graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">edge_color1</td><td>optional vector storing the coloring of the edges of the first graph. If <code>None</code>, all edges have the same color.</td></tr><tr><td></td><td class="fieldArg">edge_color2</td><td>optional vector storing the coloring of the edges of the second graph. If <code>None</code>, all edges have the same color.</td></tr><tr><td></td><td class="fieldArg">return_mapping_12</td><td>if <code>True</code>, calculates the mapping which maps the vertices of the first graph to the second. The mapping can contain -1 if a given node is not mapped.</td></tr><tr><td></td><td class="fieldArg">return_mapping_21</td><td>if <code>True</code>, calculates the mapping which maps the vertices of the second graph to the first. The mapping can contain -1 if a given node is not mapped.</td></tr><tr><td></td><td class="fieldArg">callback</td><td>if not <code>None</code>, the subisomorphism search will not stop at the first match; it will call this callback function instead for every subisomorphism found. The callback function must accept four arguments: the first graph, the second graph, a mapping from the nodes of the first graph to the second, and a mapping from the nodes of the second graph to the first. The function must return <code>True</code> if the search should continue or <code>False</code> otherwise.</td></tr><tr><td></td><td class="fieldArg">node_compat_fn</td><td>a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns <code>True</code> if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or <code>False</code> otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the <code>color1</code> and <code>color2</code> parameters). <code>None</code> means that every node is compatible with every other node.</td></tr><tr><td></td><td class="fieldArg">edge_compat_fn</td><td>a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns <code>True</code> if the edges given by the two indices are compatible (i.e. they could be matched to each other) or <code>False</code> otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the <code>edge_color1</code> and <code>edge_color2</code> parameters). <code>None</code> means that every edge is compatible with every other node.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">if no mapping is calculated, the result is <code>True</code> if the graph contains a subgraph that's isomorphic to the given one, <code>False</code> otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -&gt; 2 mapping and the third element being the 2 -&gt; 1 mapping. If the corresponding mapping was not calculated, <code>None</code> is returned in the appropriate element of the 3-tuple.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.count_subisomorphisms_vf2">
    
  </a>
  <a name="count_subisomorphisms_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">count_subisomorphisms_vf2</span>(other, color1=None, color2=None, edge_color1=None, edge_color2=None, node_compat_fn=None, edge_compat_fn=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Determines the number of subisomorphisms between the graph and another one</p><p>Vertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">other</td><td>the other graph.</td></tr><tr><td></td><td class="fieldArg">color1</td><td>optional vector storing the coloring of the vertices of the first graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">color2</td><td>optional vector storing the coloring of the vertices of the second graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">edge_color1</td><td>optional vector storing the coloring of the edges of the first graph. If <code>None</code>, all edges have the same color.</td></tr><tr><td></td><td class="fieldArg">edge_color2</td><td>optional vector storing the coloring of the edges of the second graph. If <code>None</code>, all edges have the same color.</td></tr><tr><td></td><td class="fieldArg">node_compat_fn</td><td>a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns <code>True</code> if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or <code>False</code> otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the <code>color1</code> and <code>color2</code> parameters). <code>None</code> means that every node is compatible with every other node.</td></tr><tr><td></td><td class="fieldArg">edge_compat_fn</td><td>a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns <code>True</code> if the edges given by the two indices are compatible (i.e. they could be matched to each other) or <code>False</code> otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the <code>edge_color1</code> and <code>edge_color2</code> parameters). <code>None</code> means that every edge is compatible with every other node.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the number of subisomorphisms between the two given graphs</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.get_subisomorphisms_vf2">
    
  </a>
  <a name="get_subisomorphisms_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_subisomorphisms_vf2</span>(other, color1=None, color2=None, edge_color1=None, edge_color2=None, node_compat_fn=None, edge_compat_fn=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns all subisomorphisms between the graph and another one</p><p>Vertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">other</td><td>the other graph.</td></tr><tr><td></td><td class="fieldArg">color1</td><td>optional vector storing the coloring of the vertices of the first graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">color2</td><td>optional vector storing the coloring of the vertices of the second graph. If <code>None</code>, all vertices have the same color.</td></tr><tr><td></td><td class="fieldArg">edge_color1</td><td>optional vector storing the coloring of the edges of the first graph. If <code>None</code>, all edges have the same color.</td></tr><tr><td></td><td class="fieldArg">edge_color2</td><td>optional vector storing the coloring of the edges of the second graph. If <code>None</code>, all edges have the same color.</td></tr><tr><td></td><td class="fieldArg">node_compat_fn</td><td>a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns <code>True</code> if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or <code>False</code> otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the <code>color1</code> and <code>color2</code> parameters). <code>None</code> means that every node is compatible with every other node.</td></tr><tr><td></td><td class="fieldArg">edge_compat_fn</td><td>a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns <code>True</code> if the edges given by the two indices are compatible (i.e. they could be matched to each other) or <code>False</code> otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the <code>edge_color1</code> and <code>edge_color2</code> parameters). <code>None</code> means that every edge is compatible with every other node.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.subisomorphic_lad">
    
  </a>
  <a name="subisomorphic_lad">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">subisomorphic_lad</span>(other, domains=None, induced=False, time_limit=0, return_mapping=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Checks whether a subgraph of the graph is isomorphic to another graph.</p><p>The optional <code>domains</code> argument may be used to restrict vertices that may match each other. You can also specify whether you are interested in induced subgraphs only or not.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">other</td><td>the pattern graph we are looking for in the graph.</td></tr><tr><td></td><td class="fieldArg">domains</td><td>a list of lists, one sublist belonging to each vertex in the template graph. Sublist <i class="math">i</i> contains the indices of the vertices in the original graph that may match vertex <i class="math">i</i> in the template graph. <code>None</code> means that every vertex may match every other vertex.</td></tr><tr><td></td><td class="fieldArg">induced</td><td>whether to consider induced subgraphs only.</td></tr><tr><td></td><td class="fieldArg">time_limit</td><td>an optimal time limit in seconds. Only the integral part of this number is taken into account. If the time limit is exceeded, the method will throw an exception.</td></tr><tr><td></td><td class="fieldArg">return_mapping</td><td>when <code>True</code>, the function will return a tuple, where the first element is a boolean denoting whether a subisomorphism has been found or not, and the second element describes the mapping of the vertices from the template graph to the original graph. When <code>False</code>, only the boolean is returned.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">if no mapping is calculated, the result is <code>True</code> if the graph contains a subgraph that is isomorphic to the given template, <code>False</code> otherwise. If the mapping is calculated, the result is a tuple, the first element being the above mentioned boolean, and the second element being the mapping from the target to the original graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.get_subisomorphisms_lad">
    
  </a>
  <a name="get_subisomorphisms_lad">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_subisomorphisms_lad</span>(other, domains=None, induced=False, time_limit=0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns all subisomorphisms between the graph and another one using the LAD algorithm.</p><p>The optional <code>domains</code> argument may be used to restrict vertices that may match each other. You can also specify whether you are interested in induced subgraphs only or not.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">other</td><td>the pattern graph we are looking for in the graph.</td></tr><tr><td></td><td class="fieldArg">domains</td><td>a list of lists, one sublist belonging to each vertex in the template graph. Sublist <i class="math">i</i> contains the indices of the vertices in the original graph that may match vertex <i class="math">i</i> in the template graph. <code>None</code> means that every vertex may match every other vertex.</td></tr><tr><td></td><td class="fieldArg">induced</td><td>whether to consider induced subgraphs only.</td></tr><tr><td></td><td class="fieldArg">time_limit</td><td>an optimal time limit in seconds. Only the integral part of this number is taken into account. If the time limit is exceeded, the method will throw an exception.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.attributes">
    
  </a>
  <a name="attributes">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">attributes</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the attribute name list of the graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.vertex_attributes">
    
  </a>
  <a name="vertex_attributes">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">vertex_attributes</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the attribute name list of the vertices of the graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.edge_attributes">
    
  </a>
  <a name="edge_attributes">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">edge_attributes</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the attribute name list of the edges of the graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.complementer">
    
  </a>
  <a name="complementer">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">complementer</span>(loops=False):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the complementer of the graph</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">loops</td><td>whether to include loop edges in the complementer.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the complementer of the graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.compose">
    
  </a>
  <a name="compose">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">compose</span>(other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the composition of two graphs.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.difference">
    
  </a>
  <a name="difference">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">difference</span>(other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Subtracts the given graph from the original</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.dominator">
    
  </a>
  <a name="dominator">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">dominator</span>(vid, mode='out'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the dominator tree from the given root node</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vid</td><td>the root vertex ID</td></tr><tr><td></td><td class="fieldArg">mode</td><td>either <code>"in"</code> or <code>"out"</code></td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list containing the dominator tree for the current graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.maxflow_value">
    
  </a>
  <a name="maxflow_value">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maxflow_value</span>(source, target, capacity=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the value of the maximum flow between the source and target vertices.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">source</td><td>the source vertex ID</td></tr><tr><td></td><td class="fieldArg">target</td><td>the target vertex ID</td></tr><tr><td></td><td class="fieldArg">capacity</td><td>the capacity of the edges. It must be a list or a valid attribute name or <code>None</code>. In the latter case, every edge will have the same capacity.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the value of the maximum flow between the given vertices</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.maxflow">
    
  </a>
  <a name="maxflow">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maxflow</span>(source, target, capacity=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Returns the maximum flow between the source and target vertices.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">source</td><td>the source vertex ID</td></tr><tr><td></td><td class="fieldArg">target</td><td>the target vertex ID</td></tr><tr><td></td><td class="fieldArg">capacity</td><td>the capacity of the edges. It must be a list or a valid attribute name or <code>None</code>. In the latter case, every edge will have the same capacity.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a tuple containing the following: the value of the maximum flow between the given vertices, the flow value on all the edges, the edge IDs that are part of the corresponding minimum cut, and the vertex IDs on one side of the cut. For directed graphs, the flow value vector gives the flow value on each edge. For undirected graphs, the flow value is positive if the flow goes from the smaller vertex ID to the bigger one and negative if the flow goes from the bigger vertex ID to the smaller.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html">Graph</a></code> which wraps the result in a <code><a href="igraph.cut.Flow.html">Flow</a></code> object. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.all_st_cuts">
    
  </a>
  <a name="all_st_cuts">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">all_st_cuts</span>(source, target):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Returns all the cuts between the source and target vertices in a directed graph.</p><p>This function lists all edge-cuts between a source and a target vertex. Every cut is listed exactly once.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">source</td><td>the source vertex ID</td></tr><tr><td></td><td class="fieldArg">target</td><td>the target vertex ID</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a tuple where the first element is a list of lists of edge IDs representing a cut and the second element is a list of lists of vertex IDs representing the sets of vertices that were separated by the cuts.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html">Graph</a></code> which wraps the result in a list of <code><a href="igraph.cut.Cut.html">Cut</a></code> objects. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.all_st_mincuts">
    
  </a>
  <a name="all_st_mincuts">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">all_st_mincuts</span>(source, target):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Returns all minimum cuts between the source and target vertices in a directed graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">source</td><td>the source vertex ID</td></tr><tr><td></td><td class="fieldArg">target</td><td>the target vertex ID</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html">Graph</a></code> which wraps the result in a list of <code><a href="igraph.cut.Cut.html">Cut</a></code> objects. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.mincut_value">
    
  </a>
  <a name="mincut_value">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">mincut_value</span>(source=-1, target=-1, capacity=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the minimum cut between the source and target vertices or within the whole graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">source</td><td>the source vertex ID. If negative, the calculation is done for every vertex except the target and the minimum is returned.</td></tr><tr><td></td><td class="fieldArg">target</td><td>the target vertex ID. If negative, the calculation is done for every vertex except the source and the minimum is returned.</td></tr><tr><td></td><td class="fieldArg">capacity</td><td>the capacity of the edges. It must be a list or a valid attribute name or <code>None</code>. In the latter case, every edge will have the same capacity.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the value of the minimum cut between the given vertices</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.mincut">
    
  </a>
  <a name="mincut">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">mincut</span>(source=None, target=None, capacity=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Calculates the minimum cut between the source and target vertices or within the whole graph.</p><p>The minimum cut is the minimum set of edges that needs to be removed to separate the source and the target (if they are given) or to disconnect the graph (if the source and target are not given). The minimum is calculated using the weights (capacities) of the edges, so the cut with the minimum total capacity is calculated. For undirected graphs and no source and target, the method uses the Stoer-Wagner algorithm. For a given source and target, the method uses the push-relabel algorithm; see the references below.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">source</td><td>the source vertex ID. If <code>None</code>, target must also be {None} and the calculation will be done for the entire graph (i.e. all possible vertex pairs).</td></tr><tr><td></td><td class="fieldArg">target</td><td>the target vertex ID. If <code>None</code>, source must also be {None} and the calculation will be done for the entire graph (i.e. all possible vertex pairs).</td></tr><tr><td></td><td class="fieldArg">capacity</td><td>the capacity of the edges. It must be a list or a valid attribute name or <code>None</code>. In the latter case, every edge will have the same capacity.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html">Graph</a></code> which wraps the result in a <code><a href="igraph.cut.Cut.html">Cut</a></code> object. It is advised to use that.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">M. Stoer, F. Wagner: A simple min-cut algorithm. Journal of the ACM 44(4):585-591, 1997.</td></tr><tr><td></td><td colspan="2">A. V. Goldberg, R. E. Tarjan: A new approach to the maximum-flow problem. Journal of the ACM 35(4):921-940, 1988.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.st_mincut">
    
  </a>
  <a name="st_mincut">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">st_mincut</span>(source, target, capacity=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Calculates the minimum cut between the source and target vertices in a graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">source</td><td>the source vertex ID</td></tr><tr><td></td><td class="fieldArg">target</td><td>the target vertex ID</td></tr><tr><td></td><td class="fieldArg">capacity</td><td>the capacity of the edges. It must be a list or a valid attribute name or <code>None</code>. In the latter case, every edge will have the same capacity.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html">Graph</a></code> which wraps the result in a list of <code><a href="igraph.cut.Cut.html">Cut</a></code> objects. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.gomory_hu_tree">
    
  </a>
  <a name="gomory_hu_tree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">gomory_hu_tree</span>(capacity=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">Graph.gomory_hu_tree()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.all_minimal_st_separators">
    
  </a>
  <a name="all_minimal_st_separators">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">all_minimal_st_separators</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns a list containing all the minimal s-t separators of a graph.</p><p>A minimal separator is a set of vertices whose removal disconnects the graph, while the removal of any subset of the set keeps the graph connected.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list where each item lists the vertex indices of a given minimal s-t separator.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Anne Berry, Jean-Paul Bordat and Olivier Cogis: Generating all the minimal separators of a graph. In: Peter Widmayer, Gabriele Neyer and Stephan Eidenbenz (eds.): Graph-theoretic concepts in computer science, 1665, 167--172, 1999. Springer.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.is_minimal_separator">
    
  </a>
  <a name="is_minimal_separator">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_minimal_separator</span>(vertices):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Decides whether the given vertex set is a minimal separator.</p><p>A minimal separator is a set of vertices whose removal disconnects the graph, while the removal of any subset of the set keeps the graph connected.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>a single vertex ID or a list of vertex IDs</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>True</code> is the given vertex set is a minimal separator, <code>False</code> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.is_separator">
    
  </a>
  <a name="is_separator">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_separator</span>(vertices):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Decides whether the removal of the given vertices disconnects the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">vertices</td><td>a single vertex ID or a list of vertex IDs</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2"><code>True</code> is the given vertex set is a separator, <code>False</code> if not.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.minimum_size_separators">
    
  </a>
  <a name="minimum_size_separators">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">minimum_size_separators</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns a list containing all separator vertex sets of minimum size.</p><p>A vertex set is a separator if its removal disconnects the graph. This method lists all the separators for which no smaller separator set exists in the given graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a list where each item lists the vertex indices of a given separator of minimum size.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Arkady Kanevsky: Finding all minimum-size separating vertex sets in a graph. Networks 23:533--541, 1993.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.cohesive_blocks">
    
  </a>
  <a name="cohesive_blocks">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">cohesive_blocks</span>():
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Calculates the cohesive block structure of the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html">Graph</a></code> which wraps the result in a <code><a href="igraph.clustering.CohesiveBlocks.html">CohesiveBlocks</a></code> object. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.cliques">
    
  </a>
  <a name="cliques">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">cliques</span>(min=0, max=0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns some or all cliques of the graph as a list of tuples.</p><p>A clique is a complete subgraph -- a set of vertices where an edge is present between any two of them (excluding loops)</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">min</td><td>the minimum size of cliques to be returned. If zero or negative, no lower bound will be used.</td></tr><tr><td></td><td class="fieldArg">max</td><td>the maximum size of cliques to be returned. If zero or negative, no upper bound will be used.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.largest_cliques">
    
  </a>
  <a name="largest_cliques">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">largest_cliques</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the largest cliques of the graph as a list of tuples.</p><p>Quite intuitively a clique is considered largest if there is no clique with more vertices in the whole graph. All largest cliques are maximal (i.e. nonextendable) but not all maximal cliques are largest.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#clique_number">clique_number()</a></code> for the size of the largest cliques or <code><a href="#maximal_cliques">maximal_cliques()</a></code> for the maximal cliques</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.maximal_cliques">
    
  </a>
  <a name="maximal_cliques">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maximal_cliques</span>(min=0, max=0, file=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the maximal cliques of the graph as a list of tuples.</p><p>A maximal clique is a clique which can't be extended by adding any other vertex to it. A maximal clique is not necessarily one of the largest cliques in the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">min</td><td>the minimum size of maximal cliques to be returned. If zero or negative, no lower bound will be used.</td></tr><tr><td></td><td class="fieldArg">max</td><td>the maximum size of maximal cliques to be returned. If zero or negative, no upper bound will be used. If nonzero, the size of every maximal clique found will be compared to this value and a clique will be returned only if its size is smaller than this limit.</td></tr><tr><td></td><td class="fieldArg">file</td><td>a file object or the name of the file to write the results to. When this argument is <code>None</code>, the maximal cliques will be returned as a list of lists.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the maximal cliques of the graph as a list of lists, or <code>None</code> if the <code>file</code> argument was given.@see: <code><a href="#largest_cliques">largest_cliques()</a></code> for the largest cliques.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.clique_number">
    
  </a>
  <a name="clique_number">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">clique_number</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the clique number of the graph.</p><p>The clique number of the graph is the size of the largest clique.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#largest_cliques">largest_cliques()</a></code> for the largest cliques.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.independent_vertex_sets">
    
  </a>
  <a name="independent_vertex_sets">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">independent_vertex_sets</span>(min=0, max=0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns some or all independent vertex sets of the graph as a list of tuples.</p><p>Two vertices are independent if there is no edge between them. Members of an independent vertex set are mutually independent.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">min</td><td>the minimum size of sets to be returned. If zero or negative, no lower bound will be used.</td></tr><tr><td></td><td class="fieldArg">max</td><td>the maximum size of sets to be returned. If zero or negative, no upper bound will be used.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.largest_independent_vertex_sets">
    
  </a>
  <a name="largest_independent_vertex_sets">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">largest_independent_vertex_sets</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the largest independent vertex sets of the graph as a list of tuples.</p><p>Quite intuitively an independent vertex set is considered largest if there is no other set with more vertices in the whole graph. All largest sets are maximal (i.e. nonextendable) but not all maximal sets are largest.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#independence_number">independence_number()</a></code> for the size of the largest independent vertex sets or <code><a href="#maximal_independent_vertex_sets">maximal_independent_vertex_sets()</a></code> for the maximal (nonextendable) independent vertex sets</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.maximal_independent_vertex_sets">
    
  </a>
  <a name="maximal_independent_vertex_sets">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maximal_independent_vertex_sets</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the maximal independent vertex sets of the graph as a list of tuples.</p><p>A maximal independent vertex set is an independent vertex set which can't be extended by adding any other vertex to it. A maximal independent vertex set is not necessarily one of the largest independent vertex sets in the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#largest_independent_vertex_sets">largest_independent_vertex_sets()</a></code> for the largest independent vertex sets</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka: <i>A new algorithm for generating all the maximal independent sets</i>. SIAM J Computing, 6:505--517, 1977.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.independence_number">
    
  </a>
  <a name="independence_number">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">independence_number</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the independence number of the graph.</p><p>The independence number of the graph is the size of the largest independent vertex set.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="#largest_independent_vertex_sets">largest_independent_vertex_sets()</a></code> for the largest independent vertex sets</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.modularity">
    
  </a>
  <a name="modularity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">modularity</span>(membership, weights=None, resolution=1, directed=True):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Calculates the modularity of the graph with respect to some vertex types.</p><p>The modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It is defined as <i class="math">Q=1/(2m) * sum(Aij-gamma*ki*kj/(2m)delta(ci,cj),i,j)</i>. <i class="math">m</i> is the number of edges, <i class="math">Aij</i> is the element of the <i class="math">A</i> adjacency matrix in row <i class="math">i</i> and column <i class="math">j</i>, <i class="math">ki</i> is the degree of node <i class="math">i</i>, <i class="math">kj</i> is the degree of node <i class="math">j</i>, <i class="math">Ci</i> and <code>cj</code> are the types of the two vertices (<i class="math">i</i> and <i class="math">j</i>), and <i class="math">gamma</i> is a resolution parameter that defaults to 1 for the classical definition of modularity. <i class="math">delta(x,y)</i> is one iff <i class="math">x=y</i>, 0 otherwise.</p><p>If edge weights are given, the definition of modularity is modified as follows: <i class="math">Aij</i> becomes the weight of the corresponding edge, <i class="math">ki</i> is the total weight of edges incident on vertex <i class="math">i</i>, <i class="math">kj</i> is the total weight of edges incident on vertex <i class="math">j</i> and <i class="math">m</i> is the total edge weight in the graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">membership</td><td>the membership vector, e.g. the vertex type index for each vertex.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>optional edge weights or <code>None</code> if all edges are weighed equally.</td></tr><tr><td></td><td class="fieldArg">resolution</td><td>the resolution parameter <i>gamma</i> in the formula above. The classical definition of modularity is retrieved when the resolution parameter is set to 1.</td></tr><tr><td></td><td class="fieldArg">directed</td><td>whether to consider edge directions if the graph is directed. <code>True</code> will use the directed variant of the modularity measure where the in- and out-degrees of nodes are treated separately; <code>False</code> will treat directed graphs as undirected.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the modularity score. Score larger than 0.3 usually indicates strong community structure.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">method overridden in <code><a href="igraph.Graph.html">Graph</a></code> to allow <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> objects as a parameter. This method is not strictly necessary, since the <code><a href="igraph.clustering.VertexClustering.html">VertexClustering</a></code> class provides a variable called <code>modularity</code>.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.coreness">
    
  </a>
  <a name="coreness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">coreness</span>(mode='all'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Finds the coreness (shell index) of the vertices of the network.</p><p>The <i class="math">k</i>-core of a graph is a maximal subgraph in which each vertex has at least degree k. (Degree here means the degree in the subgraph of course). The coreness of a vertex is <i class="math">k</i> if it is a member of the <i class="math">k</i>-core but not a member of the <i class="math">k+1</i>-core.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">mode</td><td>whether to compute the in-corenesses (<code>"in"</code>), the out-corenesses (<code>"out"</code>) or the undirected corenesses (<code>"all"</code>). Ignored and assumed to be <code>"all"</code> for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the corenesses for each vertex.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Vladimir Batagelj, Matjaz Zaversnik: <i>An <i class="math">O(m)</i> Algorithm for Core Decomposition of Networks.</i></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.community_fastgreedy">
    
  </a>
  <a name="community_fastgreedy">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_fastgreedy</span>(weights=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Finds the community structure of the graph according to the algorithm of Clauset et al based on the greedy optimization of modularity.</p><p>This is a bottom-up algorithm: initially every vertex belongs to a separate community, and communities are merged one by one. In every step, the two communities being merged are the ones which result in the maximal increase in modularity.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">weights</td><td>name of an edge attribute or a list containing edge weights</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a tuple with the following elements:<ol><li>The list of merges</li><li>The modularity scores before each merge</li></ol></td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">modularity()</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html">Graph</a></code>. It is advised to use that instead of this version.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">A. Clauset, M. E. J. Newman and C. Moore: <i>Finding community structure in very large networks.</i> Phys Rev E 70, 066111 (2004).</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.community_infomap">
    
  </a>
  <a name="community_infomap">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_infomap</span>(edge_weights=None, vertex_weights=None, trials=10):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Finds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.</p><p>See <a href="http://www.mapequation.org" target="_top">http://www.mapequation.org</a> for a visualization of the algorithm or one of the references provided below.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">edge_weights</td><td>name of an edge attribute or a list containing edge weights.</td></tr><tr><td></td><td class="fieldArg">vertex_weights</td><td>name of an vertex attribute or a list containing vertex weights.</td></tr><tr><td></td><td class="fieldArg">trials</td><td>the number of attempts to partition the network.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated membership vector and the corresponding codelength in a tuple.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">M. Rosvall and C. T. Bergstrom: <i>Maps of information flow reveal community structure in complex networks</i>. PNAS 105, 1118 (2008). <a href="http://arxiv.org/abs/0707.0609" target="_top">http://arxiv.org/abs/0707.0609</a></td></tr><tr><td></td><td colspan="2">M. Rosvall, D. Axelsson and C. T. Bergstrom: <i>The map equation</i>. Eur Phys J Special Topics 178, 13 (2009). <a href="http://arxiv.org/abs/0906.1405" target="_top">http://arxiv.org/abs/0906.1405</a></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.community_label_propagation">
    
  </a>
  <a name="community_label_propagation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_label_propagation</span>(weights=None, initial=None, fixed=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Finds the community structure of the graph according to the label propagation method of Raghavan et al.</p><p>Initially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus.</p><p>Note that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al on how to come up with an aggregated community structure.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">weights</td><td>name of an edge attribute or a list containing edge weights</td></tr><tr><td></td><td class="fieldArg">initial</td><td>name of a vertex attribute or a list containing the initial vertex labels. Labels are identified by integers from zero to <i class="math">n-1</i> where <i class="math">n</i> is the number of vertices. Negative numbers may also be present in this vector, they represent unlabeled vertices.</td></tr><tr><td></td><td class="fieldArg">fixed</td><td>a list of booleans for each vertex. <code>True</code> corresponds to vertices whose labeling should not change during the algorithm. It only makes sense if initial labels are also given. Unlabeled vertices cannot be fixed. Note that vertex attribute names are not accepted here.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the resulting membership vector</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. <a href="http://arxiv.org/abs/0709.2938" target="_top">http://arxiv.org/abs/0709.2938</a>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.community_leading_eigenvector">
    
  </a>
  <a name="community_leading_eigenvector">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_leading_eigenvector</span>(n=-1, arpack_options=None, weights=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>A proper implementation of Newman's eigenvector community structure detection. Each split is done by maximizing the modularity regarding the original network. See the reference for details.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">n</td><td>the desired number of communities. If negative, the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same.</td></tr><tr><td></td><td class="fieldArg">arpack_options</td><td>an <code><a href="igraph._igraph.ARPACKOptions.html">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <code>arpack_options</code> is used.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>name of an edge attribute or a list containing edge weights</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a tuple where the first element is the membership vector of the clustering and the second element is the merge matrix.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html">Graph</a></code>. It is advised to use that instead of this version.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.community_multilevel">
    
  </a>
  <a name="community_multilevel">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_multilevel</span>(weights=None, return_levels=True, resolution=1):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Finds the community structure of the graph according to the multilevel algorithm of Blondel et al. This is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrank to a single vertex (while keeping the total weight of the incident edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity any more after shrinking the communities to vertices.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">weights</td><td>name of an edge attribute or a list containing edge weights</td></tr><tr><td></td><td class="fieldArg">return_levels</td><td>if <code>True</code>, returns the multilevel result. If <code>False</code>, only the best level (corresponding to the best modularity) is returned.</td></tr><tr><td></td><td class="fieldArg">resolution</td><td>the resolution parameter to use in the modularity measure. Smaller values result in a smaller number of larger clusters, while higher values yield a large number of small clusters. The classical modularity measure assumes a resolution parameter of 1.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">either a single list describing the community membership of each vertex (if <code>return_levels</code> is <code>False</code>), or a list of community membership vectors, one corresponding to each level and a list of corresponding modularities (if <code>return_levels</code> is <code>True</code>).</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">modularity()</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html">Graph</a></code>. It is advised to use that instead of this version.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks. J Stat Mech P10008 (2008), http://arxiv.org/abs/0803.0476</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.community_edge_betweenness">
    
  </a>
  <a name="community_edge_betweenness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_edge_betweenness</span>(directed=True, weights=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Community structure detection based on the betweenness of the edges in the network. This algorithm was invented by M Girvan and MEJ Newman, see: M Girvan and MEJ Newman: Community structure in social and biological networks, Proc. Nat. Acad. Sci. USA 99, 7821-7826 (2002).</p><p>The idea is that the betweenness of the edges connecting two communities is typically high. So we gradually remove the edge with the highest betweenness from the network and recalculate edge betweenness after every removal, as long as all edges are removed.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">directed</td><td>whether to take into account the directedness of the edges when we calculate the betweenness values.</td></tr><tr><td></td><td class="fieldArg">weights</td><td>name of an edge attribute or a list containing edge weights.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a tuple with the merge matrix that describes the dendrogram and the modularity scores before each merge. The modularity scores use the weights if the original graph was weighted.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html">Graph</a></code>. It is advised to use that instead of this version.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.community_optimal_modularity">
    
  </a>
  <a name="community_optimal_modularity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_optimal_modularity</span>(weights=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Calculates the optimal modularity score of the graph and the corresponding community structure.</p><p>This function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">weights</td><td>name of an edge attribute or a list containing edge weights.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the calculated membership vector and the corresponding modularity in a tuple.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.community_spinglass">
    
  </a>
  <a name="community_spinglass">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_spinglass</span>(weights=None, spins=25, parupdate=False, start_temp=1, stop_temp=0.01, cool_fact=0.99, update_rule='config', gamma=1, implementation='orig', lambda_=1):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Finds the community structure of the graph according to the spinglass community detection method of Reichardt &amp; Bornholdt.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td></td><td class="fieldArg">spins</td><td>integer, the number of spins to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated.</td></tr><tr><td></td><td class="fieldArg">parupdate</td><td>whether to update the spins of the vertices in parallel (synchronously) or not</td></tr><tr><td></td><td class="fieldArg">start_temp</td><td>the starting temperature</td></tr><tr><td></td><td class="fieldArg">stop_temp</td><td>the stop temperature</td></tr><tr><td></td><td class="fieldArg">cool_fact</td><td>cooling factor for the simulated annealing</td></tr><tr><td></td><td class="fieldArg">update_rule</td><td>specifies the null model of the simulation. Possible values are <code>"config"</code> (a random graph with the same vertex degrees as the input graph) or <code>"simple"</code> (a random graph with the same number of edges)</td></tr><tr><td></td><td class="fieldArg">gamma</td><td>the gamma argument of the algorithm, specifying the balance between the importance of present and missing edges within a community. The default value of 1.0 assigns equal importance to both of them.</td></tr><tr><td></td><td class="fieldArg">implementation</td><td>currently igraph contains two implementations for the spinglass community detection algorithm. The faster original implementation is the default. The other implementation is able to take into account negative weights, this can be chosen by setting <code>implementation</code> to <code>"neg"</code>.</td></tr><tr><td></td><td class="fieldArg">lambda_</td><td>the lambda argument of the algorithm, which specifies the balance between the importance of present and missing negatively weighted edges within a community. Smaller values of lambda lead to communities with less negative intra-connectivity. If the argument is zero, the algorithm reduces to a graph coloring algorithm, using the number of spins as colors. This argument is ignored if the original implementation is used.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the community membership vector.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.community_leiden">
    
  </a>
  <a name="community_leiden">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_leiden</span>(edge_weights=None, node_weights=None, resolution_parameter=1.0, normalize_resolution=False, beta=0.01, initial_membership=None, n_iterations=2):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Finds the community structure of the graph using the Leiden algorithm of Traag, van Eck &amp; Waltman.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">edge_weights</td><td>edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td></td><td class="fieldArg">node_weights</td><td>the node weights used in the Leiden algorithm.</td></tr><tr><td></td><td class="fieldArg">resolution_parameter</td><td>the resolution parameter to use. Higher resolutions lead to more smaller communities, while lower resolutions lead to fewer larger communities.</td></tr><tr><td></td><td class="fieldArg">normalize_resolution</td><td>if set to true, the resolution parameter will be divided by the sum of the node weights. If this is not supplied, it will default to the node degree, or weighted degree in case edge_weights are supplied.</td></tr><tr><td></td><td class="fieldArg">beta</td><td>parameter affecting the randomness in the Leiden algorithm. This affects only the refinement step of the algorithm.</td></tr><tr><td></td><td class="fieldArg">initial_membership</td><td>if provided, the Leiden algorithm will try to improve this provided membership. If no argument is provided, the aglorithm simply starts from the singleton partition.</td></tr><tr><td></td><td class="fieldArg">n_iterations</td><td>the number of iterations to iterate the Leiden algorithm. Each iteration may improve the partition further.</td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">the community membership vector.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.community_walktrap">
    
  </a>
  <a name="community_walktrap">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_walktrap</span>(weights=None, steps=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html">igraph.Graph</a></code></div>
    
    <div><p>Finds the community structure of the graph according to the random walk method of Latapy &amp; Pons.</p><p>The basic idea of the algorithm is that short random walks tend to stay in the same community. The method provides a dendrogram.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">weights</td><td>name of an edge attribute or a list containing edge weights</td></tr><tr><td></td><td class="fieldArg">steps</td><td><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a tuple with the list of merges and the modularity scores corresponding to each merge</td></tr><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2">modularity()</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: attention</td><td colspan="2">this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html">Graph</a></code>. It is advised to use that instead of this version.</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: newfield</td><td class="fieldArg">ref</td><td>Reference</td></tr><tr class="fieldStart"><td class="fieldName">Unknown Field: ref</td><td colspan="2">Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, <a href="http://arxiv.org/abs/physics/0512106" target="_top">http://arxiv.org/abs/physics/0512106</a>.</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase._is_matching">
    
  </a>
  <a name="_is_matching">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_is_matching</span>(matching, types=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Internal function, undocumented.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase._is_maximal_matching">
    
  </a>
  <a name="_is_maximal_matching">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_is_maximal_matching</span>(matching, types=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Internal function, undocumented.</p><p>Use <code><a href="igraph.matching.Matching.html#is_maximal">igraph.Matching.is_maximal</a></code> instead.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase._maximum_bipartite_matching">
    
  </a>
  <a name="_maximum_bipartite_matching">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_maximum_bipartite_matching</span>(types, weights=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Internal function, undocumented.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">See Also</td><td colspan="2"><code><a href="igraph.Graph.html#maximum_bipartite_matching">igraph.Graph.maximum_bipartite_matching</a></code></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  <a name="igraph._igraph.GraphBase.random_walk">
    
  </a>
  <a name="random_walk">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">random_walk</span>(start, steps, mode='out', stuck='return'):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Performs a random walk of a given length from a given node.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">start</td><td>the starting vertex of the walk</td></tr><tr><td></td><td class="fieldArg">steps</td><td>the number of steps that the random walk should take</td></tr><tr><td></td><td class="fieldArg">mode</td><td>whether to follow outbound edges only (<code>"out"</code>), inbound edges only (<code>"in"</code>) or both (<code>"all"</code>). Ignored for undirected graphs.@param stuck: what to do when the random walk gets stuck. <code>"return"</code> returns a partial random walk; <code>"error"</code> throws an exception.</td></tr><tr><td></td><td class="fieldArg">stuck</td><td><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName">Returns</td><td colspan="2">a random walk that starts from the given vertex and has at most the given length (shorter if the random walk got stuck)</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase.__graph_as_capsule">
    
  </a>
  <a name="__graph_as_capsule">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__graph_as_capsule</span> (INVALID):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>__graph_as_capsule()</p><p>Returns the igraph graph encapsulated by the Python object as a PyCapsule</p><p>.A PyCapsule is practically a regular C pointer, wrapped in a Python object. This function should not be used directly by igraph users, it is useful only in the case when the underlying igraph object must be passed to other C code through Python.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase._raw_pointer">
    
  </a>
  <a name="_raw_pointer">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_raw_pointer</span>():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Returns the memory address of the igraph graph encapsulated by the Python object as an ordinary Python integer.</p><p>This function should not be used directly by igraph users, it is useful only if you want to access some unwrapped function in the C core of igraph using the ctypes module.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="igraph._igraph.GraphBase.__register_destructor">
    
  </a>
  <a name="__register_destructor">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__register_destructor</span>(destructor):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Registers a destructor to be called when the object is freed by Python. This function should not be used directly by igraph users.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for <a href="https://igraph.org/python">igraph</a>, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 21.2.2.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

</div>



  </div>
  </div>
</div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	      &copy; 2003 &ndash; 2024 The igraph core team.
        &bull; Code licensed under <a href="http://www.gnu.org/licenses/gpl-2.0.html"> GNU GPL 2</a> or later,
        documentation under <a href="http://www.gnu.org/copyleft/fdl.html">GNU FDL</a>.
      </p>
      <p class="social">
        <a href="https://twitter.com/igraph2"><i class="fa-brands fa-twitter"></i></a>
        <a rel="me" href="https://fosstodon.org/@igraph"><i class="fa-brands fa-mastodon"></i></a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'python', 'api/');
    </script>





    
  </body>
</html>
