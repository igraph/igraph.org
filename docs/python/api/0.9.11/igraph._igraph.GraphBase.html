




<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Favicon and theming -->
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.svg" />
    <link rel="alternate icon" href="/favicon.ico" />

    <title>python-igraph API reference</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom styles for this template -->
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700"
          rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/fontawesome.min.css" integrity="sha384-QYIZto+st3yW+o8+5OHfT6S482Zsvz2WfOzpFSXMF9zqeLcFV0/wlZpMtyFcZALm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/solid.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.1/css/brands.min.css">
    <link rel="stylesheet" href="/fonts/font-mfizz/font-mfizz.css">
    <link href="/css/affix.css" rel="stylesheet">
    <link href="/css/syntax.css" rel="stylesheet">
    <link href="/css/other.css" rel="stylesheet">
    <link href="/fonts/fonts.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements 
         and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-DY4MJME11Z"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-DY4MJME11Z');
	</script>

    <link href="/css/pydoctor.css" rel="stylesheet">
  </head>

  <body class="python">
  <div id="wrap">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark fixed-top">
      <a class="navbar-brand" href="/">
        <img src="/img/igraph_logo_white.svg" width="35"> igraph
      </a>

      
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item"><a class="nav-link" href="/python/versions/latest">python-igraph</a></li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">
            0.9.11
          </a>
          <div class="dropdown-menu" id="doc-version-switcher">
            <a class="dropdown-item" href="#">Please wait...</a>
          </div>
        </li>
        
      </ul>
      

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item dropdown">
            <a href="#" class="nav-link dropdown-toggle" id="productsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Products</a>
            <div class="dropdown-menu" aria-labelledby="productsDropdown">
              <a class="dropdown-item" href="https://r.igraph.org">igraph R package</a>
              <a class="dropdown-item" href="https://python.igraph.org">python-igraph</a>
              <a class="dropdown-item" href="http://szhorvat.net/mathematica/IGraphM">IGraph/M</a>
              <a class="dropdown-item" href="/c">igraph C library</a>
              <div class="dropdown-divider"></div>
              <a class="dropdown-item" href="https://github.com/igraph/igraphdata">igraphdata R package <i class="fa-brands fa-github"></i></a>
            </div>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/news.html"><i class="fa-solid fa-rss"></i> News</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://igraph.discourse.group"><i class="fa-solid fa-comments"></i> Forum</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/code-of-conduct.html"><i class="fa-solid fa-gavel"></i> Code of Conduct</a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/igraph"><i class="fa-brands fa-github"></i> On GitHub</a>
          </li>
        </ul>
      </div>
    </nav>
    
    

    <div class="jumbotron">
      <div class="container">
        <h1 class="display-4">python-igraph API reference</h1>
        <p class="lead">List of all classes, functions and methods in python-igraph</p>
      </div>
      <canvas id="jumbotron-anim"></canvas>
    </div>

    

    <div class="container bs-docs-container">
<div class="row">
  <div class="col-md-12">
  <div class="bs-docs-section">

    
<div<body>

    

    <nav class="navbar navbar-default mainnavbar">
      
  
  <div class="container-fluid">


    <div class="navbar-header">
      
      <div class="navlinks">
        <span class="navbar-brand">
          <a href="https://igraph.org/python" class="projecthome">igraph</a> <a href="index.html">API Documentation</a>
        </span>

        <a href="moduleIndex.html">
          Modules
        </a>

        <a href="classIndex.html">
          Classes
        </a>

        <a href="nameIndex.html">
          Names
        </a>

        <div id="search-box-container">
          <div class="input-group">
            <input id="search-box" type="search" name="search-query" placeholder="Search..." aria-label="Search" minlength="2" class="form-control" autocomplete="off" />
            
            <span class="input-group-btn">
              <a style="display: none;" class="btn btn-default" id="search-clear-button" title="Clear" onclick="clearSearch()"><img src="fonts/x-circle.svg" alt="Clear" /></a>
              <a class="btn btn-default" id="search-help-button" title="Help" onclick="toggleSearchHelpText()"><img src="fonts/info.svg" alt="Help" /></a>
            </span>
          </div>
        </div>

      </div>

      <div id="search-results-container" style="display: none;">
        
        <div id="search-buttons">
          <span class="label label-default" id="search-docstrings-button">
          <label class="checkbox-inline">
            <input type="checkbox" id="toggle-search-in-docstrings-checkbox" value="false" onclick="toggleSearchInDocstrings()">
              search in docstrings
            </input>
          </label>
          </span>
          
        </div>
        
        <noscript>
            <h1>Cannot search: JavaScript is not supported/enabled in your browser.</h1>
        </noscript>

        <div class="hint" id="search-help-box">
          <p class="rst-last">
      
            Search bar offers the following options:
            <ul>   
                <li>
                  <strong>Term presence.</strong> The below example searches for documents that 
                    must contain “foo”, might contain “bar” and must not contain “baz”: <code>+foo bar -baz</code>
                </li> 

                <li>
                  <strong>Wildcards.</strong> The below example searches for documents with words beginning with “foo”: <code>foo*</code>
                </li> 

                <li>
                  <strong>Search in specific fields.</strong> The following search matches all objects 
                  in "twisted.mail" that matches “search”: <code>+qname:twisted.mail.* +search</code>

                  <p>
                    Possible fields: 'name', 'qname' (fully qualified name), 'docstring', and 'kind'.
                    Last two fields are only applicable if "search in docstrings" is enabled.
                  </p>
                </li>

                <li>
                  <strong>Fuzzy matches.</strong> The following search matches all documents 
                  that have a word within 1 edit distance of “foo”: <code>foo~1</code>
                </li>
            </ul>

          </p>
        </div>

        <div id="search-status"> </div>

        <div class="warning" id="search-warn-box" style="display: none;">
          <p class="rst-last"><span id="search-warn"></span></p>
        </div>

        <table id="search-results">
          <!-- Filled dynamically by JS -->
        </table>
        
        <div style="margin-top: 8px;">
          <p>Results provided by <a href="https://lunrjs.com">Lunr.js</a></p>
        </div>
      </div>

    </div>


  </div>
</nav>
    
    <div class="container-fluid">

      <!-- Side navigation -->
      <div class="sidebarcontainer" style="display: none;">
        
        <div class="sidebar"><nav class="sidebar">
  

  <div>

      <div class="thingTitle">
        <span>Class</span>
        <code class="thisobject"><a href="igraph._igraph.GraphBase.html" class="internal-link" title="This class"><wbr></wbr>Graph<wbr></wbr>Base</a></code> 
      </div>
      
      <div>
        

        
         

        
        

        <div class="childrenKindTitle">Methods</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="#__new__" class="internal-link" title="igraph._igraph.GraphBase.__new__">__new__</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#add_edges" class="internal-link" title="igraph._igraph.GraphBase.add_edges">add<wbr></wbr>_edges</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#add_vertices" class="internal-link" title="igraph._igraph.GraphBase.add_vertices">add<wbr></wbr>_vertices</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Adjacency" class="internal-link" title="igraph._igraph.GraphBase.Adjacency"><wbr></wbr>Adjacency</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#all_minimal_st_separators" class="internal-link" title="igraph._igraph.GraphBase.all_minimal_st_separators">all<wbr></wbr>_minimal<wbr></wbr>_st<wbr></wbr>_separators</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#all_st_cuts" class="internal-link" title="igraph._igraph.GraphBase.all_st_cuts">all<wbr></wbr>_st<wbr></wbr>_cuts</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#all_st_mincuts" class="internal-link" title="igraph._igraph.GraphBase.all_st_mincuts">all<wbr></wbr>_st<wbr></wbr>_mincuts</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#are_connected" class="internal-link" title="igraph._igraph.GraphBase.are_connected">are<wbr></wbr>_connected</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#articulation_points" class="internal-link" title="igraph._igraph.GraphBase.articulation_points">articulation<wbr></wbr>_points</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#assortativity" class="internal-link" title="igraph._igraph.GraphBase.assortativity">assortativity</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#assortativity_degree" class="internal-link" title="igraph._igraph.GraphBase.assortativity_degree">assortativity<wbr></wbr>_degree</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#assortativity_nominal" class="internal-link" title="igraph._igraph.GraphBase.assortativity_nominal">assortativity<wbr></wbr>_nominal</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Asymmetric_Preference" class="internal-link" title="igraph._igraph.GraphBase.Asymmetric_Preference"><wbr></wbr>Asymmetric_<wbr></wbr>Preference</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Atlas" class="internal-link" title="igraph._igraph.GraphBase.Atlas"><wbr></wbr>Atlas</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#attributes" class="internal-link" title="igraph._igraph.GraphBase.attributes">attributes</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#authority_score" class="internal-link" title="igraph._igraph.GraphBase.authority_score">authority<wbr></wbr>_score</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#average_path_length" class="internal-link" title="igraph._igraph.GraphBase.average_path_length">average<wbr></wbr>_path<wbr></wbr>_length</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Barabasi" class="internal-link" title="igraph._igraph.GraphBase.Barabasi"><wbr></wbr>Barabasi</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#betweenness" class="internal-link" title="igraph._igraph.GraphBase.betweenness">betweenness</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#bfs" class="internal-link" title="igraph._igraph.GraphBase.bfs">bfs</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#bfsiter" class="internal-link" title="igraph._igraph.GraphBase.bfsiter">bfsiter</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#bibcoupling" class="internal-link" title="igraph._igraph.GraphBase.bibcoupling">bibcoupling</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#biconnected_components" class="internal-link" title="igraph._igraph.GraphBase.biconnected_components">biconnected<wbr></wbr>_components</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#bipartite_projection" class="internal-link" title="igraph._igraph.GraphBase.bipartite_projection">bipartite<wbr></wbr>_projection</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#bipartite_projection_size" class="internal-link" title="igraph._igraph.GraphBase.bipartite_projection_size">bipartite<wbr></wbr>_projection<wbr></wbr>_size</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#bridges" class="internal-link" title="igraph._igraph.GraphBase.bridges">bridges</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#canonical_permutation" class="internal-link" title="igraph._igraph.GraphBase.canonical_permutation">canonical<wbr></wbr>_permutation</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#chordal_completion" class="internal-link" title="igraph._igraph.GraphBase.chordal_completion">chordal<wbr></wbr>_completion</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#clique_number" class="internal-link" title="igraph._igraph.GraphBase.clique_number">clique<wbr></wbr>_number</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#cliques" class="internal-link" title="igraph._igraph.GraphBase.cliques">cliques</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#closeness" class="internal-link" title="igraph._igraph.GraphBase.closeness">closeness</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#clusters" class="internal-link" title="igraph._igraph.GraphBase.clusters">clusters</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#cocitation" class="internal-link" title="igraph._igraph.GraphBase.cocitation">cocitation</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#cohesive_blocks" class="internal-link" title="igraph._igraph.GraphBase.cohesive_blocks">cohesive<wbr></wbr>_blocks</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#community_edge_betweenness" class="internal-link" title="igraph._igraph.GraphBase.community_edge_betweenness">community<wbr></wbr>_edge<wbr></wbr>_betweenness</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#community_fastgreedy" class="internal-link" title="igraph._igraph.GraphBase.community_fastgreedy">community<wbr></wbr>_fastgreedy</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#community_infomap" class="internal-link" title="igraph._igraph.GraphBase.community_infomap">community<wbr></wbr>_infomap</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#community_label_propagation" class="internal-link" title="igraph._igraph.GraphBase.community_label_propagation">community<wbr></wbr>_label<wbr></wbr>_propagation</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#community_leading_eigenvector" class="internal-link" title="igraph._igraph.GraphBase.community_leading_eigenvector">community<wbr></wbr>_leading<wbr></wbr>_eigenvector</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#community_leiden" class="internal-link" title="igraph._igraph.GraphBase.community_leiden">community<wbr></wbr>_leiden</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#community_multilevel" class="internal-link" title="igraph._igraph.GraphBase.community_multilevel">community<wbr></wbr>_multilevel</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#community_optimal_modularity" class="internal-link" title="igraph._igraph.GraphBase.community_optimal_modularity">community<wbr></wbr>_optimal<wbr></wbr>_modularity</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#community_spinglass" class="internal-link" title="igraph._igraph.GraphBase.community_spinglass">community<wbr></wbr>_spinglass</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#community_walktrap" class="internal-link" title="igraph._igraph.GraphBase.community_walktrap">community<wbr></wbr>_walktrap</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#complementer" class="internal-link" title="igraph._igraph.GraphBase.complementer">complementer</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#compose" class="internal-link" title="igraph._igraph.GraphBase.compose">compose</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#constraint" class="internal-link" title="igraph._igraph.GraphBase.constraint">constraint</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#contract_vertices" class="internal-link" title="igraph._igraph.GraphBase.contract_vertices">contract<wbr></wbr>_vertices</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#convergence_degree" class="internal-link" title="igraph._igraph.GraphBase.convergence_degree">convergence<wbr></wbr>_degree</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#convergence_field_size" class="internal-link" title="igraph._igraph.GraphBase.convergence_field_size">convergence<wbr></wbr>_field<wbr></wbr>_size</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#copy" class="internal-link" title="igraph._igraph.GraphBase.copy">copy</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#coreness" class="internal-link" title="igraph._igraph.GraphBase.coreness">coreness</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#count_isomorphisms_vf2" class="internal-link" title="igraph._igraph.GraphBase.count_isomorphisms_vf2">count<wbr></wbr>_isomorphisms<wbr></wbr>_vf2</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#count_multiple" class="internal-link" title="igraph._igraph.GraphBase.count_multiple">count<wbr></wbr>_multiple</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#count_subisomorphisms_vf2" class="internal-link" title="igraph._igraph.GraphBase.count_subisomorphisms_vf2">count<wbr></wbr>_subisomorphisms<wbr></wbr>_vf2</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#De_Bruijn" class="internal-link" title="igraph._igraph.GraphBase.De_Bruijn"><wbr></wbr>De_<wbr></wbr>Bruijn</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#decompose" class="internal-link" title="igraph._igraph.GraphBase.decompose">decompose</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#degree" class="internal-link" title="igraph._igraph.GraphBase.degree">degree</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Degree_Sequence" class="internal-link" title="igraph._igraph.GraphBase.Degree_Sequence"><wbr></wbr>Degree_<wbr></wbr>Sequence</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#delete_edges" class="internal-link" title="igraph._igraph.GraphBase.delete_edges">delete<wbr></wbr>_edges</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#delete_vertices" class="internal-link" title="igraph._igraph.GraphBase.delete_vertices">delete<wbr></wbr>_vertices</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#density" class="internal-link" title="igraph._igraph.GraphBase.density">density</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#dfsiter" class="internal-link" title="igraph._igraph.GraphBase.dfsiter">dfsiter</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#diameter" class="internal-link" title="igraph._igraph.GraphBase.diameter">diameter</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#difference" class="internal-link" title="igraph._igraph.GraphBase.difference">difference</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#diversity" class="internal-link" title="igraph._igraph.GraphBase.diversity">diversity</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#dominator" class="internal-link" title="igraph._igraph.GraphBase.dominator">dominator</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#dyad_census" class="internal-link" title="igraph._igraph.GraphBase.dyad_census">dyad<wbr></wbr>_census</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#eccentricity" class="internal-link" title="igraph._igraph.GraphBase.eccentricity">eccentricity</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#ecount" class="internal-link" title="igraph._igraph.GraphBase.ecount">ecount</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#edge_attributes" class="internal-link" title="igraph._igraph.GraphBase.edge_attributes">edge<wbr></wbr>_attributes</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#edge_betweenness" class="internal-link" title="igraph._igraph.GraphBase.edge_betweenness">edge<wbr></wbr>_betweenness</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#edge_connectivity" class="internal-link" title="igraph._igraph.GraphBase.edge_connectivity">edge<wbr></wbr>_connectivity</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#eigen_adjacency" class="internal-link" title="igraph._igraph.GraphBase.eigen_adjacency">eigen<wbr></wbr>_adjacency</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#eigenvector_centrality" class="internal-link" title="igraph._igraph.GraphBase.eigenvector_centrality">eigenvector<wbr></wbr>_centrality</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Erdos_Renyi" class="internal-link" title="igraph._igraph.GraphBase.Erdos_Renyi"><wbr></wbr>Erdos_<wbr></wbr>Renyi</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Establishment" class="internal-link" title="igraph._igraph.GraphBase.Establishment"><wbr></wbr>Establishment</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Famous" class="internal-link" title="igraph._igraph.GraphBase.Famous"><wbr></wbr>Famous</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#farthest_points" class="internal-link" title="igraph._igraph.GraphBase.farthest_points">farthest<wbr></wbr>_points</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#feedback_arc_set" class="internal-link" title="igraph._igraph.GraphBase.feedback_arc_set">feedback<wbr></wbr>_arc<wbr></wbr>_set</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Forest_Fire" class="internal-link" title="igraph._igraph.GraphBase.Forest_Fire"><wbr></wbr>Forest_<wbr></wbr>Fire</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Full" class="internal-link" title="igraph._igraph.GraphBase.Full"><wbr></wbr>Full</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Full_Citation" class="internal-link" title="igraph._igraph.GraphBase.Full_Citation"><wbr></wbr>Full_<wbr></wbr>Citation</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#get_adjacency" class="internal-link" title="igraph._igraph.GraphBase.get_adjacency">get<wbr></wbr>_adjacency</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#get_all_shortest_paths" class="internal-link" title="igraph._igraph.GraphBase.get_all_shortest_paths">get<wbr></wbr>_all<wbr></wbr>_shortest<wbr></wbr>_paths</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#get_diameter" class="internal-link" title="igraph._igraph.GraphBase.get_diameter">get<wbr></wbr>_diameter</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#get_edgelist" class="internal-link" title="igraph._igraph.GraphBase.get_edgelist">get<wbr></wbr>_edgelist</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#get_eid" class="internal-link" title="igraph._igraph.GraphBase.get_eid">get<wbr></wbr>_eid</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#get_eids" class="internal-link" title="igraph._igraph.GraphBase.get_eids">get<wbr></wbr>_eids</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#get_incidence" class="internal-link" title="igraph._igraph.GraphBase.get_incidence">get<wbr></wbr>_incidence</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#get_isomorphisms_vf2" class="internal-link" title="igraph._igraph.GraphBase.get_isomorphisms_vf2">get<wbr></wbr>_isomorphisms<wbr></wbr>_vf2</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#get_shortest_paths" class="internal-link" title="igraph._igraph.GraphBase.get_shortest_paths">get<wbr></wbr>_shortest<wbr></wbr>_paths</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#get_subisomorphisms_lad" class="internal-link" title="igraph._igraph.GraphBase.get_subisomorphisms_lad">get<wbr></wbr>_subisomorphisms<wbr></wbr>_lad</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#get_subisomorphisms_vf2" class="internal-link" title="igraph._igraph.GraphBase.get_subisomorphisms_vf2">get<wbr></wbr>_subisomorphisms<wbr></wbr>_vf2</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#girth" class="internal-link" title="igraph._igraph.GraphBase.girth">girth</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#gomory_hu_tree" class="internal-link" title="igraph._igraph.GraphBase.gomory_hu_tree">gomory<wbr></wbr>_hu<wbr></wbr>_tree</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Growing_Random" class="internal-link" title="igraph._igraph.GraphBase.Growing_Random"><wbr></wbr>Growing_<wbr></wbr>Random</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#harmonic_centrality" class="internal-link" title="igraph._igraph.GraphBase.harmonic_centrality">harmonic<wbr></wbr>_centrality</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#has_multiple" class="internal-link" title="igraph._igraph.GraphBase.has_multiple">has<wbr></wbr>_multiple</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#hub_score" class="internal-link" title="igraph._igraph.GraphBase.hub_score">hub<wbr></wbr>_score</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#incident" class="internal-link" title="igraph._igraph.GraphBase.incident">incident</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#independence_number" class="internal-link" title="igraph._igraph.GraphBase.independence_number">independence<wbr></wbr>_number</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#independent_vertex_sets" class="internal-link" title="igraph._igraph.GraphBase.independent_vertex_sets">independent<wbr></wbr>_vertex<wbr></wbr>_sets</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#induced_subgraph" class="internal-link" title="igraph._igraph.GraphBase.induced_subgraph">induced<wbr></wbr>_subgraph</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_bipartite" class="internal-link" title="igraph._igraph.GraphBase.is_bipartite">is<wbr></wbr>_bipartite</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_chordal" class="internal-link" title="igraph._igraph.GraphBase.is_chordal">is<wbr></wbr>_chordal</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_connected" class="internal-link" title="igraph._igraph.GraphBase.is_connected">is<wbr></wbr>_connected</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_dag" class="internal-link" title="igraph._igraph.GraphBase.is_dag">is<wbr></wbr>_dag</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_directed" class="internal-link" title="igraph._igraph.GraphBase.is_directed">is<wbr></wbr>_directed</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_loop" class="internal-link" title="igraph._igraph.GraphBase.is_loop">is<wbr></wbr>_loop</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_minimal_separator" class="internal-link" title="igraph._igraph.GraphBase.is_minimal_separator">is<wbr></wbr>_minimal<wbr></wbr>_separator</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_multiple" class="internal-link" title="igraph._igraph.GraphBase.is_multiple">is<wbr></wbr>_multiple</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_mutual" class="internal-link" title="igraph._igraph.GraphBase.is_mutual">is<wbr></wbr>_mutual</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_separator" class="internal-link" title="igraph._igraph.GraphBase.is_separator">is<wbr></wbr>_separator</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_simple" class="internal-link" title="igraph._igraph.GraphBase.is_simple">is<wbr></wbr>_simple</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#is_tree" class="internal-link" title="igraph._igraph.GraphBase.is_tree">is<wbr></wbr>_tree</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Isoclass" class="internal-link" title="igraph._igraph.GraphBase.Isoclass"><wbr></wbr>Isoclass</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#isoclass" class="internal-link" title="igraph._igraph.GraphBase.isoclass">isoclass</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#isomorphic" class="internal-link" title="igraph._igraph.GraphBase.isomorphic">isomorphic</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#isomorphic_bliss" class="internal-link" title="igraph._igraph.GraphBase.isomorphic_bliss">isomorphic<wbr></wbr>_bliss</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#isomorphic_vf2" class="internal-link" title="igraph._igraph.GraphBase.isomorphic_vf2">isomorphic<wbr></wbr>_vf2</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#K_Regular" class="internal-link" title="igraph._igraph.GraphBase.K_Regular"><wbr></wbr>K_<wbr></wbr>Regular</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Kautz" class="internal-link" title="igraph._igraph.GraphBase.Kautz"><wbr></wbr>Kautz</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#knn" class="internal-link" title="igraph._igraph.GraphBase.knn">knn</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#laplacian" class="internal-link" title="igraph._igraph.GraphBase.laplacian">laplacian</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#largest_cliques" class="internal-link" title="igraph._igraph.GraphBase.largest_cliques">largest<wbr></wbr>_cliques</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#largest_independent_vertex_sets" class="internal-link" title="igraph._igraph.GraphBase.largest_independent_vertex_sets">largest<wbr></wbr>_independent<wbr></wbr>_vertex<wbr></wbr>_sets</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Lattice" class="internal-link" title="igraph._igraph.GraphBase.Lattice"><wbr></wbr>Lattice</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_bipartite" class="internal-link" title="igraph._igraph.GraphBase.layout_bipartite">layout<wbr></wbr>_bipartite</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_circle" class="internal-link" title="igraph._igraph.GraphBase.layout_circle">layout<wbr></wbr>_circle</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_davidson_harel" class="internal-link" title="igraph._igraph.GraphBase.layout_davidson_harel">layout<wbr></wbr>_davidson<wbr></wbr>_harel</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_drl" class="internal-link" title="igraph._igraph.GraphBase.layout_drl">layout<wbr></wbr>_drl</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_fruchterman_reingold" class="internal-link" title="igraph._igraph.GraphBase.layout_fruchterman_reingold">layout<wbr></wbr>_fruchterman<wbr></wbr>_reingold</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_graphopt" class="internal-link" title="igraph._igraph.GraphBase.layout_graphopt">layout<wbr></wbr>_graphopt</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_grid" class="internal-link" title="igraph._igraph.GraphBase.layout_grid">layout<wbr></wbr>_grid</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_kamada_kawai" class="internal-link" title="igraph._igraph.GraphBase.layout_kamada_kawai">layout<wbr></wbr>_kamada<wbr></wbr>_kawai</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_lgl" class="internal-link" title="igraph._igraph.GraphBase.layout_lgl">layout<wbr></wbr>_lgl</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_mds" class="internal-link" title="igraph._igraph.GraphBase.layout_mds">layout<wbr></wbr>_mds</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_random" class="internal-link" title="igraph._igraph.GraphBase.layout_random">layout<wbr></wbr>_random</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_reingold_tilford" class="internal-link" title="igraph._igraph.GraphBase.layout_reingold_tilford">layout<wbr></wbr>_reingold<wbr></wbr>_tilford</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_reingold_tilford_circular" class="internal-link" title="igraph._igraph.GraphBase.layout_reingold_tilford_circular">layout<wbr></wbr>_reingold<wbr></wbr>_tilford<wbr></wbr>_circular</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#layout_star" class="internal-link" title="igraph._igraph.GraphBase.layout_star">layout<wbr></wbr>_star</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#LCF" class="internal-link" title="igraph._igraph.GraphBase.LCF">LCF</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#linegraph" class="internal-link" title="igraph._igraph.GraphBase.linegraph">linegraph</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#maxdegree" class="internal-link" title="igraph._igraph.GraphBase.maxdegree">maxdegree</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#maxflow" class="internal-link" title="igraph._igraph.GraphBase.maxflow">maxflow</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#maxflow_value" class="internal-link" title="igraph._igraph.GraphBase.maxflow_value">maxflow<wbr></wbr>_value</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#maximal_cliques" class="internal-link" title="igraph._igraph.GraphBase.maximal_cliques">maximal<wbr></wbr>_cliques</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#maximal_independent_vertex_sets" class="internal-link" title="igraph._igraph.GraphBase.maximal_independent_vertex_sets">maximal<wbr></wbr>_independent<wbr></wbr>_vertex<wbr></wbr>_sets</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#maximum_cardinality_search" class="internal-link" title="igraph._igraph.GraphBase.maximum_cardinality_search">maximum<wbr></wbr>_cardinality<wbr></wbr>_search</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#mincut" class="internal-link" title="igraph._igraph.GraphBase.mincut">mincut</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#mincut_value" class="internal-link" title="igraph._igraph.GraphBase.mincut_value">mincut<wbr></wbr>_value</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#minimum_size_separators" class="internal-link" title="igraph._igraph.GraphBase.minimum_size_separators">minimum<wbr></wbr>_size<wbr></wbr>_separators</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#modularity" class="internal-link" title="igraph._igraph.GraphBase.modularity">modularity</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#motifs_randesu" class="internal-link" title="igraph._igraph.GraphBase.motifs_randesu">motifs<wbr></wbr>_randesu</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#motifs_randesu_estimate" class="internal-link" title="igraph._igraph.GraphBase.motifs_randesu_estimate">motifs<wbr></wbr>_randesu<wbr></wbr>_estimate</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#motifs_randesu_no" class="internal-link" title="igraph._igraph.GraphBase.motifs_randesu_no">motifs<wbr></wbr>_randesu<wbr></wbr>_no</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#neighborhood" class="internal-link" title="igraph._igraph.GraphBase.neighborhood">neighborhood</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#neighborhood_size" class="internal-link" title="igraph._igraph.GraphBase.neighborhood_size">neighborhood<wbr></wbr>_size</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#neighbors" class="internal-link" title="igraph._igraph.GraphBase.neighbors">neighbors</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#path_length_hist" class="internal-link" title="igraph._igraph.GraphBase.path_length_hist">path<wbr></wbr>_length<wbr></wbr>_hist</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#permute_vertices" class="internal-link" title="igraph._igraph.GraphBase.permute_vertices">permute<wbr></wbr>_vertices</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#personalized_pagerank" class="internal-link" title="igraph._igraph.GraphBase.personalized_pagerank">personalized<wbr></wbr>_pagerank</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#predecessors" class="internal-link" title="igraph._igraph.GraphBase.predecessors">predecessors</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Preference" class="internal-link" title="igraph._igraph.GraphBase.Preference"><wbr></wbr>Preference</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#radius" class="internal-link" title="igraph._igraph.GraphBase.radius">radius</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#random_walk" class="internal-link" title="igraph._igraph.GraphBase.random_walk">random<wbr></wbr>_walk</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Read_DIMACS" class="internal-link" title="igraph._igraph.GraphBase.Read_DIMACS"><wbr></wbr>Read_<wbr></wbr>DIMACS</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Read_DL" class="internal-link" title="igraph._igraph.GraphBase.Read_DL"><wbr></wbr>Read_<wbr></wbr>DL</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Read_Edgelist" class="internal-link" title="igraph._igraph.GraphBase.Read_Edgelist"><wbr></wbr>Read_<wbr></wbr>Edgelist</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Read_GML" class="internal-link" title="igraph._igraph.GraphBase.Read_GML"><wbr></wbr>Read_<wbr></wbr>GML</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Read_GraphDB" class="internal-link" title="igraph._igraph.GraphBase.Read_GraphDB"><wbr></wbr>Read_<wbr></wbr>Graph<wbr></wbr>DB</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Read_GraphML" class="internal-link" title="igraph._igraph.GraphBase.Read_GraphML"><wbr></wbr>Read_<wbr></wbr>Graph<wbr></wbr>ML</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Read_Lgl" class="internal-link" title="igraph._igraph.GraphBase.Read_Lgl"><wbr></wbr>Read_<wbr></wbr>Lgl</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Read_Ncol" class="internal-link" title="igraph._igraph.GraphBase.Read_Ncol"><wbr></wbr>Read_<wbr></wbr>Ncol</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Read_Pajek" class="internal-link" title="igraph._igraph.GraphBase.Read_Pajek"><wbr></wbr>Read_<wbr></wbr>Pajek</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Realize_Degree_Sequence" class="internal-link" title="igraph._igraph.GraphBase.Realize_Degree_Sequence"><wbr></wbr>Realize_<wbr></wbr>Degree_<wbr></wbr>Sequence</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Recent_Degree" class="internal-link" title="igraph._igraph.GraphBase.Recent_Degree"><wbr></wbr>Recent_<wbr></wbr>Degree</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#reciprocity" class="internal-link" title="igraph._igraph.GraphBase.reciprocity">reciprocity</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#rewire" class="internal-link" title="igraph._igraph.GraphBase.rewire">rewire</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#rewire_edges" class="internal-link" title="igraph._igraph.GraphBase.rewire_edges">rewire<wbr></wbr>_edges</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Ring" class="internal-link" title="igraph._igraph.GraphBase.Ring"><wbr></wbr>Ring</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#SBM" class="internal-link" title="igraph._igraph.GraphBase.SBM">SBM</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#shortest_paths" class="internal-link" title="igraph._igraph.GraphBase.shortest_paths">shortest<wbr></wbr>_paths</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#similarity_dice" class="internal-link" title="igraph._igraph.GraphBase.similarity_dice">similarity<wbr></wbr>_dice</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#similarity_inverse_log_weighted" class="internal-link" title="igraph._igraph.GraphBase.similarity_inverse_log_weighted">similarity<wbr></wbr>_inverse<wbr></wbr>_log<wbr></wbr>_weighted</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#similarity_jaccard" class="internal-link" title="igraph._igraph.GraphBase.similarity_jaccard">similarity<wbr></wbr>_jaccard</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#simplify" class="internal-link" title="igraph._igraph.GraphBase.simplify">simplify</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#st_mincut" class="internal-link" title="igraph._igraph.GraphBase.st_mincut">st<wbr></wbr>_mincut</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Star" class="internal-link" title="igraph._igraph.GraphBase.Star"><wbr></wbr>Star</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Static_Fitness" class="internal-link" title="igraph._igraph.GraphBase.Static_Fitness"><wbr></wbr>Static_<wbr></wbr>Fitness</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Static_Power_Law" class="internal-link" title="igraph._igraph.GraphBase.Static_Power_Law"><wbr></wbr>Static_<wbr></wbr>Power_<wbr></wbr>Law</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#strength" class="internal-link" title="igraph._igraph.GraphBase.strength">strength</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#subcomponent" class="internal-link" title="igraph._igraph.GraphBase.subcomponent">subcomponent</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#subgraph_edges" class="internal-link" title="igraph._igraph.GraphBase.subgraph_edges">subgraph<wbr></wbr>_edges</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#subisomorphic_lad" class="internal-link" title="igraph._igraph.GraphBase.subisomorphic_lad">subisomorphic<wbr></wbr>_lad</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#subisomorphic_vf2" class="internal-link" title="igraph._igraph.GraphBase.subisomorphic_vf2">subisomorphic<wbr></wbr>_vf2</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#successors" class="internal-link" title="igraph._igraph.GraphBase.successors">successors</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#to_directed" class="internal-link" title="igraph._igraph.GraphBase.to_directed">to<wbr></wbr>_directed</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#to_prufer" class="internal-link" title="igraph._igraph.GraphBase.to_prufer">to<wbr></wbr>_prufer</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#to_undirected" class="internal-link" title="igraph._igraph.GraphBase.to_undirected">to<wbr></wbr>_undirected</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#topological_sorting" class="internal-link" title="igraph._igraph.GraphBase.topological_sorting">topological<wbr></wbr>_sorting</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#transitivity_avglocal_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_avglocal_undirected">transitivity<wbr></wbr>_avglocal<wbr></wbr>_undirected</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#transitivity_local_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_local_undirected">transitivity<wbr></wbr>_local<wbr></wbr>_undirected</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#transitivity_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_undirected">transitivity<wbr></wbr>_undirected</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Tree" class="internal-link" title="igraph._igraph.GraphBase.Tree"><wbr></wbr>Tree</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Tree_Game" class="internal-link" title="igraph._igraph.GraphBase.Tree_Game"><wbr></wbr>Tree_<wbr></wbr>Game</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#triad_census" class="internal-link" title="igraph._igraph.GraphBase.triad_census">triad<wbr></wbr>_census</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#unfold_tree" class="internal-link" title="igraph._igraph.GraphBase.unfold_tree">unfold<wbr></wbr>_tree</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#vcount" class="internal-link" title="igraph._igraph.GraphBase.vcount">vcount</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#vertex_attributes" class="internal-link" title="igraph._igraph.GraphBase.vertex_attributes">vertex<wbr></wbr>_attributes</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#vertex_connectivity" class="internal-link" title="igraph._igraph.GraphBase.vertex_connectivity">vertex<wbr></wbr>_connectivity</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Watts_Strogatz" class="internal-link" title="igraph._igraph.GraphBase.Watts_Strogatz"><wbr></wbr>Watts_<wbr></wbr>Strogatz</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#Weighted_Adjacency" class="internal-link" title="igraph._igraph.GraphBase.Weighted_Adjacency"><wbr></wbr>Weighted_<wbr></wbr>Adjacency</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#write_dimacs" class="internal-link" title="igraph._igraph.GraphBase.write_dimacs">write<wbr></wbr>_dimacs</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#write_dot" class="internal-link" title="igraph._igraph.GraphBase.write_dot">write<wbr></wbr>_dot</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#write_edgelist" class="internal-link" title="igraph._igraph.GraphBase.write_edgelist">write<wbr></wbr>_edgelist</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#write_gml" class="internal-link" title="igraph._igraph.GraphBase.write_gml">write<wbr></wbr>_gml</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#write_graphml" class="internal-link" title="igraph._igraph.GraphBase.write_graphml">write<wbr></wbr>_graphml</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#write_leda" class="internal-link" title="igraph._igraph.GraphBase.write_leda">write<wbr></wbr>_leda</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#write_lgl" class="internal-link" title="igraph._igraph.GraphBase.write_lgl">write<wbr></wbr>_lgl</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#write_ncol" class="internal-link" title="igraph._igraph.GraphBase.write_ncol">write<wbr></wbr>_ncol</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#write_pajek" class="internal-link" title="igraph._igraph.GraphBase.write_pajek">write<wbr></wbr>_pajek</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#__graph_as_capsule" class="internal-link" title="igraph._igraph.GraphBase.__graph_as_capsule">__graph<wbr></wbr>_as<wbr></wbr>_capsule</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#__register_destructor" class="internal-link" title="igraph._igraph.GraphBase.__register_destructor">__register<wbr></wbr>_destructor</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_Bipartite" class="internal-link" title="igraph._igraph.GraphBase._Bipartite">_<wbr></wbr>Bipartite</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_Full_Bipartite" class="internal-link" title="igraph._igraph.GraphBase._Full_Bipartite">_<wbr></wbr>Full_<wbr></wbr>Bipartite</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_get_all_simple_paths" class="internal-link" title="igraph._igraph.GraphBase._get_all_simple_paths">_get<wbr></wbr>_all<wbr></wbr>_simple<wbr></wbr>_paths</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_GRG" class="internal-link" title="igraph._igraph.GraphBase._GRG">_GRG</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_Incidence" class="internal-link" title="igraph._igraph.GraphBase._Incidence">_<wbr></wbr>Incidence</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_is_matching" class="internal-link" title="igraph._igraph.GraphBase._is_matching">_is<wbr></wbr>_matching</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_is_maximal_matching" class="internal-link" title="igraph._igraph.GraphBase._is_maximal_matching">_is<wbr></wbr>_maximal<wbr></wbr>_matching</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_layout_sugiyama" class="internal-link" title="igraph._igraph.GraphBase._layout_sugiyama">_layout<wbr></wbr>_sugiyama</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_maximum_bipartite_matching" class="internal-link" title="igraph._igraph.GraphBase._maximum_bipartite_matching">_maximum<wbr></wbr>_bipartite<wbr></wbr>_matching</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_Random_Bipartite" class="internal-link" title="igraph._igraph.GraphBase._Random_Bipartite">_<wbr></wbr>Random_<wbr></wbr>Bipartite</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_raw_pointer" class="internal-link" title="igraph._igraph.GraphBase._raw_pointer">_raw<wbr></wbr>_pointer</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_spanning_tree" class="internal-link" title="igraph._igraph.GraphBase._spanning_tree">_spanning<wbr></wbr>_tree</a></code>
            </div>
        

    </li>
</ul> 

        
         

        
         

        
         
        
      </div>
  </div><div>

      <div class="thingTitle">
        <span>Module</span>
        <code><a href="igraph._igraph.html" class="internal-link" title="The parent of this class">_igraph</a></code> 
      </div>
      
      <div>
        

        
         

        <div class="childrenKindTitle">Classes</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.ARPACKOptions.html" class="internal-link" title="igraph._igraph.ARPACKOptions"><wbr></wbr>ARPACKOptions</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.BFSIter.html" class="internal-link" title="igraph._igraph.BFSIter"><wbr></wbr>BFSIter</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.DFSIter.html" class="internal-link" title="igraph._igraph.DFSIter"><wbr></wbr>DFSIter</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.Edge.html" class="internal-link" title="igraph._igraph.Edge"><wbr></wbr>Edge</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.EdgeSeq.html" class="internal-link" title="igraph._igraph.EdgeSeq"><wbr></wbr>Edge<wbr></wbr>Seq</a></code>
            </div>
        

    </li><li class=" thisobject">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.GraphBase.html" class="internal-link" title="igraph._igraph.GraphBase"><wbr></wbr>Graph<wbr></wbr>Base</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.InternalError.html" class="internal-link" title="igraph._igraph.InternalError"><wbr></wbr>Internal<wbr></wbr>Error</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.Vertex.html" class="internal-link" title="igraph._igraph.Vertex"><wbr></wbr>Vertex</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.VertexSeq.html" class="internal-link" title="igraph._igraph.VertexSeq"><wbr></wbr>Vertex<wbr></wbr>Seq</a></code>
            </div>
        

    </li>
</ul>

        <div class="childrenKindTitle">Functions</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#community_to_membership" class="internal-link" title="igraph._igraph.community_to_membership">community<wbr></wbr>_to<wbr></wbr>_membership</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#convex_hull" class="internal-link" title="igraph._igraph.convex_hull">convex<wbr></wbr>_hull</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#is_degree_sequence" class="internal-link" title="igraph._igraph.is_degree_sequence">is<wbr></wbr>_degree<wbr></wbr>_sequence</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#is_graphical" class="internal-link" title="igraph._igraph.is_graphical">is<wbr></wbr>_graphical</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#is_graphical_degree_sequence" class="internal-link" title="igraph._igraph.is_graphical_degree_sequence">is<wbr></wbr>_graphical<wbr></wbr>_degree<wbr></wbr>_sequence</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#set_progress_handler" class="internal-link" title="igraph._igraph.set_progress_handler">set<wbr></wbr>_progress<wbr></wbr>_handler</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#set_random_number_generator" class="internal-link" title="igraph._igraph.set_random_number_generator">set<wbr></wbr>_random<wbr></wbr>_number<wbr></wbr>_generator</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#set_status_handler" class="internal-link" title="igraph._igraph.set_status_handler">set<wbr></wbr>_status<wbr></wbr>_handler</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#_compare_communities" class="internal-link" title="igraph._igraph._compare_communities">_compare<wbr></wbr>_communities</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#_disjoint_union" class="internal-link" title="igraph._igraph._disjoint_union">_disjoint<wbr></wbr>_union</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#_intersection" class="internal-link" title="igraph._igraph._intersection">_intersection</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#_power_law_fit" class="internal-link" title="igraph._igraph._power_law_fit">_power<wbr></wbr>_law<wbr></wbr>_fit</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#_split_join_distance" class="internal-link" title="igraph._igraph._split_join_distance">_split<wbr></wbr>_join<wbr></wbr>_distance</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="igraph._igraph.html#_union" class="internal-link" title="igraph._igraph._union">_union</a></code>
            </div>
        

    </li>
</ul> 

        
         

        
         

        
         
        
      </div>
  </div>

</nav>
        </div>
        <div id="collapseSideBar">
          <a class="btn btn-link" onclick="toggleSideBarCollapse()" title="Toggle Sidebar Collapse">
          </a>
        </div> 
        <script src="sidebartoggle.js" type="text/javascript"></script>
       
      </div>

      <div id="main" class="">
        

        

        <div class="page-header">
          <h1 class="class"><code><code><a href="index.html" class="internal-link">igraph</a></code><wbr></wbr>.<code><a href="igraph._igraph.html" class="internal-link" title="igraph._igraph">_igraph</a></code><wbr></wbr>.<code><a href="igraph._igraph.GraphBase.html" class="internal-link" title="igraph._igraph.GraphBase">GraphBase</a></code></code></h1>
          <div id="showPrivate">
            <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
          </div>
        </div>

        <div class="categoryHeader">
          class documentation
        </div>

        <div class="extrasDocstring">
          <p><code><span class="py-keyword">class</span> <span class="py-defname">GraphBase</span>:</code></p><p>Known subclasses: <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></p>
          <p><a href="classIndex.html#igraph._igraph.GraphBase">View In Hierarchy</a></p>
        </div>

        <div class="moduleDocstring">
          <div><p>Low-level representation of a graph.</p>
<p>Don't use it directly, use <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">igraph.Graph</a></code> instead.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: deffield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr></table></div>
        </div>

        <div id="splitTables">
          <table class="children sortable" id="id4">
  
  
  <tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__new__" class="internal-link" title="igraph._igraph.GraphBase.__new__">__new__</a></code></td>
    <td>Create and return a new object.  See help(type) for accurate signature.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add_edges" class="internal-link" title="igraph._igraph.GraphBase.add_edges">add<wbr></wbr>_edges</a></code></td>
    <td>Adds edges to the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#add_vertices" class="internal-link" title="igraph._igraph.GraphBase.add_vertices">add<wbr></wbr>_vertices</a></code></td>
    <td>Adds vertices to the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Adjacency" class="internal-link" title="igraph._igraph.GraphBase.Adjacency"><wbr></wbr>Adjacency</a></code></td>
    <td>Generates a graph from its adjacency matrix.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#all_minimal_st_separators" class="internal-link" title="igraph._igraph.GraphBase.all_minimal_st_separators">all<wbr></wbr>_minimal<wbr></wbr>_st<wbr></wbr>_separators</a></code></td>
    <td>Returns a list containing all the minimal s-t separators of a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#all_st_cuts" class="internal-link" title="igraph._igraph.GraphBase.all_st_cuts">all<wbr></wbr>_st<wbr></wbr>_cuts</a></code></td>
    <td>Returns all the cuts between the source and target vertices in a directed graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#all_st_mincuts" class="internal-link" title="igraph._igraph.GraphBase.all_st_mincuts">all<wbr></wbr>_st<wbr></wbr>_mincuts</a></code></td>
    <td>Returns all minimum cuts between the source and target vertices in a directed graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#are_connected" class="internal-link" title="igraph._igraph.GraphBase.are_connected">are<wbr></wbr>_connected</a></code></td>
    <td>Decides whether two given vertices are directly connected.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#articulation_points" class="internal-link" title="igraph._igraph.GraphBase.articulation_points">articulation<wbr></wbr>_points</a></code></td>
    <td>Returns the list of articulation points in the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#assortativity" class="internal-link" title="igraph._igraph.GraphBase.assortativity">assortativity</a></code></td>
    <td>Returns the assortativity of the graph based on numeric properties of the vertices.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#assortativity_degree" class="internal-link" title="igraph._igraph.GraphBase.assortativity_degree">assortativity<wbr></wbr>_degree</a></code></td>
    <td>Returns the assortativity of a graph based on vertex degrees.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#assortativity_nominal" class="internal-link" title="igraph._igraph.GraphBase.assortativity_nominal">assortativity<wbr></wbr>_nominal</a></code></td>
    <td>Returns the assortativity of the graph based on vertex categories.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Asymmetric_Preference" class="internal-link" title="igraph._igraph.GraphBase.Asymmetric_Preference"><wbr></wbr>Asymmetric_<wbr></wbr>Preference</a></code></td>
    <td>Generates a graph based on asymmetric vertex types and connection probabilities.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Atlas" class="internal-link" title="igraph._igraph.GraphBase.Atlas"><wbr></wbr>Atlas</a></code></td>
    <td>Generates a graph from the Graph Atlas.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#attributes" class="internal-link" title="igraph._igraph.GraphBase.attributes">attributes</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#authority_score" class="internal-link" title="igraph._igraph.GraphBase.authority_score">authority<wbr></wbr>_score</a></code></td>
    <td>Calculates Kleinberg's authority score for the vertices of the graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#average_path_length" class="internal-link" title="igraph._igraph.GraphBase.average_path_length">average<wbr></wbr>_path<wbr></wbr>_length</a></code></td>
    <td>Calculates the average path length in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Barabasi" class="internal-link" title="igraph._igraph.GraphBase.Barabasi"><wbr></wbr>Barabasi</a></code></td>
    <td>Generates a graph based on the Barabasi-Albert model.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#betweenness" class="internal-link" title="igraph._igraph.GraphBase.betweenness">betweenness</a></code></td>
    <td>Calculates or estimates the betweenness of vertices in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bfs" class="internal-link" title="igraph._igraph.GraphBase.bfs">bfs</a></code></td>
    <td>Conducts a breadth first search (BFS) on the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bfsiter" class="internal-link" title="igraph._igraph.GraphBase.bfsiter">bfsiter</a></code></td>
    <td>Constructs a breadth first search (BFS) iterator of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bibcoupling" class="internal-link" title="igraph._igraph.GraphBase.bibcoupling">bibcoupling</a></code></td>
    <td>Calculates bibliographic coupling scores for given vertices in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#biconnected_components" class="internal-link" title="igraph._igraph.GraphBase.biconnected_components">biconnected<wbr></wbr>_components</a></code></td>
    <td>Calculates the biconnected components of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bipartite_projection" class="internal-link" title="igraph._igraph.GraphBase.bipartite_projection">bipartite<wbr></wbr>_projection</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bipartite_projection_size" class="internal-link" title="igraph._igraph.GraphBase.bipartite_projection_size">bipartite<wbr></wbr>_projection<wbr></wbr>_size</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#bridges" class="internal-link" title="igraph._igraph.GraphBase.bridges">bridges</a></code></td>
    <td>Returns the list of bridges in the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#canonical_permutation" class="internal-link" title="igraph._igraph.GraphBase.canonical_permutation">canonical<wbr></wbr>_permutation</a></code></td>
    <td>Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#chordal_completion" class="internal-link" title="igraph._igraph.GraphBase.chordal_completion">chordal<wbr></wbr>_completion</a></code></td>
    <td>chordal_complation(alpha=None, alpham1=None) --</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#clique_number" class="internal-link" title="igraph._igraph.GraphBase.clique_number">clique<wbr></wbr>_number</a></code></td>
    <td>Returns the clique number of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#cliques" class="internal-link" title="igraph._igraph.GraphBase.cliques">cliques</a></code></td>
    <td>Returns some or all cliques of the graph as a list of tuples.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#closeness" class="internal-link" title="igraph._igraph.GraphBase.closeness">closeness</a></code></td>
    <td>Calculates the closeness centralities of given vertices in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#clusters" class="internal-link" title="igraph._igraph.GraphBase.clusters">clusters</a></code></td>
    <td>Calculates the (strong or weak) clusters for a given graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#cocitation" class="internal-link" title="igraph._igraph.GraphBase.cocitation">cocitation</a></code></td>
    <td>Calculates cocitation scores for given vertices in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#cohesive_blocks" class="internal-link" title="igraph._igraph.GraphBase.cohesive_blocks">cohesive<wbr></wbr>_blocks</a></code></td>
    <td>Calculates the cohesive block structure of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_edge_betweenness" class="internal-link" title="igraph._igraph.GraphBase.community_edge_betweenness">community<wbr></wbr>_edge<wbr></wbr>_betweenness</a></code></td>
    <td>Community structure detection based on the betweenness of the edges in the network. This algorithm was invented by M Girvan and MEJ Newman, see: M Girvan and MEJ Newman: Community structure in social and biological networks, Proc...</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_fastgreedy" class="internal-link" title="igraph._igraph.GraphBase.community_fastgreedy">community<wbr></wbr>_fastgreedy</a></code></td>
    <td>Finds the community structure of the graph according to the algorithm of Clauset et al based on the greedy optimization of modularity.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_infomap" class="internal-link" title="igraph._igraph.GraphBase.community_infomap">community<wbr></wbr>_infomap</a></code></td>
    <td>Finds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_label_propagation" class="internal-link" title="igraph._igraph.GraphBase.community_label_propagation">community<wbr></wbr>_label<wbr></wbr>_propagation</a></code></td>
    <td>Finds the community structure of the graph according to the label propagation method of Raghavan et al.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_leading_eigenvector" class="internal-link" title="igraph._igraph.GraphBase.community_leading_eigenvector">community<wbr></wbr>_leading<wbr></wbr>_eigenvector</a></code></td>
    <td>A proper implementation of Newman's eigenvector community structure detection. Each split is done by maximizing the modularity regarding the original network. See the reference for details.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_leiden" class="internal-link" title="igraph._igraph.GraphBase.community_leiden">community<wbr></wbr>_leiden</a></code></td>
    <td>Finds the community structure of the graph using the Leiden algorithm of Traag, van Eck &amp; Waltman.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_multilevel" class="internal-link" title="igraph._igraph.GraphBase.community_multilevel">community<wbr></wbr>_multilevel</a></code></td>
    <td>Finds the community structure of the graph according to the multilevel algorithm of Blondel et al. This is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score...</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_optimal_modularity" class="internal-link" title="igraph._igraph.GraphBase.community_optimal_modularity">community<wbr></wbr>_optimal<wbr></wbr>_modularity</a></code></td>
    <td>Calculates the optimal modularity score of the graph and the corresponding community structure.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_spinglass" class="internal-link" title="igraph._igraph.GraphBase.community_spinglass">community<wbr></wbr>_spinglass</a></code></td>
    <td>Finds the community structure of the graph according to the spinglass community detection method of Reichardt &amp; Bornholdt.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#community_walktrap" class="internal-link" title="igraph._igraph.GraphBase.community_walktrap">community<wbr></wbr>_walktrap</a></code></td>
    <td>Finds the community structure of the graph according to the random walk method of Latapy &amp; Pons.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#complementer" class="internal-link" title="igraph._igraph.GraphBase.complementer">complementer</a></code></td>
    <td>Returns the complementer of the graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#compose" class="internal-link" title="igraph._igraph.GraphBase.compose">compose</a></code></td>
    <td>Returns the composition of two graphs.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#constraint" class="internal-link" title="igraph._igraph.GraphBase.constraint">constraint</a></code></td>
    <td>Calculates Burt's constraint scores for given vertices in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#contract_vertices" class="internal-link" title="igraph._igraph.GraphBase.contract_vertices">contract<wbr></wbr>_vertices</a></code></td>
    <td>Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#convergence_degree" class="internal-link" title="igraph._igraph.GraphBase.convergence_degree">convergence<wbr></wbr>_degree</a></code></td>
    <td>Undocumented (yet).</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#convergence_field_size" class="internal-link" title="igraph._igraph.GraphBase.convergence_field_size">convergence<wbr></wbr>_field<wbr></wbr>_size</a></code></td>
    <td>Undocumented (yet).</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#copy" class="internal-link" title="igraph._igraph.GraphBase.copy">copy</a></code></td>
    <td>Creates a copy of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#coreness" class="internal-link" title="igraph._igraph.GraphBase.coreness">coreness</a></code></td>
    <td>Finds the coreness (shell index) of the vertices of the network.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#count_isomorphisms_vf2" class="internal-link" title="igraph._igraph.GraphBase.count_isomorphisms_vf2">count<wbr></wbr>_isomorphisms<wbr></wbr>_vf2</a></code></td>
    <td>Determines the number of isomorphisms between the graph and another one</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#count_multiple" class="internal-link" title="igraph._igraph.GraphBase.count_multiple">count<wbr></wbr>_multiple</a></code></td>
    <td>Counts the multiplicities of the given edges.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#count_subisomorphisms_vf2" class="internal-link" title="igraph._igraph.GraphBase.count_subisomorphisms_vf2">count<wbr></wbr>_subisomorphisms<wbr></wbr>_vf2</a></code></td>
    <td>Determines the number of subisomorphisms between the graph and another one</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#De_Bruijn" class="internal-link" title="igraph._igraph.GraphBase.De_Bruijn"><wbr></wbr>De_<wbr></wbr>Bruijn</a></code></td>
    <td>Generates a de Bruijn graph with parameters (m, n)</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#decompose" class="internal-link" title="igraph._igraph.GraphBase.decompose">decompose</a></code></td>
    <td>Decomposes the graph into subgraphs.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#degree" class="internal-link" title="igraph._igraph.GraphBase.degree">degree</a></code></td>
    <td>Returns some vertex degrees from the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Degree_Sequence" class="internal-link" title="igraph._igraph.GraphBase.Degree_Sequence"><wbr></wbr>Degree_<wbr></wbr>Sequence</a></code></td>
    <td>Generates a graph with a given degree sequence.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#delete_edges" class="internal-link" title="igraph._igraph.GraphBase.delete_edges">delete<wbr></wbr>_edges</a></code></td>
    <td>Removes edges from the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#delete_vertices" class="internal-link" title="igraph._igraph.GraphBase.delete_vertices">delete<wbr></wbr>_vertices</a></code></td>
    <td>Deletes vertices and all its edges from the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#density" class="internal-link" title="igraph._igraph.GraphBase.density">density</a></code></td>
    <td>Calculates the density of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#dfsiter" class="internal-link" title="igraph._igraph.GraphBase.dfsiter">dfsiter</a></code></td>
    <td>Constructs a depth first search (DFS) iterator of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#diameter" class="internal-link" title="igraph._igraph.GraphBase.diameter">diameter</a></code></td>
    <td>Calculates the diameter of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#difference" class="internal-link" title="igraph._igraph.GraphBase.difference">difference</a></code></td>
    <td>Subtracts the given graph from the original</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#diversity" class="internal-link" title="igraph._igraph.GraphBase.diversity">diversity</a></code></td>
    <td>Calculates the structural diversity index of the vertices.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#dominator" class="internal-link" title="igraph._igraph.GraphBase.dominator">dominator</a></code></td>
    <td>Returns the dominator tree from the given root node</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#dyad_census" class="internal-link" title="igraph._igraph.GraphBase.dyad_census">dyad<wbr></wbr>_census</a></code></td>
    <td>Dyad census, as defined by Holland and Leinhardt</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#eccentricity" class="internal-link" title="igraph._igraph.GraphBase.eccentricity">eccentricity</a></code></td>
    <td>Calculates the eccentricities of given vertices in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#ecount" class="internal-link" title="igraph._igraph.GraphBase.ecount">ecount</a></code></td>
    <td>Counts the number of edges.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#edge_attributes" class="internal-link" title="igraph._igraph.GraphBase.edge_attributes">edge<wbr></wbr>_attributes</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#edge_betweenness" class="internal-link" title="igraph._igraph.GraphBase.edge_betweenness">edge<wbr></wbr>_betweenness</a></code></td>
    <td>Calculates or estimates the edge betweennesses in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#edge_connectivity" class="internal-link" title="igraph._igraph.GraphBase.edge_connectivity">edge<wbr></wbr>_connectivity</a></code></td>
    <td>Calculates the edge connectivity of the graph or between some vertices.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#eigen_adjacency" class="internal-link" title="igraph._igraph.GraphBase.eigen_adjacency">eigen<wbr></wbr>_adjacency</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#eigenvector_centrality" class="internal-link" title="igraph._igraph.GraphBase.eigenvector_centrality">eigenvector<wbr></wbr>_centrality</a></code></td>
    <td>Calculates the eigenvector centralities of the vertices in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Erdos_Renyi" class="internal-link" title="igraph._igraph.GraphBase.Erdos_Renyi"><wbr></wbr>Erdos_<wbr></wbr>Renyi</a></code></td>
    <td>Generates a graph based on the Erdos-Renyi model.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Establishment" class="internal-link" title="igraph._igraph.GraphBase.Establishment"><wbr></wbr>Establishment</a></code></td>
    <td>Generates a graph based on a simple growing model with vertex types.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Famous" class="internal-link" title="igraph._igraph.GraphBase.Famous"><wbr></wbr>Famous</a></code></td>
    <td>Generates a famous graph based on its name.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#farthest_points" class="internal-link" title="igraph._igraph.GraphBase.farthest_points">farthest<wbr></wbr>_points</a></code></td>
    <td>Returns two vertex IDs whose distance equals the actual diameter of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#feedback_arc_set" class="internal-link" title="igraph._igraph.GraphBase.feedback_arc_set">feedback<wbr></wbr>_arc<wbr></wbr>_set</a></code></td>
    <td>Calculates an approximately or exactly minimal feedback arc set.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Forest_Fire" class="internal-link" title="igraph._igraph.GraphBase.Forest_Fire"><wbr></wbr>Forest_<wbr></wbr>Fire</a></code></td>
    <td>Generates a graph based on the forest fire model</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Full" class="internal-link" title="igraph._igraph.GraphBase.Full"><wbr></wbr>Full</a></code></td>
    <td>Generates a full graph (directed or undirected, with or without loops).</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Full_Citation" class="internal-link" title="igraph._igraph.GraphBase.Full_Citation"><wbr></wbr>Full_<wbr></wbr>Citation</a></code></td>
    <td>Generates a full citation graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_adjacency" class="internal-link" title="igraph._igraph.GraphBase.get_adjacency">get<wbr></wbr>_adjacency</a></code></td>
    <td>Returns the adjacency matrix of a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_all_shortest_paths" class="internal-link" title="igraph._igraph.GraphBase.get_all_shortest_paths">get<wbr></wbr>_all<wbr></wbr>_shortest<wbr></wbr>_paths</a></code></td>
    <td>Calculates all of the shortest paths from/to a given node in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_diameter" class="internal-link" title="igraph._igraph.GraphBase.get_diameter">get<wbr></wbr>_diameter</a></code></td>
    <td>Returns a path with the actual diameter of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_edgelist" class="internal-link" title="igraph._igraph.GraphBase.get_edgelist">get<wbr></wbr>_edgelist</a></code></td>
    <td>Returns the edge list of a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_eid" class="internal-link" title="igraph._igraph.GraphBase.get_eid">get<wbr></wbr>_eid</a></code></td>
    <td>Returns the edge ID of an arbitrary edge between vertices v1 and v2</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_eids" class="internal-link" title="igraph._igraph.GraphBase.get_eids">get<wbr></wbr>_eids</a></code></td>
    <td>Returns the edge IDs of some edges between some vertices.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_incidence" class="internal-link" title="igraph._igraph.GraphBase.get_incidence">get<wbr></wbr>_incidence</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_isomorphisms_vf2" class="internal-link" title="igraph._igraph.GraphBase.get_isomorphisms_vf2">get<wbr></wbr>_isomorphisms<wbr></wbr>_vf2</a></code></td>
    <td>Returns all isomorphisms between the graph and another one</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_shortest_paths" class="internal-link" title="igraph._igraph.GraphBase.get_shortest_paths">get<wbr></wbr>_shortest<wbr></wbr>_paths</a></code></td>
    <td>Calculates the shortest paths from/to a given node in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_subisomorphisms_lad" class="internal-link" title="igraph._igraph.GraphBase.get_subisomorphisms_lad">get<wbr></wbr>_subisomorphisms<wbr></wbr>_lad</a></code></td>
    <td>Returns all subisomorphisms between the graph and another one using the LAD algorithm.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#get_subisomorphisms_vf2" class="internal-link" title="igraph._igraph.GraphBase.get_subisomorphisms_vf2">get<wbr></wbr>_subisomorphisms<wbr></wbr>_vf2</a></code></td>
    <td>Returns all subisomorphisms between the graph and another one</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#girth" class="internal-link" title="igraph._igraph.GraphBase.girth">girth</a></code></td>
    <td>Returns the girth of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#gomory_hu_tree" class="internal-link" title="igraph._igraph.GraphBase.gomory_hu_tree">gomory<wbr></wbr>_hu<wbr></wbr>_tree</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Growing_Random" class="internal-link" title="igraph._igraph.GraphBase.Growing_Random"><wbr></wbr>Growing_<wbr></wbr>Random</a></code></td>
    <td>Generates a growing random graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#harmonic_centrality" class="internal-link" title="igraph._igraph.GraphBase.harmonic_centrality">harmonic<wbr></wbr>_centrality</a></code></td>
    <td>Calculates the harmonic centralities of given vertices in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#has_multiple" class="internal-link" title="igraph._igraph.GraphBase.has_multiple">has<wbr></wbr>_multiple</a></code></td>
    <td>Checks whether the graph has multiple edges.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#hub_score" class="internal-link" title="igraph._igraph.GraphBase.hub_score">hub<wbr></wbr>_score</a></code></td>
    <td>Calculates Kleinberg's hub score for the vertices of the graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#incident" class="internal-link" title="igraph._igraph.GraphBase.incident">incident</a></code></td>
    <td>Returns the edges a given vertex is incident on.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#independence_number" class="internal-link" title="igraph._igraph.GraphBase.independence_number">independence<wbr></wbr>_number</a></code></td>
    <td>Returns the independence number of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#independent_vertex_sets" class="internal-link" title="igraph._igraph.GraphBase.independent_vertex_sets">independent<wbr></wbr>_vertex<wbr></wbr>_sets</a></code></td>
    <td>Returns some or all independent vertex sets of the graph as a list of tuples.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#induced_subgraph" class="internal-link" title="igraph._igraph.GraphBase.induced_subgraph">induced<wbr></wbr>_subgraph</a></code></td>
    <td>Returns a subgraph spanned by the given vertices.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_bipartite" class="internal-link" title="igraph._igraph.GraphBase.is_bipartite">is<wbr></wbr>_bipartite</a></code></td>
    <td>Decides whether the graph is bipartite or not.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_chordal" class="internal-link" title="igraph._igraph.GraphBase.is_chordal">is<wbr></wbr>_chordal</a></code></td>
    <td>Returns whether the graph is chordal or not.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_connected" class="internal-link" title="igraph._igraph.GraphBase.is_connected">is<wbr></wbr>_connected</a></code></td>
    <td>Decides whether the graph is connected.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_dag" class="internal-link" title="igraph._igraph.GraphBase.is_dag">is<wbr></wbr>_dag</a></code></td>
    <td>Checks whether the graph is a DAG (directed acyclic graph).</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_directed" class="internal-link" title="igraph._igraph.GraphBase.is_directed">is<wbr></wbr>_directed</a></code></td>
    <td>Checks whether the graph is directed.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_loop" class="internal-link" title="igraph._igraph.GraphBase.is_loop">is<wbr></wbr>_loop</a></code></td>
    <td>Checks whether a specific set of edges contain loop edges</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_minimal_separator" class="internal-link" title="igraph._igraph.GraphBase.is_minimal_separator">is<wbr></wbr>_minimal<wbr></wbr>_separator</a></code></td>
    <td>Decides whether the given vertex set is a minimal separator.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_multiple" class="internal-link" title="igraph._igraph.GraphBase.is_multiple">is<wbr></wbr>_multiple</a></code></td>
    <td>Checks whether an edge is a multiple edge.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_mutual" class="internal-link" title="igraph._igraph.GraphBase.is_mutual">is<wbr></wbr>_mutual</a></code></td>
    <td>Checks whether an edge has an opposite pair.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_separator" class="internal-link" title="igraph._igraph.GraphBase.is_separator">is<wbr></wbr>_separator</a></code></td>
    <td>Decides whether the removal of the given vertices disconnects the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_simple" class="internal-link" title="igraph._igraph.GraphBase.is_simple">is<wbr></wbr>_simple</a></code></td>
    <td>Checks whether the graph is simple (no loop or multiple edges).</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#is_tree" class="internal-link" title="igraph._igraph.GraphBase.is_tree">is<wbr></wbr>_tree</a></code></td>
    <td>Checks whether the graph is a (directed or undirected) tree graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Isoclass" class="internal-link" title="igraph._igraph.GraphBase.Isoclass"><wbr></wbr>Isoclass</a></code></td>
    <td>Generates a graph with a given isomorphism class.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#isoclass" class="internal-link" title="igraph._igraph.GraphBase.isoclass">isoclass</a></code></td>
    <td>Returns the isomorphism class of the graph or its subgraph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#isomorphic" class="internal-link" title="igraph._igraph.GraphBase.isomorphic">isomorphic</a></code></td>
    <td>Checks whether the graph is isomorphic to another graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#isomorphic_bliss" class="internal-link" title="igraph._igraph.GraphBase.isomorphic_bliss">isomorphic<wbr></wbr>_bliss</a></code></td>
    <td>Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#isomorphic_vf2" class="internal-link" title="igraph._igraph.GraphBase.isomorphic_vf2">isomorphic<wbr></wbr>_vf2</a></code></td>
    <td>Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#K_Regular" class="internal-link" title="igraph._igraph.GraphBase.K_Regular"><wbr></wbr>K_<wbr></wbr>Regular</a></code></td>
    <td>Generates a k-regular random graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Kautz" class="internal-link" title="igraph._igraph.GraphBase.Kautz"><wbr></wbr>Kautz</a></code></td>
    <td>Generates a Kautz graph with parameters (m, n)</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#knn" class="internal-link" title="igraph._igraph.GraphBase.knn">knn</a></code></td>
    <td>Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#laplacian" class="internal-link" title="igraph._igraph.GraphBase.laplacian">laplacian</a></code></td>
    <td>Returns the Laplacian matrix of a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#largest_cliques" class="internal-link" title="igraph._igraph.GraphBase.largest_cliques">largest<wbr></wbr>_cliques</a></code></td>
    <td>Returns the largest cliques of the graph as a list of tuples.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#largest_independent_vertex_sets" class="internal-link" title="igraph._igraph.GraphBase.largest_independent_vertex_sets">largest<wbr></wbr>_independent<wbr></wbr>_vertex<wbr></wbr>_sets</a></code></td>
    <td>Returns the largest independent vertex sets of the graph as a list of tuples.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Lattice" class="internal-link" title="igraph._igraph.GraphBase.Lattice"><wbr></wbr>Lattice</a></code></td>
    <td>Generates a regular lattice.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_bipartite" class="internal-link" title="igraph._igraph.GraphBase.layout_bipartite">layout<wbr></wbr>_bipartite</a></code></td>
    <td>Place the vertices of a bipartite graph in two layers.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_circle" class="internal-link" title="igraph._igraph.GraphBase.layout_circle">layout<wbr></wbr>_circle</a></code></td>
    <td>Places the vertices of the graph uniformly on a circle or a sphere.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_davidson_harel" class="internal-link" title="igraph._igraph.GraphBase.layout_davidson_harel">layout<wbr></wbr>_davidson<wbr></wbr>_harel</a></code></td>
    <td>Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_drl" class="internal-link" title="igraph._igraph.GraphBase.layout_drl">layout<wbr></wbr>_drl</a></code></td>
    <td>Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_fruchterman_reingold" class="internal-link" title="igraph._igraph.GraphBase.layout_fruchterman_reingold">layout<wbr></wbr>_fruchterman<wbr></wbr>_reingold</a></code></td>
    <td>Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_graphopt" class="internal-link" title="igraph._igraph.GraphBase.layout_graphopt">layout<wbr></wbr>_graphopt</a></code></td>
    <td>This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_grid" class="internal-link" title="igraph._igraph.GraphBase.layout_grid">layout<wbr></wbr>_grid</a></code></td>
    <td>Places the vertices of a graph in a 2D or 3D grid.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_kamada_kawai" class="internal-link" title="igraph._igraph.GraphBase.layout_kamada_kawai">layout<wbr></wbr>_kamada<wbr></wbr>_kawai</a></code></td>
    <td>Places the vertices on a plane according to the Kamada-Kawai algorithm.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_lgl" class="internal-link" title="igraph._igraph.GraphBase.layout_lgl">layout<wbr></wbr>_lgl</a></code></td>
    <td>Places the vertices on a 2D plane according to the Large Graph Layout.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_mds" class="internal-link" title="igraph._igraph.GraphBase.layout_mds">layout<wbr></wbr>_mds</a></code></td>
    <td>Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_random" class="internal-link" title="igraph._igraph.GraphBase.layout_random">layout<wbr></wbr>_random</a></code></td>
    <td>Places the vertices of the graph randomly.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_reingold_tilford" class="internal-link" title="igraph._igraph.GraphBase.layout_reingold_tilford">layout<wbr></wbr>_reingold<wbr></wbr>_tilford</a></code></td>
    <td>Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_reingold_tilford_circular" class="internal-link" title="igraph._igraph.GraphBase.layout_reingold_tilford_circular">layout<wbr></wbr>_reingold<wbr></wbr>_tilford<wbr></wbr>_circular</a></code></td>
    <td>Circular Reingold-Tilford layout for trees.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#layout_star" class="internal-link" title="igraph._igraph.GraphBase.layout_star">layout<wbr></wbr>_star</a></code></td>
    <td>Calculates a star-like layout for the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#LCF" class="internal-link" title="igraph._igraph.GraphBase.LCF">LCF</a></code></td>
    <td>Generates a graph from LCF notation.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#linegraph" class="internal-link" title="igraph._igraph.GraphBase.linegraph">linegraph</a></code></td>
    <td>Returns the line graph of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maxdegree" class="internal-link" title="igraph._igraph.GraphBase.maxdegree">maxdegree</a></code></td>
    <td>Returns the maximum degree of a vertex set in the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maxflow" class="internal-link" title="igraph._igraph.GraphBase.maxflow">maxflow</a></code></td>
    <td>Returns the maximum flow between the source and target vertices.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maxflow_value" class="internal-link" title="igraph._igraph.GraphBase.maxflow_value">maxflow<wbr></wbr>_value</a></code></td>
    <td>Returns the value of the maximum flow between the source and target vertices.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maximal_cliques" class="internal-link" title="igraph._igraph.GraphBase.maximal_cliques">maximal<wbr></wbr>_cliques</a></code></td>
    <td>Returns the maximal cliques of the graph as a list of tuples.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maximal_independent_vertex_sets" class="internal-link" title="igraph._igraph.GraphBase.maximal_independent_vertex_sets">maximal<wbr></wbr>_independent<wbr></wbr>_vertex<wbr></wbr>_sets</a></code></td>
    <td>Returns the maximal independent vertex sets of the graph as a list of tuples.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#maximum_cardinality_search" class="internal-link" title="igraph._igraph.GraphBase.maximum_cardinality_search">maximum<wbr></wbr>_cardinality<wbr></wbr>_search</a></code></td>
    <td>Conducts a maximum cardinality search on the graph. The function computes a rank <em>alpha</em> for each vertex such that visiting vertices in decreasing rank order corresponds to always choosing the vertex with the most already visited neighbors as the next one to visit.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#mincut" class="internal-link" title="igraph._igraph.GraphBase.mincut">mincut</a></code></td>
    <td>Calculates the minimum cut between the source and target vertices or within the whole graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#mincut_value" class="internal-link" title="igraph._igraph.GraphBase.mincut_value">mincut<wbr></wbr>_value</a></code></td>
    <td>Returns the minimum cut between the source and target vertices or within the whole graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#minimum_size_separators" class="internal-link" title="igraph._igraph.GraphBase.minimum_size_separators">minimum<wbr></wbr>_size<wbr></wbr>_separators</a></code></td>
    <td>Returns a list containing all separator vertex sets of minimum size.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#modularity" class="internal-link" title="igraph._igraph.GraphBase.modularity">modularity</a></code></td>
    <td>Calculates the modularity of the graph with respect to some vertex types.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#motifs_randesu" class="internal-link" title="igraph._igraph.GraphBase.motifs_randesu">motifs<wbr></wbr>_randesu</a></code></td>
    <td>Counts the number of motifs in the graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#motifs_randesu_estimate" class="internal-link" title="igraph._igraph.GraphBase.motifs_randesu_estimate">motifs<wbr></wbr>_randesu<wbr></wbr>_estimate</a></code></td>
    <td>Counts the total number of motifs in the graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#motifs_randesu_no" class="internal-link" title="igraph._igraph.GraphBase.motifs_randesu_no">motifs<wbr></wbr>_randesu<wbr></wbr>_no</a></code></td>
    <td>Counts the total number of motifs in the graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#neighborhood" class="internal-link" title="igraph._igraph.GraphBase.neighborhood">neighborhood</a></code></td>
    <td>For each vertex specified by <em>vertices</em>, returns the vertices reachable from that vertex in at most <em>order</em> steps. If <em>mindist</em> is larger than zero, vertices that are reachable in less than <em>mindist</em> steps are excluded.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#neighborhood_size" class="internal-link" title="igraph._igraph.GraphBase.neighborhood_size">neighborhood<wbr></wbr>_size</a></code></td>
    <td>For each vertex specified by <em>vertices</em>, returns the number of vertices reachable from that vertex in at most <em>order</em> steps. If <em>mindist</em> is larger than zero, vertices that are reachable in less than <em>mindist</em>...</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#neighbors" class="internal-link" title="igraph._igraph.GraphBase.neighbors">neighbors</a></code></td>
    <td>Returns adjacent vertices to a given vertex.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#path_length_hist" class="internal-link" title="igraph._igraph.GraphBase.path_length_hist">path<wbr></wbr>_length<wbr></wbr>_hist</a></code></td>
    <td>Calculates the path length histogram of the graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#permute_vertices" class="internal-link" title="igraph._igraph.GraphBase.permute_vertices">permute<wbr></wbr>_vertices</a></code></td>
    <td>Permutes the vertices of the graph according to the given permutation and returns the new graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#personalized_pagerank" class="internal-link" title="igraph._igraph.GraphBase.personalized_pagerank">personalized<wbr></wbr>_pagerank</a></code></td>
    <td>Calculates the personalized PageRank values of a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#predecessors" class="internal-link" title="igraph._igraph.GraphBase.predecessors">predecessors</a></code></td>
    <td>Returns the predecessors of a given vertex.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Preference" class="internal-link" title="igraph._igraph.GraphBase.Preference"><wbr></wbr>Preference</a></code></td>
    <td>Generates a graph based on vertex types and connection probabilities.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#radius" class="internal-link" title="igraph._igraph.GraphBase.radius">radius</a></code></td>
    <td>Calculates the radius of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#random_walk" class="internal-link" title="igraph._igraph.GraphBase.random_walk">random<wbr></wbr>_walk</a></code></td>
    <td>Performs a random walk of a given length from a given node.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_DIMACS" class="internal-link" title="igraph._igraph.GraphBase.Read_DIMACS"><wbr></wbr>Read_<wbr></wbr>DIMACS</a></code></td>
    <td>Reads a graph from a file conforming to the DIMACS minimum-cost flow file format.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_DL" class="internal-link" title="igraph._igraph.GraphBase.Read_DL"><wbr></wbr>Read_<wbr></wbr>DL</a></code></td>
    <td>Reads an UCINET DL file and creates a graph based on it.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_Edgelist" class="internal-link" title="igraph._igraph.GraphBase.Read_Edgelist"><wbr></wbr>Read_<wbr></wbr>Edgelist</a></code></td>
    <td>Reads an edge list from a file and creates a graph based on it.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_GML" class="internal-link" title="igraph._igraph.GraphBase.Read_GML"><wbr></wbr>Read_<wbr></wbr>GML</a></code></td>
    <td>Reads a GML file and creates a graph based on it.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_GraphDB" class="internal-link" title="igraph._igraph.GraphBase.Read_GraphDB"><wbr></wbr>Read_<wbr></wbr>Graph<wbr></wbr>DB</a></code></td>
    <td>Reads a GraphDB format file and creates a graph based on it.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_GraphML" class="internal-link" title="igraph._igraph.GraphBase.Read_GraphML"><wbr></wbr>Read_<wbr></wbr>Graph<wbr></wbr>ML</a></code></td>
    <td>Reads a GraphML format file and creates a graph based on it.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_Lgl" class="internal-link" title="igraph._igraph.GraphBase.Read_Lgl"><wbr></wbr>Read_<wbr></wbr>Lgl</a></code></td>
    <td>Reads an .lgl file used by LGL.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_Ncol" class="internal-link" title="igraph._igraph.GraphBase.Read_Ncol"><wbr></wbr>Read_<wbr></wbr>Ncol</a></code></td>
    <td>Reads an .ncol file used by LGL.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Read_Pajek" class="internal-link" title="igraph._igraph.GraphBase.Read_Pajek"><wbr></wbr>Read_<wbr></wbr>Pajek</a></code></td>
    <td>Reads a Pajek format file and creates a graph based on it.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Realize_Degree_Sequence" class="internal-link" title="igraph._igraph.GraphBase.Realize_Degree_Sequence"><wbr></wbr>Realize_<wbr></wbr>Degree_<wbr></wbr>Sequence</a></code></td>
    <td>Generates a graph from a degree sequence.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Recent_Degree" class="internal-link" title="igraph._igraph.GraphBase.Recent_Degree"><wbr></wbr>Recent_<wbr></wbr>Degree</a></code></td>
    <td>Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#reciprocity" class="internal-link" title="igraph._igraph.GraphBase.reciprocity">reciprocity</a></code></td>
    <td>Reciprocity defines the proportion of mutual connections in a directed graph. It is most commonly defined as the probability that the opposite counterpart of a directed edge is also included in the graph...</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#rewire" class="internal-link" title="igraph._igraph.GraphBase.rewire">rewire</a></code></td>
    <td>Randomly rewires the graph while preserving the degree distribution.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#rewire_edges" class="internal-link" title="igraph._igraph.GraphBase.rewire_edges">rewire<wbr></wbr>_edges</a></code></td>
    <td>Rewires the edges of a graph with constant probability.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Ring" class="internal-link" title="igraph._igraph.GraphBase.Ring"><wbr></wbr>Ring</a></code></td>
    <td>Generates a ring graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#SBM" class="internal-link" title="igraph._igraph.GraphBase.SBM">SBM</a></code></td>
    <td>Generates a graph based on a stochastic blockmodel.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#shortest_paths" class="internal-link" title="igraph._igraph.GraphBase.shortest_paths">shortest<wbr></wbr>_paths</a></code></td>
    <td>Calculates shortest path lengths for given vertices in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#similarity_dice" class="internal-link" title="igraph._igraph.GraphBase.similarity_dice">similarity<wbr></wbr>_dice</a></code></td>
    <td>Dice similarity coefficient of vertices.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#similarity_inverse_log_weighted" class="internal-link" title="igraph._igraph.GraphBase.similarity_inverse_log_weighted">similarity<wbr></wbr>_inverse<wbr></wbr>_log<wbr></wbr>_weighted</a></code></td>
    <td>Inverse log-weighted similarity coefficient of vertices.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#similarity_jaccard" class="internal-link" title="igraph._igraph.GraphBase.similarity_jaccard">similarity<wbr></wbr>_jaccard</a></code></td>
    <td>Jaccard similarity coefficient of vertices.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#simplify" class="internal-link" title="igraph._igraph.GraphBase.simplify">simplify</a></code></td>
    <td>Simplifies a graph by removing self-loops and/or multiple edges.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#st_mincut" class="internal-link" title="igraph._igraph.GraphBase.st_mincut">st<wbr></wbr>_mincut</a></code></td>
    <td>Calculates the minimum cut between the source and target vertices in a graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Star" class="internal-link" title="igraph._igraph.GraphBase.Star"><wbr></wbr>Star</a></code></td>
    <td>Generates a star graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Static_Fitness" class="internal-link" title="igraph._igraph.GraphBase.Static_Fitness"><wbr></wbr>Static_<wbr></wbr>Fitness</a></code></td>
    <td>Generates a non-growing graph with edge probabilities proportional to node fitnesses.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Static_Power_Law" class="internal-link" title="igraph._igraph.GraphBase.Static_Power_Law"><wbr></wbr>Static_<wbr></wbr>Power_<wbr></wbr>Law</a></code></td>
    <td>Generates a non-growing graph with prescribed power-law degree distributions.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#strength" class="internal-link" title="igraph._igraph.GraphBase.strength">strength</a></code></td>
    <td>Returns the strength (weighted degree) of some vertices from the graph</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#subcomponent" class="internal-link" title="igraph._igraph.GraphBase.subcomponent">subcomponent</a></code></td>
    <td>Determines the indices of vertices which are in the same component as a given vertex.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#subgraph_edges" class="internal-link" title="igraph._igraph.GraphBase.subgraph_edges">subgraph<wbr></wbr>_edges</a></code></td>
    <td>Returns a subgraph spanned by the given edges.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#subisomorphic_lad" class="internal-link" title="igraph._igraph.GraphBase.subisomorphic_lad">subisomorphic<wbr></wbr>_lad</a></code></td>
    <td>Checks whether a subgraph of the graph is isomorphic to another graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#subisomorphic_vf2" class="internal-link" title="igraph._igraph.GraphBase.subisomorphic_vf2">subisomorphic<wbr></wbr>_vf2</a></code></td>
    <td>Checks whether a subgraph of the graph is isomorphic to another graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#successors" class="internal-link" title="igraph._igraph.GraphBase.successors">successors</a></code></td>
    <td>Returns the successors of a given vertex.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#to_directed" class="internal-link" title="igraph._igraph.GraphBase.to_directed">to<wbr></wbr>_directed</a></code></td>
    <td>Converts an undirected graph to directed.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#to_prufer" class="internal-link" title="igraph._igraph.GraphBase.to_prufer">to<wbr></wbr>_prufer</a></code></td>
    <td>Converts a tree graph into a Prufer sequence.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#to_undirected" class="internal-link" title="igraph._igraph.GraphBase.to_undirected">to<wbr></wbr>_undirected</a></code></td>
    <td>Converts a directed graph to undirected.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#topological_sorting" class="internal-link" title="igraph._igraph.GraphBase.topological_sorting">topological<wbr></wbr>_sorting</a></code></td>
    <td>Calculates a possible topological sorting of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#transitivity_avglocal_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_avglocal_undirected">transitivity<wbr></wbr>_avglocal<wbr></wbr>_undirected</a></code></td>
    <td>Calculates the average of the vertex transitivities of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#transitivity_local_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_local_undirected">transitivity<wbr></wbr>_local<wbr></wbr>_undirected</a></code></td>
    <td>Calculates the local transitivity (clustering coefficient) of the given vertices in the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#transitivity_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_undirected">transitivity<wbr></wbr>_undirected</a></code></td>
    <td>Calculates the global transitivity (clustering coefficient) of the graph.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Tree" class="internal-link" title="igraph._igraph.GraphBase.Tree"><wbr></wbr>Tree</a></code></td>
    <td>Generates a tree in which almost all vertices have the same number of children.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Tree_Game" class="internal-link" title="igraph._igraph.GraphBase.Tree_Game"><wbr></wbr>Tree_<wbr></wbr>Game</a></code></td>
    <td>Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#triad_census" class="internal-link" title="igraph._igraph.GraphBase.triad_census">triad<wbr></wbr>_census</a></code></td>
    <td>Triad census, as defined by Davis and Leinhardt</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#unfold_tree" class="internal-link" title="igraph._igraph.GraphBase.unfold_tree">unfold<wbr></wbr>_tree</a></code></td>
    <td>Unfolds the graph using a BFS to a tree by duplicating vertices as necessary.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#vcount" class="internal-link" title="igraph._igraph.GraphBase.vcount">vcount</a></code></td>
    <td>Counts the number of vertices.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#vertex_attributes" class="internal-link" title="igraph._igraph.GraphBase.vertex_attributes">vertex<wbr></wbr>_attributes</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#vertex_connectivity" class="internal-link" title="igraph._igraph.GraphBase.vertex_connectivity">vertex<wbr></wbr>_connectivity</a></code></td>
    <td>Calculates the vertex connectivity of the graph or between some vertices.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Watts_Strogatz" class="internal-link" title="igraph._igraph.GraphBase.Watts_Strogatz"><wbr></wbr>Watts_<wbr></wbr>Strogatz</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#Weighted_Adjacency" class="internal-link" title="igraph._igraph.GraphBase.Weighted_Adjacency"><wbr></wbr>Weighted_<wbr></wbr>Adjacency</a></code></td>
    <td>Generates a graph from its adjacency matrix.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_dimacs" class="internal-link" title="igraph._igraph.GraphBase.write_dimacs">write<wbr></wbr>_dimacs</a></code></td>
    <td>Writes the graph in DIMACS format to the given file.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_dot" class="internal-link" title="igraph._igraph.GraphBase.write_dot">write<wbr></wbr>_dot</a></code></td>
    <td>Writes the graph in DOT format to the given file.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_edgelist" class="internal-link" title="igraph._igraph.GraphBase.write_edgelist">write<wbr></wbr>_edgelist</a></code></td>
    <td>Writes the edge list of a graph to a file.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_gml" class="internal-link" title="igraph._igraph.GraphBase.write_gml">write<wbr></wbr>_gml</a></code></td>
    <td>Writes the graph in GML format to the given file.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_graphml" class="internal-link" title="igraph._igraph.GraphBase.write_graphml">write<wbr></wbr>_graphml</a></code></td>
    <td>Writes the graph to a GraphML file.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_leda" class="internal-link" title="igraph._igraph.GraphBase.write_leda">write<wbr></wbr>_leda</a></code></td>
    <td>Writes the graph to a file in LEDA native format.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_lgl" class="internal-link" title="igraph._igraph.GraphBase.write_lgl">write<wbr></wbr>_lgl</a></code></td>
    <td>Writes the edge list of a graph to a file in .lgl format.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_ncol" class="internal-link" title="igraph._igraph.GraphBase.write_ncol">write<wbr></wbr>_ncol</a></code></td>
    <td>Writes the edge list of a graph to a file in .ncol format.</td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#write_pajek" class="internal-link" title="igraph._igraph.GraphBase.write_pajek">write<wbr></wbr>_pajek</a></code></td>
    <td>Writes the graph in Pajek format to the given file.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#__graph_as_capsule" class="internal-link" title="igraph._igraph.GraphBase.__graph_as_capsule">__graph<wbr></wbr>_as<wbr></wbr>_capsule</a></code></td>
    <td>__graph_as_capsule()</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#__register_destructor" class="internal-link" title="igraph._igraph.GraphBase.__register_destructor">__register<wbr></wbr>_destructor</a></code></td>
    <td>Registers a destructor to be called when the object is freed by Python. This function should not be used directly by igraph users.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_Bipartite" class="internal-link" title="igraph._igraph.GraphBase._Bipartite">_<wbr></wbr>Bipartite</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_Full_Bipartite" class="internal-link" title="igraph._igraph.GraphBase._Full_Bipartite">_<wbr></wbr>Full_<wbr></wbr>Bipartite</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_get_all_simple_paths" class="internal-link" title="igraph._igraph.GraphBase._get_all_simple_paths">_get<wbr></wbr>_all<wbr></wbr>_simple<wbr></wbr>_paths</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_GRG" class="internal-link" title="igraph._igraph.GraphBase._GRG">_GRG</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_Incidence" class="internal-link" title="igraph._igraph.GraphBase._Incidence">_<wbr></wbr>Incidence</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_is_matching" class="internal-link" title="igraph._igraph.GraphBase._is_matching">_is<wbr></wbr>_matching</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_is_maximal_matching" class="internal-link" title="igraph._igraph.GraphBase._is_maximal_matching">_is<wbr></wbr>_maximal<wbr></wbr>_matching</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_layout_sugiyama" class="internal-link" title="igraph._igraph.GraphBase._layout_sugiyama">_layout<wbr></wbr>_sugiyama</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_maximum_bipartite_matching" class="internal-link" title="igraph._igraph.GraphBase._maximum_bipartite_matching">_maximum<wbr></wbr>_bipartite<wbr></wbr>_matching</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_Random_Bipartite" class="internal-link" title="igraph._igraph.GraphBase._Random_Bipartite">_<wbr></wbr>Random_<wbr></wbr>Bipartite</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_raw_pointer" class="internal-link" title="igraph._igraph.GraphBase._raw_pointer">_raw<wbr></wbr>_pointer</a></code></td>
    <td>Returns the memory address of the igraph graph encapsulated by the Python object as an ordinary Python integer.</td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_spanning_tree" class="internal-link" title="igraph._igraph.GraphBase._spanning_tree">_spanning<wbr></wbr>_tree</a></code></td>
    <td>Internal function, undocumented.</td>
  </tr>
</table>
          

            
        </div>

        <div id="childList">
          <div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.__new__">
    
  </a>
  <a name="__new__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__new__</span>(*args, **kwargs):
    
    <a class="headerLink" href="#__new__" title="igraph._igraph.GraphBase.__new__">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Create and return a new object.  See help(type) for accurate signature.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.add_edges">
    
  </a>
  <a name="add_edges">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">add_edges</span>(es):
    
    <a class="headerLink" href="#add_edges" title="igraph._igraph.GraphBase.add_edges">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Adds edges to the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">es</span></td><td class="fieldArgDesc">the list of edges to be added. Every edge is represented with a tuple, containing the vertex IDs of the two endpoints. Vertices are enumerated from zero.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.add_vertices">
    
  </a>
  <a name="add_vertices">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">add_vertices</span>(n):
    
    <a class="headerLink" href="#add_vertices" title="igraph._igraph.GraphBase.add_vertices">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Adds vertices to the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices to be added</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Adjacency">
    
  </a>
  <a name="Adjacency">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Adjacency</span>(matrix, mode='directed'):
    
    <a class="headerLink" href="#Adjacency" title="igraph._igraph.GraphBase.Adjacency">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Generates a graph from its adjacency matrix.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">matrix</span></td><td class="fieldArgDesc">the adjacency matrix</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc"><p>the mode to be used. Possible values are:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"directed"</tt> - the graph will be directed and a matrix element gives the number of edges between two vertices.</li>
<li><tt class="rst-docutils literal">"undirected"</tt> - alias to <tt class="rst-docutils literal">"max"</tt> for convenience.</li>
<li><tt class="rst-docutils literal">"max"</tt>   - undirected graph will be created and the number of edges between vertex <span class="rst-math rst-formula"><i>i</i></span> and <span class="rst-math rst-formula"><i>j</i></span> is <span class="rst-math rst-formula"><i>max</i>(<i>A</i>(<i>i</i>, <i>j</i>), <i>A</i>(<i>j</i>, <i>i</i>))</span></li>
<li><tt class="rst-docutils literal">"min"</tt>   - like <tt class="rst-docutils literal">"max"</tt>, but with <span class="rst-math rst-formula"><i>min</i>(<i>A</i>(<i>i</i>, <i>j</i>), <i>A</i>(<i>j</i>, <i>i</i>))</span></li>
<li><tt class="rst-docutils literal">"plus"</tt>  - like <tt class="rst-docutils literal">"max"</tt>, but with <span class="rst-math rst-formula"><i>A</i>(<i>i</i>, <i>j</i>) + <i>A</i>(<i>j</i>, <i>i</i>)</span></li>
<li><tt class="rst-docutils literal">"upper"</tt> - undirected graph with the upper right triangle of the matrix (including the diagonal)</li>
<li><tt class="rst-docutils literal">"lower"</tt> - undirected graph with the lower left triangle of the matrix (including the diagonal)</li>
</ul>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.all_minimal_st_separators">
    
  </a>
  <a name="all_minimal_st_separators">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">all_minimal_st_separators</span>():
    
    <a class="headerLink" href="#all_minimal_st_separators" title="igraph._igraph.GraphBase.all_minimal_st_separators">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns a list containing all the minimal s-t separators of a graph.</p>
<p>A minimal separator is a set of vertices whose removal disconnects the graph, while the removal of any subset of the set keeps the graph connected.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list where each item lists the vertex indices of a given minimal s-t separator.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Anne Berry, Jean-Paul Bordat and Olivier Cogis: Generating all the minimal separators of a graph. In: Peter Widmayer, Gabriele Neyer and Stephan Eidenbenz (eds.): Graph-theoretic concepts in computer science, 1665, 167--172, 1999. Springer.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.all_st_cuts">
    
  </a>
  <a name="all_st_cuts">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">all_st_cuts</span>(source, target):
    
    <a class="headerLink" href="#all_st_cuts" title="igraph._igraph.GraphBase.all_st_cuts">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Returns all the cuts between the source and target vertices in a directed graph.</p>
<p>This function lists all edge-cuts between a source and a target vertex. Every cut is listed exactly once.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex ID</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a tuple where the first element is a list of lists of edge IDs representing a cut and the second element is a list of lists of vertex IDs representing the sets of vertices that were separated by the cuts.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> which wraps the result in a list of <code><a href="igraph.cut.Cut.html" class="internal-link" title="igraph.cut.Cut">Cut</a></code> objects. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.all_st_mincuts">
    
  </a>
  <a name="all_st_mincuts">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">all_st_mincuts</span>(source, target):
    
    <a class="headerLink" href="#all_st_mincuts" title="igraph._igraph.GraphBase.all_st_mincuts">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Returns all minimum cuts between the source and target vertices in a directed graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex ID</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> which wraps the result in a list of <code><a href="igraph.cut.Cut.html" class="internal-link" title="igraph.cut.Cut">Cut</a></code> objects. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.are_connected">
    
  </a>
  <a name="are_connected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">are_connected</span>(v1, v2):
    
    <a class="headerLink" href="#are_connected" title="igraph._igraph.GraphBase.are_connected">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Decides whether two given vertices are directly connected.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">v1</span></td><td class="fieldArgDesc">the ID or name of the first vertex</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">v2</span></td><td class="fieldArgDesc">the ID or name of the second vertex</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><tt class="rst-docutils literal">True</tt> if there exists an edge from v1 to v2, <tt class="rst-docutils literal">False</tt> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.articulation_points">
    
  </a>
  <a name="articulation_points">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">articulation_points</span>():
    
    <a class="headerLink" href="#articulation_points" title="igraph._igraph.GraphBase.articulation_points">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the list of articulation points in the graph.</p>
<p>A vertex is an articulation point if its removal increases the number of connected components in the graph.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.assortativity">
    
  </a>
  <a name="assortativity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">assortativity</span>(types1, types2=None, directed=True):
    
    <a class="headerLink" href="#assortativity" title="igraph._igraph.GraphBase.assortativity">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the assortativity of the graph based on numeric properties of the vertices.</p>
<p>This coefficient is basically the correlation between the actual connectivity patterns of the vertices and the pattern expected from the disribution of the vertex types.</p>
<p>See equation (21) in Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126 (2003) for the proper definition. The actual calculation is performed using equation (26) in the same paper for directed graphs, and equation (4) in Newman MEJ: Assortative mixing in networks, Phys Rev Lett 89:208701 (2002) for undirected graphs.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">types1</span></td><td class="fieldArgDesc">vertex types in a list or the name of a vertex attribute holding vertex types. Types are ideally denoted by numeric values.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">types2</span></td><td class="fieldArgDesc">in directed assortativity calculations, each vertex can have an out-type and an in-type. In this case, <em>types1</em> contains the out-types and this parameter contains the in-types in a list or the name of a vertex attribute. If <tt class="rst-docutils literal">None</tt>, it is assumed to be equal to <em>types1</em>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider edge directions or not.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the assortativity coefficient</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#assortativity_degree" class="internal-link" title="igraph._igraph.GraphBase.assortativity_degree">assortativity_degree()</a></code> when the types are the vertex degrees</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126, 2003.</td></tr><tr><td colspan="2"><p>Newman MEJ: Assortative mixing in networks, Phys Rev Lett 89:208701,</p>
<ol class="rst-simple">
<li></li>
</ol>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.assortativity_degree">
    
  </a>
  <a name="assortativity_degree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">assortativity_degree</span>(directed=True):
    
    <a class="headerLink" href="#assortativity_degree" title="igraph._igraph.GraphBase.assortativity_degree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the assortativity of a graph based on vertex degrees.</p>
<p>See <code><a href="#assortativity" class="internal-link" title="igraph._igraph.GraphBase.assortativity">assortativity()</a></code> for the details. <code><a href="#assortativity_degree" class="internal-link" title="igraph._igraph.GraphBase.assortativity_degree">assortativity_degree()</a></code> simply calls <code><a href="#assortativity" class="internal-link" title="igraph._igraph.GraphBase.assortativity">assortativity()</a></code> with the vertex degrees as types.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider edge directions for directed graphs or not. This argument is ignored for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the assortativity coefficient</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#assortativity" class="internal-link" title="igraph._igraph.GraphBase.assortativity">assortativity()</a></code></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.assortativity_nominal">
    
  </a>
  <a name="assortativity_nominal">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">assortativity_nominal</span>(types, directed=True):
    
    <a class="headerLink" href="#assortativity_nominal" title="igraph._igraph.GraphBase.assortativity_nominal">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the assortativity of the graph based on vertex categories.</p>
<p>Assuming that the vertices belong to different categories, this function calculates the assortativity coefficient, which specifies the extent to which the connections stay within categories. The assortativity coefficient is one if all the connections stay within categories and minus one if all the connections join vertices of different categories. For a randomly connected network, it is asymptotically zero.</p>
<p>See equation (2) in Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126 (2003) for the proper definition.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">types</span></td><td class="fieldArgDesc">vertex types in a list or the name of a vertex attribute holding vertex types. Types should be denoted by numeric values.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider edge directions or not.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the assortativity coefficient</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Newman MEJ: Mixing patterns in networks, Phys Rev E 67:026126, 2003.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Asymmetric_Preference">
    
  </a>
  <a name="Asymmetric_Preference">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Asymmetric_Preference</span>(n, type_dist_matrix, pref_matrix, attribute=None, loops=False):
    
    <a class="headerLink" href="#Asymmetric_Preference" title="igraph._igraph.GraphBase.Asymmetric_Preference">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph based on asymmetric vertex types and connection probabilities.</p>
<p>This is the asymmetric variant of <code><a href="#Preference" class="internal-link" title="igraph._igraph.GraphBase.Preference">Preference()</a></code>. A given number of vertices are generated. Every vertex is assigned to an "incoming" and an "outgoing" vertex type according to the given joint type probabilities. Finally, every vertex pair is evaluated and a directed edge is created between them with a probability depending on the "outgoing" type of the source vertex and the "incoming" type of the target vertex.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">type<wbr></wbr>_dist<wbr></wbr>_matrix</span></td><td class="fieldArgDesc">matrix giving the joint distribution of vertex types</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">pref<wbr></wbr>_matrix</span></td><td class="fieldArgDesc">matrix giving the connection probabilities for different vertex types.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">attribute</span></td><td class="fieldArgDesc">the vertex attribute name used to store the vertex types. If <tt class="rst-docutils literal">None</tt>, vertex types are not stored.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether loop edges are allowed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Atlas">
    
  </a>
  <a name="Atlas">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Atlas</span>(idx):
    
    <a class="headerLink" href="#Atlas" title="igraph._igraph.GraphBase.Atlas">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph from the Graph Atlas.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">idx</span></td><td class="fieldArgDesc"><p>The index of the graph to be generated. Indices start from zero, graphs are listed:</p>
<ol class="rst-simple">
<li>in increasing order of number of vertices;</li>
<li>for a fixed number of vertices, in increasing order of the number of edges;</li>
<li>for fixed numbers of vertices and edges, in increasing order of the degree sequence, for example 111223 &lt; 112222;</li>
<li>for fixed degree sequence, in increasing number of automorphisms.</li>
</ol>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2"><em>An Atlas of Graphs</em> by Ronald C. Read and Robin J. Wilson, Oxford University Press, 1998.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.attributes">
    
  </a>
  <a name="attributes">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">attributes</span>():
    
    <a class="headerLink" href="#attributes" title="igraph._igraph.GraphBase.attributes">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the attribute name list of the graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.authority_score">
    
  </a>
  <a name="authority_score">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">authority_score</span>(weights=None, scale=True, arpack_options=None, return_eigenvalue=False):
    
    <a class="headerLink" href="#authority_score" title="igraph._igraph.GraphBase.authority_score">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates Kleinberg's authority score for the vertices of the graph</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">scale</span></td><td class="fieldArgDesc">whether to normalize the scores so that the largest one is 1.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">arpack<wbr></wbr>_options</span></td><td class="fieldArgDesc">an <code><a href="igraph._igraph.ARPACKOptions.html" class="internal-link" title="igraph._igraph.ARPACKOptions">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <tt class="rst-docutils literal">arpack_options</tt> is used.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_eigenvalue</span></td><td class="fieldArgDesc">whether to return the largest eigenvalue</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the authority scores in a list and optionally the largest eigenvalue as a second member of a tuple</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">hub_score()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.average_path_length">
    
  </a>
  <a name="average_path_length">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">average_path_length</span>(directed=True, unconn=True):
    
    <a class="headerLink" href="#average_path_length" title="igraph._igraph.GraphBase.average_path_length">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the average path length in a graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider directed paths in case of a directed graph. Ignored for undirected graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">unconn</span></td><td class="fieldArgDesc">what to do when the graph is unconnected. If <tt class="rst-docutils literal">True</tt>, the average of the geodesic lengths in the components is calculated. Otherwise for all unconnected vertex pairs, a path length equal to the number of vertices is used.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the average path length in the graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Barabasi">
    
  </a>
  <a name="Barabasi">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Barabasi</span>(n, m, outpref=False, directed=False, power=1, zero_appeal=1, implementation='psumtree', start_from=None):
    
    <a class="headerLink" href="#Barabasi" title="igraph._igraph.GraphBase.Barabasi">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph based on the Barabasi-Albert model.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">m</span></td><td class="fieldArgDesc">either the number of outgoing edges generated for each vertex or a list containing the number of outgoing edges for each vertex explicitly.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">outpref</span></td><td class="fieldArgDesc"><tt class="rst-docutils literal">True</tt> if the out-degree of a given vertex should also increase its citation probability (as well as its in-degree), but it defaults to <tt class="rst-docutils literal">False</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc"><tt class="rst-docutils literal">True</tt> if the generated graph should be directed (default: <tt class="rst-docutils literal">False</tt>).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">power</span></td><td class="fieldArgDesc">the power constant of the nonlinear model. It can be omitted, and in this case the usual linear model will be used.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">zero<wbr></wbr>_appeal</span></td><td class="fieldArgDesc">the attractivity of vertices with degree zero.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">implementation</span></td><td class="fieldArgDesc"><p>the algorithm to use to generate the network. Possible values are:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"bag"</tt>: the algorithm that was the default in igraph before 0.6. It works by putting the ids of the vertices into a bag (multiset) exactly as many times as their in-degree, plus once more. The required number of cited vertices are then drawn from the bag with replacement. It works only for <em>power</em>=1 and <em>zero_appeal</em>=1.</li>
<li><tt class="rst-docutils literal">"psumtree"</tt>: this algorithm uses a partial prefix-sum tree to generate the graph. It does not generate multiple edges and it works for any values of <em>power</em> and <em>zero_appeal</em>.</li>
<li><tt class="rst-docutils literal">"psumtree_multiple"</tt>: similar to <tt class="rst-docutils literal">"psumtree"</tt>, but it will generate multiple edges as well. igraph before 0.6 used this algorithm for <em>power</em>s other than 1.</li>
</ul>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">start<wbr></wbr>_from</span></td><td class="fieldArgDesc">if given and not <tt class="rst-docutils literal">None</tt>, this must be another <code><a href="igraph._igraph.GraphBase.html" class="internal-link" title="igraph._igraph.GraphBase">GraphBase</a></code> object. igraph will use this graph as a starting point for the preferential attachment model.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Barabasi, A-L and Albert, R. 1999. Emergence of scaling in random networks. Science, 286 509-512.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.betweenness">
    
  </a>
  <a name="betweenness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">betweenness</span>(vertices=None, directed=True, cutoff=None, weights=None):
    
    <a class="headerLink" href="#betweenness" title="igraph._igraph.GraphBase.betweenness">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates or estimates the betweenness of vertices in a graph.</p>
<p>Keyword arguments:</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the vertices for which the betweennesses must be returned. If <tt class="rst-docutils literal">None</tt>, assumes all of the vertices in the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider directed paths.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cutoff</span></td><td class="fieldArgDesc">if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the betweenness for the given vertices. If <tt class="rst-docutils literal">None</tt>, the exact betweenness is returned.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the (possibly estimated) betweenness of the given vertices in a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.bfs">
    
  </a>
  <a name="bfs">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bfs</span>(vid, mode='out'):
    
    <a class="headerLink" href="#bfs" title="igraph._igraph.GraphBase.bfs">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Conducts a breadth first search (BFS) on the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vid</span></td><td class="fieldArgDesc">the root vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">either <tt class="rst-docutils literal">"in"</tt> or <tt class="rst-docutils literal">"out"</tt> or <tt class="rst-docutils literal">"all"</tt>, ignored for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><p>a tuple with the following items:</p>
<ul class="rst-simple">
<li>The vertex IDs visited (in order)</li>
<li>The start indices of the layers in the vertex list</li>
<li>The parent of every vertex in the BFS</li>
</ul>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.bfsiter">
    
  </a>
  <a name="bfsiter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bfsiter</span>(vid, mode='out', advanced=False):
    
    <a class="headerLink" href="#bfsiter" title="igraph._igraph.GraphBase.bfsiter">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Constructs a breadth first search (BFS) iterator of the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vid</span></td><td class="fieldArgDesc">the root vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">either <tt class="rst-docutils literal">"in"</tt> or <tt class="rst-docutils literal">"out"</tt> or <tt class="rst-docutils literal">"all"</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">advanced</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">False</tt>, the iterator returns the next vertex in BFS order in every step. If <tt class="rst-docutils literal">True</tt>, the iterator returns the distance of the vertex from the root and the parent of the vertex in the BFS tree as well.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the BFS iterator as an <code><a href="igraph._igraph.BFSIter.html" class="internal-link" title="igraph._igraph.BFSIter">igraph.BFSIter</a></code> object.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.bibcoupling">
    
  </a>
  <a name="bibcoupling">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bibcoupling</span>(vertices=None):
    
    <a class="headerLink" href="#bibcoupling" title="igraph._igraph.GraphBase.bibcoupling">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates bibliographic coupling scores for given vertices in a graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the vertices to be analysed. If <tt class="rst-docutils literal">None</tt>, all vertices will be considered.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">bibliographic coupling scores for all given vertices in a matrix.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.biconnected_components">
    
  </a>
  <a name="biconnected_components">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">biconnected_components</span>(return_articulation_points=True):
    
    <a class="headerLink" href="#biconnected_components" title="igraph._igraph.GraphBase.biconnected_components">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Calculates the biconnected components of the graph.</p>
<p>Components containing a single vertex only are not considered as being biconnected.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_articulation<wbr></wbr>_points</span></td><td class="fieldArgDesc">whether to return the articulation points as well</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of lists containing edge indices making up spanning trees of the biconnected components (one spanning tree for each component) and optionally the list of articulation points</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.bipartite_projection">
    
  </a>
  <a name="bipartite_projection">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bipartite_projection</span>(types, multiplicity=True, probe1=-1, which=-1):
    
    <a class="headerLink" href="#bipartite_projection" title="igraph._igraph.GraphBase.bipartite_projection">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.bipartite_projection()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.bipartite_projection_size">
    
  </a>
  <a name="bipartite_projection_size">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bipartite_projection_size</span>(types):
    
    <a class="headerLink" href="#bipartite_projection_size" title="igraph._igraph.GraphBase.bipartite_projection_size">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.bipartite_projection_size()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.bridges">
    
  </a>
  <a name="bridges">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">bridges</span>():
    
    <a class="headerLink" href="#bridges" title="igraph._igraph.GraphBase.bridges">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the list of bridges in the graph.</p>
<p>An edge is a bridge if its removal increases the number of (weakly) connected components in the graph.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.canonical_permutation">
    
  </a>
  <a name="canonical_permutation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">canonical_permutation</span>(sh='fl', color=None):
    
    <a class="headerLink" href="#canonical_permutation" title="igraph._igraph.GraphBase.canonical_permutation">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the canonical permutation of a graph using the BLISS isomorphism algorithm.</p>
<p>Passing the permutation returned here to <code><a href="#permute_vertices" class="internal-link" title="igraph._igraph.GraphBase.permute_vertices">permute_vertices()</a></code> will transform the graph into its canonical form.</p>
<p>See <a class="rst-reference external" href="http://www.tcs.hut.fi/Software/bliss/index.html" target="_top">http://www.tcs.hut.fi/Software/bliss/index.html</a> for more information about the BLISS algorithm and canonical permutations.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">sh</span></td><td class="fieldArgDesc"><p>splitting heuristics for graph as a case-insensitive string, with the following possible values:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"f"</tt>: first non-singleton cell</li>
<li><tt class="rst-docutils literal">"fl"</tt>: first largest non-singleton cell</li>
<li><tt class="rst-docutils literal">"fs"</tt>: first smallest non-singleton cell</li>
<li><tt class="rst-docutils literal">"fm"</tt>: first maximally non-trivially connected non-singleton cell</li>
<li><tt class="rst-docutils literal">"flm"</tt>: largest maximally non-trivially connected non-singleton cell</li>
<li><tt class="rst-docutils literal">"fsm"</tt>: smallest maximally non-trivially connected non-singleton cell</li>
</ul>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color</span></td><td class="fieldArgDesc">optional vector storing a coloring of the vertices with respect to which the isomorphism is computed.If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a permutation vector containing vertex IDs. Vertex 0 in the original graph will be mapped to an ID contained in the first element of this vector; vertex 1 will be mapped to the second and so on.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.chordal_completion">
    
  </a>
  <a name="chordal_completion">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">chordal_completion</span>(...):
    
    <a class="headerLink" href="#chordal_completion" title="igraph._igraph.GraphBase.chordal_completion">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>chordal_complation(alpha=None, alpham1=None) --</p>
<p>Returns the list of edges needed to be added to the graph to make it chordal.</p>
<p>A graph is chordal if each of its cycles of four or more nodes has a chord, i.e. an edge joining two nodes that are not adjacent in the cycle. An equivalent definition is that any chordless cycles have at most three nodes.</p>
<p>The chordal completion of a graph is the list of edges that needed to be added to the graph to make it chordal. It is an empty list if the graph is already chordal.</p>
<p>Note that at the moment igraph does not guarantee that the returned chordal completion is <em>minimal</em>; there may exist a subset of the returned chordal completion that is still a valid chordal completion.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">alpha</span></td><td class="fieldArgDesc">the alpha vector from the result of calling <code><a href="#maximum_cardinality_search" class="internal-link" title="igraph._igraph.GraphBase.maximum_cardinality_search">maximum_cardinality_search()</a></code> on the graph. Useful only if you already have the alpha vector; simply passing <tt class="rst-docutils literal">None</tt> here will make igraph calculate the alpha vector on its own.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">alpham1</span></td><td class="fieldArgDesc">the inverse alpha vector from the result of calling <code><a href="#maximum_cardinality_search" class="internal-link" title="igraph._igraph.GraphBase.maximum_cardinality_search">maximum_cardinality_search()</a></code> on the graph. Useful only if you already have the inverse alpha vector; simply passing <tt class="rst-docutils literal">None</tt> here will make igraph calculate the inverse alpha vector on its own.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the list of edges to add to the graph; each item in the list is a source-target pair of vertex indices.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.clique_number">
    
  </a>
  <a name="clique_number">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">clique_number</span>():
    
    <a class="headerLink" href="#clique_number" title="igraph._igraph.GraphBase.clique_number">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the clique number of the graph.</p>
<p>The clique number of the graph is the size of the largest clique.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#largest_cliques" class="internal-link" title="igraph._igraph.GraphBase.largest_cliques">largest_cliques()</a></code> for the largest cliques.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.cliques">
    
  </a>
  <a name="cliques">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">cliques</span>(min=0, max=0):
    
    <a class="headerLink" href="#cliques" title="igraph._igraph.GraphBase.cliques">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns some or all cliques of the graph as a list of tuples.</p>
<p>A clique is a complete subgraph -- a set of vertices where an edge is present between any two of them (excluding loops)</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">min</span></td><td class="fieldArgDesc">the minimum size of cliques to be returned. If zero or negative, no lower bound will be used.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">max</span></td><td class="fieldArgDesc">the maximum size of cliques to be returned. If zero or negative, no upper bound will be used.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.closeness">
    
  </a>
  <a name="closeness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">closeness</span>(vertices=None, mode='all', cutoff=None, weights=None, normalized=True):
    
    <a class="headerLink" href="#closeness" title="igraph._igraph.GraphBase.closeness">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the closeness centralities of given vertices in a graph.</p>
<p>The closeness centerality of a vertex measures how easily other vertices can be reached from it (or the other way: how easily it can be reached from the other vertices). It is defined as the number of vertices minus one divided by the sum of the lengths of all geodesics from/to the given vertex.</p>
<p>If the graph is not connected, and there is no path between two vertices, the number of vertices is used instead the length of the geodesic. This is always longer than the longest possible geodesic.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the vertices for which the closenesses must be returned. If <tt class="rst-docutils literal">None</tt>, uses all of the vertices in the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">must be one of <tt class="rst-docutils literal">"in"</tt>, <tt class="rst-docutils literal">"out"</tt> and <tt class="rst-docutils literal">"all"</tt>. <tt class="rst-docutils literal">"in"</tt> means that the length of the incoming paths, <tt class="rst-docutils literal">"out"</tt> means that the length of the outgoing paths must be calculated. <tt class="rst-docutils literal">"all"</tt> means that both of them must be calculated.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cutoff</span></td><td class="fieldArgDesc">if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the closeness for the given vertices (which is always an underestimation of the real closeness, since some vertex pairs will appear as disconnected even though they are connected).. If <tt class="rst-docutils literal">None</tt>, the exact closeness is returned.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">normalized</span></td><td class="fieldArgDesc">Whether to normalize the raw closeness scores by multiplying by the number of vertices minus one.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated closenesses in a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.clusters">
    
  </a>
  <a name="clusters">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">clusters</span>(mode='strong'):
    
    <a class="headerLink" href="#clusters" title="igraph._igraph.GraphBase.clusters">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Calculates the (strong or weak) clusters for a given graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">must be either <tt class="rst-docutils literal">"strong"</tt> or <tt class="rst-docutils literal">"weak"</tt>, depending on the clusters being sought. Optional, defaults to <tt class="rst-docutils literal">"strong"</tt>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the component index for every node in the graph.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> which wraps the result in a <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> object. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.cocitation">
    
  </a>
  <a name="cocitation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">cocitation</span>(vertices=None):
    
    <a class="headerLink" href="#cocitation" title="igraph._igraph.GraphBase.cocitation">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates cocitation scores for given vertices in a graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the vertices to be analysed. If <tt class="rst-docutils literal">None</tt>, all vertices will be considered.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">cocitation scores for all given vertices in a matrix.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.cohesive_blocks">
    
  </a>
  <a name="cohesive_blocks">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">cohesive_blocks</span>():
    
    <a class="headerLink" href="#cohesive_blocks" title="igraph._igraph.GraphBase.cohesive_blocks">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Calculates the cohesive block structure of the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> which wraps the result in a <code><a href="igraph.clustering.CohesiveBlocks.html" class="internal-link" title="igraph.clustering.CohesiveBlocks">CohesiveBlocks</a></code> object. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.community_edge_betweenness">
    
  </a>
  <a name="community_edge_betweenness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_edge_betweenness</span>(directed=True, weights=None):
    
    <a class="headerLink" href="#community_edge_betweenness" title="igraph._igraph.GraphBase.community_edge_betweenness">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Community structure detection based on the betweenness of the edges in the network. This algorithm was invented by M Girvan and MEJ Newman, see: M Girvan and MEJ Newman: Community structure in social and biological networks, Proc. Nat. Acad. Sci. USA 99, 7821-7826 (2002).</p>
<p>The idea is that the betweenness of the edges connecting two communities is typically high. So we gradually remove the edge with the highest betweenness from the network and recalculate edge betweenness after every removal, as long as all edges are removed.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to take into account the directedness of the edges when we calculate the betweenness values.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a tuple with the merge matrix that describes the dendrogram and the modularity scores before each merge. The modularity scores use the weights if the original graph was weighted.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code>. It is advised to use that instead of this version.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.community_fastgreedy">
    
  </a>
  <a name="community_fastgreedy">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_fastgreedy</span>(weights=None):
    
    <a class="headerLink" href="#community_fastgreedy" title="igraph._igraph.GraphBase.community_fastgreedy">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Finds the community structure of the graph according to the algorithm of Clauset et al based on the greedy optimization of modularity.</p>
<p>This is a bottom-up algorithm: initially every vertex belongs to a separate community, and communities are merged one by one. In every step, the two communities being merged are the ones which result in the maximal increase in modularity.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><p>a tuple with the following elements:</p>
<ol class="rst-simple">
<li>The list of merges</li>
<li>The modularity scores before each merge</li>
</ol>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">modularity()</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code>. It is advised to use that instead of this version.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">A. Clauset, M. E. J. Newman and C. Moore: <em>Finding community structure in very large networks.</em> Phys Rev E 70, 066111 (2004).</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.community_infomap">
    
  </a>
  <a name="community_infomap">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_infomap</span>(edge_weights=None, vertex_weights=None, trials=10):
    
    <a class="headerLink" href="#community_infomap" title="igraph._igraph.GraphBase.community_infomap">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Finds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.</p>
<p>See <a class="rst-reference external" href="http://www.mapequation.org" target="_top">http://www.mapequation.org</a> for a visualization of the algorithm or one of the references provided below.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_weights</span></td><td class="fieldArgDesc">name of an vertex attribute or a list containing vertex weights.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">trials</span></td><td class="fieldArgDesc">the number of attempts to partition the network.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated membership vector and the corresponding codelength in a tuple.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">M. Rosvall and C. T. Bergstrom: <em>Maps of information flow reveal community structure in complex networks</em>. PNAS 105, 1118 (2008). <a class="rst-reference external" href="http://arxiv.org/abs/0707.0609" target="_top">http://arxiv.org/abs/0707.0609</a></td></tr><tr><td colspan="2">M. Rosvall, D. Axelsson and C. T. Bergstrom: <em>The map equation</em>. Eur Phys J Special Topics 178, 13 (2009). <a class="rst-reference external" href="http://arxiv.org/abs/0906.1405" target="_top">http://arxiv.org/abs/0906.1405</a></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.community_label_propagation">
    
  </a>
  <a name="community_label_propagation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_label_propagation</span>(weights=None, initial=None, fixed=None):
    
    <a class="headerLink" href="#community_label_propagation" title="igraph._igraph.GraphBase.community_label_propagation">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Finds the community structure of the graph according to the label propagation method of Raghavan et al.</p>
<p>Initially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus.</p>
<p>Note that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al on how to come up with an aggregated community structure.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">initial</span></td><td class="fieldArgDesc">name of a vertex attribute or a list containing the initial vertex labels. Labels are identified by integers from zero to <span class="rst-math rst-formula"><i>n</i> − 1</span> where <span class="rst-math rst-formula"><i>n</i></span> is the number of vertices. Negative numbers may also be present in this vector, they represent unlabeled vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fixed</span></td><td class="fieldArgDesc">a list of booleans for each vertex. <tt class="rst-docutils literal">True</tt> corresponds to vertices whose labeling should not change during the algorithm. It only makes sense if initial labels are also given. Unlabeled vertices cannot be fixed. Note that vertex attribute names are not accepted here.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the resulting membership vector</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. <a class="rst-reference external" href="http://arxiv.org/abs/0709.2938" target="_top">http://arxiv.org/abs/0709.2938</a>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.community_leading_eigenvector">
    
  </a>
  <a name="community_leading_eigenvector">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_leading_eigenvector</span>(n=-1, arpack_options=None, weights=None):
    
    <a class="headerLink" href="#community_leading_eigenvector" title="igraph._igraph.GraphBase.community_leading_eigenvector">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>A proper implementation of Newman's eigenvector community structure detection. Each split is done by maximizing the modularity regarding the original network. See the reference for details.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the desired number of communities. If negative, the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">arpack<wbr></wbr>_options</span></td><td class="fieldArgDesc">an <code><a href="igraph._igraph.ARPACKOptions.html" class="internal-link" title="igraph._igraph.ARPACKOptions">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <tt class="rst-docutils literal">arpack_options</tt> is used.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a tuple where the first element is the membership vector of the clustering and the second element is the merge matrix.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code>. It is advised to use that instead of this version.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.community_leiden">
    
  </a>
  <a name="community_leiden">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_leiden</span>(edge_weights=None, node_weights=None, resolution_parameter=1.0, normalize_resolution=False, beta=0.01, initial_membership=None, n_iterations=2):
    
    <a class="headerLink" href="#community_leiden" title="igraph._igraph.GraphBase.community_leiden">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Finds the community structure of the graph using the Leiden algorithm of Traag, van Eck &amp; Waltman.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">node<wbr></wbr>_weights</span></td><td class="fieldArgDesc">the node weights used in the Leiden algorithm.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">resolution<wbr></wbr>_parameter</span></td><td class="fieldArgDesc">the resolution parameter to use. Higher resolutions lead to more smaller communities, while lower resolutions lead to fewer larger communities.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">normalize<wbr></wbr>_resolution</span></td><td class="fieldArgDesc">if set to true, the resolution parameter will be divided by the sum of the node weights. If this is not supplied, it will default to the node degree, or weighted degree in case edge_weights are supplied.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">beta</span></td><td class="fieldArgDesc">parameter affecting the randomness in the Leiden algorithm. This affects only the refinement step of the algorithm.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">initial<wbr></wbr>_membership</span></td><td class="fieldArgDesc">if provided, the Leiden algorithm will try to improve this provided membership. If no argument is provided, the aglorithm simply starts from the singleton partition.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n<wbr></wbr>_iterations</span></td><td class="fieldArgDesc">the number of iterations to iterate the Leiden algorithm. Each iteration may improve the partition further.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the community membership vector.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.community_multilevel">
    
  </a>
  <a name="community_multilevel">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_multilevel</span>(weights=None, return_levels=True, resolution=1):
    
    <a class="headerLink" href="#community_multilevel" title="igraph._igraph.GraphBase.community_multilevel">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Finds the community structure of the graph according to the multilevel algorithm of Blondel et al. This is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrank to a single vertex (while keeping the total weight of the incident edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity any more after shrinking the communities to vertices.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_levels</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, returns the multilevel result. If <tt class="rst-docutils literal">False</tt>, only the best level (corresponding to the best modularity) is returned.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">resolution</span></td><td class="fieldArgDesc">the resolution parameter to use in the modularity measure. Smaller values result in a smaller number of larger clusters, while higher values yield a large number of small clusters. The classical modularity measure assumes a resolution parameter of 1.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">either a single list describing the community membership of each vertex (if <tt class="rst-docutils literal">return_levels</tt> is <tt class="rst-docutils literal">False</tt>), or a list of community membership vectors, one corresponding to each level and a list of corresponding modularities (if <tt class="rst-docutils literal">return_levels</tt> is <tt class="rst-docutils literal">True</tt>).</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">modularity()</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code>. It is advised to use that instead of this version.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks. J Stat Mech P10008 (2008), http://arxiv.org/abs/0803.0476</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.community_optimal_modularity">
    
  </a>
  <a name="community_optimal_modularity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_optimal_modularity</span>(weights=None):
    
    <a class="headerLink" href="#community_optimal_modularity" title="igraph._igraph.GraphBase.community_optimal_modularity">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Calculates the optimal modularity score of the graph and the corresponding community structure.</p>
<p>This function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated membership vector and the corresponding modularity in a tuple.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.community_spinglass">
    
  </a>
  <a name="community_spinglass">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_spinglass</span>(weights=None, spins=25, parupdate=False, start_temp=1, stop_temp=0.01, cool_fact=0.99, update_rule='config', gamma=1, implementation='orig', lambda_=1):
    
    <a class="headerLink" href="#community_spinglass" title="igraph._igraph.GraphBase.community_spinglass">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Finds the community structure of the graph according to the spinglass community detection method of Reichardt &amp; Bornholdt.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">spins</span></td><td class="fieldArgDesc">integer, the number of spins to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">parupdate</span></td><td class="fieldArgDesc">whether to update the spins of the vertices in parallel (synchronously) or not</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">start<wbr></wbr>_temp</span></td><td class="fieldArgDesc">the starting temperature</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">stop<wbr></wbr>_temp</span></td><td class="fieldArgDesc">the stop temperature</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cool<wbr></wbr>_fact</span></td><td class="fieldArgDesc">cooling factor for the simulated annealing</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">update<wbr></wbr>_rule</span></td><td class="fieldArgDesc">specifies the null model of the simulation. Possible values are <tt class="rst-docutils literal">"config"</tt> (a random graph with the same vertex degrees as the input graph) or <tt class="rst-docutils literal">"simple"</tt> (a random graph with the same number of edges)</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">gamma</span></td><td class="fieldArgDesc">the gamma argument of the algorithm, specifying the balance between the importance of present and missing edges within a community. The default value of 1.0 assigns equal importance to both of them.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">implementation</span></td><td class="fieldArgDesc">currently igraph contains two implementations for the spinglass community detection algorithm. The faster original implementation is the default. The other implementation is able to take into account negative weights, this can be chosen by setting <tt class="rst-docutils literal">implementation</tt> to <tt class="rst-docutils literal">"neg"</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">lambda_</span></td><td class="fieldArgDesc">the lambda argument of the algorithm, which specifies the balance between the importance of present and missing negatively weighted edges within a community. Smaller values of lambda lead to communities with less negative intra-connectivity. If the argument is zero, the algorithm reduces to a graph coloring algorithm, using the number of spins as colors. This argument is ignored if the original implementation is used.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the community membership vector.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.community_walktrap">
    
  </a>
  <a name="community_walktrap">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">community_walktrap</span>(weights=None, steps=None):
    
    <a class="headerLink" href="#community_walktrap" title="igraph._igraph.GraphBase.community_walktrap">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Finds the community structure of the graph according to the random walk method of Latapy &amp; Pons.</p>
<p>The basic idea of the algorithm is that short random walks tend to stay in the same community. The method provides a dendrogram.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">steps</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a tuple with the list of merges and the modularity scores corresponding to each merge</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">modularity()</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code>. It is advised to use that instead of this version.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, <a class="rst-reference external" href="http://arxiv.org/abs/physics/0512106" target="_top">http://arxiv.org/abs/physics/0512106</a>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.complementer">
    
  </a>
  <a name="complementer">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">complementer</span>(loops=False):
    
    <a class="headerLink" href="#complementer" title="igraph._igraph.GraphBase.complementer">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the complementer of the graph</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether to include loop edges in the complementer.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the complementer of the graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.compose">
    
  </a>
  <a name="compose">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">compose</span>(other):
    
    <a class="headerLink" href="#compose" title="igraph._igraph.GraphBase.compose">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the composition of two graphs.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.constraint">
    
  </a>
  <a name="constraint">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">constraint</span>(vertices=None, weights=None):
    
    <a class="headerLink" href="#constraint" title="igraph._igraph.GraphBase.constraint">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates Burt's constraint scores for given vertices in a graph.</p>
<p>Burt's constraint is higher if ego has less, or mutually stronger related (i.e. more redundant) contacts. Burt's measure of constraint, C[i], of vertex i's ego network V[i], is defined for directed and valued graphs as follows:</p>
<p>C[i] = sum( sum( (p[i,q] p[q,j])^2, q in V[i], q != i,j ), j in V[], j != i)</p>
<p>for a graph of order (ie. number od vertices) N, where proportional tie strengths are defined as follows:</p>
<p>p[i,j]=(a[i,j]+a[j,i]) / sum(a[i,k]+a[k,i], k in V[i], k != i), a[i,j] are elements of A and the latter being the graph adjacency matrix.</p>
<p>For isolated vertices, constraint is undefined.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the vertices to be analysed or <tt class="rst-docutils literal">None</tt> for all vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">weights associated to the edges. Can be an attribute name as well. If <tt class="rst-docutils literal">None</tt>, every edge will have the same weight.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">constraint scores for all given vertices in a matrix.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.contract_vertices">
    
  </a>
  <a name="contract_vertices">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">contract_vertices</span>(mapping, combine_attrs=None):
    
    <a class="headerLink" href="#contract_vertices" title="igraph._igraph.GraphBase.contract_vertices">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Contracts some vertices in the graph, i.e. replaces groups of vertices with single vertices. Edges are not affected.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mapping</span></td><td class="fieldArgDesc">numeric vector which gives the mapping between old and new vertex IDs. Vertices having the same new vertex ID in this vector will be remapped into a single new vertex. It is safe to pass the membership vector of a <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> object here.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">combine<wbr></wbr>_attrs</span></td><td class="fieldArgDesc">specifies how to combine the attributes of the vertices being collapsed into a single one. If it is <tt class="rst-docutils literal">None</tt>, all the attributes will be lost. If it is a function, the attributes of the vertices will be collected and passed on to that function which will return the new attribute value that has to be assigned to the single collapsed vertex. It can also be one of the following string constants which define built-in collapsing functions: <tt class="rst-docutils literal">sum</tt>, <tt class="rst-docutils literal">prod</tt>, <tt class="rst-docutils literal">mean</tt>, <tt class="rst-docutils literal">median</tt>, <tt class="rst-docutils literal">max</tt>, <tt class="rst-docutils literal">min</tt>, <tt class="rst-docutils literal">first</tt>, <tt class="rst-docutils literal">last</tt>, <tt class="rst-docutils literal">random</tt>. You can also specify different combination functions for different attributes by passing a dict here which maps attribute names to functions. See <code><a href="#simplify" class="internal-link" title="igraph._igraph.GraphBase.simplify">simplify()</a></code> for more details.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><tt class="rst-docutils literal">None</tt>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#simplify" class="internal-link" title="igraph._igraph.GraphBase.simplify">simplify()</a></code></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.convergence_degree">
    
  </a>
  <a name="convergence_degree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">convergence_degree</span>():
    
    <a class="headerLink" href="#convergence_degree" title="igraph._igraph.GraphBase.convergence_degree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Undocumented (yet).</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.convergence_field_size">
    
  </a>
  <a name="convergence_field_size">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">convergence_field_size</span>():
    
    <a class="headerLink" href="#convergence_field_size" title="igraph._igraph.GraphBase.convergence_field_size">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Undocumented (yet).</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.copy">
    
  </a>
  <a name="copy">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">copy</span>():
    
    <a class="headerLink" href="#copy" title="igraph._igraph.GraphBase.copy">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Creates a copy of the graph.</p>
<p>Attributes are copied by reference; in other words, if you use mutable Python objects as attribute values, these objects will still be shared between the old and new graph. You can use `deepcopy()` from the `copy` module if you need a truly deep copy of the graph.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.coreness">
    
  </a>
  <a name="coreness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">coreness</span>(mode='all'):
    
    <a class="headerLink" href="#coreness" title="igraph._igraph.GraphBase.coreness">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Finds the coreness (shell index) of the vertices of the network.</p>
<p>The <span class="rst-math rst-formula"><i>k</i></span>-core of a graph is a maximal subgraph in which each vertex has at least degree k. (Degree here means the degree in the subgraph of course). The coreness of a vertex is <span class="rst-math rst-formula"><i>k</i></span> if it is a member of the <span class="rst-math rst-formula"><i>k</i></span>-core but not a member of the <span class="rst-math rst-formula"><i>k</i> + 1</span>-core.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">whether to compute the in-corenesses (<tt class="rst-docutils literal">"in"</tt>), the out-corenesses (<tt class="rst-docutils literal">"out"</tt>) or the undirected corenesses (<tt class="rst-docutils literal">"all"</tt>). Ignored and assumed to be <tt class="rst-docutils literal">"all"</tt> for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the corenesses for each vertex.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Vladimir Batagelj, Matjaz Zaversnik: <em>An <span class="rst-math rst-formula"><i>O</i>(<i>m</i>)</span> Algorithm for Core Decomposition of Networks.</em></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.count_isomorphisms_vf2">
    
  </a>
  <a name="count_isomorphisms_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">count_isomorphisms_vf2</span>(other=None, color1=None, color2=None, edge_color1=None, edge_color2=None, node_compat_fn=None, edge_compat_fn=None):
    
    <a class="headerLink" href="#count_isomorphisms_vf2" title="igraph._igraph.GraphBase.count_isomorphisms_vf2">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Determines the number of isomorphisms between the graph and another one</p>
<p>Vertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">the other graph. If <tt class="rst-docutils literal">None</tt>, the number of automorphisms will be returned.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the first graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the second graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the edges of the first graph. If <tt class="rst-docutils literal">None</tt>, all edges have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the edges of the second graph. If <tt class="rst-docutils literal">None</tt>, all edges have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">node<wbr></wbr>_compat<wbr></wbr>_fn</span></td><td class="fieldArgDesc">a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns <tt class="rst-docutils literal">True</tt> if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or <tt class="rst-docutils literal">False</tt> otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the <tt class="rst-docutils literal">color1</tt> and <tt class="rst-docutils literal">color2</tt> parameters). <tt class="rst-docutils literal">None</tt> means that every node is compatible with every other node.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_compat<wbr></wbr>_fn</span></td><td class="fieldArgDesc">a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns <tt class="rst-docutils literal">True</tt> if the edges given by the two indices are compatible (i.e. they could be matched to each other) or <tt class="rst-docutils literal">False</tt> otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the <tt class="rst-docutils literal">edge_color1</tt> and <tt class="rst-docutils literal">edge_color2</tt> parameters). <tt class="rst-docutils literal">None</tt> means that every edge is compatible with every other node.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the number of isomorphisms between the two given graphs (or the number of automorphisms if <tt class="rst-docutils literal">other</tt> is <tt class="rst-docutils literal">None</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.count_multiple">
    
  </a>
  <a name="count_multiple">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">count_multiple</span>(edges=None):
    
    <a class="headerLink" href="#count_multiple" title="igraph._igraph.GraphBase.count_multiple">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Counts the multiplicities of the given edges.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">edge indices for which we want to count their multiplicity. If <tt class="rst-docutils literal">None</tt>, all edges are counted.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the multiplicities of the given edges as a list.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.count_subisomorphisms_vf2">
    
  </a>
  <a name="count_subisomorphisms_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">count_subisomorphisms_vf2</span>(other, color1=None, color2=None, edge_color1=None, edge_color2=None, node_compat_fn=None, edge_compat_fn=None):
    
    <a class="headerLink" href="#count_subisomorphisms_vf2" title="igraph._igraph.GraphBase.count_subisomorphisms_vf2">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Determines the number of subisomorphisms between the graph and another one</p>
<p>Vertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">the other graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the first graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the second graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the edges of the first graph. If <tt class="rst-docutils literal">None</tt>, all edges have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the edges of the second graph. If <tt class="rst-docutils literal">None</tt>, all edges have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">node<wbr></wbr>_compat<wbr></wbr>_fn</span></td><td class="fieldArgDesc">a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns <tt class="rst-docutils literal">True</tt> if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or <tt class="rst-docutils literal">False</tt> otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the <tt class="rst-docutils literal">color1</tt> and <tt class="rst-docutils literal">color2</tt> parameters). <tt class="rst-docutils literal">None</tt> means that every node is compatible with every other node.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_compat<wbr></wbr>_fn</span></td><td class="fieldArgDesc">a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns <tt class="rst-docutils literal">True</tt> if the edges given by the two indices are compatible (i.e. they could be matched to each other) or <tt class="rst-docutils literal">False</tt> otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the <tt class="rst-docutils literal">edge_color1</tt> and <tt class="rst-docutils literal">edge_color2</tt> parameters). <tt class="rst-docutils literal">None</tt> means that every edge is compatible with every other node.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the number of subisomorphisms between the two given graphs</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.De_Bruijn">
    
  </a>
  <a name="De_Bruijn">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">De_Bruijn</span>(m, n):
    
    <a class="headerLink" href="#De_Bruijn" title="igraph._igraph.GraphBase.De_Bruijn">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a de Bruijn graph with parameters (m, n)</p>
<p>A de Bruijn graph represents relationships between strings. An alphabet of <span class="rst-math rst-formula"><i>m</i></span> letters are used and strings of length <span class="rst-math rst-formula"><i>n</i></span> are considered. A vertex corresponds to every possible string and there is a directed edge from vertex <span class="rst-math rst-formula"><i>v</i></span> to vertex <span class="rst-math rst-formula"><i>w</i></span> if the string of <span class="rst-math rst-formula"><i>v</i></span> can be transformed into the string of <span class="rst-math rst-formula"><i>w</i></span> by removing its first letter and appending a letter to it.</p>
<p>Please note that the graph will have <span class="rst-math rst-formula"><i>m</i><sup><i>n</i></sup></span> vertices and even more edges, so probably you don't want to supply too big numbers for <span class="rst-math rst-formula"><i>m</i></span> and <span class="rst-math rst-formula"><i>n</i></span>.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">m</span></td><td class="fieldArgDesc">the size of the alphabet</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the length of the strings</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.decompose">
    
  </a>
  <a name="decompose">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">decompose</span>(mode='strong', maxcompno=None, minelements=1):
    
    <a class="headerLink" href="#decompose" title="igraph._igraph.GraphBase.decompose">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Decomposes the graph into subgraphs.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">must be either <tt class="rst-docutils literal">"strong"</tt> or <tt class="rst-docutils literal">"weak"</tt>, depending on the clusters being sought. Optional, defaults to <tt class="rst-docutils literal">"strong"</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxcompno</span></td><td class="fieldArgDesc">maximum number of components to return. <tt class="rst-docutils literal">None</tt> means all possible components.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">minelements</span></td><td class="fieldArgDesc">minimum number of vertices in a component. By setting this to 2, isolated vertices are not returned as separate components.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of the subgraphs. Every returned subgraph is a copy of the original.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.degree">
    
  </a>
  <a name="degree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">degree</span>(vertices, mode='all', loops=True):
    
    <a class="headerLink" href="#degree" title="igraph._igraph.GraphBase.degree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns some vertex degrees from the graph.</p>
<p>This method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the degree of the given vertices (in the form of a single integer or a list, depending on the input parameter).</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">a single vertex ID or a list of vertex IDs</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">the type of degree to be returned (<tt class="rst-docutils literal">"out"</tt> for out-degrees, <tt class="rst-docutils literal">"in"</tt> for in-degrees or <tt class="rst-docutils literal">"all"</tt> for the sum of them).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether self-loops should be counted.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Degree_Sequence">
    
  </a>
  <a name="Degree_Sequence">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Degree_Sequence</span>(out, in_=None, method='simple'):
    
    <a class="headerLink" href="#Degree_Sequence" title="igraph._igraph.GraphBase.Degree_Sequence">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph with a given degree sequence.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">out</span></td><td class="fieldArgDesc">the out-degree sequence for a directed graph. If the in-degree sequence is omitted, the generated graph will be undirected, so this will be the in-degree sequence as well</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">in_</span></td><td class="fieldArgDesc">the in-degree sequence for a directed graph. If omitted, the generated graph will be undirected.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">method</span></td><td class="fieldArgDesc"><p>the generation method to be used. One of the following:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"simple"</tt> -- simple generator that sometimes generates loop edges and multiple edges. The generated graph is not guaranteed to be connected.</li>
<li><tt class="rst-docutils literal">"no_multiple"</tt> -- similar to <tt class="rst-docutils literal">"simple"</tt> but avoids the generation of multiple and loop edges at the expense of increased time complexity. The method will re-start the generation every time it gets stuck in a configuration where it is not possible to insert any more edges without creating loops or multiple edges, and there is no upper bound on the number of iterations, but it will succeed eventually if the input degree sequence is graphical and throw an exception if the input degree sequence is not graphical.</li>
<li><tt class="rst-docutils literal">"vl"</tt> -- a more sophisticated generator that can sample undirected, connected simple graphs uniformly. It uses Monte-Carlo methods to randomize the graphs. This generator should be favoured if undirected and connected graphs are to be generated and execution time is not a concern. igraph uses the original implementation of Fabien Viger; see the following URL and the paper cited on it for the details of the algorithm: <a class="rst-reference external" href="https://www-complexnetworks.lip6.fr/~latapy/FV/generation.html" target="_top">https://www-complexnetworks.lip6.fr/~latapy/FV/generation.html</a>.</li>
</ul>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.delete_edges">
    
  </a>
  <a name="delete_edges">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">delete_edges</span>(es):
    
    <a class="headerLink" href="#delete_edges" title="igraph._igraph.GraphBase.delete_edges">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Removes edges from the graph.</p>
<p>All vertices will be kept, even if they lose all their edges. Nonexistent edges will be silently ignored.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">es</span></td><td class="fieldArgDesc">the list of edges to be removed. Edges are identifed by edge IDs. <code><a href="igraph._igraph.EdgeSeq.html" class="internal-link" title="igraph._igraph.EdgeSeq">EdgeSeq</a></code> objects are also accepted here. No argument deletes all edges.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.delete_vertices">
    
  </a>
  <a name="delete_vertices">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">delete_vertices</span>(vs):
    
    <a class="headerLink" href="#delete_vertices" title="igraph._igraph.GraphBase.delete_vertices">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Deletes vertices and all its edges from the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vs</span></td><td class="fieldArgDesc">a single vertex ID or the list of vertex IDs to be deleted. No argument deletes all vertices.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.density">
    
  </a>
  <a name="density">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">density</span>(loops=False):
    
    <a class="headerLink" href="#density" title="igraph._igraph.GraphBase.density">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the density of the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether to take loops into consideration. If <tt class="rst-docutils literal">True</tt>, the algorithm assumes that there might be some loops in the graph and calculates the density accordingly. If <tt class="rst-docutils literal">False</tt>, the algorithm assumes that there can't be any loops.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the density of the graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.dfsiter">
    
  </a>
  <a name="dfsiter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">dfsiter</span>(vid, mode='out', advanced=False):
    
    <a class="headerLink" href="#dfsiter" title="igraph._igraph.GraphBase.dfsiter">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Constructs a depth first search (DFS) iterator of the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vid</span></td><td class="fieldArgDesc">the root vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">either <tt class="rst-docutils literal">"in"</tt> or <tt class="rst-docutils literal">"out"</tt> or <tt class="rst-docutils literal">"all"</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">advanced</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">False</tt>, the iterator returns the next vertex in DFS order in every step. If <tt class="rst-docutils literal">True</tt>, the iterator returns the distance of the vertex from the root and the parent of the vertex in the DFS tree as well.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the DFS iterator as an <code><a href="igraph._igraph.DFSIter.html" class="internal-link" title="igraph._igraph.DFSIter">igraph.DFSIter</a></code> object.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.diameter">
    
  </a>
  <a name="diameter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">diameter</span>(directed=True, unconn=True, weights=None):
    
    <a class="headerLink" href="#diameter" title="igraph._igraph.GraphBase.diameter">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the diameter of the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider directed paths.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">unconn</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt> and the graph is unconnected, the longest geodesic within a component will be returned. If <tt class="rst-docutils literal">False</tt> and the graph is unconnected, the result is the number of vertices if there are no weights or infinity if there are weights.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the diameter</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.difference">
    
  </a>
  <a name="difference">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">difference</span>(other):
    
    <a class="headerLink" href="#difference" title="igraph._igraph.GraphBase.difference">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Subtracts the given graph from the original</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.diversity">
    
  </a>
  <a name="diversity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">diversity</span>(vertices=None, weights=None):
    
    <a class="headerLink" href="#diversity" title="igraph._igraph.GraphBase.diversity">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the structural diversity index of the vertices.</p>
<p>The structural diversity index of a vertex is simply the (normalized) Shannon entropy of the weights of the edges incident on the vertex.</p>
<p>The measure is defined for undirected graphs only; edge directions are ignored.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the vertices for which the diversity indices must be returned. If <tt class="rst-docutils literal">None</tt>, uses all of the vertices in the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated diversity indices in a list, or a single number if a single vertex was supplied.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Eagle N, Macy M and Claxton R: Network diversity and economic development, Science 328, 1029--1031, 2010.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.dominator">
    
  </a>
  <a name="dominator">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">dominator</span>(vid, mode='out'):
    
    <a class="headerLink" href="#dominator" title="igraph._igraph.GraphBase.dominator">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the dominator tree from the given root node</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vid</span></td><td class="fieldArgDesc">the root vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">either <tt class="rst-docutils literal">"in"</tt> or <tt class="rst-docutils literal">"out"</tt></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list containing the dominator tree for the current graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.dyad_census">
    
  </a>
  <a name="dyad_census">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">dyad_census</span>():
    
    <a class="headerLink" href="#dyad_census" title="igraph._igraph.GraphBase.dyad_census">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Dyad census, as defined by Holland and Leinhardt</p>
<p>Dyad census means classifying each pair of vertices of a directed graph into three categories: mutual, there is an edge from <em>a</em> to <em>b</em> and also from <em>b</em> to <em>a</em>; asymmetric, there is an edge either from <em>a</em> to <em>b</em> or from <em>b</em> to <em>a</em> but not the other way and null, no edges between <em>a</em> and <em>b</em>.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the number of mutual, asymmetric and null connections in a 3-tuple.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> which wraps the result in a <code><a href="igraph.datatypes.DyadCensus.html" class="internal-link" title="igraph.datatypes.DyadCensus">DyadCensus</a></code> object. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.eccentricity">
    
  </a>
  <a name="eccentricity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">eccentricity</span>(vertices=None, mode='all'):
    
    <a class="headerLink" href="#eccentricity" title="igraph._igraph.GraphBase.eccentricity">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the eccentricities of given vertices in a graph.</p>
<p>The eccentricity of a vertex is calculated by measuring the shortest distance from (or to) the vertex, to (or from) all other vertices in the graph, and taking the maximum.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the vertices for which the eccentricity scores must be returned. If <tt class="rst-docutils literal">None</tt>, uses all of the vertices in the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">must be one of <tt class="rst-docutils literal">"in"</tt>, <tt class="rst-docutils literal">"out"</tt> and <tt class="rst-docutils literal">"all"</tt>. <tt class="rst-docutils literal">"in"</tt> means that edge directions are followed; <tt class="rst-docutils literal">"out"</tt> means that edge directions are followed the opposite direction; <tt class="rst-docutils literal">"all"</tt> means that directions are ignored. The argument has no effect for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated eccentricities in a list, or a single number if a single vertex was supplied.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.ecount">
    
  </a>
  <a name="ecount">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">ecount</span>():
    
    <a class="headerLink" href="#ecount" title="igraph._igraph.GraphBase.ecount">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Counts the number of edges.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">integer</td><td class="fieldArgDesc">the number of edges in the graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.edge_attributes">
    
  </a>
  <a name="edge_attributes">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">edge_attributes</span>():
    
    <a class="headerLink" href="#edge_attributes" title="igraph._igraph.GraphBase.edge_attributes">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the attribute name list of the edges of the graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.edge_betweenness">
    
  </a>
  <a name="edge_betweenness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">edge_betweenness</span>(directed=True, cutoff=None, weights=None):
    
    <a class="headerLink" href="#edge_betweenness" title="igraph._igraph.GraphBase.edge_betweenness">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates or estimates the edge betweennesses in a graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider directed paths.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cutoff</span></td><td class="fieldArgDesc">if it is an integer, only paths less than or equal to this length are considered, effectively resulting in an estimation of the betweenness values. If <tt class="rst-docutils literal">None</tt>, the exact betweennesses are returned.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list with the (exact or estimated) edge betweennesses of all edges.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.edge_connectivity">
    
  </a>
  <a name="edge_connectivity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">edge_connectivity</span>(source=-1, target=-1, checks=True):
    
    <a class="headerLink" href="#edge_connectivity" title="igraph._igraph.GraphBase.edge_connectivity">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the edge connectivity of the graph or between some vertices.</p>
<p>The edge connectivity between two given vertices is the number of edges that have to be removed in order to disconnect the two vertices into two separate components. This is also the number of edge disjoint directed paths between the vertices. The edge connectivity of the graph is the minimal edge connectivity over all vertex pairs.</p>
<p>This method calculates the edge connectivity of a given vertex pair if both the source and target vertices are given. If none of them is given (or they are both negative), the overall edge connectivity is returned.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex involved in the calculation.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex involved in the calculation.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">checks</span></td><td class="fieldArgDesc">if the whole graph connectivity is calculated and this is <tt class="rst-docutils literal">True</tt>, igraph performs some basic checks before calculation. If the graph is not strongly connected, then the connectivity is obviously zero. If the minimum degree is one, then the connectivity is also one. These simple checks are much faster than checking the entire graph, therefore it is advised to set this to <tt class="rst-docutils literal">True</tt>. The parameter is ignored if the connectivity between two given vertices is computed.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the edge connectivity</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.eigen_adjacency">
    
  </a>
  <a name="eigen_adjacency">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">eigen_adjacency</span>(...):
    
    <a class="headerLink" href="#eigen_adjacency" title="igraph._igraph.GraphBase.eigen_adjacency">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.eigenvector_centrality">
    
  </a>
  <a name="eigenvector_centrality">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">eigenvector_centrality</span>(directed=True, scale=True, weights=None, return_eigenvalue=False, arpack_options=None):
    
    <a class="headerLink" href="#eigenvector_centrality" title="igraph._igraph.GraphBase.eigenvector_centrality">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the eigenvector centralities of the vertices in a graph.</p>
<p>Eigenvector centrality is a measure of the importance of a node in a network. It assigns relative scores to all nodes in the network based on the principle that connections from high-scoring nodes contribute more to the score of the node in question than equal connections from low-scoring nodes. In practice, the centralities are determined by calculating eigenvector corresponding to the largest positive eigenvalue of the adjacency matrix. In the undirected case, this function considers the diagonal entries of the adjacency matrix to be twice the number of self-loops on the corresponding vertex.</p>
<p>In the directed case, the left eigenvector of the adjacency matrix is calculated. In other words, the centrality of a vertex is proportional to the sum of centralities of vertices pointing to it.</p>
<p>Eigenvector centrality is meaningful only for connected graphs. Graphs that are not connected should be decomposed into connected components, and the eigenvector centrality calculated for each separately.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider edge directions in a directed graph. Ignored for undirected graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">scale</span></td><td class="fieldArgDesc">whether to normalize the centralities so the largest one will always be 1.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights given as a list or an edge attribute. If <tt class="rst-docutils literal">None</tt>, all edges have equal weight.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_eigenvalue</span></td><td class="fieldArgDesc">whether to return the actual largest eigenvalue along with the centralities</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">arpack<wbr></wbr>_options</span></td><td class="fieldArgDesc">an <code><a href="igraph._igraph.ARPACKOptions.html" class="internal-link" title="igraph._igraph.ARPACKOptions">ARPACKOptions</a></code> object that can be used to fine-tune the calculation. If it is omitted, the module-level variable called <tt class="rst-docutils literal">arpack_options</tt> is used.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the eigenvector centralities in a list and optionally the largest eigenvalue (as a second member of a tuple)</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Erdos_Renyi">
    
  </a>
  <a name="Erdos_Renyi">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Erdos_Renyi</span>(n, p, m, directed=False, loops=False):
    
    <a class="headerLink" href="#Erdos_Renyi" title="igraph._igraph.GraphBase.Erdos_Renyi">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph based on the Erdos-Renyi model.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">p</span></td><td class="fieldArgDesc">the probability of edges. If given, <tt class="rst-docutils literal">m</tt> must be missing.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">m</span></td><td class="fieldArgDesc">the number of edges. If given, <tt class="rst-docutils literal">p</tt> must be missing.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to generate a directed graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether self-loops are allowed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Establishment">
    
  </a>
  <a name="Establishment">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Establishment</span>(n, k, type_dist, pref_matrix, directed=False):
    
    <a class="headerLink" href="#Establishment" title="igraph._igraph.GraphBase.Establishment">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph based on a simple growing model with vertex types.</p>
<p>A single vertex is added at each time step. This new vertex tries to connect to k vertices in the graph. The probability that such a connection is realized depends on the types of the vertices involved.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">k</span></td><td class="fieldArgDesc">the number of connections tried in each step</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">type<wbr></wbr>_dist</span></td><td class="fieldArgDesc">list giving the distribution of vertex types</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">pref<wbr></wbr>_matrix</span></td><td class="fieldArgDesc">matrix (list of lists) giving the connection probabilities for different vertex types</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to generate a directed graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Famous">
    
  </a>
  <a name="Famous">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Famous</span>(name):
    
    <a class="headerLink" href="#Famous" title="igraph._igraph.GraphBase.Famous">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a famous graph based on its name.</p>
<p>Several famous graphs are known to <tt class="rst-docutils literal">igraph</tt> including (but not limited to) the Chvatal graph, the Petersen graph or the Tutte graph. This method generates one of them based on its name (case insensitive). See the documentation of the C interface of <tt class="rst-docutils literal">igraph</tt> for the names available: <a class="rst-reference external" href="https://igraph.org/c/doc" target="_top">https://igraph.org/c/doc</a>.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">name</span></td><td class="fieldArgDesc">the name of the graph to be generated.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.farthest_points">
    
  </a>
  <a name="farthest_points">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">farthest_points</span>(directed=True, unconn=True, weights=None):
    
    <a class="headerLink" href="#farthest_points" title="igraph._igraph.GraphBase.farthest_points">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns two vertex IDs whose distance equals the actual diameter of the graph.</p>
<p>If there are many shortest paths with the length of the diameter, it returns the first one it found.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider directed paths.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">unconn</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt> and the graph is unconnected, the longest geodesic within a component will be returned. If <tt class="rst-docutils literal">False</tt> and the graph is unconnected, the result contains the number of vertices if there are no weights or infinity if there are weights.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a triplet containing the two vertex IDs and their distance. The IDs are <tt class="rst-docutils literal">None</tt> if the graph is unconnected and <tt class="rst-docutils literal">unconn</tt> is <tt class="rst-docutils literal">False</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.feedback_arc_set">
    
  </a>
  <a name="feedback_arc_set">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">feedback_arc_set</span>(weights=None, method='eades'):
    
    <a class="headerLink" href="#feedback_arc_set" title="igraph._igraph.GraphBase.feedback_arc_set">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates an approximately or exactly minimal feedback arc set.</p>
<p>A feedback arc set is a set of edges whose removal makes the graph acyclic. Since this is always possible by removing all the edges, we are in general interested in removing the smallest possible number of edges, or an edge set with as small total weight as possible. This method calculates one such edge set. Note that the task is trivial for an undirected graph as it is enough to find a spanning tree and then remove all the edges not in the spanning tree. Of course it is more complicated for directed graphs.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name. When given, the algorithm will strive to remove lightweight edges in order to minimize the total weight of the feedback arc set.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">method</span></td><td class="fieldArgDesc">the algorithm to use. <tt class="rst-docutils literal">"eades"</tt> uses the greedy cycle breaking heuristic of Eades, Lin and Smyth, which is linear in the number of edges but not necessarily optimal; however, it guarantees that the number of edges to be removed is smaller than |E|/2 - |V|/6. <tt class="rst-docutils literal">"ip"</tt> uses an integer programming formulation which is guaranteed to yield an optimal result, but is too slow for large graphs.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the IDs of the edges to be removed, in a list.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Eades P, Lin X and Smyth WF: A fast and effective heuristic for the feedback arc set problem. In: Proc Inf Process Lett 319-323, 1993.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Forest_Fire">
    
  </a>
  <a name="Forest_Fire">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Forest_Fire</span>(n, fw_prob, bw_factor=0.0, ambs=1, directed=False):
    
    <a class="headerLink" href="#Forest_Fire" title="igraph._igraph.GraphBase.Forest_Fire">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph based on the forest fire model</p>
<p>The forest fire model is a growing graph model. In every time step, a new vertex is added to the graph. The new vertex chooses an ambassador (or more than one if <span class="rst-math rst-formula"><i>ambs</i> &gt; 1</span>) and starts a simulated forest fire at its ambassador(s). The fire spreads through the edges. The spreading probability along an edge is given by <span class="rst-math rst-formula"><i>fw</i><sub><i>prob</i></sub></span>. The fire may also spread backwards on an edge by probability <span class="rst-math rst-formula"><i>fw</i><sub><i>prob</i></sub>*<i>bw</i><sub><i>factor</i></sub></span>. When the fire ended, the newly added vertex connects to the vertices ``burned'' in the previous fire.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fw<wbr></wbr>_prob</span></td><td class="fieldArgDesc">forward burning probability</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">bw<wbr></wbr>_factor</span></td><td class="fieldArgDesc">ratio of backward and forward burning probability</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ambs</span></td><td class="fieldArgDesc">number of ambassadors chosen in each step</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the graph will be directed</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Full">
    
  </a>
  <a name="Full">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Full</span>(n, directed=False, loops=False):
    
    <a class="headerLink" href="#Full" title="igraph._igraph.GraphBase.Full">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a full graph (directed or undirected, with or without loops).</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to generate a directed graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether self-loops are allowed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Full_Citation">
    
  </a>
  <a name="Full_Citation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Full_Citation</span>(n, directed=False):
    
    <a class="headerLink" href="#Full_Citation" title="igraph._igraph.GraphBase.Full_Citation">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a full citation graph</p>
<p>A full citation graph is a graph where the vertices are indexed from 0 to <span class="rst-math rst-formula"><i>n</i> − 1</span> and vertex <span class="rst-math rst-formula"><i>i</i></span> has a directed edge towards all vertices with an index less than <span class="rst-math rst-formula"><i>i</i></span>.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to generate a directed graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.get_adjacency">
    
  </a>
  <a name="get_adjacency">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_adjacency</span>(type='both', eids=False):
    
    <a class="headerLink" href="#get_adjacency" title="igraph._igraph.GraphBase.get_adjacency">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Returns the adjacency matrix of a graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">type</span></td><td class="fieldArgDesc">one of <tt class="rst-docutils literal">"lower"</tt> (uses the lower triangle of the matrix), <tt class="rst-docutils literal">"upper"</tt> (uses the upper triangle) or <tt class="rst-docutils literal">"both"</tt> (uses both parts). Ignored for directed graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">eids</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, the result matrix will contain zeros for non-edges and the ID of the edge plus one for edges in the appropriate cell. If <tt class="rst-docutils literal">False</tt>, the result matrix will contain the number of edges for each vertex pair.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the adjacency matrix.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.get_all_shortest_paths">
    
  </a>
  <a name="get_all_shortest_paths">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_all_shortest_paths</span>(v, to=None, weights=None, mode='out'):
    
    <a class="headerLink" href="#get_all_shortest_paths" title="igraph._igraph.GraphBase.get_all_shortest_paths">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates all of the shortest paths from/to a given node in a graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">v</span></td><td class="fieldArgDesc">the source for the calculated paths</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">to</span></td><td class="fieldArgDesc">a vertex selector describing the destination for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a <code><a href="igraph._igraph.VertexSeq.html" class="internal-link" title="igraph._igraph.VertexSeq">VertexSeq</a></code> object. <tt class="rst-docutils literal">None</tt> means all the vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights in a list or the name of an edge attribute holding edge weights. If <tt class="rst-docutils literal">None</tt>, all edges are assumed to have equal weight.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">the directionality of the paths. <tt class="rst-docutils literal">"in"</tt> means to calculate incoming paths, <tt class="rst-docutils literal">"out"</tt> means to calculate outgoing paths, <tt class="rst-docutils literal">"all"</tt> means to calculate both ones.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">all of the shortest path from the given node to every other reachable node in the graph in a list. Note that in case of mode=<tt class="rst-docutils literal">"in"</tt>, the vertices in a path are returned in reversed order!</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.get_diameter">
    
  </a>
  <a name="get_diameter">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_diameter</span>(directed=True, unconn=True, weights=None):
    
    <a class="headerLink" href="#get_diameter" title="igraph._igraph.GraphBase.get_diameter">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns a path with the actual diameter of the graph.</p>
<p>If there are many shortest paths with the length of the diameter, it returns the first one it founds.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider directed paths.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">unconn</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt> and the graph is unconnected, the longest geodesic within a component will be returned. If <tt class="rst-docutils literal">False</tt> and the graph is unconnected, the result is the number of vertices if there are no weights or infinity if there are weights.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the vertices in the path in order.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.get_edgelist">
    
  </a>
  <a name="get_edgelist">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_edgelist</span>():
    
    <a class="headerLink" href="#get_edgelist" title="igraph._igraph.GraphBase.get_edgelist">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the edge list of a graph.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.get_eid">
    
  </a>
  <a name="get_eid">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_eid</span>(v1, v2, directed=True, error=True):
    
    <a class="headerLink" href="#get_eid" title="igraph._igraph.GraphBase.get_eid">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the edge ID of an arbitrary edge between vertices v1 and v2</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">v1</span></td><td class="fieldArgDesc">the ID or name of the first vertex</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">v2</span></td><td class="fieldArgDesc">the ID or name of the second vertex</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether edge directions should be considered in directed graphs. The default is <tt class="rst-docutils literal">True</tt>. Ignored for undirected graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">error</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, an exception will be raised when the given edge does not exist. If <tt class="rst-docutils literal">False</tt>, -1 will be returned in that case.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the edge ID of an arbitrary edge between vertices v1 and v2</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.get_eids">
    
  </a>
  <a name="get_eids">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_eids</span>(pairs=None, path=None, directed=True, error=True):
    
    <a class="headerLink" href="#get_eids" title="igraph._igraph.GraphBase.get_eids">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the edge IDs of some edges between some vertices.</p>
<p>This method can operate in two different modes, depending on which of the keyword arguments <tt class="rst-docutils literal">pairs</tt> and <tt class="rst-docutils literal">path</tt> are given.</p>
<p>The method does not consider multiple edges; if there are multiple edges between a pair of vertices, only the ID of one of the edges is returned.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">pairs</span></td><td class="fieldArgDesc">a list of integer pairs. Each integer pair is considered as a source-target vertex pair; the corresponding edge is looked up in the graph and the edge ID is returned for each pair.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">path</span></td><td class="fieldArgDesc">a list of vertex IDs. The list is considered as a continuous path from the first vertex to the last, passing through the intermediate vertices. The corresponding edge IDs between the first and the second, the second and the third and so on are looked up in the graph and the edge IDs are returned. If both <tt class="rst-docutils literal">path</tt> and <tt class="rst-docutils literal">pairs</tt> are given, the two lists are concatenated.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether edge directions should be considered in directed graphs. The default is <tt class="rst-docutils literal">True</tt>. Ignored for undirected graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">error</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, an exception will be raised if a given edge does not exist. If <tt class="rst-docutils literal">False</tt>, -1 will be returned in that case.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the edge IDs in a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.get_incidence">
    
  </a>
  <a name="get_incidence">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_incidence</span>(types):
    
    <a class="headerLink" href="#get_incidence" title="igraph._igraph.GraphBase.get_incidence">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.get_incidence()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.get_isomorphisms_vf2">
    
  </a>
  <a name="get_isomorphisms_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_isomorphisms_vf2</span>(other=None, color1=None, color2=None, edge_color1=None, edge_color2=None, node_compat_fn=None, edge_compat_fn=None):
    
    <a class="headerLink" href="#get_isomorphisms_vf2" title="igraph._igraph.GraphBase.get_isomorphisms_vf2">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns all isomorphisms between the graph and another one</p>
<p>Vertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">the other graph. If <tt class="rst-docutils literal">None</tt>, the automorphisms will be returned.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the first graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the second graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the edges of the first graph. If <tt class="rst-docutils literal">None</tt>, all edges have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the edges of the second graph. If <tt class="rst-docutils literal">None</tt>, all edges have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">node<wbr></wbr>_compat<wbr></wbr>_fn</span></td><td class="fieldArgDesc">a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns <tt class="rst-docutils literal">True</tt> if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or <tt class="rst-docutils literal">False</tt> otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the <tt class="rst-docutils literal">color1</tt> and <tt class="rst-docutils literal">color2</tt> parameters). <tt class="rst-docutils literal">None</tt> means that every node is compatible with every other node.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_compat<wbr></wbr>_fn</span></td><td class="fieldArgDesc">a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns <tt class="rst-docutils literal">True</tt> if the edges given by the two indices are compatible (i.e. they could be matched to each other) or <tt class="rst-docutils literal">False</tt> otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the <tt class="rst-docutils literal">edge_color1</tt> and <tt class="rst-docutils literal">edge_color2</tt> parameters). <tt class="rst-docutils literal">None</tt> means that every edge is compatible with every other node.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.get_shortest_paths">
    
  </a>
  <a name="get_shortest_paths">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_shortest_paths</span>(v, to=None, weights=None, mode='out', output='vpath'):
    
    <a class="headerLink" href="#get_shortest_paths" title="igraph._igraph.GraphBase.get_shortest_paths">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the shortest paths from/to a given node in a graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">v</span></td><td class="fieldArgDesc">the source/destination for the calculated paths</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">to</span></td><td class="fieldArgDesc">a vertex selector describing the destination/source for the calculated paths. This can be a single vertex ID, a list of vertex IDs, a single vertex name, a list of vertex names or a <code><a href="igraph._igraph.VertexSeq.html" class="internal-link" title="igraph._igraph.VertexSeq">VertexSeq</a></code> object. <tt class="rst-docutils literal">None</tt> means all the vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights in a list or the name of an edge attribute holding edge weights. If <tt class="rst-docutils literal">None</tt>, all edges are assumed to have equal weight.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">the directionality of the paths. <tt class="rst-docutils literal">"in"</tt> means to calculate incoming paths, <tt class="rst-docutils literal">"out"</tt> means to calculate outgoing paths, <tt class="rst-docutils literal">"all"</tt> means to calculate both ones.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">output</span></td><td class="fieldArgDesc">determines what should be returned. If this is <tt class="rst-docutils literal">"vpath"</tt>, a list of vertex IDs will be returned, one path for each target vertex. For unconnected graphs, some of the list elements may be empty. Note that in case of mode=<tt class="rst-docutils literal">"in"</tt>, the vertices in a path are returned in reversed order. If <tt class="rst-docutils literal"><span class="pre">output="epath"</span></tt>, edge IDs are returned instead of vertex IDs.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">see the documentation of the <tt class="rst-docutils literal">output</tt> parameter.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.get_subisomorphisms_lad">
    
  </a>
  <a name="get_subisomorphisms_lad">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_subisomorphisms_lad</span>(other, domains=None, induced=False, time_limit=0):
    
    <a class="headerLink" href="#get_subisomorphisms_lad" title="igraph._igraph.GraphBase.get_subisomorphisms_lad">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns all subisomorphisms between the graph and another one using the LAD algorithm.</p>
<p>The optional <tt class="rst-docutils literal">domains</tt> argument may be used to restrict vertices that may match each other. You can also specify whether you are interested in induced subgraphs only or not.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">the pattern graph we are looking for in the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">domains</span></td><td class="fieldArgDesc">a list of lists, one sublist belonging to each vertex in the template graph. Sublist <span class="rst-math rst-formula"><i>i</i></span> contains the indices of the vertices in the original graph that may match vertex <span class="rst-math rst-formula"><i>i</i></span> in the template graph. <tt class="rst-docutils literal">None</tt> means that every vertex may match every other vertex.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">induced</span></td><td class="fieldArgDesc">whether to consider induced subgraphs only.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">time<wbr></wbr>_limit</span></td><td class="fieldArgDesc">an optimal time limit in seconds. Only the integral part of this number is taken into account. If the time limit is exceeded, the method will throw an exception.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.get_subisomorphisms_vf2">
    
  </a>
  <a name="get_subisomorphisms_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_subisomorphisms_vf2</span>(other, color1=None, color2=None, edge_color1=None, edge_color2=None, node_compat_fn=None, edge_compat_fn=None):
    
    <a class="headerLink" href="#get_subisomorphisms_vf2" title="igraph._igraph.GraphBase.get_subisomorphisms_vf2">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns all subisomorphisms between the graph and another one</p>
<p>Vertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">the other graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the first graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the second graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the edges of the first graph. If <tt class="rst-docutils literal">None</tt>, all edges have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the edges of the second graph. If <tt class="rst-docutils literal">None</tt>, all edges have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">node<wbr></wbr>_compat<wbr></wbr>_fn</span></td><td class="fieldArgDesc">a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns <tt class="rst-docutils literal">True</tt> if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or <tt class="rst-docutils literal">False</tt> otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the <tt class="rst-docutils literal">color1</tt> and <tt class="rst-docutils literal">color2</tt> parameters). <tt class="rst-docutils literal">None</tt> means that every node is compatible with every other node.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_compat<wbr></wbr>_fn</span></td><td class="fieldArgDesc">a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns <tt class="rst-docutils literal">True</tt> if the edges given by the two indices are compatible (i.e. they could be matched to each other) or <tt class="rst-docutils literal">False</tt> otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the <tt class="rst-docutils literal">edge_color1</tt> and <tt class="rst-docutils literal">edge_color2</tt> parameters). <tt class="rst-docutils literal">None</tt> means that every edge is compatible with every other node.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of lists, each item of the list containing the mapping from vertices of the second graph to the vertices of the first one</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.girth">
    
  </a>
  <a name="girth">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">girth</span>(return_shortest_circle=False):
    
    <a class="headerLink" href="#girth" title="igraph._igraph.GraphBase.girth">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the girth of the graph.</p>
<p>The girth of a graph is the length of the shortest circle in it.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_shortest<wbr></wbr>_circle</span></td><td class="fieldArgDesc">whether to return one of the shortest circles found in the graph.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the length of the shortest circle or (if <tt class="rst-docutils literal">return_shortest_circle</tt>) is true, the shortest circle itself as a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.gomory_hu_tree">
    
  </a>
  <a name="gomory_hu_tree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">gomory_hu_tree</span>(capacity=None):
    
    <a class="headerLink" href="#gomory_hu_tree" title="igraph._igraph.GraphBase.gomory_hu_tree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.gomory_hu_tree()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Growing_Random">
    
  </a>
  <a name="Growing_Random">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Growing_Random</span>(n, m, directed=False, citation=False):
    
    <a class="headerLink" href="#Growing_Random" title="igraph._igraph.GraphBase.Growing_Random">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a growing random graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">The number of vertices in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">m</span></td><td class="fieldArgDesc">The number of edges to add in each step (after adding a new vertex)</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the graph should be directed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">citation</span></td><td class="fieldArgDesc">whether the new edges should originate from the most recently added vertex.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.harmonic_centrality">
    
  </a>
  <a name="harmonic_centrality">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">harmonic_centrality</span>(vertices=None, mode='all', cutoff=None, weights=None, normalized=True):
    
    <a class="headerLink" href="#harmonic_centrality" title="igraph._igraph.GraphBase.harmonic_centrality">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the harmonic centralities of given vertices in a graph.</p>
<p>The harmonic centerality of a vertex measures how easily other vertices can be reached from it (or the other way: how easily it can be reached from the other vertices). It is defined as the mean inverse distance to all other vertices.</p>
<p>If the graph is not connected, and there is no path between two vertices, the inverse distance is taken to be zero.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the vertices for which the harmonic centrality must be returned. If <tt class="rst-docutils literal">None</tt>, uses all of the vertices in the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">must be one of <tt class="rst-docutils literal">"in"</tt>, <tt class="rst-docutils literal">"out"</tt> and <tt class="rst-docutils literal">"all"</tt>. <tt class="rst-docutils literal">"in"</tt> means that the length of the incoming paths, <tt class="rst-docutils literal">"out"</tt> means that the length of the outgoing paths must be calculated. <tt class="rst-docutils literal">"all"</tt> means that both of them must be calculated.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cutoff</span></td><td class="fieldArgDesc">if it is not <tt class="rst-docutils literal">None</tt>, only paths less than or equal to this length are considered.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">normalized</span></td><td class="fieldArgDesc">Whether to normalize the result. If True, the result is the mean inverse path length to other vertices, i.e. it is normalized by the number of vertices minus one. If False, the result is the sum of inverse path lengths to other vertices.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated harmonic centralities in a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.has_multiple">
    
  </a>
  <a name="has_multiple">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">has_multiple</span>():
    
    <a class="headerLink" href="#has_multiple" title="igraph._igraph.GraphBase.has_multiple">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether the graph has multiple edges.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">boolean</td><td class="fieldArgDesc"><tt class="rst-docutils literal">True</tt> if the graph has at least one multiple edge, <tt class="rst-docutils literal">False</tt> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.hub_score">
    
  </a>
  <a name="hub_score">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">hub_score</span>(weights=None, scale=True, arpack_options=None, return_eigenvalue=False):
    
    <a class="headerLink" href="#hub_score" title="igraph._igraph.GraphBase.hub_score">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates Kleinberg's hub score for the vertices of the graph</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">scale</span></td><td class="fieldArgDesc">whether to normalize the scores so that the largest one is 1.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">arpack<wbr></wbr>_options</span></td><td class="fieldArgDesc">an <code><a href="igraph._igraph.ARPACKOptions.html" class="internal-link" title="igraph._igraph.ARPACKOptions">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <tt class="rst-docutils literal">arpack_options</tt> is used.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_eigenvalue</span></td><td class="fieldArgDesc">whether to return the largest eigenvalue</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the hub scores in a list and optionally the largest eigenvalue as a second member of a tuple</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">authority_score()</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.incident">
    
  </a>
  <a name="incident">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">incident</span>(vertex, mode='out'):
    
    <a class="headerLink" href="#incident" title="igraph._igraph.GraphBase.incident">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the edges a given vertex is incident on.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex</span></td><td class="fieldArgDesc">a vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">whether to return only successors (<tt class="rst-docutils literal">"out"</tt>), predecessors (<tt class="rst-docutils literal">"in"</tt>) or both (<tt class="rst-docutils literal">"all"</tt>). Ignored for undirected graphs.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.independence_number">
    
  </a>
  <a name="independence_number">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">independence_number</span>():
    
    <a class="headerLink" href="#independence_number" title="igraph._igraph.GraphBase.independence_number">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the independence number of the graph.</p>
<p>The independence number of the graph is the size of the largest independent vertex set.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#largest_independent_vertex_sets" class="internal-link" title="igraph._igraph.GraphBase.largest_independent_vertex_sets">largest_independent_vertex_sets()</a></code> for the largest independent vertex sets</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.independent_vertex_sets">
    
  </a>
  <a name="independent_vertex_sets">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">independent_vertex_sets</span>(min=0, max=0):
    
    <a class="headerLink" href="#independent_vertex_sets" title="igraph._igraph.GraphBase.independent_vertex_sets">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns some or all independent vertex sets of the graph as a list of tuples.</p>
<p>Two vertices are independent if there is no edge between them. Members of an independent vertex set are mutually independent.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">min</span></td><td class="fieldArgDesc">the minimum size of sets to be returned. If zero or negative, no lower bound will be used.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">max</span></td><td class="fieldArgDesc">the maximum size of sets to be returned. If zero or negative, no upper bound will be used.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.induced_subgraph">
    
  </a>
  <a name="induced_subgraph">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">induced_subgraph</span>(vertices, implementation='auto'):
    
    <a class="headerLink" href="#induced_subgraph" title="igraph._igraph.GraphBase.induced_subgraph">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns a subgraph spanned by the given vertices.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">a list containing the vertex IDs which should be included in the result.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">implementation</span></td><td class="fieldArgDesc">the implementation to use when constructing the new subgraph. igraph includes two implementations at the moment. <tt class="rst-docutils literal">"copy_and_delete"</tt> copies the original graph and removes those vertices that are not in the given set. This is more efficient if the size of the subgraph is comparable to the original graph. The other implementation (<tt class="rst-docutils literal">"create_from_scratch"</tt>) constructs the result graph from scratch and then copies the attributes accordingly. This is a better solution if the subgraph is relatively small, compared to the original graph. <tt class="rst-docutils literal">"auto"</tt> selects between the two implementations automatically, based on the ratio of the size of the subgraph and the size of the original graph.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the subgraph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.is_bipartite">
    
  </a>
  <a name="is_bipartite">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_bipartite</span>(return_types=False):
    
    <a class="headerLink" href="#is_bipartite" title="igraph._igraph.GraphBase.is_bipartite">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Decides whether the graph is bipartite or not.</p>
<p>Vertices of a bipartite graph can be partitioned into two groups A and B in a way that all edges go between the two groups.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_types</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">False</tt>, the method will simply return <tt class="rst-docutils literal">True</tt> or <tt class="rst-docutils literal">False</tt> depending on whether the graph is bipartite or not. If <tt class="rst-docutils literal">True</tt>, the actual group assignments are also returned as a list of boolean values. (Note that the group assignment is not unique, especially if the graph consists of multiple components, since the assignments of components are independent from each other).</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><tt class="rst-docutils literal">True</tt> if the graph is bipartite, <tt class="rst-docutils literal">False</tt> if not. If <tt class="rst-docutils literal">return_types</tt> is <tt class="rst-docutils literal">True</tt>, the group assignment is also returned.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.is_chordal">
    
  </a>
  <a name="is_chordal">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_chordal</span>(alpha=None, alpham1=None):
    
    <a class="headerLink" href="#is_chordal" title="igraph._igraph.GraphBase.is_chordal">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns whether the graph is chordal or not.</p>
<p>A graph is chordal if each of its cycles of four or more nodes has a chord, i.e. an edge joining two nodes that are not adjacent in the cycle. An equivalent definition is that any chordless cycles have at most three nodes.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">alpha</span></td><td class="fieldArgDesc">the alpha vector from the result of calling <code><a href="#maximum_cardinality_search" class="internal-link" title="igraph._igraph.GraphBase.maximum_cardinality_search">maximum_cardinality_search()</a></code> on the graph. Useful only if you already have the alpha vector; simply passing <tt class="rst-docutils literal">None</tt> here will make igraph calculate the alpha vector on its own.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">alpham1</span></td><td class="fieldArgDesc">the inverse alpha vector from the result of calling <code><a href="#maximum_cardinality_search" class="internal-link" title="igraph._igraph.GraphBase.maximum_cardinality_search">maximum_cardinality_search()</a></code> on the graph. Useful only if you already have the inverse alpha vector; simply passing <tt class="rst-docutils literal">None</tt> here will make igraph calculate the inverse alpha vector on its own.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><tt class="rst-docutils literal">True</tt> if the graph is chordal, <tt class="rst-docutils literal">False</tt> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.is_connected">
    
  </a>
  <a name="is_connected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_connected</span>(mode='strong'):
    
    <a class="headerLink" href="#is_connected" title="igraph._igraph.GraphBase.is_connected">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Decides whether the graph is connected.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">whether we should calculate strong or weak connectivity.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><tt class="rst-docutils literal">True</tt> if the graph is connected, <tt class="rst-docutils literal">False</tt> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.is_dag">
    
  </a>
  <a name="is_dag">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_dag</span>():
    
    <a class="headerLink" href="#is_dag" title="igraph._igraph.GraphBase.is_dag">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether the graph is a DAG (directed acyclic graph).</p>
<p>A DAG is a directed graph with no directed cycles.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">boolean</td><td class="fieldArgDesc"><tt class="rst-docutils literal">True</tt> if it is a DAG, <tt class="rst-docutils literal">False</tt> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.is_directed">
    
  </a>
  <a name="is_directed">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_directed</span>():
    
    <a class="headerLink" href="#is_directed" title="igraph._igraph.GraphBase.is_directed">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether the graph is directed.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">boolean</td><td class="fieldArgDesc"><tt class="rst-docutils literal">True</tt> if it is directed, <tt class="rst-docutils literal">False</tt> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.is_loop">
    
  </a>
  <a name="is_loop">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_loop</span>(edges=None):
    
    <a class="headerLink" href="#is_loop" title="igraph._igraph.GraphBase.is_loop">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether a specific set of edges contain loop edges</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">edge indices which we want to check. If <tt class="rst-docutils literal">None</tt>, all edges are checked.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of booleans, one for every edge given</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.is_minimal_separator">
    
  </a>
  <a name="is_minimal_separator">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_minimal_separator</span>(vertices):
    
    <a class="headerLink" href="#is_minimal_separator" title="igraph._igraph.GraphBase.is_minimal_separator">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Decides whether the given vertex set is a minimal separator.</p>
<p>A minimal separator is a set of vertices whose removal disconnects the graph, while the removal of any subset of the set keeps the graph connected.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">a single vertex ID or a list of vertex IDs</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><tt class="rst-docutils literal">True</tt> is the given vertex set is a minimal separator, <tt class="rst-docutils literal">False</tt> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.is_multiple">
    
  </a>
  <a name="is_multiple">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_multiple</span>(edges=None):
    
    <a class="headerLink" href="#is_multiple" title="igraph._igraph.GraphBase.is_multiple">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether an edge is a multiple edge.</p>
<p>Also works for a set of edges -- in this case, every edge is checked one by one. Note that if there are multiple edges going between a pair of vertices, there is always one of them that is <em>not</em> reported as multiple (only the others). This allows one to easily detect the edges that have to be deleted in order to make the graph free of multiple edges.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">edge indices which we want to check. If <tt class="rst-docutils literal">None</tt>, all edges are checked.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of booleans, one for every edge given</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.is_mutual">
    
  </a>
  <a name="is_mutual">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_mutual</span>(edges=None):
    
    <a class="headerLink" href="#is_mutual" title="igraph._igraph.GraphBase.is_mutual">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether an edge has an opposite pair.</p>
<p>Also works for a set of edges -- in this case, every edge is checked one by one. The result will be a list of booleans (or a single boolean if only an edge index is supplied), every boolean corresponding to an edge in the edge set supplied. <tt class="rst-docutils literal">True</tt> is returned for a given edge <span class="rst-math rst-formula"><i>a</i></span> --&gt; <span class="rst-math rst-formula"><i>b</i></span> if there exists another edge <span class="rst-math rst-formula"><i>b</i></span> --&gt; <span class="rst-math rst-formula"><i>a</i></span> in the original graph (not the given edge set!). All edges in an undirected graph are mutual. In case there are multiple edges between <span class="rst-math rst-formula"><i>a</i></span> and <span class="rst-math rst-formula"><i>b</i></span>, it is enough to have at least one edge in either direction to report all edges between them as mutual, so the multiplicity of edges do not matter.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">edge indices which we want to check. If <tt class="rst-docutils literal">None</tt>, all edges are checked.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of booleans, one for every edge given</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.is_separator">
    
  </a>
  <a name="is_separator">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_separator</span>(vertices):
    
    <a class="headerLink" href="#is_separator" title="igraph._igraph.GraphBase.is_separator">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Decides whether the removal of the given vertices disconnects the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">a single vertex ID or a list of vertex IDs</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><tt class="rst-docutils literal">True</tt> is the given vertex set is a separator, <tt class="rst-docutils literal">False</tt> if not.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.is_simple">
    
  </a>
  <a name="is_simple">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_simple</span>():
    
    <a class="headerLink" href="#is_simple" title="igraph._igraph.GraphBase.is_simple">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether the graph is simple (no loop or multiple edges).</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">boolean</td><td class="fieldArgDesc"><tt class="rst-docutils literal">True</tt> if it is simple, <tt class="rst-docutils literal">False</tt> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.is_tree">
    
  </a>
  <a name="is_tree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">is_tree</span>(mode='out'):
    
    <a class="headerLink" href="#is_tree" title="igraph._igraph.GraphBase.is_tree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether the graph is a (directed or undirected) tree graph.</p>
<p>For directed trees, the function may require that the edges are oriented outwards from the root or inwards to the root, depending on the value of the <tt class="rst-docutils literal">mode</tt> argument.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">for directed graphs, specifies how the edge directions should be taken into account. <tt class="rst-docutils literal">"all"</tt> means that the edge directions must be ignored, <tt class="rst-docutils literal">"out"</tt> means that the edges must be oriented away from the root, <tt class="rst-docutils literal">"in"</tt> means that the edges must be oriented towards the root. Ignored for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">boolean</td><td class="fieldArgDesc"><tt class="rst-docutils literal">True</tt> if the graph is a tree, <tt class="rst-docutils literal">False</tt> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Isoclass">
    
  </a>
  <a name="Isoclass">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Isoclass</span>(n, cls, directed=False):
    
    <a class="headerLink" href="#Isoclass" title="igraph._igraph.GraphBase.Isoclass">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph with a given isomorphism class.</p>
<p>Currently we support directed graphs of size 3 and 4, and undirected graphs of size 3, 4, 5 or 6. Use the <code><a href="#isoclass" class="internal-link" title="igraph._igraph.GraphBase.isoclass">isoclass()</a></code> instance method to find the isomorphism class of a given graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cls</span></td><td class="fieldArgDesc">the isomorphism class</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the graph should be directed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.isoclass">
    
  </a>
  <a name="isoclass">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">isoclass</span>(vertices):
    
    <a class="headerLink" href="#isoclass" title="igraph._igraph.GraphBase.isoclass">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the isomorphism class of the graph or its subgraph.</p>
<p>Isomorphism class calculations are implemented only for directed graphs with 3 or 4 vertices, or undirected graphs with 3, 4, 5 or 6 vertices..</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">a list of vertices if we want to calculate the isomorphism class for only a subset of vertices. <tt class="rst-docutils literal">None</tt> means to use the full graph.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the isomorphism class of the (sub)graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.isomorphic">
    
  </a>
  <a name="isomorphic">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">isomorphic</span>(other):
    
    <a class="headerLink" href="#isomorphic" title="igraph._igraph.GraphBase.isomorphic">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether the graph is isomorphic to another graph.</p>
<p>The algorithm being used is selected using a simple heuristic:</p>
<ul class="rst-simple">
<li>If one graph is directed and the other undirected, an exception is thrown.</li>
<li>If the two graphs does not have the same number of vertices and edges, it returns with <tt class="rst-docutils literal">False</tt></li>
<li>If the graphs have three or four vertices, then an O(1) algorithm is used with precomputed data.</li>
<li>Otherwise if the graphs are directed, then the VF2 isomorphism algorithm is used (see <code><a href="#isomorphic_vf2" class="internal-link" title="igraph._igraph.GraphBase.isomorphic_vf2">isomorphic_vf2</a></code>).</li>
<li>Otherwise the BLISS isomorphism algorithm is used, see <code><a href="#isomorphic_bliss" class="internal-link" title="igraph._igraph.GraphBase.isomorphic_bliss">isomorphic_bliss</a></code>.</li>
</ul>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><tt class="rst-docutils literal">True</tt> if the graphs are isomorphic, <tt class="rst-docutils literal">False</tt> otherwise.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.isomorphic_bliss">
    
  </a>
  <a name="isomorphic_bliss">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">isomorphic_bliss</span>(other, return_mapping_12=False, return_mapping_21=False, sh1='fl', sh2=None, color1=None, color2=None):
    
    <a class="headerLink" href="#isomorphic_bliss" title="igraph._igraph.GraphBase.isomorphic_bliss">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether the graph is isomorphic to another graph, using the BLISS isomorphism algorithm.</p>
<p>See <a class="rst-reference external" href="http://www.tcs.hut.fi/Software/bliss/index.html" target="_top">http://www.tcs.hut.fi/Software/bliss/index.html</a> for more information about the BLISS algorithm.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">the other graph with which we want to compare the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_mapping<wbr></wbr>_12</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, calculates the mapping which maps the vertices of the first graph to the second.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_mapping<wbr></wbr>_21</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, calculates the mapping which maps the vertices of the second graph to the first.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">sh1</span></td><td class="fieldArgDesc"><p>splitting heuristics for the first graph as a case-insensitive string, with the following possible values:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"f"</tt>: first non-singleton cell</li>
<li><tt class="rst-docutils literal">"fl"</tt>: first largest non-singleton cell</li>
<li><tt class="rst-docutils literal">"fs"</tt>: first smallest non-singleton cell</li>
<li><tt class="rst-docutils literal">"fm"</tt>: first maximally non-trivially connected non-singleton cell</li>
<li><tt class="rst-docutils literal">"flm"</tt>: largest maximally non-trivially connected non-singleton cell</li>
<li><tt class="rst-docutils literal">"fsm"</tt>: smallest maximally non-trivially connected non-singleton cell</li>
</ul>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">sh2</span></td><td class="fieldArgDesc">splitting heuristics to be used for the second graph. This must be the same as <tt class="rst-docutils literal">sh1</tt>; alternatively, it can be <tt class="rst-docutils literal">None</tt>, in which case it will automatically use the same value as <tt class="rst-docutils literal">sh1</tt>. Currently it is present for backwards compatibility only.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the first graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the second graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">if no mapping is calculated, the result is <tt class="rst-docutils literal">True</tt> if the graphs are isomorphic, <tt class="rst-docutils literal">False</tt> otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -&gt; 2 mapping and the third element being the 2 -&gt; 1 mapping. If the corresponding mapping was not calculated, <tt class="rst-docutils literal">None</tt> is returned in the appropriate element of the 3-tuple.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.isomorphic_vf2">
    
  </a>
  <a name="isomorphic_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">isomorphic_vf2</span>(other=None, color1=None, color2=None, edge_color1=None, edge_color2=None, return_mapping_12=False, return_mapping_21=False, node_compat_fn=None, edge_compat_fn=None, callback=None):
    
    <a class="headerLink" href="#isomorphic_vf2" title="igraph._igraph.GraphBase.isomorphic_vf2">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether the graph is isomorphic to another graph, using the VF2 isomorphism algorithm.</p>
<p>Vertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">the other graph with which we want to compare the graph. If <tt class="rst-docutils literal">None</tt>, the automorphjisms of the graph will be tested.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the first graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the second graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the edges of the first graph. If <tt class="rst-docutils literal">None</tt>, all edges have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the edges of the second graph. If <tt class="rst-docutils literal">None</tt>, all edges have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_mapping<wbr></wbr>_12</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, calculates the mapping which maps the vertices of the first graph to the second.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_mapping<wbr></wbr>_21</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, calculates the mapping which maps the vertices of the second graph to the first.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">node<wbr></wbr>_compat<wbr></wbr>_fn</span></td><td class="fieldArgDesc">a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns <tt class="rst-docutils literal">True</tt> if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or <tt class="rst-docutils literal">False</tt> otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the <tt class="rst-docutils literal">color1</tt> and <tt class="rst-docutils literal">color2</tt> parameters). <tt class="rst-docutils literal">None</tt> means that every node is compatible with every other node.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_compat<wbr></wbr>_fn</span></td><td class="fieldArgDesc">a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns <tt class="rst-docutils literal">True</tt> if the edges given by the two indices are compatible (i.e. they could be matched to each other) or <tt class="rst-docutils literal">False</tt> otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the <tt class="rst-docutils literal">edge_color1</tt> and <tt class="rst-docutils literal">edge_color2</tt> parameters). <tt class="rst-docutils literal">None</tt> means that every edge is compatible with every other node.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">callback</span></td><td class="fieldArgDesc">if not <tt class="rst-docutils literal">None</tt>, the isomorphism search will not stop at the first match; it will call this callback function instead for every isomorphism found. The callback function must accept four arguments: the first graph, the second graph, a mapping from the nodes of the first graph to the second, and a mapping from the nodes of the second graph to the first. The function must return <tt class="rst-docutils literal">True</tt> if the search should continue or <tt class="rst-docutils literal">False</tt> otherwise.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">if no mapping is calculated, the result is <tt class="rst-docutils literal">True</tt> if the graphs are isomorphic, <tt class="rst-docutils literal">False</tt> otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -&gt; 2 mapping and the third element being the 2 -&gt; 1 mapping. If the corresponding mapping was not calculated, <tt class="rst-docutils literal">None</tt> is returned in the appropriate element of the 3-tuple.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.K_Regular">
    
  </a>
  <a name="K_Regular">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">K_Regular</span>(n, k, directed=False, multiple=False):
    
    <a class="headerLink" href="#K_Regular" title="igraph._igraph.GraphBase.K_Regular">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a k-regular random graph</p>
<p>A k-regular random graph is a random graph where each vertex has degree k. If the graph is directed, both the in-degree and the out-degree of each vertex will be k.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">The number of vertices in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">k</span></td><td class="fieldArgDesc">The degree of each vertex if the graph is undirected, or the in-degree and out-degree of each vertex if the graph is directed</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the graph should be directed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">multiple</span></td><td class="fieldArgDesc">whether it is allowed to create multiple edges.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Kautz">
    
  </a>
  <a name="Kautz">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Kautz</span>(m, n):
    
    <a class="headerLink" href="#Kautz" title="igraph._igraph.GraphBase.Kautz">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a Kautz graph with parameters (m, n)</p>
<p>A Kautz graph is a labeled graph, vertices are labeled by strings of length <span class="rst-math rst-formula"><i>n</i> + 1</span> above an alphabet with <span class="rst-math rst-formula"><i>m</i> + 1</span> letters, with the restriction that every two consecutive letters in the string must be different. There is a directed edge from a vertex <span class="rst-math rst-formula"><i>v</i></span> to another vertex <span class="rst-math rst-formula"><i>w</i></span> if it is possible to transform the string of <span class="rst-math rst-formula"><i>v</i></span> into the string of <span class="rst-math rst-formula"><i>w</i></span> by removing the first letter and appending a letter to it.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">m</span></td><td class="fieldArgDesc">the size of the alphabet minus one</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the length of the strings minus one</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.knn">
    
  </a>
  <a name="knn">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">knn</span>(vids=None, weights=None):
    
    <a class="headerLink" href="#knn" title="igraph._igraph.GraphBase.knn">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the average degree of the neighbors for each vertex, and the same quantity as the function of vertex degree.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vids</span></td><td class="fieldArgDesc">the vertices for which the calculation is performed. <tt class="rst-docutils literal">None</tt> means all vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name. If this is given, the vertex strength will be used instead of the vertex degree in the calculations, but the "ordinary" vertex degree will be used for the second (degree- dependent) list in the result.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">two lists in a tuple. The first list contains the average degree of neighbors for each vertex, the second contains the average degree of neighbors as a function of vertex degree. The zeroth element of this list corresponds to vertices of degree 1.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.laplacian">
    
  </a>
  <a name="laplacian">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">laplacian</span>(weights=None, normalized=False):
    
    <a class="headerLink" href="#laplacian" title="igraph._igraph.GraphBase.laplacian">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the Laplacian matrix of a graph.</p>
<p>The Laplacian matrix is similar to the adjacency matrix, but the edges are denoted with -1 and the diagonal contains the node degrees.</p>
<p>Normalized Laplacian matrices have 1 or 0 in their diagonals (0 for vertices with no edges), edges are denoted by 1 / sqrt(d_i * d_j) where d_i is the degree of node i.</p>
<p>Multiple edges and self-loops are silently ignored. Although it is possible to calculate the Laplacian matrix of a directed graph, it does not make much sense.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name. When edge weights are used, the degree of a node is considered to be the weight of its incident edges.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">normalized</span></td><td class="fieldArgDesc">whether to return the normalized Laplacian matrix.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the Laplacian matrix.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.largest_cliques">
    
  </a>
  <a name="largest_cliques">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">largest_cliques</span>():
    
    <a class="headerLink" href="#largest_cliques" title="igraph._igraph.GraphBase.largest_cliques">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the largest cliques of the graph as a list of tuples.</p>
<p>Quite intuitively a clique is considered largest if there is no clique with more vertices in the whole graph. All largest cliques are maximal (i.e. nonextendable) but not all maximal cliques are largest.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#clique_number" class="internal-link" title="igraph._igraph.GraphBase.clique_number">clique_number()</a></code> for the size of the largest cliques or <code><a href="#maximal_cliques" class="internal-link" title="igraph._igraph.GraphBase.maximal_cliques">maximal_cliques()</a></code> for the maximal cliques</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.largest_independent_vertex_sets">
    
  </a>
  <a name="largest_independent_vertex_sets">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">largest_independent_vertex_sets</span>():
    
    <a class="headerLink" href="#largest_independent_vertex_sets" title="igraph._igraph.GraphBase.largest_independent_vertex_sets">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the largest independent vertex sets of the graph as a list of tuples.</p>
<p>Quite intuitively an independent vertex set is considered largest if there is no other set with more vertices in the whole graph. All largest sets are maximal (i.e. nonextendable) but not all maximal sets are largest.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#independence_number" class="internal-link" title="igraph._igraph.GraphBase.independence_number">independence_number()</a></code> for the size of the largest independent vertex sets or <code><a href="#maximal_independent_vertex_sets" class="internal-link" title="igraph._igraph.GraphBase.maximal_independent_vertex_sets">maximal_independent_vertex_sets()</a></code> for the maximal (nonextendable) independent vertex sets</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Lattice">
    
  </a>
  <a name="Lattice">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Lattice</span>(dim, nei=1, directed=False, mutual=True, circular=True):
    
    <a class="headerLink" href="#Lattice" title="igraph._igraph.GraphBase.Lattice">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a regular lattice.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">dim</span></td><td class="fieldArgDesc">list with the dimensions of the lattice</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">nei</span></td><td class="fieldArgDesc">value giving the distance (number of steps) within which two vertices will be connected.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to create a directed graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mutual</span></td><td class="fieldArgDesc">whether to create all connections as mutual in case of a directed graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">circular</span></td><td class="fieldArgDesc">whether the generated lattice is periodic.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_bipartite">
    
  </a>
  <a name="layout_bipartite">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_bipartite</span>(types='type', hgap=1, vgap=1, maxiter=100):
    
    <a class="headerLink" href="#layout_bipartite" title="igraph._igraph.GraphBase.layout_bipartite">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Place the vertices of a bipartite graph in two layers.</p>
<p>The layout is created by placing the vertices in two rows, according to their types. The positions of the vertices within the rows are then optimized to minimize the number of edge crossings using the heuristic used by the Sugiyama layout algorithm.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">types</span></td><td class="fieldArgDesc">an igraph vector containing the vertex types, or an attribute name. Anything that evalulates to <tt class="rst-docutils literal">False</tt> corresponds to vertices of the first kind, everything else to the second kind.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">hgap</span></td><td class="fieldArgDesc">minimum horizontal gap between vertices in the same layer.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vgap</span></td><td class="fieldArgDesc">vertical gap between the two layers.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxiter</span></td><td class="fieldArgDesc">maximum number of iterations to take in the crossing reduction step. Increase this if you feel that you are getting too many edge crossings.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_circle">
    
  </a>
  <a name="layout_circle">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_circle</span>(dim=2, order=None):
    
    <a class="headerLink" href="#layout_circle" title="igraph._igraph.GraphBase.layout_circle">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Places the vertices of the graph uniformly on a circle or a sphere.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">dim</span></td><td class="fieldArgDesc">the desired number of dimensions for the layout. dim=2 means a 2D layout, dim=3 means a 3D layout.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">order</span></td><td class="fieldArgDesc">the order in which the vertices are placed along the circle. Not supported when <em>dim</em> is not equal to 2.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_davidson_harel">
    
  </a>
  <a name="layout_davidson_harel">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_davidson_harel</span>(seed=None, maxiter=10, fineiter=-1, cool_fact=0.75, weight_node_dist=1.0, weight_border=0.0, weight_edge_lengths=-1, weight_edge_crossings=-1, weight_node_edge_dist=-1):
    
    <a class="headerLink" href="#layout_davidson_harel" title="igraph._igraph.GraphBase.layout_davidson_harel">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Places the vertices on a 2D plane according to the Davidson-Harel layout algorithm.</p>
<p>The algorithm uses simulated annealing and a sophisticated energy function, which is unfortunately hard to parameterize for different graphs. The original publication did not disclose any parameter values, and the ones below were determined by experimentation.</p>
<p>The algorithm consists of two phases: an annealing phase and a fine-tuning phase. There is no simulated annealing in the second phase.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">seed</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">None</tt>, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxiter</span></td><td class="fieldArgDesc">Number of iterations to perform in the annealing phase.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fineiter</span></td><td class="fieldArgDesc">Number of iterations to perform in the fine-tuning phase. Negative numbers set up a reasonable default from the base-2 logarithm of the vertex count, bounded by 10 from above.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cool<wbr></wbr>_fact</span></td><td class="fieldArgDesc">Cooling factor of the simulated annealing phase.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weight<wbr></wbr>_node<wbr></wbr>_dist</span></td><td class="fieldArgDesc">Weight for the node-node distances in the energy function.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weight<wbr></wbr>_border</span></td><td class="fieldArgDesc">Weight for the distance from the border component of the energy function. Zero means that vertices are allowed to sit on the border of the area designated for the layout.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weight<wbr></wbr>_edge<wbr></wbr>_lengths</span></td><td class="fieldArgDesc">Weight for the edge length component of the energy function. Negative numbers are replaced by the density of the graph divided by 10.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weight<wbr></wbr>_edge<wbr></wbr>_crossings</span></td><td class="fieldArgDesc">Weight for the edge crossing component of the energy function. Negative numbers are replaced by one minus the square root of the density of the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weight<wbr></wbr>_node<wbr></wbr>_edge<wbr></wbr>_dist</span></td><td class="fieldArgDesc">Weight for the node-edge distance component of the energy function. Negative numbers are replaced by 0.2 minus 0.2 times the density of the graph.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_drl">
    
  </a>
  <a name="layout_drl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_drl</span>(weights=None, fixed=None, seed=None, options=None, dim=2):
    
    <a class="headerLink" href="#layout_drl" title="igraph._igraph.GraphBase.layout_drl">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Places the vertices on a 2D plane or in the 3D space ccording to the DrL layout algorithm.</p>
<p>This is an algorithm suitable for quite large graphs, but it can be surprisingly slow for small ones (where the simpler force-based layouts like <tt class="rst-docutils literal">layout_kamada_kawai()</tt> or <tt class="rst-docutils literal">layout_fruchterman_reingold()</tt> are more useful.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fixed</span></td><td class="fieldArgDesc">ignored. We used to assume that the DrL layout supports fixed nodes, but later it turned out that the argument has no effect in the original DrL code. We kept the argument for sake of backwards compatibility, but it will have no effect on the final layout.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">seed</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">None</tt>, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">options</span></td><td class="fieldArgDesc"><p>if you give a string argument here, you can select from five default preset parameterisations: <tt class="rst-docutils literal">default</tt>, <tt class="rst-docutils literal">coarsen</tt> for a coarser layout, <tt class="rst-docutils literal">coarsest</tt> for an even coarser layout, <tt class="rst-docutils literal">refine</tt> for refining an existing layout and <tt class="rst-docutils literal">final</tt> for finalizing a layout. If you supply an object that is not a string, the DrL layout parameters are retrieved from the respective keys of the object (so it should be a dict or something else that supports the mapping protocol). The following keys can be used:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">edge_cut</tt>: edge cutting is done in the late stages of the algorithm in order to achieve less dense layouts. Edges are cut if there is a lot of stress on them (a large value in the objective function sum). The edge cutting parameter is a value between 0 and 1 with 0 representing no edge cutting and 1 representing maximal edge cutting.</li>
<li><tt class="rst-docutils literal">init_iterations</tt>: number of iterations in the initialization phase</li>
<li><tt class="rst-docutils literal">init_temperature</tt>: start temperature during initialization</li>
<li><tt class="rst-docutils literal">init_attraction</tt>: attraction during initialization</li>
<li><tt class="rst-docutils literal">init_damping_mult</tt>: damping multiplier during initialization</li>
<li><tt class="rst-docutils literal">liquid_iterations</tt>, <tt class="rst-docutils literal">liquid_temperature</tt>, <tt class="rst-docutils literal">liquid_attraction</tt>, <tt class="rst-docutils literal">liquid_damping_mult</tt>: same parameters for the liquid phase</li>
<li><tt class="rst-docutils literal">expansion_iterations</tt>, <tt class="rst-docutils literal">expansion_temperature</tt>, <tt class="rst-docutils literal">expansion_attraction</tt>, <tt class="rst-docutils literal">expansion_damping_mult</tt>: parameters for the expansion phase</li>
<li><tt class="rst-docutils literal"><span class="pre">cooldown_...</span></tt>: parameters for the cooldown phase</li>
<li><tt class="rst-docutils literal"><span class="pre">crunch_...</span></tt>: parameters for the crunch phase</li>
<li><tt class="rst-docutils literal"><span class="pre">simmer_...</span></tt>: parameters for the simmer phase</li>
</ul>
<p>Instead of a mapping, you can also use an arbitrary Python object here: if the object does not support the mapping protocol, an attribute of the object with the same name is looked up instead. If a parameter cannot be found either as a key or an attribute, the default from the <tt class="rst-docutils literal">default</tt> preset will be used.</p>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">dim</span></td><td class="fieldArgDesc">the desired number of dimensions for the layout. dim=2 means a 2D layout, dim=3 means a 3D layout.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_fruchterman_reingold">
    
  </a>
  <a name="layout_fruchterman_reingold">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_fruchterman_reingold</span>(weights=None, niter=500, seed=None, start_temp=None, minx=None, maxx=None, miny=None, maxy=None, minz=None, maxz=None, grid='auto'):
    
    <a class="headerLink" href="#layout_fruchterman_reingold" title="igraph._igraph.GraphBase.layout_fruchterman_reingold">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Places the vertices on a 2D plane according to the Fruchterman-Reingold algorithm.</p>
<p>This is a force directed layout, see Fruchterman, T. M. J. and Reingold, E. M.: Graph Drawing by Force-directed Placement. Software -- Practice and Experience, 21/11, 1129--1164, 1991</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">niter</span></td><td class="fieldArgDesc">the number of iterations to perform. The default is 500.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">seed</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">None</tt>, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">start<wbr></wbr>_temp</span></td><td class="fieldArgDesc">Real scalar, the start temperature. This is the maximum amount of movement alloved along one axis, within one step, for a vertex. Currently it is decreased linearly to zero during the iteration. The default is the square root of the number of vertices divided by 10.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">minx</span></td><td class="fieldArgDesc">if not <tt class="rst-docutils literal">None</tt>, it must be a vector with exactly as many elements as there are vertices in the graph. Each element is a minimum constraint on the X value of the vertex in the layout.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxx</span></td><td class="fieldArgDesc">similar to <em>minx</em>, but with maximum constraints</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">miny</span></td><td class="fieldArgDesc">similar to <em>minx</em>, but with the Y coordinates</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxy</span></td><td class="fieldArgDesc">similar to <em>maxx</em>, but with the Y coordinates</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">minz</span></td><td class="fieldArgDesc">similar to <em>minx</em>, but with the Z coordinates. Use only for 3D layouts (<tt class="rst-docutils literal">dim</tt>=3).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxz</span></td><td class="fieldArgDesc">similar to <em>maxx</em>, but with the Z coordinates. Use only for 3D layouts (<tt class="rst-docutils literal">dim</tt>=3).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">grid</span></td><td class="fieldArgDesc">whether to use a faster, but less accurate grid-based implementation of the algorithm. <tt class="rst-docutils literal">"auto"</tt> decides based on the number of vertices in the graph; a grid will be used if there are at least 1000 vertices. <tt class="rst-docutils literal">"grid"</tt> is equivalent to <tt class="rst-docutils literal">True</tt>, <tt class="rst-docutils literal">"nogrid"</tt> is equivalent to <tt class="rst-docutils literal">False</tt>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_graphopt">
    
  </a>
  <a name="layout_graphopt">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_graphopt</span>(niter=500, node_charge=0.001, node_mass=30, spring_length=0, spring_constant=1, max_sa_movement=5, seed=None):
    
    <a class="headerLink" href="#layout_graphopt" title="igraph._igraph.GraphBase.layout_graphopt">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>This is a port of the graphopt layout algorithm by Michael Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for layers was removed.</p>
<p>graphopt uses physical analogies for defining attracting and repelling forces among the vertices and then the physical system is simulated until it reaches an equilibrium or the maximal number of iterations is reached.</p>
<p>See <a class="rst-reference external" href="http://www.schmuhl.org/graphopt/" target="_top">http://www.schmuhl.org/graphopt/</a> for the original graphopt.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">niter</span></td><td class="fieldArgDesc">the number of iterations to perform. Should be a couple of hundred in general.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">node<wbr></wbr>_charge</span></td><td class="fieldArgDesc">the charge of the vertices, used to calculate electric repulsion.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">node<wbr></wbr>_mass</span></td><td class="fieldArgDesc">the mass of the vertices, used for the spring forces</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">spring<wbr></wbr>_length</span></td><td class="fieldArgDesc">the length of the springs</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">spring<wbr></wbr>_constant</span></td><td class="fieldArgDesc">the spring constant</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">max<wbr></wbr>_sa<wbr></wbr>_movement</span></td><td class="fieldArgDesc">the maximum amount of movement allowed in a single step along a single axis.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">seed</span></td><td class="fieldArgDesc">a matrix containing a seed layout from which the algorithm will be started. If <tt class="rst-docutils literal">None</tt>, a random layout will be used.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_grid">
    
  </a>
  <a name="layout_grid">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_grid</span>(width=0, height=0, dim=2):
    
    <a class="headerLink" href="#layout_grid" title="igraph._igraph.GraphBase.layout_grid">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Places the vertices of a graph in a 2D or 3D grid.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">width</span></td><td class="fieldArgDesc">the number of vertices in a single row of the layout. Zero or negative numbers mean that the width should be determined automatically.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">height</span></td><td class="fieldArgDesc">the number of vertices in a single column of the layout. Zero or negative numbers mean that the height should be determined automatically. It must not be given if the number of dimensions is 2.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">dim</span></td><td class="fieldArgDesc">the desired number of dimensions for the layout. dim=2 means a 2D layout, dim=3 means a 3D layout.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_kamada_kawai">
    
  </a>
  <a name="layout_kamada_kawai">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_kamada_kawai</span>(maxiter=1000, epsilon=0, kkconst=None, seed=None, minx=None, maxx=None, miny=None, maxy=None, minz=None, maxz=None, dim=2):
    
    <a class="headerLink" href="#layout_kamada_kawai" title="igraph._igraph.GraphBase.layout_kamada_kawai">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Places the vertices on a plane according to the Kamada-Kawai algorithm.</p>
<p>This is a force directed layout, see Kamada, T. and Kawai, S.: An Algorithm for Drawing General Undirected Graphs. Information Processing Letters, 31/1, 7--15, 1989.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxiter</span></td><td class="fieldArgDesc">the maximum number of iterations to perform.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">epsilon</span></td><td class="fieldArgDesc">quit if the energy of the system changes less than epsilon. See the original paper for details.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">kkconst</span></td><td class="fieldArgDesc">the Kamada-Kawai vertex attraction constant. <tt class="rst-docutils literal">None</tt> means the square of the number of vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">seed</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">None</tt>, uses a random starting layout for the algorithm. If a matrix (list of lists), uses the given matrix as the starting position.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">minx</span></td><td class="fieldArgDesc">if not <tt class="rst-docutils literal">None</tt>, it must be a vector with exactly as many elements as there are vertices in the graph. Each element is a minimum constraint on the X value of the vertex in the layout.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxx</span></td><td class="fieldArgDesc">similar to <em>minx</em>, but with maximum constraints</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">miny</span></td><td class="fieldArgDesc">similar to <em>minx</em>, but with the Y coordinates</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxy</span></td><td class="fieldArgDesc">similar to <em>maxx</em>, but with the Y coordinates</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">minz</span></td><td class="fieldArgDesc">similar to <em>minx</em>, but with the Z coordinates. Use only for 3D layouts (<tt class="rst-docutils literal">dim</tt>=3).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxz</span></td><td class="fieldArgDesc">similar to <em>maxx</em>, but with the Z coordinates. Use only for 3D layouts (<tt class="rst-docutils literal">dim</tt>=3).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">dim</span></td><td class="fieldArgDesc">the desired number of dimensions for the layout. dim=2 means a 2D layout, dim=3 means a 3D layout.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_lgl">
    
  </a>
  <a name="layout_lgl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_lgl</span>(maxiter=150, maxdelta=-1, area=-1, coolexp=1.5, repulserad=-1, cellsize=-1, root=None):
    
    <a class="headerLink" href="#layout_lgl" title="igraph._igraph.GraphBase.layout_lgl">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Places the vertices on a 2D plane according to the Large Graph Layout.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxiter</span></td><td class="fieldArgDesc">the number of iterations to perform.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">maxdelta</span></td><td class="fieldArgDesc">the maximum distance to move a vertex in an iteration. If negative, defaults to the number of vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">area</span></td><td class="fieldArgDesc">the area of the square on which the vertices will be placed. If negative, defaults to the number of vertices squared.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">coolexp</span></td><td class="fieldArgDesc">the cooling exponent of the simulated annealing.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">repulserad</span></td><td class="fieldArgDesc">determines the radius at which vertex-vertex repulsion cancels out attraction of adjacent vertices. If negative, defaults to <span class="rst-math rst-formula"><i>area</i></span> times the number of vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cellsize</span></td><td class="fieldArgDesc">the size of the grid cells. When calculating the repulsion forces, only vertices in the same or neighboring grid cells are taken into account. Defaults to the fourth root of <span class="rst-math rst-formula"><i>area</i></span>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">root</span></td><td class="fieldArgDesc">the root vertex, this is placed first, its neighbors in the first iteration, second neighbors in the second, etc. <tt class="rst-docutils literal">None</tt> means that a random vertex will be chosen.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_mds">
    
  </a>
  <a name="layout_mds">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_mds</span>(dist=None, dim=2, arpack_options=None):
    
    <a class="headerLink" href="#layout_mds" title="igraph._igraph.GraphBase.layout_mds">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Places the vertices in an Euclidean space with the given number of dimensions using multidimensional scaling.</p>
<p>This layout requires a distance matrix, where the intersection of row <span class="rst-math rst-formula"><i>i</i></span> and column <span class="rst-math rst-formula"><i>j</i></span> specifies the desired distance between vertex <span class="rst-math rst-formula"><i>i</i></span> and vertex <span class="rst-math rst-formula"><i>j</i></span>. The algorithm will try to place the vertices in a way that approximates the distance relations prescribed in the distance matrix. igraph uses the classical multidimensional scaling by Torgerson (see reference below).</p>
<p>For unconnected graphs, the method will decompose the graph into weakly connected components and then lay out the components individually using the appropriate parts of the distance matrix.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">dist</span></td><td class="fieldArgDesc">the distance matrix. It must be symmetric and the symmetry is not checked -- results are unspecified when a non-symmetric distance matrix is used. If this parameter is <tt class="rst-docutils literal">None</tt>, the shortest path lengths will be used as distances. Directed graphs are treated as undirected when calculating the shortest path lengths to ensure symmetry.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">dim</span></td><td class="fieldArgDesc">the number of dimensions. For 2D layouts, supply 2 here; for 3D layouts, supply 3.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">arpack<wbr></wbr>_options</span></td><td class="fieldArgDesc">an <code><a href="igraph._igraph.ARPACKOptions.html" class="internal-link" title="igraph._igraph.ARPACKOptions">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <tt class="rst-docutils literal">arpack_options</tt> is used.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Cox &amp; Cox: Multidimensional Scaling (1994), Chapman and Hall, London.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_random">
    
  </a>
  <a name="layout_random">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_random</span>(dim=2):
    
    <a class="headerLink" href="#layout_random" title="igraph._igraph.GraphBase.layout_random">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Places the vertices of the graph randomly.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">dim</span></td><td class="fieldArgDesc">the desired number of dimensions for the layout. dim=2 means a 2D layout, dim=3 means a 3D layout.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the coordinate pairs in a list.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_reingold_tilford">
    
  </a>
  <a name="layout_reingold_tilford">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_reingold_tilford</span>(mode='out', root=None, rootlevel=None):
    
    <a class="headerLink" href="#layout_reingold_tilford" title="igraph._igraph.GraphBase.layout_reingold_tilford">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Places the vertices on a 2D plane according to the Reingold-Tilford layout algorithm.</p>
<p>This is a tree layout. If the given graph is not a tree, a breadth-first search is executed first to obtain a possible spanning tree.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">specifies which edges to consider when builing the tree. If it is <tt class="rst-docutils literal">OUT</tt> then only the outgoing, if it is <tt class="rst-docutils literal">IN</tt> then only the incoming edges of a parent are considered. If it is <tt class="rst-docutils literal">ALL</tt> then all edges are used (this was the behaviour in igraph 0.5 and before). This parameter also influences how the root vertices are calculated if they are not given. See the <em>root</em> parameter.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">root</span></td><td class="fieldArgDesc">the index of the root vertex or root vertices. If this is a non-empty vector then the supplied vertex IDs are used as the roots of the trees (or a single tree if the graph is connected). If this is <tt class="rst-docutils literal">None</tt> or an empty list, the root vertices are automatically calculated in such a way so that all other vertices would be reachable from them. Currently, automatic root selection prefers low eccentricity vertices in small graphs (fewer than 500 vertices) and high degree vertices in large graphs. This heuristic may change in future versions. Specify roots manually for a consistent output.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">rootlevel</span></td><td class="fieldArgDesc">this argument is useful when drawing forests which are not trees. It specifies the level of the root vertices for every tree in the forest.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">layout_reingold_tilford_circular</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">EM Reingold, JS Tilford: <em>Tidier Drawings of Trees.</em> IEEE Transactions on Software Engineering 7:22, 223-228, 1981.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_reingold_tilford_circular">
    
  </a>
  <a name="layout_reingold_tilford_circular">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_reingold_tilford_circular</span>(mode='out', root=None, rootlevel=None):
    
    <a class="headerLink" href="#layout_reingold_tilford_circular" title="igraph._igraph.GraphBase.layout_reingold_tilford_circular">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Circular Reingold-Tilford layout for trees.</p>
<p>This layout is similar to the Reingold-Tilford layout, but the vertices are placed in a circular way, with the root vertex in the center.</p>
<p>See <code><a href="#layout_reingold_tilford" class="internal-link" title="igraph._igraph.GraphBase.layout_reingold_tilford">layout_reingold_tilford</a></code> for the explanation of the parameters.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">layout_reingold_tilford</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">EM Reingold, JS Tilford: <em>Tidier Drawings of Trees.</em> IEEE Transactions on Software Engineering 7:22, 223-228, 1981.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.layout_star">
    
  </a>
  <a name="layout_star">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">layout_star</span>(center=0, order=None):
    
    <a class="headerLink" href="#layout_star" title="igraph._igraph.GraphBase.layout_star">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates a star-like layout for the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">center</span></td><td class="fieldArgDesc">the ID of the vertex to put in the center</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">order</span></td><td class="fieldArgDesc">a numeric vector giving the order of the vertices (including the center vertex!). If it is <tt class="rst-docutils literal">None</tt>, the vertices will be placed in increasing vertex ID order.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated layout.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.LCF">
    
  </a>
  <a name="LCF">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">LCF</span>(n, shifts, repeats):
    
    <a class="headerLink" href="#LCF" title="igraph._igraph.GraphBase.LCF">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph from LCF notation.</p>
<p>LCF is short for Lederberg-Coxeter-Frucht, it is a concise notation for 3-regular Hamiltonian graphs. It consists of three parameters, the number of vertices in the graph, a list of shifts giving additional edges to a cycle backbone and another integer giving how many times the shifts should be performed. See <a class="rst-reference external" href="http://mathworld.wolfram.com/LCFNotation.html" target="_top">http://mathworld.wolfram.com/LCFNotation.html</a> for details.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">shifts</span></td><td class="fieldArgDesc">the shifts in a list or tuple</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">repeats</span></td><td class="fieldArgDesc">the number of repeats</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.linegraph">
    
  </a>
  <a name="linegraph">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">linegraph</span>():
    
    <a class="headerLink" href="#linegraph" title="igraph._igraph.GraphBase.linegraph">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the line graph of the graph.</p>
<p>The line graph <span class="rst-math rst-formula"><i>L</i>(<i>G</i>)</span> of an undirected graph is defined as follows: <span class="rst-math rst-formula"><i>L</i>(<i>G</i>)</span> has one vertex for each edge in G and two vertices in <span class="rst-math rst-formula"><i>L</i>(<i>G</i>)</span> are connected iff their corresponding edges in the original graph share an end point.</p>
<p>The line graph of a directed graph is slightly different: two vertices are connected by a directed edge iff the target of the first vertex's corresponding edge is the same as the source of the second vertex's corresponding edge.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.maxdegree">
    
  </a>
  <a name="maxdegree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maxdegree</span>(vertices=None, mode='all', loops=False):
    
    <a class="headerLink" href="#maxdegree" title="igraph._igraph.GraphBase.maxdegree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the maximum degree of a vertex set in the graph.</p>
<p>This method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the degree of the given vertices (in the form of a single integer or a list, depending on the input parameter).</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">a single vertex ID or a list of vertex IDs, or <tt class="rst-docutils literal">None</tt> meaning all the vertices in the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">the type of degree to be returned (<tt class="rst-docutils literal">"out"</tt> for out-degrees, <tt class="rst-docutils literal">"in"</tt> IN for in-degrees or <tt class="rst-docutils literal">"all"</tt> for the sum of them).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether self-loops should be counted.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.maxflow">
    
  </a>
  <a name="maxflow">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maxflow</span>(source, target, capacity=None):
    
    <a class="headerLink" href="#maxflow" title="igraph._igraph.GraphBase.maxflow">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Returns the maximum flow between the source and target vertices.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">capacity</span></td><td class="fieldArgDesc">the capacity of the edges. It must be a list or a valid attribute name or <tt class="rst-docutils literal">None</tt>. In the latter case, every edge will have the same capacity.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a tuple containing the following: the value of the maximum flow between the given vertices, the flow value on all the edges, the edge IDs that are part of the corresponding minimum cut, and the vertex IDs on one side of the cut. For directed graphs, the flow value vector gives the flow value on each edge. For undirected graphs, the flow value is positive if the flow goes from the smaller vertex ID to the bigger one and negative if the flow goes from the bigger vertex ID to the smaller.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> which wraps the result in a <code><a href="igraph.cut.Flow.html" class="internal-link" title="igraph.cut.Flow">Flow</a></code> object. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.maxflow_value">
    
  </a>
  <a name="maxflow_value">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maxflow_value</span>(source, target, capacity=None):
    
    <a class="headerLink" href="#maxflow_value" title="igraph._igraph.GraphBase.maxflow_value">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the value of the maximum flow between the source and target vertices.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">capacity</span></td><td class="fieldArgDesc">the capacity of the edges. It must be a list or a valid attribute name or <tt class="rst-docutils literal">None</tt>. In the latter case, every edge will have the same capacity.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the value of the maximum flow between the given vertices</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.maximal_cliques">
    
  </a>
  <a name="maximal_cliques">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maximal_cliques</span>(min=0, max=0, file=None):
    
    <a class="headerLink" href="#maximal_cliques" title="igraph._igraph.GraphBase.maximal_cliques">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the maximal cliques of the graph as a list of tuples.</p>
<p>A maximal clique is a clique which can't be extended by adding any other vertex to it. A maximal clique is not necessarily one of the largest cliques in the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">min</span></td><td class="fieldArgDesc">the minimum size of maximal cliques to be returned. If zero or negative, no lower bound will be used.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">max</span></td><td class="fieldArgDesc">the maximum size of maximal cliques to be returned. If zero or negative, no upper bound will be used. If nonzero, the size of every maximal clique found will be compared to this value and a clique will be returned only if its size is smaller than this limit.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">file</span></td><td class="fieldArgDesc">a file object or the name of the file to write the results to. When this argument is <tt class="rst-docutils literal">None</tt>, the maximal cliques will be returned as a list of lists.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the maximal cliques of the graph as a list of lists, or <tt class="rst-docutils literal">None</tt> if the <tt class="rst-docutils literal">file</tt> argument was given.@see: <code><a href="#largest_cliques" class="internal-link" title="igraph._igraph.GraphBase.largest_cliques">largest_cliques()</a></code> for the largest cliques.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.maximal_independent_vertex_sets">
    
  </a>
  <a name="maximal_independent_vertex_sets">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maximal_independent_vertex_sets</span>():
    
    <a class="headerLink" href="#maximal_independent_vertex_sets" title="igraph._igraph.GraphBase.maximal_independent_vertex_sets">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the maximal independent vertex sets of the graph as a list of tuples.</p>
<p>A maximal independent vertex set is an independent vertex set which can't be extended by adding any other vertex to it. A maximal independent vertex set is not necessarily one of the largest independent vertex sets in the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#largest_independent_vertex_sets" class="internal-link" title="igraph._igraph.GraphBase.largest_independent_vertex_sets">largest_independent_vertex_sets()</a></code> for the largest independent vertex sets</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka: <em>A new algorithm for generating all the maximal independent sets</em>. SIAM J Computing, 6:505--517, 1977.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.maximum_cardinality_search">
    
  </a>
  <a name="maximum_cardinality_search">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">maximum_cardinality_search</span>():
    
    <a class="headerLink" href="#maximum_cardinality_search" title="igraph._igraph.GraphBase.maximum_cardinality_search">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Conducts a maximum cardinality search on the graph. The function computes a rank <em>alpha</em> for each vertex such that visiting vertices in decreasing rank order corresponds to always choosing the vertex with the most already visited neighbors as the next one to visit.</p>
<p>Maximum cardinality search is useful in deciding the chordality of a graph: a graph is chordal if and only if any two neighbors of a vertex that are higher in rank than the original vertex are connected to each other.</p>
<p>The result of this function can be passed to <code><a href="#is_chordal" class="internal-link" title="igraph._igraph.GraphBase.is_chordal">is_chordal()</a></code> to speed up the chordality computation if you also need the result of the maximum cardinality search for other purposes.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a tuple consisting of the rank vector and its inverse.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.mincut">
    
  </a>
  <a name="mincut">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">mincut</span>(source=None, target=None, capacity=None):
    
    <a class="headerLink" href="#mincut" title="igraph._igraph.GraphBase.mincut">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Calculates the minimum cut between the source and target vertices or within the whole graph.</p>
<p>The minimum cut is the minimum set of edges that needs to be removed to separate the source and the target (if they are given) or to disconnect the graph (if the source and target are not given). The minimum is calculated using the weights (capacities) of the edges, so the cut with the minimum total capacity is calculated. For undirected graphs and no source and target, the method uses the Stoer-Wagner algorithm. For a given source and target, the method uses the push-relabel algorithm; see the references below.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex ID. If <tt class="rst-docutils literal">None</tt>, target must also be {None} and the calculation will be done for the entire graph (i.e. all possible vertex pairs).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex ID. If <tt class="rst-docutils literal">None</tt>, source must also be {None} and the calculation will be done for the entire graph (i.e. all possible vertex pairs).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">capacity</span></td><td class="fieldArgDesc">the capacity of the edges. It must be a list or a valid attribute name or <tt class="rst-docutils literal">None</tt>. In the latter case, every edge will have the same capacity.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> which wraps the result in a <code><a href="igraph.cut.Cut.html" class="internal-link" title="igraph.cut.Cut">Cut</a></code> object. It is advised to use that.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">M. Stoer, F. Wagner: A simple min-cut algorithm. Journal of the ACM 44(4):585-591, 1997.</td></tr><tr><td colspan="2">A. V. Goldberg, R. E. Tarjan: A new approach to the maximum-flow problem. Journal of the ACM 35(4):921-940, 1988.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.mincut_value">
    
  </a>
  <a name="mincut_value">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">mincut_value</span>(source=-1, target=-1, capacity=None):
    
    <a class="headerLink" href="#mincut_value" title="igraph._igraph.GraphBase.mincut_value">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the minimum cut between the source and target vertices or within the whole graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex ID. If negative, the calculation is done for every vertex except the target and the minimum is returned.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex ID. If negative, the calculation is done for every vertex except the source and the minimum is returned.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">capacity</span></td><td class="fieldArgDesc">the capacity of the edges. It must be a list or a valid attribute name or <tt class="rst-docutils literal">None</tt>. In the latter case, every edge will have the same capacity.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the value of the minimum cut between the given vertices</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.minimum_size_separators">
    
  </a>
  <a name="minimum_size_separators">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">minimum_size_separators</span>():
    
    <a class="headerLink" href="#minimum_size_separators" title="igraph._igraph.GraphBase.minimum_size_separators">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns a list containing all separator vertex sets of minimum size.</p>
<p>A vertex set is a separator if its removal disconnects the graph. This method lists all the separators for which no smaller separator set exists in the given graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list where each item lists the vertex indices of a given separator of minimum size.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Arkady Kanevsky: Finding all minimum-size separating vertex sets in a graph. Networks 23:533--541, 1993.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.modularity">
    
  </a>
  <a name="modularity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">modularity</span>(membership, weights=None, resolution=1, directed=True):
    
    <a class="headerLink" href="#modularity" title="igraph._igraph.GraphBase.modularity">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Calculates the modularity of the graph with respect to some vertex types.</p>
<p>The modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It is defined as <span class="rst-math rst-formula"><i>Q</i> = 1 ⁄ (2<i>m</i>)*<i>sum</i>(<i>Aij</i> − <i>gamma</i>*<i>ki</i>*<i>kj</i> ⁄ (2<i>m</i>)<i>delta</i>(<i>ci</i>, <i>cj</i>), <i>i</i>, <i>j</i>)</span>. <span class="rst-math rst-formula"><i>m</i></span> is the number of edges, <span class="rst-math rst-formula"><i>Aij</i></span> is the element of the <span class="rst-math rst-formula"><i>A</i></span> adjacency matrix in row <span class="rst-math rst-formula"><i>i</i></span> and column <span class="rst-math rst-formula"><i>j</i></span>, <span class="rst-math rst-formula"><i>ki</i></span> is the degree of node <span class="rst-math rst-formula"><i>i</i></span>, <span class="rst-math rst-formula"><i>kj</i></span> is the degree of node <span class="rst-math rst-formula"><i>j</i></span>, <span class="rst-math rst-formula"><i>Ci</i></span> and <tt class="rst-docutils literal">cj</tt> are the types of the two vertices (<span class="rst-math rst-formula"><i>i</i></span> and <span class="rst-math rst-formula"><i>j</i></span>), and <span class="rst-math rst-formula"><i>gamma</i></span> is a resolution parameter that defaults to 1 for the classical definition of modularity. <span class="rst-math rst-formula"><i>delta</i>(<i>x</i>, <i>y</i>)</span> is one iff <span class="rst-math rst-formula"><i>x</i> = <i>y</i></span>, 0 otherwise.</p>
<p>If edge weights are given, the definition of modularity is modified as follows: <span class="rst-math rst-formula"><i>Aij</i></span> becomes the weight of the corresponding edge, <span class="rst-math rst-formula"><i>ki</i></span> is the total weight of edges incident on vertex <span class="rst-math rst-formula"><i>i</i></span>, <span class="rst-math rst-formula"><i>kj</i></span> is the total weight of edges incident on vertex <span class="rst-math rst-formula"><i>j</i></span> and <span class="rst-math rst-formula"><i>m</i></span> is the total edge weight in the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">membership</span></td><td class="fieldArgDesc">the membership vector, e.g. the vertex type index for each vertex.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">optional edge weights or <tt class="rst-docutils literal">None</tt> if all edges are weighed equally.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">resolution</span></td><td class="fieldArgDesc">the resolution parameter <em>gamma</em> in the formula above. The classical definition of modularity is retrieved when the resolution parameter is set to 1.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider edge directions if the graph is directed. <tt class="rst-docutils literal">True</tt> will use the directed variant of the modularity measure where the in- and out-degrees of nodes are treated separately; <tt class="rst-docutils literal">False</tt> will treat directed graphs as undirected.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the modularity score. Score larger than 0.3 usually indicates strong community structure.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">method overridden in <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> to allow <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> objects as a parameter. This method is not strictly necessary, since the <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> class provides a variable called <tt class="rst-docutils literal">modularity</tt>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.motifs_randesu">
    
  </a>
  <a name="motifs_randesu">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">motifs_randesu</span>(size=3, cut_prob=None, callback=None):
    
    <a class="headerLink" href="#motifs_randesu" title="igraph._igraph.GraphBase.motifs_randesu">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Counts the number of motifs in the graph</p>
<p>Motifs are small subgraphs of a given structure in a graph. It is argued that the motif profile (ie. the number of different motifs in the graph) is characteristic for different types of networks and network function is related to the motifs in the graph.</p>
<p>Currently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.</p>
<p>In a big network the total number of motifs can be very large, so it takes a lot of time to find all of them. In such cases, a sampling method can be used. This function is capable of doing sampling via the <em>cut_prob</em> argument. This argument gives the probability that a branch of the motif search tree will not be explored.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">size</span></td><td class="fieldArgDesc">the size of the motifs</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cut<wbr></wbr>_prob</span></td><td class="fieldArgDesc">the cut probabilities for different levels of the search tree. This must be a list of length <em>size</em> or <tt class="rst-docutils literal">None</tt> to find all motifs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">callback</span></td><td class="fieldArgDesc"><tt class="rst-docutils literal">None</tt> or a callable that will be called for every motif found in the graph. The callable must accept three parameters: the graph itself, the list of vertices in the motif and the isomorphism class of the motif (see <code><a href="#isoclass" class="internal-link" title="igraph._igraph.GraphBase.isoclass">isoclass()</a></code>). The search will stop when the callback returns an object with a non-zero truth value or raises an exception.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the list of motifs if <em>callback</em> is <tt class="rst-docutils literal">None</tt>, or <tt class="rst-docutils literal">None</tt> otherwise</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.motifs_randesu_no()</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.motifs_randesu_estimate">
    
  </a>
  <a name="motifs_randesu_estimate">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">motifs_randesu_estimate</span>(size=3, cut_prob=None, sample=None):
    
    <a class="headerLink" href="#motifs_randesu_estimate" title="igraph._igraph.GraphBase.motifs_randesu_estimate">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Counts the total number of motifs in the graph</p>
<p>Motifs are small subgraphs of a given structure in a graph. This function estimates the total number of motifs in a graph without assigning isomorphism classes to them by extrapolating from a random sample of vertices.</p>
<p>Currently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">size</span></td><td class="fieldArgDesc">the size of the motifs</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cut<wbr></wbr>_prob</span></td><td class="fieldArgDesc">the cut probabilities for different levels of the search tree. This must be a list of length <em>size</em> or <tt class="rst-docutils literal">None</tt> to find all motifs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">sample</span></td><td class="fieldArgDesc">the size of the sample or the vertex IDs of the vertices to be used for sampling.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.motifs_randesu()</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.motifs_randesu_no">
    
  </a>
  <a name="motifs_randesu_no">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">motifs_randesu_no</span>(size=3, cut_prob=None):
    
    <a class="headerLink" href="#motifs_randesu_no" title="igraph._igraph.GraphBase.motifs_randesu_no">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Counts the total number of motifs in the graph</p>
<p>Motifs are small subgraphs of a given structure in a graph. This function counts the total number of motifs in a graph without assigning isomorphism classes to them.</p>
<p>Currently we support motifs of size 3 and 4 for directed graphs, and motifs of size 3, 4, 5 or 6 for undirected graphs.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">size</span></td><td class="fieldArgDesc">the size of the motifs</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cut<wbr></wbr>_prob</span></td><td class="fieldArgDesc">the cut probabilities for different levels of the search tree. This must be a list of length <em>size</em> or <tt class="rst-docutils literal">None</tt> to find all motifs.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.motifs_randesu()</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif detection, Bioinformatics 22(9), 1152--1153, 2006.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.neighborhood">
    
  </a>
  <a name="neighborhood">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">neighborhood</span>(vertices=None, order=1, mode='all', mindist=0):
    
    <a class="headerLink" href="#neighborhood" title="igraph._igraph.GraphBase.neighborhood">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>For each vertex specified by <em>vertices</em>, returns the vertices reachable from that vertex in at most <em>order</em> steps. If <em>mindist</em> is larger than zero, vertices that are reachable in less than <em>mindist</em> steps are excluded.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">a single vertex ID or a list of vertex IDs, or <tt class="rst-docutils literal">None</tt> meaning all the vertices in the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">order</span></td><td class="fieldArgDesc">the order of the neighborhood, i.e. the maximum number of steps to take from the seed vertex.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">specifies how to take into account the direction of the edges if a directed graph is analyzed. <tt class="rst-docutils literal">"out"</tt> means that only the outgoing edges are followed, so all vertices reachable from the source vertex in at most <em>order</em> steps are counted. <tt class="rst-docutils literal">"in"</tt> means that only the incoming edges are followed (in reverse direction of course), so all vertices from which the source vertex is reachable in at most <em>order</em> steps are counted. <tt class="rst-docutils literal">"all"</tt> treats directed edges as undirected.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mindist</span></td><td class="fieldArgDesc">the minimum distance required to include a vertex in the result. If this is one, the seed vertex is not included. If this is two, the direct neighbors of the seed vertex are not included either, and so on.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a single list specifying the neighborhood if <em>vertices</em> was an integer specifying a single vertex index, or a list of lists if <em>vertices</em> was a list or <tt class="rst-docutils literal">None</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.neighborhood_size">
    
  </a>
  <a name="neighborhood_size">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">neighborhood_size</span>(vertices=None, order=1, mode='all', mindist=0):
    
    <a class="headerLink" href="#neighborhood_size" title="igraph._igraph.GraphBase.neighborhood_size">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>For each vertex specified by <em>vertices</em>, returns the number of vertices reachable from that vertex in at most <em>order</em> steps. If <em>mindist</em> is larger than zero, vertices that are reachable in less than <em>mindist</em> steps are excluded.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">a single vertex ID or a list of vertex IDs, or <tt class="rst-docutils literal">None</tt> meaning all the vertices in the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">order</span></td><td class="fieldArgDesc">the order of the neighborhood, i.e. the maximum number of steps to take from the seed vertex.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">specifies how to take into account the direction of the edges if a directed graph is analyzed. <tt class="rst-docutils literal">"out"</tt> means that only the outgoing edges are followed, so all vertices reachable from the source vertex in at most <em>order</em> steps are counted. <tt class="rst-docutils literal">"in"</tt> means that only the incoming edges are followed (in reverse direction of course), so all vertices from which the source vertex is reachable in at most <em>order</em> steps are counted. <tt class="rst-docutils literal">"all"</tt> treats directed edges as undirected.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mindist</span></td><td class="fieldArgDesc">the minimum distance required to include a vertex in the result. If this is one, the seed vertex is not counted. If this is two, the direct neighbors of the seed vertex are not counted either, and so on.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a single number specifying the neighborhood size if <em>vertices</em> was an integer specifying a single vertex index, or a list of sizes if <em>vertices</em> was a list or <tt class="rst-docutils literal">None</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.neighbors">
    
  </a>
  <a name="neighbors">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">neighbors</span>(vertex, mode='all'):
    
    <a class="headerLink" href="#neighbors" title="igraph._igraph.GraphBase.neighbors">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns adjacent vertices to a given vertex.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex</span></td><td class="fieldArgDesc">a vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">whether to return only successors (<tt class="rst-docutils literal">"out"</tt>), predecessors (<tt class="rst-docutils literal">"in"</tt>) or both (<tt class="rst-docutils literal">"all"</tt>). Ignored for undirected graphs.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.path_length_hist">
    
  </a>
  <a name="path_length_hist">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">path_length_hist</span>(directed=True):
    
    <a class="headerLink" href="#path_length_hist" title="igraph._igraph.GraphBase.path_length_hist">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Calculates the path length histogram of the graph</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider directed paths</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a tuple. The first item of the tuple is a list of path lengths, the <span class="rst-math rst-formula"><i>i</i></span>th element of the list contains the number of paths with length <span class="rst-math rst-formula"><i>i</i> + 1</span>. The second item contains the number of unconnected vertex pairs as a float (since it might not fit into an integer)</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function is wrapped in a more convenient syntax in the derived class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code>. It is advised to use that instead of this version.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.permute_vertices">
    
  </a>
  <a name="permute_vertices">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">permute_vertices</span>(permutation):
    
    <a class="headerLink" href="#permute_vertices" title="igraph._igraph.GraphBase.permute_vertices">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Permutes the vertices of the graph according to the given permutation and returns the new graph.</p>
<p>Vertex <span class="rst-math rst-formula"><i>k</i></span> of the original graph will become vertex <span class="rst-math rst-formula"><i>permutation</i>[<i>k</i>]</span> in the new graph. No validity checks are performed on the permutation vector.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the new graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.personalized_pagerank">
    
  </a>
  <a name="personalized_pagerank">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">personalized_pagerank</span>(vertices=None, directed=True, damping=0.85, reset=None, reset_vertices=None, weights=None, arpack_options=None, implementation='prpack', niter=1000, eps=0.001):
    
    <a class="headerLink" href="#personalized_pagerank" title="igraph._igraph.GraphBase.personalized_pagerank">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the personalized PageRank values of a graph.</p>
<p>The personalized PageRank calculation is similar to the PageRank calculation, but the random walk is reset to a non-uniform distribution over the vertices in every step with probability <span class="rst-math rst-formula">1 − <i>damping</i></span> instead of a uniform distribution.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the indices of the vertices being queried. <tt class="rst-docutils literal">None</tt> means all of the vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to consider directed paths.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">damping</span></td><td class="fieldArgDesc">the damping factor. <span class="rst-math rst-formula">1 − <i>damping</i></span> is the PageRank value for vertices with no incoming links.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">reset</span></td><td class="fieldArgDesc">the distribution over the vertices to be used when resetting the random walk. Can be a sequence, an iterable or a vertex attribute name as long as they return a list of floats whose length is equal to the number of vertices. If <tt class="rst-docutils literal">None</tt>, a uniform distribution is assumed, which makes the method equivalent to the original PageRank algorithm.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">reset<wbr></wbr>_vertices</span></td><td class="fieldArgDesc">an alternative way to specify the distribution over the vertices to be used when resetting the random walk. Simply supply a list of vertex IDs here, or a <code><a href="igraph._igraph.VertexSeq.html" class="internal-link" title="igraph._igraph.VertexSeq">VertexSeq</a></code> or a <code><a href="igraph._igraph.Vertex.html" class="internal-link" title="igraph._igraph.Vertex">Vertex</a></code>. Resetting will take place using a uniform distribution over the specified vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">arpack<wbr></wbr>_options</span></td><td class="fieldArgDesc">an <code><a href="igraph._igraph.ARPACKOptions.html" class="internal-link" title="igraph._igraph.ARPACKOptions">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <tt class="rst-docutils literal">arpack_options</tt> is used. This argument is ignored if not the ARPACK implementation is used, see the <em>implementation</em> argument.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">implementation</span></td><td class="fieldArgDesc"><p>which implementation to use to solve the PageRank eigenproblem. Possible values are:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"prpack"</tt>: use the PRPACK library. This is a new implementation in igraph 0.7</li>
<li><tt class="rst-docutils literal">"arpack"</tt>: use the ARPACK library. This implementation was used from version 0.5, until version 0.7.</li>
<li><tt class="rst-docutils literal">"power"</tt>: use a simple power method. This is the implementation that was used before igraph version 0.5.</li>
</ul>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">niter</span></td><td class="fieldArgDesc">The number of iterations to use in the power method implementation. It is ignored in the other implementations.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">eps</span></td><td class="fieldArgDesc">The power method implementation will consider the calculation as complete if the difference of PageRank values between iterations change less than this value for every node. It is ignored by the other implementations.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list with the personalized PageRank values of the specified vertices.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.predecessors">
    
  </a>
  <a name="predecessors">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">predecessors</span>(vertex):
    
    <a class="headerLink" href="#predecessors" title="igraph._igraph.GraphBase.predecessors">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the predecessors of a given vertex.</p>
<p>Equivalent to calling the <code><a href="#neighbors" class="internal-link" title="igraph._igraph.GraphBase.neighbors">neighbors()</a></code> method with type=<tt class="rst-docutils literal">"in"</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Preference">
    
  </a>
  <a name="Preference">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Preference</span>(n, type_dist, pref_matrix, attribute=None, directed=False, loops=False):
    
    <a class="headerLink" href="#Preference" title="igraph._igraph.GraphBase.Preference">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph based on vertex types and connection probabilities.</p>
<p>This is practically the nongrowing variant of <code><a href="#Establishment" class="internal-link" title="igraph._igraph.GraphBase.Establishment">Establishment</a></code>. A given number of vertices are generated. Every vertex is assigned to a vertex type according to the given type probabilities. Finally, every vertex pair is evaluated and an edge is created between them with a probability depending on the types of the vertices involved.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">type<wbr></wbr>_dist</span></td><td class="fieldArgDesc">list giving the distribution of vertex types</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">pref<wbr></wbr>_matrix</span></td><td class="fieldArgDesc">matrix giving the connection probabilities for different vertex types.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">attribute</span></td><td class="fieldArgDesc">the vertex attribute name used to store the vertex types. If <tt class="rst-docutils literal">None</tt>, vertex types are not stored.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to generate a directed graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether loop edges are allowed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.radius">
    
  </a>
  <a name="radius">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">radius</span>(mode='out'):
    
    <a class="headerLink" href="#radius" title="igraph._igraph.GraphBase.radius">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the radius of the graph.</p>
<p>The radius of a graph is defined as the minimum eccentricity of its vertices (see <code><a href="#eccentricity" class="internal-link" title="igraph._igraph.GraphBase.eccentricity">eccentricity()</a></code>).</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">what kind of paths to consider for the calculation in case of directed graphs. <tt class="rst-docutils literal">OUT</tt> considers paths that follow edge directions, <tt class="rst-docutils literal">IN</tt> considers paths that follow the opposite edge directions, <tt class="rst-docutils literal">ALL</tt> ignores edge directions. The argument is ignored for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the radius</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#eccentricity" class="internal-link" title="igraph._igraph.GraphBase.eccentricity">eccentricity()</a></code></td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.random_walk">
    
  </a>
  <a name="random_walk">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">random_walk</span>(start, steps, mode='out', stuck='return'):
    
    <a class="headerLink" href="#random_walk" title="igraph._igraph.GraphBase.random_walk">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Performs a random walk of a given length from a given node.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">start</span></td><td class="fieldArgDesc">the starting vertex of the walk</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">steps</span></td><td class="fieldArgDesc">the number of steps that the random walk should take</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">whether to follow outbound edges only (<tt class="rst-docutils literal">"out"</tt>), inbound edges only (<tt class="rst-docutils literal">"in"</tt>) or both (<tt class="rst-docutils literal">"all"</tt>). Ignored for undirected graphs.@param stuck: what to do when the random walk gets stuck. <tt class="rst-docutils literal">"return"</tt> returns a partial random walk; <tt class="rst-docutils literal">"error"</tt> throws an exception.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">stuck</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a random walk that starts from the given vertex and has at most the given length (shorter if the random walk got stuck)</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Read_DIMACS">
    
  </a>
  <a name="Read_DIMACS">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_DIMACS</span>(f, directed=False):
    
    <a class="headerLink" href="#Read_DIMACS" title="igraph._igraph.GraphBase.Read_DIMACS">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Reads a graph from a file conforming to the DIMACS minimum-cost flow file format.</p>
<p>For the exact description of the format, see <a class="rst-reference external" href="http://lpsolve.sourceforge.net/5.5/DIMACS.htm" target="_top">http://lpsolve.sourceforge.net/5.5/DIMACS.htm</a></p>
<p>Restrictions compared to the official description of the format:</p>
<ul class="rst-simple">
<li>igraph's DIMACS reader requires only three fields in an arc definition, describing the edge's source and target node and its capacity.</li>
<li>Source vertices are identified by 's' in the FLOW field, target vertices are identified by 't'.</li>
<li>Node indices start from 1. Only a single source and target node is allowed.</li>
</ul>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the generated graph should be directed.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the generated graph, the source and the target of the flow and the edge capacities in a tuple</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Read_DL">
    
  </a>
  <a name="Read_DL">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_DL</span>(f, directed=True):
    
    <a class="headerLink" href="#Read_DL" title="igraph._igraph.GraphBase.Read_DL">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reads an UCINET DL file and creates a graph based on it.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the generated graph should be directed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Read_Edgelist">
    
  </a>
  <a name="Read_Edgelist">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_Edgelist</span>(f, directed=True):
    
    <a class="headerLink" href="#Read_Edgelist" title="igraph._igraph.GraphBase.Read_Edgelist">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reads an edge list from a file and creates a graph based on it.</p>
<p>Please note that the vertex indices are zero-based. A vertex of zero degree will be created for every integer that is in range but does not appear in the edgelist.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the generated graph should be directed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Read_GML">
    
  </a>
  <a name="Read_GML">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_GML</span>(f):
    
    <a class="headerLink" href="#Read_GML" title="igraph._igraph.GraphBase.Read_GML">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reads a GML file and creates a graph based on it.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file or a Python file handle</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Read_GraphDB">
    
  </a>
  <a name="Read_GraphDB">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_GraphDB</span>(f, directed=False):
    
    <a class="headerLink" href="#Read_GraphDB" title="igraph._igraph.GraphBase.Read_GraphDB">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reads a GraphDB format file and creates a graph based on it.</p>
<p>GraphDB is a binary format, used in the graph database for isomorphism testing (see <a class="rst-reference external" href="http://amalfi.dis.unina.it/graph/" target="_top">http://amalfi.dis.unina.it/graph/</a>).</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the generated graph should be directed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Read_GraphML">
    
  </a>
  <a name="Read_GraphML">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_GraphML</span>(f, index=0):
    
    <a class="headerLink" href="#Read_GraphML" title="igraph._igraph.GraphBase.Read_GraphML">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reads a GraphML format file and creates a graph based on it.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">index</span></td><td class="fieldArgDesc">if the GraphML file contains multiple graphs, specifies the one that should be loaded. Graph indices start from zero, so if you want to load the first graph, specify 0 here.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Read_Lgl">
    
  </a>
  <a name="Read_Lgl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_Lgl</span>(f, names=True, weights='if_present', directed=True):
    
    <a class="headerLink" href="#Read_Lgl" title="igraph._igraph.GraphBase.Read_Lgl">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reads an .lgl file used by LGL.</p>
<p>It is also useful for creating graphs from "named" (and optionally weighted) edge lists.</p>
<p>This format is used by the Large Graph Layout program. See the <a class="rst-reference external" href="http://bioinformatics.icmb.utexas.edu/lgl/" target="_top">documentation of LGL</a> regarding the exact format description.</p>
<p>LGL originally cannot deal with graphs containing multiple or loop edges, but this condition is not checked here, as igraph is happy with these.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">names</span></td><td class="fieldArgDesc">If <tt class="rst-docutils literal">True</tt>, the vertex names are added as a vertex attribute called 'name'.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">If True, the edge weights are added as an edge attribute called 'weight', even if there are no weights in the file. If False, the edge weights are never added, even if they are present. <tt class="rst-docutils literal">"auto"</tt> or <tt class="rst-docutils literal">"if_present"</tt> means that weights are added if there is at least one weighted edge in the input file, but they are not added otherwise.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the graph being created should be directed</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Read_Ncol">
    
  </a>
  <a name="Read_Ncol">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_Ncol</span>(f, names=True, weights='if_present', directed=True):
    
    <a class="headerLink" href="#Read_Ncol" title="igraph._igraph.GraphBase.Read_Ncol">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reads an .ncol file used by LGL.</p>
<p>It is also useful for creating graphs from "named" (and optionally weighted) edge lists.</p>
<p>This format is used by the Large Graph Layout program. See the <a class="rst-reference external" href="https://github.com/TheOpteProject/LGL/" target="_top">repository of LGL</a> for more information.</p>
<p>LGL originally cannot deal with graphs containing multiple or loop edges, but this condition is not checked here, as igraph is happy with these.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">names</span></td><td class="fieldArgDesc">If <tt class="rst-docutils literal">True</tt>, the vertex names are added as a vertex attribute called 'name'.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">If True, the edge weights are added as an edge attribute called 'weight', even if there are no weights in the file. If False, the edge weights are never added, even if they are present. <tt class="rst-docutils literal">"auto"</tt> or <tt class="rst-docutils literal">"if_present"</tt> means that weights are added if there is at least one weighted edge in the input file, but they are not added otherwise.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the graph being created should be directed</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Read_Pajek">
    
  </a>
  <a name="Read_Pajek">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Read_Pajek</span>(f):
    
    <a class="headerLink" href="#Read_Pajek" title="igraph._igraph.GraphBase.Read_Pajek">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reads a Pajek format file and creates a graph based on it.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file or a Python file handle</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Realize_Degree_Sequence">
    
  </a>
  <a name="Realize_Degree_Sequence">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Realize_Degree_Sequence</span>(out, in_=None, allowed_edge_types='simple', method='smallest'):
    
    <a class="headerLink" href="#Realize_Degree_Sequence" title="igraph._igraph.GraphBase.Realize_Degree_Sequence">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph from a degree sequence.</p>
<p>This method implements a Havel-Hakimi style graph construction from a given degree sequence. In each step, the algorithm picks two vertices in a deterministic manner and connects them. The way the vertices are picked is defined by the <tt class="rst-docutils literal">method</tt> parameter. The allowed edge types (i.e. whether multiple or loop edges are allowed) are specified in the <tt class="rst-docutils literal">allowed_edge_types</tt> parameter.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">out</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">in_</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">allowed<wbr></wbr>_edge<wbr></wbr>_types</span></td><td class="fieldArgDesc"><p>controls whether loops or multi-edges are allowed during the generation process. Note that not all combinations are supported for all types of graphs; an exception will be raised for unsupported combinations. Possible values are:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"simple"</tt>: simple graphs (no self-loops, no multi-edges)</li>
<li><tt class="rst-docutils literal">"loops"</tt>: single self-loops allowed, but not multi-edges</li>
<li><tt class="rst-docutils literal">"multi"</tt>: multi-edges allowed, but not self-loops</li>
<li><tt class="rst-docutils literal">"all"</tt>: multi-edges and self-loops allowed</li>
</ul>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">method</span></td><td class="fieldArgDesc"><p>controls how the vertices are selected during the generation process. Possible values are:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">smallest</tt>: The vertex with smallest remaining degree first.</li>
<li><tt class="rst-docutils literal">largest</tt>: The vertex with the largest remaining degree first.</li>
<li><tt class="rst-docutils literal">index</tt>: The vertices are selected in order of their index.</li>
</ul>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">outdeg</span></td><td class="fieldArgDesc">the degree sequence of an undirected graph (if indeg=None), or the out-degree sequence of a directed graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">indeg</span></td><td class="fieldArgDesc">None to generate an undirected graph, the in-degree sequence to generate a directed graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Recent_Degree">
    
  </a>
  <a name="Recent_Degree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Recent_Degree</span>(n, m, window, outpref=False, directed=False, power=1):
    
    <a class="headerLink" href="#Recent_Degree" title="igraph._igraph.GraphBase.Recent_Degree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph based on a stochastic model where the probability of an edge gaining a new node is proportional to the edges gained in a given time window.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">m</span></td><td class="fieldArgDesc">either the number of outgoing edges generated for each vertex or a list containing the number of outgoing edges for each vertex explicitly.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">window</span></td><td class="fieldArgDesc">size of the window in time steps</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">outpref</span></td><td class="fieldArgDesc"><tt class="rst-docutils literal">True</tt> if the out-degree of a given vertex should also increase its citation probability (as well as its in-degree), but it defaults to <tt class="rst-docutils literal">False</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc"><tt class="rst-docutils literal">True</tt> if the generated graph should be directed (default: <tt class="rst-docutils literal">False</tt>).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">power</span></td><td class="fieldArgDesc">the power constant of the nonlinear model. It can be omitted, and in this case the usual linear model will be used.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.reciprocity">
    
  </a>
  <a name="reciprocity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">reciprocity</span>(ignore_loops=True, mode='default'):
    
    <a class="headerLink" href="#reciprocity" title="igraph._igraph.GraphBase.reciprocity">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Reciprocity defines the proportion of mutual connections in a directed graph. It is most commonly defined as the probability that the opposite counterpart of a directed edge is also included in the graph. This measure is calculated if <tt class="rst-docutils literal">mode</tt> is <tt class="rst-docutils literal">"default"</tt>.</p>
<p>Prior to igraph 0.6, another measure was implemented, defined as the probability of mutual connection between a vertex pair if we know that there is a (possibly non-mutual) connection between them. In other words, (unordered) vertex pairs are classified into three groups: (1) disconnected, (2) non-reciprocally connected and (3) reciprocally connected. The result is the size of group (3), divided by the sum of sizes of groups (2) and (3). This measure is calculated if <tt class="rst-docutils literal">mode</tt> is <tt class="rst-docutils literal">"ratio"</tt>.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ignore<wbr></wbr>_loops</span></td><td class="fieldArgDesc">whether loop edges should be ignored.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">the algorithm to use to calculate the reciprocity; see above for more details.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the reciprocity of the graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.rewire">
    
  </a>
  <a name="rewire">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rewire</span>(n=1000, mode='simple'):
    
    <a class="headerLink" href="#rewire" title="igraph._igraph.GraphBase.rewire">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Randomly rewires the graph while preserving the degree distribution.</p>
<p>Please note that the rewiring is done "in-place", so the original graph will be modified. If you want to preserve the original graph, use the <code><a href="#copy" class="internal-link" title="igraph._igraph.GraphBase.copy">copy</a></code> method before.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of rewiring trials.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">the rewiring algorithm to use. It can either be <tt class="rst-docutils literal">"simple"</tt> or <tt class="rst-docutils literal">"loops"</tt>; the former does not create or destroy loop edges while the latter does.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.rewire_edges">
    
  </a>
  <a name="rewire_edges">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">rewire_edges</span>(prob, loops=False, multiple=False):
    
    <a class="headerLink" href="#rewire_edges" title="igraph._igraph.GraphBase.rewire_edges">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Rewires the edges of a graph with constant probability.</p>
<p>Each endpoint of each edge of the graph will be rewired with a constant probability, given in the first argument.</p>
<p>Please note that the rewiring is done "in-place", so the original graph will be modified. If you want to preserve the original graph, use the <code><a href="#copy" class="internal-link" title="igraph._igraph.GraphBase.copy">copy</a></code> method before.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">prob</span></td><td class="fieldArgDesc">rewiring probability</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether the algorithm is allowed to create loop edges</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">multiple</span></td><td class="fieldArgDesc">whether the algorithm is allowed to create multiple edges.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Ring">
    
  </a>
  <a name="Ring">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Ring</span>(n, directed=False, mutual=False, circular=True):
    
    <a class="headerLink" href="#Ring" title="igraph._igraph.GraphBase.Ring">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a ring graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices in the ring</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to create a directed ring.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mutual</span></td><td class="fieldArgDesc">whether to create mutual edges in a directed ring.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">circular</span></td><td class="fieldArgDesc">whether to create a closed ring.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.SBM">
    
  </a>
  <a name="SBM">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">SBM</span>(n, pref_matrix, block_sizes, directed=False, loops=False):
    
    <a class="headerLink" href="#SBM" title="igraph._igraph.GraphBase.SBM">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a graph based on a stochastic blockmodel.</p>
<p>A given number of vertices are generated. Every vertex is assigned to a vertex type according to the given block sizes. Vertices of the same type will be assigned consecutive vertex IDs. Finally, every vertex pair is evaluated and an edge is created between them with a probability depending on the types of the vertices involved. The probabilities are taken from the preference matrix.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">pref<wbr></wbr>_matrix</span></td><td class="fieldArgDesc">matrix giving the connection probabilities for different vertex types.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">block<wbr></wbr>_sizes</span></td><td class="fieldArgDesc">list giving the number of vertices in each block; must sum up to <em>n</em>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to generate a directed graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether loop edges are allowed.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.shortest_paths">
    
  </a>
  <a name="shortest_paths">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">shortest_paths</span>(source=None, target=None, weights=None, mode='out'):
    
    <a class="headerLink" href="#shortest_paths" title="igraph._igraph.GraphBase.shortest_paths">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates shortest path lengths for given vertices in a graph.</p>
<p>The algorithm used for the calculations is selected automatically: a simple BFS is used for unweighted graphs, Dijkstra's algorithm is used when all the weights are positive. Otherwise, the Bellman-Ford algorithm is used if the number of requested source vertices is larger than 100 and Johnson's algorithm is used otherwise.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">a list containing the source vertex IDs which should be included in the result. If <tt class="rst-docutils literal">None</tt>, all vertices will be considered.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">a list containing the target vertex IDs which should be included in the result. If <tt class="rst-docutils literal">None</tt>, all vertices will be considered.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">a list containing the edge weights. It can also be an attribute name (edge weights are retrieved from the given attribute) or <tt class="rst-docutils literal">None</tt> (all edges have equal weight).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">the type of shortest paths to be used for the calculation in directed graphs. <tt class="rst-docutils literal">"out"</tt> means only outgoing, <tt class="rst-docutils literal">"in"</tt> means only incoming paths. <tt class="rst-docutils literal">"all"</tt> means to consider the directed graph as an undirected one.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the shortest path lengths for given vertices in a matrix</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.similarity_dice">
    
  </a>
  <a name="similarity_dice">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">similarity_dice</span>(vertices=None, pairs=None, mode='all', loops=True):
    
    <a class="headerLink" href="#similarity_dice" title="igraph._igraph.GraphBase.similarity_dice">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Dice similarity coefficient of vertices.</p>
<p>The Dice similarity coefficient of two vertices is twice the number of their common neighbors divided by the sum of their degrees. This coefficient is very similar to the Jaccard coefficient, but usually gives higher similarities than its counterpart.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the vertices to be analysed. If <tt class="rst-docutils literal">None</tt> and <em>pairs</em> is also <tt class="rst-docutils literal">None</tt>, all vertices will be considered.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">pairs</span></td><td class="fieldArgDesc">the vertex pairs to be analysed. If this is given, <em>vertices</em> must be <tt class="rst-docutils literal">None</tt>, and the similarity values will be calculated only for the given pairs. Vertex pairs must be specified as tuples of vertex IDs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">which neighbors should be considered for directed graphs. Can be <tt class="rst-docutils literal">"all"</tt>, <tt class="rst-docutils literal">"in"</tt> or <tt class="rst-docutils literal">"out"</tt>, ignored for undirected graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether vertices should be considered adjacent to themselves. Setting this to <tt class="rst-docutils literal">True</tt> assumes a loop edge for all vertices even if none is present in the graph. Setting this to <tt class="rst-docutils literal">False</tt> may result in strange results: nonadjacent vertices may have larger similarities compared to the case when an edge is added between them -- however, this might be exactly the result you want to get.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the pairwise similarity coefficients for the vertices specified, in the form of a matrix if <tt class="rst-docutils literal">pairs</tt> is <tt class="rst-docutils literal">None</tt> or in the form of a list if <tt class="rst-docutils literal">pairs</tt> is not <tt class="rst-docutils literal">None</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.similarity_inverse_log_weighted">
    
  </a>
  <a name="similarity_inverse_log_weighted">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">similarity_inverse_log_weighted</span>(vertices=None, mode='all'):
    
    <a class="headerLink" href="#similarity_inverse_log_weighted" title="igraph._igraph.GraphBase.similarity_inverse_log_weighted">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Inverse log-weighted similarity coefficient of vertices.</p>
<p>Each vertex is assigned a weight which is 1 / log(degree). The log-weighted similarity of two vertices is the sum of the weights of their common neighbors.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the vertices to be analysed. If <tt class="rst-docutils literal">None</tt>, all vertices will be considered.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">which neighbors should be considered for directed graphs. Can be <tt class="rst-docutils literal">"all"</tt>, <tt class="rst-docutils literal">"in"</tt> or <tt class="rst-docutils literal">"out"</tt>, ignored for undirected graphs. <tt class="rst-docutils literal">"in"</tt> means that the weights are determined by the out-degrees, <tt class="rst-docutils literal">"out"</tt> means that the weights are determined by the in-degrees.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the pairwise similarity coefficients for the vertices specified, in the form of a matrix (list of lists).</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.similarity_jaccard">
    
  </a>
  <a name="similarity_jaccard">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">similarity_jaccard</span>(vertices=None, pairs=None, mode='all', loops=True):
    
    <a class="headerLink" href="#similarity_jaccard" title="igraph._igraph.GraphBase.similarity_jaccard">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Jaccard similarity coefficient of vertices.</p>
<p>The Jaccard similarity coefficient of two vertices is the number of their common neighbors divided by the number of vertices that are adjacent to at least one of them.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">the vertices to be analysed. If <tt class="rst-docutils literal">None</tt> and <em>pairs</em> is also <tt class="rst-docutils literal">None</tt>, all vertices will be considered.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">pairs</span></td><td class="fieldArgDesc">the vertex pairs to be analysed. If this is given, <em>vertices</em> must be <tt class="rst-docutils literal">None</tt>, and the similarity values will be calculated only for the given pairs. Vertex pairs must be specified as tuples of vertex IDs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">which neighbors should be considered for directed graphs. Can be <tt class="rst-docutils literal">"all"</tt>, <tt class="rst-docutils literal">"in"</tt> or <tt class="rst-docutils literal">"out"</tt>, ignored for undirected graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether vertices should be considered adjacent to themselves. Setting this to <tt class="rst-docutils literal">True</tt> assumes a loop edge for all vertices even if none is present in the graph. Setting this to <tt class="rst-docutils literal">False</tt> may result in strange results: nonadjacent vertices may have larger similarities compared to the case when an edge is added between them -- however, this might be exactly the result you want to get.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the pairwise similarity coefficients for the vertices specified, in the form of a matrix if <tt class="rst-docutils literal">pairs</tt> is <tt class="rst-docutils literal">None</tt> or in the form of a list if <tt class="rst-docutils literal">pairs</tt> is not <tt class="rst-docutils literal">None</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.simplify">
    
  </a>
  <a name="simplify">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">simplify</span>(multiple=True, loops=True, combine_edges=None):
    
    <a class="headerLink" href="#simplify" title="igraph._igraph.GraphBase.simplify">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Simplifies a graph by removing self-loops and/or multiple edges.</p>
<p>For example, suppose you have a graph with an edge attribute named <tt class="rst-docutils literal">weight</tt>. <tt class="rst-docutils literal">graph.simplify(combine_edges=max)</tt> will take the maximum of the weights of multiple edges and assign that weight to the collapsed edge. <tt class="rst-docutils literal">graph.simplify(combine_edges=sum)</tt> will take the sum of the weights. You can also write <tt class="rst-docutils literal"><span class="pre">graph.simplify(combine_edges=dict(weight="sum"))</span></tt> or <tt class="rst-docutils literal">graph.simplify(combine_edges=dict(weight=sum))</tt>, since <tt class="rst-docutils literal">sum</tt> is recognised both as a Python built-in function and as a string constant.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">multiple</span></td><td class="fieldArgDesc">whether to remove multiple edges.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether to remove loops.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">combine<wbr></wbr>_edges</span></td><td class="fieldArgDesc"><p>specifies how to combine the attributes of multiple edges between the same pair of vertices into a single attribute. If it is <tt class="rst-docutils literal">None</tt>, only one of the edges will be kept and all the attributes will be lost. If it is a function, the attributes of multiple edges will be collected and passed on to that function which will return the new attribute value that has to be assigned to the single collapsed edge. It can also be one of the following string constants:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"ignore"</tt>: all the edge attributes will be ignored.</li>
<li><tt class="rst-docutils literal">"sum"</tt>: the sum of the edge attribute values will be used for the new edge.</li>
<li><tt class="rst-docutils literal">"product"</tt>: the product of the edge attribute values will be used for the new edge.</li>
<li><tt class="rst-docutils literal">"mean"</tt>: the mean of the edge attribute values will be used for the new edge.</li>
<li><tt class="rst-docutils literal">"median"</tt>: the median of the edge attribute values will be used for the new edge.</li>
<li><tt class="rst-docutils literal">"min"</tt>: the minimum of the edge attribute values will be used for the new edge.</li>
<li><tt class="rst-docutils literal">"max"</tt>: the maximum of the edge attribute values will be used for the new edge.</li>
<li><tt class="rst-docutils literal">"first"</tt>: the attribute value of the first edge in the collapsed set will be used for the new edge.</li>
<li><tt class="rst-docutils literal">"last"</tt>: the attribute value of the last edge in the collapsed set will be used for the new edge.</li>
<li><tt class="rst-docutils literal">"random"</tt>: a randomly selected value will be used for the new edge</li>
<li><tt class="rst-docutils literal">"concat"</tt>: the attribute values will be concatenated for the new edge.</li>
</ul>
<p>You can also use a dict mapping edge attribute names to functions or the above string constants if you want to make the behaviour of the simplification process depend on the name of the attribute. <tt class="rst-docutils literal">None</tt> is a special key in this dict, its value will be used for all the attributes not specified explicitly in the dictionary.</p>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.st_mincut">
    
  </a>
  <a name="st_mincut">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">st_mincut</span>(source, target, capacity=None):
    
    <a class="headerLink" href="#st_mincut" title="igraph._igraph.GraphBase.st_mincut">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Calculates the minimum cut between the source and target vertices in a graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">capacity</span></td><td class="fieldArgDesc">the capacity of the edges. It must be a list or a valid attribute name or <tt class="rst-docutils literal">None</tt>. In the latter case, every edge will have the same capacity.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the value of the minimum cut, the IDs of vertices in the first and second partition, and the IDs of edges in the cut, packed in a 4-tuple</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> which wraps the result in a list of <code><a href="igraph.cut.Cut.html" class="internal-link" title="igraph.cut.Cut">Cut</a></code> objects. It is advised to use that.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Star">
    
  </a>
  <a name="Star">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Star</span>(n, mode='undirected', center=0):
    
    <a class="headerLink" href="#Star" title="igraph._igraph.GraphBase.Star">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a star graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">Gives the type of the star graph to create. Should be either "in", "out", "mutual" or "undirected"</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">center</span></td><td class="fieldArgDesc">Vertex ID for the central vertex in the star.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Static_Fitness">
    
  </a>
  <a name="Static_Fitness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Static_Fitness</span>(m, fitness_out, fitness_in=None, loops=False, multiple=False):
    
    <a class="headerLink" href="#Static_Fitness" title="igraph._igraph.GraphBase.Static_Fitness">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a non-growing graph with edge probabilities proportional to node fitnesses.</p>
<p>The algorithm randomly selects vertex pairs and connects them until the given number of edges are created. Each vertex is selected with a probability proportional to its fitness; for directed graphs, a vertex is selected as a source proportional to its out-fitness and as a target proportional to its in-fitness.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">m</span></td><td class="fieldArgDesc">the number of edges in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fitness<wbr></wbr>_out</span></td><td class="fieldArgDesc">a numeric vector with non-negative entries, one for each vertex. These values represent the fitness scores (out-fitness scores for directed graphs). <em>fitness</em> is an alias of this keyword argument.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fitness<wbr></wbr>_in</span></td><td class="fieldArgDesc">a numeric vector with non-negative entries, one for each vertex. These values represent the in-fitness scores for directed graphs. For undirected graphs, this argument must be <tt class="rst-docutils literal">None</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether loop edges are allowed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">multiple</span></td><td class="fieldArgDesc">whether multiple edges are allowed.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a directed or undirected graph with the prescribed power-law degree distributions.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Static_Power_Law">
    
  </a>
  <a name="Static_Power_Law">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Static_Power_Law</span>(n, m, exponent_out, exponent_in=-1, loops=False, multiple=False, finite_size_correction=True):
    
    <a class="headerLink" href="#Static_Power_Law" title="igraph._igraph.GraphBase.Static_Power_Law">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a non-growing graph with prescribed power-law degree distributions.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">m</span></td><td class="fieldArgDesc">the number of edges in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">exponent<wbr></wbr>_out</span></td><td class="fieldArgDesc">the exponent of the out-degree distribution, which must be between 2 and infinity (inclusive). When <em>exponent_in</em> is not given or negative, the graph will be undirected and this parameter specifies the degree distribution. <em>exponent</em> is an alias to this keyword argument.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">exponent<wbr></wbr>_in</span></td><td class="fieldArgDesc">the exponent of the in-degree distribution, which must be between 2 and infinity (inclusive) It can also be negative, in which case an undirected graph will be generated.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether loop edges are allowed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">multiple</span></td><td class="fieldArgDesc">whether multiple edges are allowed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">finite<wbr></wbr>_size<wbr></wbr>_correction</span></td><td class="fieldArgDesc">whether to apply a finite-size correction to the generated fitness values for exponents less than 3. See the paper of Cho et al for more details.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a directed or undirected graph with the prescribed power-law degree distributions.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.</td></tr><tr><td colspan="2">Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.strength">
    
  </a>
  <a name="strength">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">strength</span>(vertices, mode='all', loops=True, weights=None):
    
    <a class="headerLink" href="#strength" title="igraph._igraph.GraphBase.strength">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the strength (weighted degree) of some vertices from the graph</p>
<p>This method accepts a single vertex ID or a list of vertex IDs as a parameter, and returns the strength (that is, the sum of the weights of all incident edges) of the given vertices (in the form of a single integer or a list, depending on the input parameter).</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">a single vertex ID or a list of vertex IDs</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">the type of degree to be returned (<tt class="rst-docutils literal">"out"</tt> for out-degrees, <tt class="rst-docutils literal">"in"</tt> for in-degrees or <tt class="rst-docutils literal">"all"</tt> for the sum of them).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether self-loops should be counted.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name. ``None`` means to treat the graph as unweighted, falling back to ordinary degree calculations.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.subcomponent">
    
  </a>
  <a name="subcomponent">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">subcomponent</span>(v, mode='all'):
    
    <a class="headerLink" href="#subcomponent" title="igraph._igraph.GraphBase.subcomponent">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Determines the indices of vertices which are in the same component as a given vertex.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">v</span></td><td class="fieldArgDesc">the index of the vertex used as the source/destination</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">if equals to <tt class="rst-docutils literal">"in"</tt>, returns the vertex IDs from where the given vertex can be reached. If equals to <tt class="rst-docutils literal">"out"</tt>, returns the vertex IDs which are reachable from the given vertex. If equals to <tt class="rst-docutils literal">"all"</tt>, returns all vertices within the same component as the given vertex, ignoring edge directions. Note that this is not equal to calculating the union of the results of <tt class="rst-docutils literal">"in"</tt> and <tt class="rst-docutils literal">"out"</tt>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the indices of vertices which are in the same component as a given vertex.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.subgraph_edges">
    
  </a>
  <a name="subgraph_edges">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">subgraph_edges</span>(edges, delete_vertices=True):
    
    <a class="headerLink" href="#subgraph_edges" title="igraph._igraph.GraphBase.subgraph_edges">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns a subgraph spanned by the given edges.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">a list containing the edge IDs which should be included in the result.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">delete<wbr></wbr>_vertices</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, vertices not incident on any of the specified edges will be deleted from the result. If <tt class="rst-docutils literal">False</tt>, all vertices will be kept.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the subgraph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.subisomorphic_lad">
    
  </a>
  <a name="subisomorphic_lad">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">subisomorphic_lad</span>(other, domains=None, induced=False, time_limit=0, return_mapping=False):
    
    <a class="headerLink" href="#subisomorphic_lad" title="igraph._igraph.GraphBase.subisomorphic_lad">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether a subgraph of the graph is isomorphic to another graph.</p>
<p>The optional <tt class="rst-docutils literal">domains</tt> argument may be used to restrict vertices that may match each other. You can also specify whether you are interested in induced subgraphs only or not.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">the pattern graph we are looking for in the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">domains</span></td><td class="fieldArgDesc">a list of lists, one sublist belonging to each vertex in the template graph. Sublist <span class="rst-math rst-formula"><i>i</i></span> contains the indices of the vertices in the original graph that may match vertex <span class="rst-math rst-formula"><i>i</i></span> in the template graph. <tt class="rst-docutils literal">None</tt> means that every vertex may match every other vertex.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">induced</span></td><td class="fieldArgDesc">whether to consider induced subgraphs only.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">time<wbr></wbr>_limit</span></td><td class="fieldArgDesc">an optimal time limit in seconds. Only the integral part of this number is taken into account. If the time limit is exceeded, the method will throw an exception.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_mapping</span></td><td class="fieldArgDesc">when <tt class="rst-docutils literal">True</tt>, the function will return a tuple, where the first element is a boolean denoting whether a subisomorphism has been found or not, and the second element describes the mapping of the vertices from the template graph to the original graph. When <tt class="rst-docutils literal">False</tt>, only the boolean is returned.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">if no mapping is calculated, the result is <tt class="rst-docutils literal">True</tt> if the graph contains a subgraph that is isomorphic to the given template, <tt class="rst-docutils literal">False</tt> otherwise. If the mapping is calculated, the result is a tuple, the first element being the above mentioned boolean, and the second element being the mapping from the target to the original graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.subisomorphic_vf2">
    
  </a>
  <a name="subisomorphic_vf2">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">subisomorphic_vf2</span>(other, color1=None, color2=None, edge_color1=None, edge_color2=None, return_mapping_12=False, return_mapping_21=False, callback=None, node_compat_fn=None, edge_compat_fn=None):
    
    <a class="headerLink" href="#subisomorphic_vf2" title="igraph._igraph.GraphBase.subisomorphic_vf2">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Checks whether a subgraph of the graph is isomorphic to another graph.</p>
<p>Vertex and edge colors may be used to restrict the isomorphisms, as only vertices and edges with the same color will be allowed to match each other.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">other</span></td><td class="fieldArgDesc">the other graph with which we want to compare the graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the first graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the vertices of the second graph. If <tt class="rst-docutils literal">None</tt>, all vertices have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_color1</span></td><td class="fieldArgDesc">optional vector storing the coloring of the edges of the first graph. If <tt class="rst-docutils literal">None</tt>, all edges have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_color2</span></td><td class="fieldArgDesc">optional vector storing the coloring of the edges of the second graph. If <tt class="rst-docutils literal">None</tt>, all edges have the same color.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_mapping<wbr></wbr>_12</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, calculates the mapping which maps the vertices of the first graph to the second. The mapping can contain -1 if a given node is not mapped.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_mapping<wbr></wbr>_21</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, calculates the mapping which maps the vertices of the second graph to the first. The mapping can contain -1 if a given node is not mapped.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">callback</span></td><td class="fieldArgDesc">if not <tt class="rst-docutils literal">None</tt>, the subisomorphism search will not stop at the first match; it will call this callback function instead for every subisomorphism found. The callback function must accept four arguments: the first graph, the second graph, a mapping from the nodes of the first graph to the second, and a mapping from the nodes of the second graph to the first. The function must return <tt class="rst-docutils literal">True</tt> if the search should continue or <tt class="rst-docutils literal">False</tt> otherwise.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">node<wbr></wbr>_compat<wbr></wbr>_fn</span></td><td class="fieldArgDesc">a function that receives the two graphs and two node indices (one from the first graph, one from the second graph) and returns <tt class="rst-docutils literal">True</tt> if the nodes given by the two indices are compatible (i.e. they could be matched to each other) or <tt class="rst-docutils literal">False</tt> otherwise. This can be used to restrict the set of isomorphisms based on node-specific criteria that are too complicated to be represented by node color vectors (i.e. the <tt class="rst-docutils literal">color1</tt> and <tt class="rst-docutils literal">color2</tt> parameters). <tt class="rst-docutils literal">None</tt> means that every node is compatible with every other node.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_compat<wbr></wbr>_fn</span></td><td class="fieldArgDesc">a function that receives the two graphs and two edge indices (one from the first graph, one from the second graph) and returns <tt class="rst-docutils literal">True</tt> if the edges given by the two indices are compatible (i.e. they could be matched to each other) or <tt class="rst-docutils literal">False</tt> otherwise. This can be used to restrict the set of isomorphisms based on edge-specific criteria that are too complicated to be represented by edge color vectors (i.e. the <tt class="rst-docutils literal">edge_color1</tt> and <tt class="rst-docutils literal">edge_color2</tt> parameters). <tt class="rst-docutils literal">None</tt> means that every edge is compatible with every other node.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">if no mapping is calculated, the result is <tt class="rst-docutils literal">True</tt> if the graph contains a subgraph that's isomorphic to the given one, <tt class="rst-docutils literal">False</tt> otherwise. If any or both mappings are calculated, the result is a 3-tuple, the first element being the above mentioned boolean, the second element being the 1 -&gt; 2 mapping and the third element being the 2 -&gt; 1 mapping. If the corresponding mapping was not calculated, <tt class="rst-docutils literal">None</tt> is returned in the appropriate element of the 3-tuple.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.successors">
    
  </a>
  <a name="successors">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">successors</span>(vertex):
    
    <a class="headerLink" href="#successors" title="igraph._igraph.GraphBase.successors">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the successors of a given vertex.</p>
<p>Equivalent to calling the <code><a href="#neighbors" class="internal-link" title="igraph._igraph.GraphBase.neighbors">neighbors()</a></code> method with type=<tt class="rst-docutils literal">"out"</tt>.</p>
</div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.to_directed">
    
  </a>
  <a name="to_directed">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">to_directed</span>(mode='mutual'):
    
    <a class="headerLink" href="#to_directed" title="igraph._igraph.GraphBase.to_directed">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Converts an undirected graph to directed.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">specifies how to convert undirected edges into directed ones. <tt class="rst-docutils literal">True</tt> or <tt class="rst-docutils literal">"mutual"</tt> creates a mutual edge pair for each undirected edge. <tt class="rst-docutils literal">False</tt> or <tt class="rst-docutils literal">"arbitrary"</tt> picks an arbitrary (but deterministic) edge direction for each edge. <tt class="rst-docutils literal">"random"</tt> picks a random direction for each edge. <tt class="rst-docutils literal">"acyclic"</tt> picks the edge directions in a way that the resulting graph will be acyclic if there were no self-loops in the original graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.to_prufer">
    
  </a>
  <a name="to_prufer">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">to_prufer</span>():
    
    <a class="headerLink" href="#to_prufer" title="igraph._igraph.GraphBase.to_prufer">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Converts a tree graph into a Prufer sequence.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the Prufer sequence as a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.to_undirected">
    
  </a>
  <a name="to_undirected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">to_undirected</span>(mode='collapse', combine_edges=None):
    
    <a class="headerLink" href="#to_undirected" title="igraph._igraph.GraphBase.to_undirected">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Converts a directed graph to undirected.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">specifies what to do with multiple directed edges going between the same vertex pair. <tt class="rst-docutils literal">True</tt> or <tt class="rst-docutils literal">"collapse"</tt> means that only a single edge should be created from multiple directed edges. <tt class="rst-docutils literal">False</tt> or <tt class="rst-docutils literal">"each"</tt> means that every edge will be kept (with the arrowheads removed). <tt class="rst-docutils literal">"mutual"</tt> creates one undirected edge for each mutual directed edge pair.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">combine<wbr></wbr>_edges</span></td><td class="fieldArgDesc">specifies how to combine the attributes of multiple edges between the same pair of vertices into a single attribute. See <code><a href="#simplify" class="internal-link" title="igraph._igraph.GraphBase.simplify">simplify()</a></code> for more details.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.topological_sorting">
    
  </a>
  <a name="topological_sorting">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">topological_sorting</span>(mode='out'):
    
    <a class="headerLink" href="#topological_sorting" title="igraph._igraph.GraphBase.topological_sorting">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates a possible topological sorting of the graph.</p>
<p>Returns a partial sorting and issues a warning if the graph is not a directed acyclic graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">"out"</tt>, vertices are returned according to the forward topological order -- all vertices come before their successors. If <tt class="rst-docutils literal">"in"</tt>, all vertices come before their ancestors.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a possible topological ordering as a list</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.transitivity_avglocal_undirected">
    
  </a>
  <a name="transitivity_avglocal_undirected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">transitivity_avglocal_undirected</span>(mode='nan'):
    
    <a class="headerLink" href="#transitivity_avglocal_undirected" title="igraph._igraph.GraphBase.transitivity_avglocal_undirected">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Calculates the average of the vertex transitivities of the graph.</p>
<p>The transitivity measures the probability that two neighbors of a vertex are connected. In case of the average local transitivity, this probability is calculated for each vertex and then the average is taken. Vertices with less than two neighbors require special treatment, they will either be left out from the calculation or they will be considered as having zero transitivity, depending on the <em>mode</em> parameter.</p>
<p>Note that this measure is different from the global transitivity measure (see <code><a href="#transitivity_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_undirected">transitivity_undirected()</a></code>) as it simply takes the average local transitivity across the whole network.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">defines how to treat vertices with degree less than two. If <tt class="rst-docutils literal">TRANSITIVITT_ZERO</tt> or <tt class="rst-docutils literal">"zero"</tt>, these vertices will have zero transitivity. If <tt class="rst-docutils literal">TRANSITIVITY_NAN</tt> or <tt class="rst-docutils literal">"nan"</tt>, these vertices will be excluded from the average.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#transitivity_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_undirected">transitivity_undirected()</a></code>, <code><a href="#transitivity_local_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_local_undirected">transitivity_local_undirected()</a></code></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">D. J. Watts and S. Strogatz: <em>Collective dynamics of small-world networks</em>. Nature 393(6884):440-442, 1998.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.transitivity_local_undirected">
    
  </a>
  <a name="transitivity_local_undirected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">transitivity_local_undirected</span>(vertices=None, mode='nan', weights=None):
    
    <a class="headerLink" href="#transitivity_local_undirected" title="igraph._igraph.GraphBase.transitivity_local_undirected">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the local transitivity (clustering coefficient) of the given vertices in the graph.</p>
<p>The transitivity measures the probability that two neighbors of a vertex are connected. In case of the local transitivity, this probability is calculated separately for each vertex.</p>
<p>Note that this measure is different from the global transitivity measure (see <code><a href="#transitivity_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_undirected">transitivity_undirected()</a></code>) as it calculates a transitivity value for each vertex individually.</p>
<p>The traditional local transitivity measure applies for unweighted graphs only. When the <tt class="rst-docutils literal">weights</tt> argument is given, this function calculates the weighted local transitivity proposed by Barrat et al (see references).</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertices</span></td><td class="fieldArgDesc">a list containing the vertex IDs which should be included in the result. <tt class="rst-docutils literal">None</tt> means all of the vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">defines how to treat vertices with degree less than two. If <tt class="rst-docutils literal">TRANSITIVITT_ZERO</tt> or <tt class="rst-docutils literal">"zero"</tt>, these vertices will have zero transitivity. If <tt class="rst-docutils literal">TRANSITIVITY_NAN</tt> or <tt class="rst-docutils literal">"nan"</tt>, these vertices will have <tt class="rst-docutils literal">NaN</tt> (not a number) as their transitivity.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the transitivities for the given vertices in a list</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#transitivity_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_undirected">transitivity_undirected()</a></code>, <code><a href="#transitivity_avglocal_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_avglocal_undirected">transitivity_avglocal_undirected()</a></code></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Watts DJ and Strogatz S: <em>Collective dynamics of small-world networks</em>. Nature 393(6884):440-442, 1998.</td></tr><tr><td colspan="2">Barrat A, Barthelemy M, Pastor-Satorras R and Vespignani A: <em>The architecture of complex weighted networks</em>. PNAS 101, 3747 (2004). <a class="rst-reference external" href="http://arxiv.org/abs/cond-mat/0311416" target="_top">http://arxiv.org/abs/cond-mat/0311416</a>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.transitivity_undirected">
    
  </a>
  <a name="transitivity_undirected">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">transitivity_undirected</span>(mode='nan'):
    
    <a class="headerLink" href="#transitivity_undirected" title="igraph._igraph.GraphBase.transitivity_undirected">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the global transitivity (clustering coefficient) of the graph.</p>
<p>The transitivity measures the probability that two neighbors of a vertex are connected. More precisely, this is the ratio of the triangles and connected triplets in the graph. The result is a single real number. Directed graphs are considered as undirected ones.</p>
<p>Note that this measure is different from the local transitivity measure (see <code><a href="#transitivity_local_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_local_undirected">transitivity_local_undirected()</a></code>) as it calculates a single value for the whole graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">TRANSITIVITY_ZERO</tt> or <tt class="rst-docutils literal">"zero"</tt>, the result will be zero if the graph does not have any triplets. If <tt class="rst-docutils literal">"nan"</tt> or <tt class="rst-docutils literal">TRANSITIVITY_NAN</tt>, the result will be <tt class="rst-docutils literal">NaN</tt> (not a number).</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the transitivity</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#transitivity_local_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_local_undirected">transitivity_local_undirected()</a></code>, <code><a href="#transitivity_avglocal_undirected" class="internal-link" title="igraph._igraph.GraphBase.transitivity_avglocal_undirected">transitivity_avglocal_undirected()</a></code></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">S. Wasserman and K. Faust: <em>Social Network Analysis: Methods and Applications</em>. Cambridge: Cambridge University Press, 1994.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Tree">
    
  </a>
  <a name="Tree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Tree</span>(n, children, type='undirected'):
    
    <a class="headerLink" href="#Tree" title="igraph._igraph.GraphBase.Tree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a tree in which almost all vertices have the same number of children.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">children</span></td><td class="fieldArgDesc">the number of children of a vertex in the graph</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">type</span></td><td class="fieldArgDesc">determines whether the tree should be directed, and if this is the case, also its orientation. Must be one of <tt class="rst-docutils literal">"in"</tt>, <tt class="rst-docutils literal">"out"</tt> and <tt class="rst-docutils literal">"undirected"</tt>.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Tree_Game">
    
  </a>
  <a name="Tree_Game">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Tree_Game</span>(n, directed=False, method='lerw'):
    
    <a class="headerLink" href="#Tree_Game" title="igraph._igraph.GraphBase.Tree_Game">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a random tree by sampling uniformly from the set of labelled trees with a given number of nodes.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n</span></td><td class="fieldArgDesc">the number of vertices in the tree</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the graph should be directed</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">method</span></td><td class="fieldArgDesc"><p>the generation method to be used. One of the following:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"prufer"</tt> -- samples Prufer sequences uniformly, then converts them to trees</li>
<li><tt class="rst-docutils literal">"lerw"</tt> -- performs a loop-erased random walk on the complete graph to uniformly sample its spanning trees (Wilson's algorithm). This is the default choice as it supports both directed and undirected graphs.</li>
</ul>
</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.triad_census">
    
  </a>
  <a name="triad_census">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">triad_census</span>():
    
    <a class="headerLink" href="#triad_census" title="igraph._igraph.GraphBase.triad_census">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Triad census, as defined by Davis and Leinhardt</p>
<p>Calculating the triad census means classifying every triplets of vertices in a directed graph. A triplet can be in one of 16 states, these are listed in the documentation of the C interface of igraph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: attention</td></tr><tr><td colspan="2">this function has a more convenient interface in class <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> which wraps the result in a <code><a href="igraph.datatypes.TriadCensus.html" class="internal-link" title="igraph.datatypes.TriadCensus">TriadCensus</a></code> object. It is advised to use that. The name of the triplet classes are also documented there.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.unfold_tree">
    
  </a>
  <a name="unfold_tree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">unfold_tree</span>(sources=None, mode='out'):
    
    <a class="headerLink" href="#unfold_tree" title="igraph._igraph.GraphBase.unfold_tree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Unfolds the graph using a BFS to a tree by duplicating vertices as necessary.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">sources</span></td><td class="fieldArgDesc">the source vertices to start the unfolding from. It should be a list of vertex indices, preferably one vertex from each connected component. You can use <code><a href="#topological_sorting" class="internal-link" title="igraph._igraph.GraphBase.topological_sorting">topological_sorting()</a></code> to determine a suitable set. A single vertex index is also accepted.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">which edges to follow during the BFS. <tt class="rst-docutils literal">OUT</tt> follows outgoing edges, <tt class="rst-docutils literal">IN</tt> follows incoming edges, <tt class="rst-docutils literal">ALL</tt> follows both. Ignored for undirected graphs.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the unfolded tree graph and a mapping from the new vertex indices to the old ones.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.vcount">
    
  </a>
  <a name="vcount">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">vcount</span>():
    
    <a class="headerLink" href="#vcount" title="igraph._igraph.GraphBase.vcount">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Counts the number of vertices.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">integer</td><td class="fieldArgDesc">the number of vertices in the graph.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.vertex_attributes">
    
  </a>
  <a name="vertex_attributes">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">vertex_attributes</span>():
    
    <a class="headerLink" href="#vertex_attributes" title="igraph._igraph.GraphBase.vertex_attributes">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the attribute name list of the vertices of the graph</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.vertex_connectivity">
    
  </a>
  <a name="vertex_connectivity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">vertex_connectivity</span>(source=-1, target=-1, checks=True, neighbors='error'):
    
    <a class="headerLink" href="#vertex_connectivity" title="igraph._igraph.GraphBase.vertex_connectivity">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the vertex connectivity of the graph or between some vertices.</p>
<p>The vertex connectivity between two given vertices is the number of vertices that have to be removed in order to disconnect the two vertices into two separate components. This is also the number of vertex disjoint directed paths between the vertices (apart from the source and target vertices of course). The vertex connectivity of the graph is the minimal vertex connectivity over all vertex pairs.</p>
<p>This method calculates the vertex connectivity of a given vertex pair if both the source and target vertices are given. If none of them is given (or they are both negative), the overall vertex connectivity is returned.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex involved in the calculation.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex involved in the calculation.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">checks</span></td><td class="fieldArgDesc">if the whole graph connectivity is calculated and this is <tt class="rst-docutils literal">True</tt>, igraph performs some basic checks before calculation. If the graph is not strongly connected, then the connectivity is obviously zero. If the minimum degree is one, then the connectivity is also one. These simple checks are much faster than checking the entire graph, therefore it is advised to set this to <tt class="rst-docutils literal">True</tt>. The parameter is ignored if the connectivity between two given vertices is computed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">neighbors</span></td><td class="fieldArgDesc">tells igraph what to do when the two vertices are connected. <tt class="rst-docutils literal">"error"</tt> raises an exception, <tt class="rst-docutils literal">"infinity"</tt> returns infinity, <tt class="rst-docutils literal">"ignore"</tt> ignores the edge.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the vertex connectivity</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Watts_Strogatz">
    
  </a>
  <a name="Watts_Strogatz">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Watts_Strogatz</span>(dim, size, nei, p, loops=False, multiple=False):
    
    <a class="headerLink" href="#Watts_Strogatz" title="igraph._igraph.GraphBase.Watts_Strogatz">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">dim</span></td><td class="fieldArgDesc">the dimension of the lattice</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">size</span></td><td class="fieldArgDesc">the size of the lattice along all dimensions</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">nei</span></td><td class="fieldArgDesc">value giving the distance (number of steps) within which two vertices will be connected.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">p</span></td><td class="fieldArgDesc">rewiring probability</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">specifies whether loop edges are allowed</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">multiple</span></td><td class="fieldArgDesc">specifies whether multiple edges are allowed</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="#Lattice" class="internal-link" title="igraph._igraph.GraphBase.Lattice">Lattice()</a></code>, <code><a href="#rewire" class="internal-link" title="igraph._igraph.GraphBase.rewire">rewire()</a></code>, <code><a href="#rewire_edges" class="internal-link" title="igraph._igraph.GraphBase.rewire_edges">rewire_edges()</a></code> if more flexibility is needed</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Duncan J Watts and Steven H Strogatz: <em>Collective dynamics of small world networks</em>, Nature 393, 440-442, 1998</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.Weighted_Adjacency">
    
  </a>
  <a name="Weighted_Adjacency">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">Weighted_Adjacency</span>(matrix, mode='directed', attr='weight', loops=True):
    
    <a class="headerLink" href="#Weighted_Adjacency" title="igraph._igraph.GraphBase.Weighted_Adjacency">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Generates a graph from its adjacency matrix.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">matrix</span></td><td class="fieldArgDesc">the adjacency matrix</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc"><p>the mode to be used. Possible values are:</p>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">"directed"</tt> - the graph will be directed and a matrix element gives the number of edges between two vertices.</li>
<li><tt class="rst-docutils literal">"undirected"</tt> - alias to <tt class="rst-docutils literal">"max"</tt> for convenience.</li>
<li><tt class="rst-docutils literal">"max"</tt>   - undirected graph will be created and the number of edges between vertex <span class="rst-math rst-formula"><i>i</i></span> and <span class="rst-math rst-formula"><i>j</i></span> is <span class="rst-math rst-formula"><i>max</i>(<i>A</i>(<i>i</i>, <i>j</i>), <i>A</i>(<i>j</i>, <i>i</i>))</span></li>
<li><tt class="rst-docutils literal">"min"</tt>   - like <tt class="rst-docutils literal">"max"</tt>, but with <span class="rst-math rst-formula"><i>min</i>(<i>A</i>(<i>i</i>, <i>j</i>), <i>A</i>(<i>j</i>, <i>i</i>))</span></li>
<li><tt class="rst-docutils literal">"plus"</tt>  - like <tt class="rst-docutils literal">"max"</tt>, but with <span class="rst-math rst-formula"><i>A</i>(<i>i</i>, <i>j</i>) + <i>A</i>(<i>j</i>, <i>i</i>)</span></li>
<li><tt class="rst-docutils literal">"upper"</tt> - undirected graph with the upper right triangle of the matrix (including the diagonal)</li>
<li><tt class="rst-docutils literal">"lower"</tt> - undirected graph with the lower left triangle of the matrix (including the diagonal)</li>
</ul>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">attr</span></td><td class="fieldArgDesc">the name of the edge attribute that stores the edge weights.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">loops</span></td><td class="fieldArgDesc">whether to include loop edges. When <tt class="rst-docutils literal">False</tt>, the diagonal of the adjacency matrix will be ignored.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.write_dimacs">
    
  </a>
  <a name="write_dimacs">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_dimacs</span>(f, source, target, capacity=None):
    
    <a class="headerLink" href="#write_dimacs" title="igraph._igraph.GraphBase.write_dimacs">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <code><a href="igraph.Graph.html" class="internal-link">igraph.Graph</a></code></div>
    <div><p>Writes the graph in DIMACS format to the given file.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file to be written or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">source</span></td><td class="fieldArgDesc">the source vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">target</span></td><td class="fieldArgDesc">the target vertex ID</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">capacity</span></td><td class="fieldArgDesc">the capacities of the edges in a list. If it is not a list, the corresponding edge attribute will be used to retrieve capacities.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.write_dot">
    
  </a>
  <a name="write_dot">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_dot</span>(f):
    
    <a class="headerLink" href="#write_dot" title="igraph._igraph.GraphBase.write_dot">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Writes the graph in DOT format to the given file.</p>
<p>DOT is the format used by the <a class="rst-reference external" href="http://www.graphviz.org" target="_top">GraphViz</a> software package.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file to be written or a Python file handle</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.write_edgelist">
    
  </a>
  <a name="write_edgelist">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_edgelist</span>(f):
    
    <a class="headerLink" href="#write_edgelist" title="igraph._igraph.GraphBase.write_edgelist">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Writes the edge list of a graph to a file.</p>
<p>Directed edges are written in (from, to) order.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file to be written or a Python file handle</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.write_gml">
    
  </a>
  <a name="write_gml">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_gml</span>(f, creator=None, ids=None):
    
    <a class="headerLink" href="#write_gml" title="igraph._igraph.GraphBase.write_gml">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Writes the graph in GML format to the given file.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file to be written or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">creator</span></td><td class="fieldArgDesc">optional creator information to be written to the file. If <tt class="rst-docutils literal">None</tt>, the current date and time is added.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ids</span></td><td class="fieldArgDesc">optional numeric vertex IDs to use in the file. This must be a list of integers or <tt class="rst-docutils literal">None</tt>. If <tt class="rst-docutils literal">None</tt>, the <tt class="rst-docutils literal">id</tt> attribute of the vertices are used, or if they don't exist, numeric vertex IDs will be generated automatically.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.write_graphml">
    
  </a>
  <a name="write_graphml">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_graphml</span>(f):
    
    <a class="headerLink" href="#write_graphml" title="igraph._igraph.GraphBase.write_graphml">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Writes the graph to a GraphML file.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file to be written or a Python file handle</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.write_leda">
    
  </a>
  <a name="write_leda">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_leda</span>(f, names='name', weights='weights'):
    
    <a class="headerLink" href="#write_leda" title="igraph._igraph.GraphBase.write_leda">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Writes the graph to a file in LEDA native format.</p>
<p>The LEDA format supports at most one attribute per vertex and edge. You can specify which vertex and edge attribute you want to use. Note that the name of the attribute is not saved in the LEDA file.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file to be written or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">names</span></td><td class="fieldArgDesc">the name of the vertex attribute to be stored along with the vertices. It is usually used to store the vertex names (hence the name of the keyword argument), but you may also use a numeric attribute. If you don't want to store any vertex attributes, supply <tt class="rst-docutils literal">None</tt> here.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">the name of the edge attribute to be stored along with the edges. It is usually used to store the edge weights (hence the name of the keyword argument), but you may also use a string attribute. If you don't want to store any edge attributes, supply <tt class="rst-docutils literal">None</tt> here.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.write_lgl">
    
  </a>
  <a name="write_lgl">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_lgl</span>(f, names='name', weights='weights', isolates=True):
    
    <a class="headerLink" href="#write_lgl" title="igraph._igraph.GraphBase.write_lgl">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Writes the edge list of a graph to a file in .lgl format.</p>
<p>Note that multiple edges and/or loops break the LGL software, but igraph does not check for this condition. Unless you know that the graph does not have multiple edges and/or loops, it is wise to call <code><a href="#simplify" class="internal-link" title="igraph._igraph.GraphBase.simplify">simplify()</a></code> before saving.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file to be written or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">names</span></td><td class="fieldArgDesc">the name of the vertex attribute containing the name of the vertices. If you don't want to store vertex names, supply <tt class="rst-docutils literal">None</tt> here.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">the name of the edge attribute containing the weight of the vertices. If you don't want to store weights, supply <tt class="rst-docutils literal">None</tt> here.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">isolates</span></td><td class="fieldArgDesc">whether to include isolated vertices in the output.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.write_ncol">
    
  </a>
  <a name="write_ncol">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_ncol</span>(f, names='name', weights='weights'):
    
    <a class="headerLink" href="#write_ncol" title="igraph._igraph.GraphBase.write_ncol">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Writes the edge list of a graph to a file in .ncol format.</p>
<p>Note that multiple edges and/or loops break the LGL software, but igraph does not check for this condition. Unless you know that the graph does not have multiple edges and/or loops, it is wise to call <code><a href="#simplify" class="internal-link" title="igraph._igraph.GraphBase.simplify">simplify()</a></code> before saving.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file to be written or a Python file handle</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">names</span></td><td class="fieldArgDesc">the name of the vertex attribute containing the name of the vertices. If you don't want to store vertex names, supply <tt class="rst-docutils literal">None</tt> here.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">the name of the edge attribute containing the weight of the vertices. If you don't want to store weights, supply <tt class="rst-docutils literal">None</tt> here.</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="igraph._igraph.GraphBase.write_pajek">
    
  </a>
  <a name="write_pajek">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">write_pajek</span>(f):
    
    <a class="headerLink" href="#write_pajek" title="igraph._igraph.GraphBase.write_pajek">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Writes the graph in Pajek format to the given file.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">f</span></td><td class="fieldArgDesc">the name of the file to be written or a Python file handle</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase.__graph_as_capsule">
    
  </a>
  <a name="__graph_as_capsule">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__graph_as_capsule</span>(...):
    
    <a class="headerLink" href="#__graph_as_capsule" title="igraph._igraph.GraphBase.__graph_as_capsule">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>__graph_as_capsule()</p>
<p>Returns the igraph graph encapsulated by the Python object as a PyCapsule</p>
<p>.A PyCapsule is practically a regular C pointer, wrapped in a Python object. This function should not be used directly by igraph users, it is useful only in the case when the underlying igraph object must be passed to other C code through Python.</p>
</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase.__register_destructor">
    
  </a>
  <a name="__register_destructor">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__register_destructor</span>(destructor):
    
    <a class="headerLink" href="#__register_destructor" title="igraph._igraph.GraphBase.__register_destructor">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Registers a destructor to be called when the object is freed by Python. This function should not be used directly by igraph users.</p>
</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase._Bipartite">
    
  </a>
  <a name="_Bipartite">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_Bipartite</span>(types, edges, directed=False):
    
    <a class="headerLink" href="#_Bipartite" title="igraph._igraph.GraphBase._Bipartite">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.Bipartite()</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase._Full_Bipartite">
    
  </a>
  <a name="_Full_Bipartite">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_Full_Bipartite</span>(n1, n2, directed=False, loops=False):
    
    <a class="headerLink" href="#_Full_Bipartite" title="igraph._igraph.GraphBase._Full_Bipartite">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.Full_Bipartite()</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase._get_all_simple_paths">
    
  </a>
  <a name="_get_all_simple_paths">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_get_all_simple_paths</span>(v, to=None, cutoff=-1, mode='out'):
    
    <a class="headerLink" href="#_get_all_simple_paths" title="igraph._igraph.GraphBase._get_all_simple_paths">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.get_all_simple_paths()</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase._GRG">
    
  </a>
  <a name="_GRG">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_GRG</span>(n, radius, torus=False):
    
    <a class="headerLink" href="#_GRG" title="igraph._igraph.GraphBase._GRG">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.GRG()</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase._Incidence">
    
  </a>
  <a name="_Incidence">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_Incidence</span>(matrix, directed=False, mode='all', multiple=False):
    
    <a class="headerLink" href="#_Incidence" title="igraph._igraph.GraphBase._Incidence">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.Incidence()</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase._is_matching">
    
  </a>
  <a name="_is_matching">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_is_matching</span>(matching, types=None):
    
    <a class="headerLink" href="#_is_matching" title="igraph._igraph.GraphBase._is_matching">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Internal function, undocumented.</p>
</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase._is_maximal_matching">
    
  </a>
  <a name="_is_maximal_matching">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_is_maximal_matching</span>(matching, types=None):
    
    <a class="headerLink" href="#_is_maximal_matching" title="igraph._igraph.GraphBase._is_maximal_matching">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Internal function, undocumented.</p>
<p>Use <code><a href="igraph.matching.Matching.html#is_maximal" class="internal-link" title="igraph.matching.Matching.is_maximal">igraph.Matching.is_maximal</a></code> instead.</p>
</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase._layout_sugiyama">
    
  </a>
  <a name="_layout_sugiyama">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_layout_sugiyama</span>(...):
    
    <a class="headerLink" href="#_layout_sugiyama" title="igraph._igraph.GraphBase._layout_sugiyama">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.layout_sugiyama()</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase._maximum_bipartite_matching">
    
  </a>
  <a name="_maximum_bipartite_matching">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_maximum_bipartite_matching</span>(types, weights=None):
    
    <a class="headerLink" href="#_maximum_bipartite_matching" title="igraph._igraph.GraphBase._maximum_bipartite_matching">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2"><code><a href="igraph.Graph.html#maximum_bipartite_matching" class="internal-link" title="igraph.Graph.maximum_bipartite_matching">igraph.Graph.maximum_bipartite_matching</a></code></td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase._Random_Bipartite">
    
  </a>
  <a name="_Random_Bipartite">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_Random_Bipartite</span>(n1, n2, p=None, m=None, directed=False, neimode='all'):
    
    <a class="headerLink" href="#_Random_Bipartite" title="igraph._igraph.GraphBase._Random_Bipartite">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.Random_Bipartite()</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase._raw_pointer">
    
  </a>
  <a name="_raw_pointer">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_raw_pointer</span>():
    
    <a class="headerLink" href="#_raw_pointer" title="igraph._igraph.GraphBase._raw_pointer">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns the memory address of the igraph graph encapsulated by the Python object as an ordinary Python integer.</p>
<p>This function should not be used directly by igraph users, it is useful only if you want to access some unwrapped function in the C core of igraph using the ctypes module.</p>
</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="igraph._igraph.GraphBase._spanning_tree">
    
  </a>
  <a name="_spanning_tree">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_spanning_tree</span>(weights=None):
    
    <a class="headerLink" href="#_spanning_tree" title="igraph._igraph.GraphBase._spanning_tree">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Internal function, undocumented.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">See Also</td></tr><tr><td colspan="2">Graph.spanning_tree()</td></tr></table></div>
  </div>
</div>
        </div>
      
      </div>
    </div>

    <footer class="pydoctor-navbar navbar-default">

  
  <div class="container">
    <a href="index.html">API Documentation</a> for <a href="https://igraph.org/python" class="projecthome">igraph</a>,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.9.1 at 2022-09-29 14:39:08.
  </div>

  <!-- Search related scripts needs to be loaded at the end of HTML 
    parsing not to introduce overhead and display HTML data asap -->
  <script src="ajax.js" type="text/javascript"></script>
  <script src="searchlib.js" type="text/javascript"></script>
  <script src="search.js" type="text/javascript"></script>

</footer>
  
    <script src="pydoctor.js" type="text/javascript"></script>

</div>



  </div>
  </div>
</div>
</div>


    </div>

    <div id="footer"><div class="container-fluid">
      <p class="text-muted credit">
	      &copy; 2003 &ndash; 2025 The igraph core team.
        &bull; Code licensed under <a href="http://www.gnu.org/licenses/gpl-2.0.html"> GNU GPL 2</a> or later,
        documentation under <a href="http://www.gnu.org/copyleft/fdl.html">GNU FDL</a>.
      </p>
      <p class="social">
        <a href="https://twitter.com/igraph2"><i class="fa-brands fa-twitter"></i></a>
        <a rel="me" href="https://fosstodon.org/@igraph"><i class="fa-brands fa-mastodon"></i></a>
      </p>
    </div></div>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

    <script src="/js/affix.js"></script>
    <script src="/js/jumbotron.js"></script>
    <script src="/js/toggle.js"></script>


    <script src="/js/doc-version-switcher.js"></script>
    <script>
        generateVersionSwitcher('#doc-version-switcher', 'python', 'api/');
    </script>





    
  </body>
</html>
