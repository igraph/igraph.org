---
layout: pydoctor
title: python-igraph API reference
mainheader: python-igraph API reference
lead: List of all classes, functions and methods in python-igraph
doctype: api/
vmenu: true
lang: python
langversion: 0.10.1
---
{% raw %}
<nav class="navbar navbar-default mainnavbar">
      
  
  <div class="container-fluid">


    <div class="navbar-header">
      
      <div class="navlinks">
        <span class="navbar-brand">
          <a href="https://igraph.org/python" class="projecthome">"igraph"</a> <a href="index.html">API Documentation</a>
        </span>

        <a href="moduleIndex.html">
          Modules
        </a>

        <a href="classIndex.html">
          Classes
        </a>

        <a href="nameIndex.html">
          Names
        </a>

        <div id="search-box-container">
          <div class="input-group">
            <input id="search-box" type="search" name="search-query" placeholder="Search..." aria-label="Search" minlength="2" class="form-control" autocomplete="off" />
            
            <span class="input-group-btn">
              <a style="display: none;" class="btn btn-default" id="search-clear-button" title="Clear" onclick="clearSearch()"><img src="fonts/x-circle.svg" alt="Clear" /></a>
              <a class="btn btn-default" id="search-help-button" title="Help" onclick="toggleSearchHelpText()"><img src="fonts/info.svg" alt="Help" /></a>
            </span>
          </div>
        </div>

      </div>

      <div id="search-results-container" style="display: none;">
        
        <div id="search-buttons">
          <span class="label label-default" id="search-docstrings-button">
          <label class="checkbox-inline">
            <input type="checkbox" id="toggle-search-in-docstrings-checkbox" value="false" onclick="toggleSearchInDocstrings()">
              search in docstrings
            </input>
          </label>
          </span>
          
        </div>
        
        <noscript>
            <h1>Cannot search: JavaScript is not supported/enabled in your browser.</h1>
        </noscript>

        <div class="hint" id="search-help-box">
          <p class="rst-last">
      
            Search bar offers the following options:
            <ul>   
                <li>
                  <strong>Term presence.</strong> The below example searches for documents that 
                    must contain “foo”, might contain “bar” and must not contain “baz”: <code>+foo bar -baz</code>
                </li> 

                <li>
                  <strong>Wildcards.</strong> The below example searches for documents with words beginning with “foo”: <code>foo*</code>
                </li> 

                <li>
                  <strong>Search in specific fields.</strong> The following search matches all objects 
                  in "twisted.mail" that matches “search”: <code>+qname:twisted.mail.* +search</code>

                  <p>
                    Possible fields: 'name', 'qname' (fully qualified name), 'docstring', and 'kind'.
                    Last two fields are only applicable if "search in docstrings" is enabled.
                  </p>
                </li>

                <li>
                  <strong>Fuzzy matches.</strong> The following search matches all documents 
                  that have a word within 1 edit distance of “foo”: <code>foo~1</code>
                </li>
            </ul>

          </p>
        </div>

        <div id="search-status"> </div>

        <div class="warning" id="search-warn-box" style="display: none;">
          <p class="rst-last"><span id="search-warn"></span></p>
        </div>

        <table id="search-results">
          <!-- Filled dynamically by JS -->
        </table>
        
        <div style="margin-top: 8px;">
          <p>Results provided by <a href="https://lunrjs.com">Lunr.js</a></p>
        </div>
      </div>

    </div>


  </div>
</nav>
    
    <div class="container-fluid">

      <!-- Side navigation -->
      

      <div id="main" class="nosidebar">
        

        

        <div class="page-header">
          <h1 class="module"><code><code><a href="index.html" class="internal-link">igraph</a></code><wbr></wbr>.<code><a href="igraph.io.html" class="internal-link" title="igraph.io">io</a></code><wbr></wbr>.<code><a href="igraph.io.bipartite.html" class="internal-link" title="igraph.io.bipartite">bipartite</a></code></code></h1>
          <div id="showPrivate">
            <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
          </div>
        </div>

        <div class="categoryHeader">
          module documentation
        </div>

        <div class="extrasDocstring">
          
          <p></p>
        </div>

        <div class="moduleDocstring">
          <div><p class="undocumented">Undocumented</p></div>
        </div>

        <div id="splitTables">
          <table class="children sortable" id="id183">
  
  
  <tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_bipartite_graph" class="internal-link" title="igraph.io.bipartite._construct_bipartite_graph">_construct<wbr></wbr>_bipartite<wbr></wbr>_graph</a></code></td>
    <td>Creates a bipartite graph with the given vertex types and edges. This is similar to the default constructor of the graph, the only difference is that it checks whether all the edges go between the two vertex classes and it assigns the type vector to a ...</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_full_bipartite_graph" class="internal-link" title="igraph.io.bipartite._construct_full_bipartite_graph">_construct<wbr></wbr>_full<wbr></wbr>_bipartite<wbr></wbr>_graph</a></code></td>
    <td>Generates a full bipartite graph (directed or undirected, with or without loops).</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_incidence_bipartite_graph" class="internal-link" title="igraph.io.bipartite._construct_incidence_bipartite_graph">_construct<wbr></wbr>_incidence<wbr></wbr>_bipartite<wbr></wbr>_graph</a></code></td>
    <td>Creates a bipartite graph from an incidence matrix.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_construct_random_bipartite_graph" class="internal-link" title="igraph.io.bipartite._construct_random_bipartite_graph">_construct<wbr></wbr>_random<wbr></wbr>_bipartite<wbr></wbr>_graph</a></code></td>
    <td>Generates a random bipartite graph with the given number of vertices and edges (if m is given), or with the given number of vertices and the given connection probability (if p is given).</td>
  </tr>
</table>
          

            
        </div>

        <div id="childList">
          <div class="basefunction private">
  
  
  <a name="igraph.io.bipartite._construct_bipartite_graph">
    
  </a>
  <a name="_construct_bipartite_graph">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_bipartite_graph</span>(cls, types, edges, directed=False, *args, **kwds):
    
    <a class="headerLink" href="#_construct_bipartite_graph" title="igraph.io.bipartite._construct_bipartite_graph">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Creates a bipartite graph with the given vertex types and edges. This is similar to the default constructor of the graph, the only difference is that it checks whether all the edges go between the two vertex classes and it assigns the type vector to a <tt class="rst-docutils literal">type</tt> attribute afterwards.</p>
<p>Examples:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Bipartite([0, 1, 0, 1], [(0, 1), (2, 3), (0, 3)])
<span class="py-prompt">&gt;&gt;&gt; </span>g.is_bipartite()
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g.vs[<span class="py-string">"type"</span>]
<span class="py-output">[False, True, False, True]</span>
</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cls</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">types</span></td><td class="fieldArgDesc">the vertex types as a boolean list. Anything that evaluates to <tt class="rst-docutils literal">False</tt> will denote a vertex of the first kind, anything that evaluates to <tt class="rst-docutils literal">True</tt> will denote a vertex of the second kind.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edges</span></td><td class="fieldArgDesc">the edges as a list of tuples.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to create a directed graph. Bipartite networks are usually undirected, so the default is <tt class="rst-docutils literal">False</tt></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the graph with a binary vertex attribute named <tt class="rst-docutils literal">"type"</tt> that stores the vertex classes.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.bipartite._construct_full_bipartite_graph">
    
  </a>
  <a name="_construct_full_bipartite_graph">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_full_bipartite_graph</span>(cls, n1, n2, directed=False, mode=<span class="rst-variable-quote">'</span><span class="rst-variable-string">all</span><span class="rst-variable-quote">'</span>, *args, **kwds):
    
    <a class="headerLink" href="#_construct_full_bipartite_graph" title="igraph.io.bipartite._construct_full_bipartite_graph">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a full bipartite graph (directed or undirected, with or without loops).</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Full_Bipartite(2, 3)
<span class="py-prompt">&gt;&gt;&gt; </span>g.is_bipartite()
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>g.vs[<span class="py-string">"type"</span>]
<span class="py-output">[False, False, True, True, True]</span>
</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cls</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n1</span></td><td class="fieldArgDesc">the number of vertices of the first kind.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n2</span></td><td class="fieldArgDesc">the number of vertices of the second kind.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether tp generate a directed graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">"out"</tt>, then all vertices of the first kind are connected to the others; <tt class="rst-docutils literal">"in"</tt> specifies the opposite direction, <tt class="rst-docutils literal">"all"</tt> creates mutual edges. Ignored for undirected graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the graph with a binary vertex attribute named <tt class="rst-docutils literal">"type"</tt> that stores the vertex classes.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.bipartite._construct_incidence_bipartite_graph">
    
  </a>
  <a name="_construct_incidence_bipartite_graph">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_incidence_bipartite_graph</span>(cls, matrix, directed=False, mode=<span class="rst-variable-quote">'</span><span class="rst-variable-string">out</span><span class="rst-variable-quote">'</span>, multiple=False, weighted=None, *args, **kwds):
    
    <a class="headerLink" href="#_construct_incidence_bipartite_graph" title="igraph.io.bipartite._construct_incidence_bipartite_graph">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Creates a bipartite graph from an incidence matrix.</p>
<p>Example:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>g = Graph.Incidence([[0, 1, 1], [1, 1, 0]])</pre><table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cls</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">matrix</span></td><td class="fieldArgDesc">the incidence matrix.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to create a directed graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode</span></td><td class="fieldArgDesc">defines the direction of edges in the graph. If <tt class="rst-docutils literal">"out"</tt>, then edges go from vertices of the first kind (corresponding to rows of the matrix) to vertices of the second kind (the columns of the matrix). If <tt class="rst-docutils literal">"in"</tt>, the opposite direction is used. <tt class="rst-docutils literal">"all"</tt> creates mutual edges. Ignored for undirected graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">multiple</span></td><td class="fieldArgDesc">defines what to do with non-zero entries in the matrix. If <tt class="rst-docutils literal">False</tt>, non-zero entries will create an edge no matter what the value is. If <tt class="rst-docutils literal">True</tt>, non-zero entries are rounded up to the nearest integer and this will be the number of multiple edges created.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weighted</span></td><td class="fieldArgDesc">defines whether to create a weighted graph from the incidence matrix. If it is c{None} then an unweighted graph is created and the multiple argument is used to determine the edges of the graph. If it is a string then for every non-zero matrix entry, an edge is created and the value of the entry is added as an edge attribute named by the weighted argument. If it is <tt class="rst-docutils literal">True</tt> then a weighted graph is created and the name of the edge attribute will be ‘weight’.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the graph with a binary vertex attribute named <tt class="rst-docutils literal">"type"</tt> that stores the vertex classes.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code>ValueError</code></td><td>if the weighted and multiple are passed together.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.io.bipartite._construct_random_bipartite_graph">
    
  </a>
  <a name="_construct_random_bipartite_graph">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_construct_random_bipartite_graph</span>(cls, n1, n2, p=None, m=None, directed=False, neimode=<span class="rst-variable-quote">'</span><span class="rst-variable-string">all</span><span class="rst-variable-quote">'</span>, *args, **kwds):
    
    <a class="headerLink" href="#_construct_random_bipartite_graph" title="igraph.io.bipartite._construct_random_bipartite_graph">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Generates a random bipartite graph with the given number of vertices and edges (if m is given), or with the given number of vertices and the given connection probability (if p is given).</p>
<p>If m is given but p is not, the generated graph will have n1 vertices of type 1, n2 vertices of type 2 and m randomly selected edges between them. If p is given but m is not, the generated graph will have n1 vertices of type 1 and n2 vertices of type 2, and each edge will exist between them with probability p.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cls</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n1</span></td><td class="fieldArgDesc">the number of vertices of type 1.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n2</span></td><td class="fieldArgDesc">the number of vertices of type 2.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">p</span></td><td class="fieldArgDesc">the probability of edges. If given, <tt class="rst-docutils literal">m</tt> must be missing.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">m</span></td><td class="fieldArgDesc">the number of edges. If given, <tt class="rst-docutils literal">p</tt> must be missing.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether to generate a directed graph.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">neimode</span></td><td class="fieldArgDesc">if the graph is directed, specifies how the edges will be generated. If it is <tt class="rst-docutils literal">"all"</tt>, edges will be generated in both directions (from type 1 to type 2 and vice versa) independently. If it is <tt class="rst-docutils literal">"out"</tt> edges will always point from type 1 to type 2. If it is <tt class="rst-docutils literal">"in"</tt>, edges will always point from type 2 to type 1. This argument is ignored for undirected graphs.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr></table></div>
  </div>
</div>
        </div>
      
      </div>
    </div>

    {% endraw %}
