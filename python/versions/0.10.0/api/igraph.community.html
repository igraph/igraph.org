---
layout: pydoctor
title: python-igraph API reference
mainheader: python-igraph API reference
lead: List of all classes, functions and methods in python-igraph
doctype: api/
vmenu: true
lang: python
langversion: 0.10.0
---
{% raw %}
<nav class="navbar navbar-default mainnavbar">
      
  
  <div class="container-fluid">


    <div class="navbar-header">
      
      <div class="navlinks">
        <span class="navbar-brand">
          <a href="https://igraph.org/python" class="projecthome">"igraph"</a> <a href="index.html">API Documentation</a>
        </span>

        <a href="moduleIndex.html">
          Modules
        </a>

        <a href="classIndex.html">
          Classes
        </a>

        <a href="nameIndex.html">
          Names
        </a>

        <div id="search-box-container">
          <div class="input-group">
            <input id="search-box" type="search" name="search-query" placeholder="Search..." aria-label="Search" minlength="2" class="form-control" autocomplete="off" />
            
            <span class="input-group-btn">
              <a style="display: none;" class="btn btn-default" id="search-clear-button" title="Clear" onclick="clearSearch()"><img src="fonts/x-circle.svg" alt="Clear" /></a>
              <a class="btn btn-default" id="search-help-button" title="Help" onclick="toggleSearchHelpText()"><img src="fonts/info.svg" alt="Help" /></a>
            </span>
          </div>
        </div>

      </div>

      <div id="search-results-container" style="display: none;">
        
        <div id="search-buttons">
          <span class="label label-default" id="search-docstrings-button">
          <label class="checkbox-inline">
            <input type="checkbox" id="toggle-search-in-docstrings-checkbox" value="false" onclick="toggleSearchInDocstrings()">
              search in docstrings
            </input>
          </label>
          </span>
          
        </div>
        
        <noscript>
            <h1>Cannot search: JavaScript is not supported/enabled in your browser.</h1>
        </noscript>

        <div class="hint" id="search-help-box">
          <p class="rst-last">
      
            Search bar offers the following options:
            <ul>   
                <li>
                  <strong>Term presence.</strong> The below example searches for documents that 
                    must contain “foo”, might contain “bar” and must not contain “baz”: <code>+foo bar -baz</code>
                </li> 

                <li>
                  <strong>Wildcards.</strong> The below example searches for documents with words beginning with “foo”: <code>foo*</code>
                </li> 

                <li>
                  <strong>Search in specific fields.</strong> The following search matches all objects 
                  in "twisted.mail" that matches “search”: <code>+qname:twisted.mail.* +search</code>

                  <p>
                    Possible fields: 'name', 'qname' (fully qualified name), 'docstring', and 'kind'.
                    Last two fields are only applicable if "search in docstrings" is enabled.
                  </p>
                </li>

                <li>
                  <strong>Fuzzy matches.</strong> The following search matches all documents 
                  that have a word within 1 edit distance of “foo”: <code>foo~1</code>
                </li>
            </ul>

          </p>
        </div>

        <div id="search-status"> </div>

        <div class="warning" id="search-warn-box" style="display: none;">
          <p class="rst-last"><span id="search-warn"></span></p>
        </div>

        <table id="search-results">
          <!-- Filled dynamically by JS -->
        </table>
        
        <div style="margin-top: 8px;">
          <p>Results provided by <a href="https://lunrjs.com">Lunr.js</a></p>
        </div>
      </div>

    </div>


  </div>
</nav>
    
    <div class="container-fluid">

      <!-- Side navigation -->
      

      <div id="main" class="nosidebar">
        

        

        <div class="page-header">
          <h1 class="module"><code><code><a href="index.html" class="internal-link">igraph</a></code><wbr></wbr>.<code><a href="igraph.community.html" class="internal-link" title="igraph.community">community</a></code></code></h1>
          <div id="showPrivate">
            <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
          </div>
        </div>

        <div class="categoryHeader">
          module documentation
        </div>

        <div class="extrasDocstring">
          
          <p></p>
        </div>

        <div class="moduleDocstring">
          <div><p class="undocumented">Undocumented</p></div>
        </div>

        <div id="splitTables">
          <table class="children sortable" id="id37">
  
  
  <tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_edge_betweenness" class="internal-link" title="igraph.community._community_edge_betweenness">_community<wbr></wbr>_edge<wbr></wbr>_betweenness</a></code></td>
    <td>Community structure based on the betweenness of the edges in the network.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_fastgreedy" class="internal-link" title="igraph.community._community_fastgreedy">_community<wbr></wbr>_fastgreedy</a></code></td>
    <td>Community structure based on the greedy optimization of modularity.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_infomap" class="internal-link" title="igraph.community._community_infomap">_community<wbr></wbr>_infomap</a></code></td>
    <td>Finds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_label_propagation" class="internal-link" title="igraph.community._community_label_propagation">_community<wbr></wbr>_label<wbr></wbr>_propagation</a></code></td>
    <td>Finds the community structure of the graph according to the label propagation method of Raghavan et al.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_leading_eigenvector" class="internal-link" title="igraph.community._community_leading_eigenvector">_community<wbr></wbr>_leading<wbr></wbr>_eigenvector</a></code></td>
    <td>Newman's leading eigenvector method for detecting community structure.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_leading_eigenvector_naive" class="internal-link" title="igraph.community._community_leading_eigenvector_naive">_community<wbr></wbr>_leading<wbr></wbr>_eigenvector<wbr></wbr>_naive</a></code></td>
    <td>Naive implementation of Newman's eigenvector community structure detection.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_leiden" class="internal-link" title="igraph.community._community_leiden">_community<wbr></wbr>_leiden</a></code></td>
    <td>Finds the community structure of the graph using the Leiden algorithm of Traag, van Eck &amp; Waltman.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_multilevel" class="internal-link" title="igraph.community._community_multilevel">_community<wbr></wbr>_multilevel</a></code></td>
    <td>Community structure based on the multilevel algorithm of Blondel et al.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_optimal_modularity" class="internal-link" title="igraph.community._community_optimal_modularity">_community<wbr></wbr>_optimal<wbr></wbr>_modularity</a></code></td>
    <td>Calculates the optimal modularity score of the graph and the corresponding community structure.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_spinglass" class="internal-link" title="igraph.community._community_spinglass">_community<wbr></wbr>_spinglass</a></code></td>
    <td>Finds the community structure of the graph according to the spinglass community detection method of Reichardt &amp; Bornholdt.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_community_walktrap" class="internal-link" title="igraph.community._community_walktrap">_community<wbr></wbr>_walktrap</a></code></td>
    <td>Community detection algorithm of Latapy &amp; Pons, based on random walks.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_k_core" class="internal-link" title="igraph.community._k_core">_k<wbr></wbr>_core</a></code></td>
    <td>Returns some k-cores of the graph.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_modularity" class="internal-link" title="igraph.community._modularity">_modularity</a></code></td>
    <td>Calculates the modularity score of the graph with respect to a given clustering.</td>
  </tr>
</table>
          

            
        </div>

        <div id="childList">
          <div class="basefunction private">
  
  
  <a name="igraph.community._community_edge_betweenness">
    
  </a>
  <a name="_community_edge_betweenness">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_edge_betweenness</span>(graph, clusters=None, directed=True, weights=None):
    
    <a class="headerLink" href="#_community_edge_betweenness" title="igraph.community._community_edge_betweenness">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Community structure based on the betweenness of the edges in the network.</p>
<p>The idea is that the betweenness of the edges connecting two communities is typically high, as many of the shortest paths between nodes in separate communities go through them. So we gradually remove the edge with the highest betweenness and recalculate the betweennesses after every removal. This way sooner or later the network falls of to separate components. The result of the clustering will be represented by a dendrogram.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">clusters</span></td><td class="fieldArgDesc">the number of clusters we would like to see. This practically defines the "level" where we "cut" the dendrogram to get the membership vector of the vertices. If <tt class="rst-docutils literal">None</tt>, the dendrogram is cut at the level which maximizes the modularity when the graph is unweighted; otherwise the dendrogram is cut at at a single cluster (because cluster count selection based on modularities does not make sense for this method if not all the weights are equal).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">directed</span></td><td class="fieldArgDesc">whether the directionality of the edges should be taken into account or not.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.clustering.VertexDendrogram.html" class="internal-link" title="igraph.clustering.VertexDendrogram">VertexDendrogram</a></code> object, initally cut at the maximum modularity or at the desired number of clusters.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.community._community_fastgreedy">
    
  </a>
  <a name="_community_fastgreedy">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_fastgreedy</span>(graph, weights=None):
    
    <a class="headerLink" href="#_community_fastgreedy" title="igraph.community._community_fastgreedy">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Community structure based on the greedy optimization of modularity.</p>
<p>This algorithm merges individual nodes into communities in a way that greedily maximizes the modularity score of the graph. It can be proven that if no merge can increase the current modularity score, the algorithm can be stopped since no further increase can be achieved.</p>
<p>This algorithm is said to run almost in linear time on sparse graphs.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge attribute name or a list containing edge weights</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexDendrogram.html" class="internal-link" title="igraph.clustering.VertexDendrogram">VertexDendrogram</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">A Clauset, MEJ Newman and C Moore: Finding community structure in very large networks. Phys Rev E 70, 066111 (2004).</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.community._community_infomap">
    
  </a>
  <a name="_community_infomap">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_infomap</span>(graph, edge_weights=None, vertex_weights=None, trials=10):
    
    <a class="headerLink" href="#_community_infomap" title="igraph.community._community_infomap">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Finds the community structure of the network according to the Infomap method of Martin Rosvall and Carl T. Bergstrom.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">edge<wbr></wbr>_weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">vertex<wbr></wbr>_weights</span></td><td class="fieldArgDesc">name of an vertex attribute or a list containing vertex weights.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">trials</span></td><td class="fieldArgDesc">the number of attempts to partition the network.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> object with an extra attribute called <tt class="rst-docutils literal">codelength</tt> that stores the code length determined by the algorithm.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">M. Rosvall and C. T. Bergstrom: Maps of information flow reveal community structure in complex networks, PNAS 105, 1118 (2008). <a class="rst-reference external" href="http://dx.doi.org/10.1073/pnas.0706851105" target="_top">http://dx.doi.org/10.1073/pnas.0706851105</a>, <a class="rst-reference external" href="http://arxiv.org/abs/0707.0609" target="_top">http://arxiv.org/abs/0707.0609</a>.</td></tr><tr><td colspan="2">M. Rosvall, D. Axelsson, and C. T. Bergstrom: The map equation, Eur. Phys. J. Special Topics 178, 13 (2009). <a class="rst-reference external" href="http://dx.doi.org/10.1140/epjst/e2010-01179-1" target="_top">http://dx.doi.org/10.1140/epjst/e2010-01179-1</a>, <a class="rst-reference external" href="http://arxiv.org/abs/0906.1405" target="_top">http://arxiv.org/abs/0906.1405</a>.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.community._community_label_propagation">
    
  </a>
  <a name="_community_label_propagation">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_label_propagation</span>(graph, weights=None, initial=None, fixed=None):
    
    <a class="headerLink" href="#_community_label_propagation" title="igraph.community._community_label_propagation">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Finds the community structure of the graph according to the label propagation method of Raghavan et al.</p>
<p>Initially, each vertex is assigned a different label. After that, each vertex chooses the dominant label in its neighbourhood in each iteration. Ties are broken randomly and the order in which the vertices are updated is randomized before every iteration. The algorithm ends when vertices reach a consensus.</p>
<p>Note that since ties are broken randomly, there is no guarantee that the algorithm returns the same community structure after each run. In fact, they frequently differ. See the paper of Raghavan et al on how to come up with an aggregated community structure.</p>
<p>Also note that the community _labels_ (numbers) have no semantic meaning and igraph is free to re-number communities. If you use fixed labels, igraph may still re-number the communities, but co-community membership constraints will be respected: if you had two vertices with fixed labels that belonged to the same community, they will still be in the same community at the end. Similarly, if you had two vertices with fixed labels that belonged to different communities, they will still be in different communities at the end.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">initial</span></td><td class="fieldArgDesc">name of a vertex attribute or a list containing the initial vertex labels. Labels are identified by integers from zero to <span class="rst-math rst-formula"><i>n</i> − 1</span> where <span class="rst-math rst-formula"><i>n</i></span> is the number of vertices. Negative numbers may also be present in this vector, they represent unlabeled vertices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">fixed</span></td><td class="fieldArgDesc">a list of booleans for each vertex. <tt class="rst-docutils literal">True</tt> corresponds to vertices whose labeling should not change during the algorithm. It only makes sense if initial labels are also given. Unlabeled vertices cannot be fixed. It may also be the name of a vertex attribute; each attribute value will be interpreted as a Boolean.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Raghavan, U.N. and Albert, R. and Kumara, S. Near linear time algorithm to detect community structures in large-scale networks. Phys Rev E 76:036106, 2007. <a class="rst-reference external" href="http://arxiv.org/abs/0709.2938" target="_top">http://arxiv.org/abs/0709.2938</a>.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.community._community_leading_eigenvector">
    
  </a>
  <a name="_community_leading_eigenvector">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_leading_eigenvector</span>(graph, clusters=None, weights=None, arpack_options=None):
    
    <a class="headerLink" href="#_community_leading_eigenvector" title="igraph.community._community_leading_eigenvector">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Newman's leading eigenvector method for detecting community structure.</p>
<p>This is the proper implementation of the recursive, divisive algorithm: each split is done by maximizing the modularity regarding the original network.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">clusters</span></td><td class="fieldArgDesc">the desired number of communities. If <tt class="rst-docutils literal">None</tt>, the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same, so the actual number of discovered communities can be less than the desired one.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">arpack<wbr></wbr>_options</span></td><td class="fieldArgDesc">an <code><a href="igraph.ARPACKOptions.html" class="internal-link" title="igraph.ARPACKOptions">ARPACKOptions</a></code> object used to fine-tune the ARPACK eigenvector calculation. If omitted, the module-level variable called <tt class="rst-docutils literal">arpack_options</tt> is used.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.community._community_leading_eigenvector_naive">
    
  </a>
  <a name="_community_leading_eigenvector_naive">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_leading_eigenvector_naive</span>(graph, clusters=None, return_merges=False):
    
    <a class="headerLink" href="#_community_leading_eigenvector_naive" title="igraph.community._community_leading_eigenvector_naive">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Naive implementation of Newman's eigenvector community structure detection.</p>
<p>This function splits the network into two components according to the leading eigenvector of the modularity matrix and then recursively takes the given number of steps by splitting the communities as individual networks. This is not the correct way, however, see the reference for explanation. Consider using the correct <code><a href="igraph.Graph.html#community_leading_eigenvector" class="internal-link" title="igraph.Graph.community_leading_eigenvector">Graph.community_leading_eigenvector</a></code> method instead.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">clusters</span></td><td class="fieldArgDesc">the desired number of communities. If <tt class="rst-docutils literal">None</tt>, the algorithm tries to do as many splits as possible. Note that the algorithm won't split a community further if the signs of the leading eigenvector are all the same, so the actual number of discovered communities can be less than the desired one.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_merges</span></td><td class="fieldArgDesc">whether the returned object should be a dendrogram instead of a single clustering.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> or <code><a href="igraph.clustering.VertexDendrogram.html" class="internal-link" title="igraph.clustering.VertexDendrogram">VertexDendrogram</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">MEJ Newman: Finding community structure in networks using the eigenvectors of matrices, arXiv:physics/0605087</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.community._community_leiden">
    
  </a>
  <a name="_community_leiden">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_leiden</span>(graph, objective_function=<span class="rst-variable-quote">'</span><span class="rst-variable-string">CPM</span><span class="rst-variable-quote">'</span>, weights=None, resolution_parameter=1.0, beta=0.01, initial_membership=None, n_iterations=2, node_weights=None):
    
    <a class="headerLink" href="#_community_leiden" title="igraph.community._community_leiden">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Finds the community structure of the graph using the Leiden algorithm of Traag, van Eck &amp; Waltman.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">objective<wbr></wbr>_function</span></td><td class="fieldArgDesc">whether to use the Constant Potts Model (CPM) or modularity. Must be either <tt class="rst-docutils literal">"CPM"</tt> or <tt class="rst-docutils literal">"modularity"</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">resolution<wbr></wbr>_parameter</span></td><td class="fieldArgDesc">the resolution parameter to use. Higher resolutions lead to more smaller communities, while lower resolutions lead to fewer larger communities.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">beta</span></td><td class="fieldArgDesc">parameter affecting the randomness in the Leiden algorithm. This affects only the refinement step of the algorithm.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">initial<wbr></wbr>_membership</span></td><td class="fieldArgDesc">if provided, the Leiden algorithm will try to improve this provided membership. If no argument is provided, the aglorithm simply starts from the singleton partition.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n<wbr></wbr>_iterations</span></td><td class="fieldArgDesc">the number of iterations to iterate the Leiden algorithm. Each iteration may improve the partition further. Using a negative number of iterations will run until a stable iteration is encountered (i.e. the quality was not increased during that iteration).</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">node<wbr></wbr>_weights</span></td><td class="fieldArgDesc">the node weights used in the Leiden algorithm. If this is not provided, it will be automatically determined on the basis of whether you want to use CPM or modularity. If you do provide this, please make sure that you understand what you are doing.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Traag, V. A., Waltman, L., &amp; van Eck, N. J. (2019). From Louvain to Leiden: guaranteeing well-connected communities. Scientific reports, 9(1), 5233. doi: 10.1038/s41598-019-41695-z</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.community._community_multilevel">
    
  </a>
  <a name="_community_multilevel">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_multilevel</span>(graph, weights=None, return_levels=False):
    
    <a class="headerLink" href="#_community_multilevel" title="igraph.community._community_multilevel">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Community structure based on the multilevel algorithm of Blondel et al.</p>
<p>This is a bottom-up algorithm: initially every vertex belongs to a separate community, and vertices are moved between communities iteratively in a way that maximizes the vertices' local contribution to the overall modularity score. When a consensus is reached (i.e. no single move would increase the modularity score), every community in the original graph is shrank to a single vertex (while keeping the total weight of the adjacent edges) and the process continues on the next level. The algorithm stops when it is not possible to increase the modularity any more after shrinking the communities to vertices.</p>
<p>This algorithm is said to run almost in linear time on sparse graphs.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge attribute name or a list containing edge weights</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">return<wbr></wbr>_levels</span></td><td class="fieldArgDesc">if <tt class="rst-docutils literal">True</tt>, the communities at each level are returned in a list. If <tt class="rst-docutils literal">False</tt>, only the community structure with the best modularity is returned.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a list of <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> objects, one corresponding to each level (if <tt class="rst-docutils literal">return_levels</tt> is <tt class="rst-docutils literal">True</tt>), or a <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> corresponding to the best modularity.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of community hierarchies in large networks, J Stat Mech P10008 (2008), http://arxiv.org/abs/0803.0476</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.community._community_optimal_modularity">
    
  </a>
  <a name="_community_optimal_modularity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_optimal_modularity</span>(graph, *args, **kwds):
    
    <a class="headerLink" href="#_community_optimal_modularity" title="igraph.community._community_optimal_modularity">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the optimal modularity score of the graph and the corresponding community structure.</p>
<p>This function uses the GNU Linear Programming Kit to solve a large integer optimization problem in order to find the optimal modularity score and the corresponding community structure, therefore it is unlikely to work for graphs larger than a few (less than a hundred) vertices. Consider using one of the heuristic approaches instead if you have such a large graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the calculated membership vector and the corresponding modularity in a tuple.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.community._community_spinglass">
    
  </a>
  <a name="_community_spinglass">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_spinglass</span>(graph, *args, **kwds):
    
    <a class="headerLink" href="#_community_spinglass" title="igraph.community._community_spinglass">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Finds the community structure of the graph according to the spinglass community detection method of Reichardt &amp; Bornholdt.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">*args</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">**kwds</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">edge weights to be used. Can be a sequence or iterable or even an edge attribute name.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">spins</span></td><td class="fieldArgDesc">integer, the number of spins to use. This is the upper limit for the number of communities. It is not a problem to supply a (reasonably) big number here, in which case some spin states will be unpopulated.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">parupdate</span></td><td class="fieldArgDesc">whether to update the spins of the vertices in parallel (synchronously) or not</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">start<wbr></wbr>_temp</span></td><td class="fieldArgDesc">the starting temperature</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">stop<wbr></wbr>_temp</span></td><td class="fieldArgDesc">the stop temperature</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">cool<wbr></wbr>_fact</span></td><td class="fieldArgDesc">cooling factor for the simulated annealing</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">update<wbr></wbr>_rule</span></td><td class="fieldArgDesc">specifies the null model of the simulation. Possible values are <tt class="rst-docutils literal">"config"</tt> (a random graph with the same vertex degrees as the input graph) or <tt class="rst-docutils literal">"simple"</tt> (a random graph with the same number of edges)</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">gamma</span></td><td class="fieldArgDesc">the gamma argument of the algorithm, specifying the balance between the importance of present and missing edges within a community. The default value of 1.0 assigns equal importance to both of them.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">implementation</span></td><td class="fieldArgDesc">currently igraph contains two implementations of the spinglass community detection algorithm. The faster original implementation is the default. The other implementation is able to take into account negative weights, this can be chosen by setting <tt class="rst-docutils literal">implementation</tt> to <tt class="rst-docutils literal">"neg"</tt></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">lambda_</span></td><td class="fieldArgDesc">the lambda argument of the algorithm, which specifies the balance between the importance of present and missing negatively weighted edges within a community. Smaller values of lambda lead to communities with less negative intra-connectivity. If the argument is zero, the algorithm reduces to a graph coloring algorithm, using the number of spins as colors. This argument is ignored if the original implementation is used. Note the underscore at the end of the argument name; this is due to the fact that lambda is a reserved keyword in Python.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">an appropriate <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Reichardt J and Bornholdt S: Statistical mechanics of community detection. Phys Rev E 74:016110 (2006). <a class="rst-reference external" href="http://arxiv.org/abs/cond-mat/0603718" target="_top">http://arxiv.org/abs/cond-mat/0603718</a>.</td></tr><tr><td colspan="2">Traag VA and Bruggeman J: Community detection in networks with positive and negative links. Phys Rev E 80:036115 (2009). <a class="rst-reference external" href="http://arxiv.org/abs/0811.2329" target="_top">http://arxiv.org/abs/0811.2329</a>.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.community._community_walktrap">
    
  </a>
  <a name="_community_walktrap">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_community_walktrap</span>(graph, weights=None, steps=4):
    
    <a class="headerLink" href="#_community_walktrap" title="igraph.community._community_walktrap">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Community detection algorithm of Latapy &amp; Pons, based on random walks.</p>
<p>The basic idea of the algorithm is that short random walks tend to stay in the same community. The result of the clustering will be represented as a dendrogram.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">graph</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">name of an edge attribute or a list containing edge weights</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">steps</span></td><td class="fieldArgDesc">length of random walks to perform</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">a <code><a href="igraph.clustering.VertexDendrogram.html" class="internal-link" title="igraph.clustering.VertexDendrogram">VertexDendrogram</a></code> object, initially cut at the maximum modularity.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">Pascal Pons, Matthieu Latapy: Computing communities in large networks using random walks, <a class="rst-reference external" href="http://arxiv.org/abs/physics/0512106" target="_top">http://arxiv.org/abs/physics/0512106</a>.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.community._k_core">
    
  </a>
  <a name="_k_core">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_k_core</span>(graph, *args):
    
    <a class="headerLink" href="#_k_core" title="igraph.community._k_core">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Returns some k-cores of the graph.</p>
<p>The method accepts an arbitrary number of arguments representing the desired indices of the <span class="rst-math rst-formula"><i>k</i></span>-cores to be returned. The arguments can also be lists or tuples. The result is a single <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> object if an only integer argument was given, otherwise the result is a list of <code><a href="igraph.Graph.html" class="internal-link" title="igraph.Graph">Graph</a></code> objects representing the desired k-cores in the order the arguments were specified. If no argument is given, returns all <span class="rst-math rst-formula"><i>k</i></span>-cores in increasing order of <span class="rst-math rst-formula"><i>k</i></span>.</p>
</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="igraph.community._modularity">
    
  </a>
  <a name="_modularity">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_modularity</span>(self, membership, weights=None):
    
    <a class="headerLink" href="#_modularity" title="igraph.community._modularity">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Calculates the modularity score of the graph with respect to a given clustering.</p>
<p>The modularity of a graph w.r.t. some division measures how good the division is, or how separated are the different vertex types from each other. It's defined as <span class="rst-math rst-formula"><i>Q</i> = 1 ⁄ (2<i>m</i>)*<i>sum</i>(<i>Aij</i> − <i>ki</i>*<i>kj</i> ⁄ (2<i>m</i>)<i>delta</i>(<i>ci</i>, <i>cj</i>), <i>i</i>, <i>j</i>)</span>. <span class="rst-math rst-formula"><i>m</i></span> is the number of edges, <span class="rst-math rst-formula"><i>Aij</i></span> is the element of the <span class="rst-math rst-formula"><i>A</i></span> adjacency matrix in row <span class="rst-math rst-formula"><i>i</i></span> and column <span class="rst-math rst-formula"><i>j</i></span>, <span class="rst-math rst-formula"><i>ki</i></span> is the degree of node <span class="rst-math rst-formula"><i>i</i></span>, <span class="rst-math rst-formula"><i>kj</i></span> is the degree of node <span class="rst-math rst-formula"><i>j</i></span>, and <span class="rst-math rst-formula"><i>Ci</i></span> and <tt class="rst-docutils literal">cj</tt> are the types of the two vertices (<span class="rst-math rst-formula"><i>i</i></span> and <span class="rst-math rst-formula"><i>j</i></span>). <span class="rst-math rst-formula"><i>delta</i>(<i>x</i>, <i>y</i>)</span> is one iff <span class="rst-math rst-formula"><i>x</i> = <i>y</i></span>, 0 otherwise.</p>
<p>If edge weights are given, the definition of modularity is modified as follows: <span class="rst-math rst-formula"><i>Aij</i></span> becomes the weight of the corresponding edge, <span class="rst-math rst-formula"><i>ki</i></span> is the total weight of edges adjacent to vertex <span class="rst-math rst-formula"><i>i</i></span>, <span class="rst-math rst-formula"><i>kj</i></span> is the total weight of edges adjacent to vertex <span class="rst-math rst-formula"><i>j</i></span> and <span class="rst-math rst-formula"><i>m</i></span> is the total edge weight in the graph.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">self</span></td><td class="fieldArgDesc"><span class="undocumented">Undocumented</span></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">membership</span></td><td class="fieldArgDesc">a membership list or a <code><a href="igraph.clustering.VertexClustering.html" class="internal-link" title="igraph.clustering.VertexClustering">VertexClustering</a></code> object</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">weights</span></td><td class="fieldArgDesc">optional edge weights or <tt class="rst-docutils literal">None</tt> if all edges are weighed equally. Attribute names are also allowed.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">the modularity score</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: newfield</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ref</span></td><td class="fieldArgDesc">Reference</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Unknown Field: ref</td></tr><tr><td colspan="2">MEJ Newman and M Girvan: Finding and evaluating community structure in networks. Phys Rev E 69 026113, 2004.</td></tr></table></div>
  </div>
</div>
        </div>
      
      </div>
    </div>

    {% endraw %}
