---
layout: r-manual
title: igraph R manual pages
mainheader: R igraph manual pages
lead: Use this if you are using igraph from R
vmenu: true

doctype: html/
langversion: 1.2.6
---


{% raw %}


<h2>Finding community structure by multi-level optimization of modularity</h2>

<h3>Description</h3>

<p>This function implements the multi-level modularity optimization algorithm
for finding community structure, see references below. It is based on the
modularity measure and a hierarchial approach.
</p>


<h3>Usage</h3>

<pre>
cluster_louvain(graph, weights = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
<p>Optional positive weight vector.  If the graph has a
<code>weight</code> edge attribute, then this is used by default. Supply <code>NA</code>
here if the graph has a <code>weight</code> edge attribute, but you want to ignore
it. Larger edge weights correspond to stronger connections.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the multi-level modularity optimization algorithm
for finding community structure, see VD Blondel, J-L Guillaume, R Lambiotte
and E Lefebvre: Fast unfolding of community hierarchies in large networks,
<a href="https://arxiv.org/abs/0803.0476">https://arxiv.org/abs/0803.0476</a> for the details.
</p>
<p>It is based on the modularity measure and a hierarchial approach.
Initially, each vertex is assigned to a community on its own. In every step,
vertices are re-assigned to communities in a local, greedy way: each vertex
is moved to the community with which it achieves the highest contribution to
modularity. When no vertices can be reassigned, each community is considered
a vertex on its own, and the process starts again with the merged
communities. The process stops when there is only a single vertex left or
when the modularity cannot be increased any more in a step.
</p>
<p>This function was contributed by Tom Gregorovic.
</p>


<h3>Value</h3>

<p><code>cluster_louvain</code> returns a <code><a href="communities.html">communities</a></code>
object, please see the <code><a href="communities.html">communities</a></code> manual page for details.
</p>


<h3>Author(s)</h3>

<p>Tom Gregorovic, Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>


<h3>References</h3>

<p>Vincent D. Blondel, Jean-Loup Guillaume, Renaud Lambiotte,
Etienne Lefebvre: Fast unfolding of communities in large networks. J. Stat.
Mech. (2008) P10008
</p>


<h3>See Also</h3>

<p>See <code><a href="communities.html">communities</a></code> for extracting the membership,
modularity scores, etc. from the results.
</p>
<p>Other community detection algorithms: <code><a href="cluster_walktrap.html">cluster_walktrap</a></code>,
<code><a href="cluster_spinglass.html">cluster_spinglass</a></code>,
<code><a href="cluster_leading_eigen.html">cluster_leading_eigen</a></code>,
<code><a href="cluster_edge_betweenness.html">cluster_edge_betweenness</a></code>,
<code><a href="cluster_fast_greedy.html">cluster_fast_greedy</a></code>,
<code><a href="cluster_label_prop.html">cluster_label_prop</a></code>
</p>


<h3>Examples</h3>

<pre>

# This is so simple that we will have only one level
g &lt;- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
g &lt;- add_edges(g, c(1,6, 1,11, 6, 11))
cluster_louvain(g)

</pre>

<hr /><div style="text-align: center;">[Package <em>igraph</em> version 1.2.6 <a href="index.html">Index</a>]</div>
{% endraw %}
